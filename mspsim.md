Project Path: mspsim

Source Tree:

```
mspsim
├── tests
│   ├── msp430setup.c
│   ├── cputest.c
│   ├── msp430setup.h
│   ├── timertest.c
│   └── Makefile
├── license.txt
├── images
│   ├── jcreate.jpg
│   ├── z1.jpg
│   ├── cc430.jpg
│   ├── sentilla-usb.jpg
│   ├── wismote.jpg
│   ├── sky.jpg
│   └── esb.jpg
├── README.md
├── lib
│   ├── json-simple-1.1.1.jar
│   ├── jfreechart-licence-LGPL.txt
│   ├── jfreechart-1.0.11.jar
│   ├── JSON-SIMPLE-LICENSE
│   ├── jcommon-1.0.14.jar
│   └── jipv6.jar
├── se
│   └── sics
│       ├── mspsim
│       │   ├── net
│       │   │   └── CC2420PacketHandler.java
│       │   ├── ui
│       │   │   ├── DoubleBarChart.java
│       │   │   ├── WindowManager.java
│       │   │   ├── ControlUI.java
│       │   │   ├── BarChart.java
│       │   │   ├── StackUI.java
│       │   │   ├── SerialMon.java
│       │   │   ├── ConsoleUI.java
│       │   │   ├── WindowUtils.java
│       │   │   ├── SourceViewer.java
│       │   │   ├── LineChart.java
│       │   │   ├── ConstantLineChart.java
│       │   │   ├── DoubleSerieChart.java
│       │   │   ├── ManagedWindow.java
│       │   │   ├── ChartPanel.java
│       │   │   ├── IntSerieChart.java
│       │   │   ├── AbstractChart.java
│       │   │   ├── Chart.java
│       │   │   ├── JFrameWindowManager.java
│       │   │   ├── CPUHeatMap.java
│       │   │   └── DebugUI.java
│       │   ├── cli
│       │   │   ├── BasicAsyncCommand.java
│       │   │   ├── BasicLineCommand.java
│       │   │   ├── NetCommands.java
│       │   │   ├── FileTarget.java
│       │   │   ├── ScriptCommand.java
│       │   │   ├── WindowTarget.java
│       │   │   ├── Target.java
│       │   │   ├── ExecCommand.java
│       │   │   ├── CommandParser.java
│       │   │   ├── WindowDataHandler.java
│       │   │   ├── LineListener.java
│       │   │   ├── AsyncCommand.java
│       │   │   ├── WindowCommands.java
│       │   │   ├── BasicCommand.java
│       │   │   ├── CommandContext.java
│       │   │   ├── CommandBundle.java
│       │   │   ├── AbstractWindowDataHandler.java
│       │   │   ├── LineOutputStream.java
│       │   │   ├── DebugCommands.java
│       │   │   ├── CommandHandler.java
│       │   │   ├── StreamCommandHandler.java
│       │   │   ├── ProfilerCommands.java
│       │   │   ├── Command.java
│       │   │   ├── MiscCommands.java
│       │   │   ├── FileCommands.java
│       │   │   └── FileTargetCommand.java
│       │   ├── platform
│       │   │   ├── wismote
│       │   │   │   ├── WismoteNode.java
│       │   │   │   └── WismoteGui.java
│       │   │   ├── GenericNode.java
│       │   │   ├── sentillausb
│       │   │   │   ├── SentillaUSBNode.java
│       │   │   │   └── SentillaUSBGui.java
│       │   │   ├── jcreate
│       │   │   │   ├── JCreateNode.java
│       │   │   │   └── JCreateGui.java
│       │   │   ├── esb
│       │   │   │   ├── ESBGui.java
│       │   │   │   └── ESBNode.java
│       │   │   ├── ti
│       │   │   │   ├── CC430Node.java
│       │   │   │   ├── Exp5438Node.java
│       │   │   │   ├── Exp1120Node.java
│       │   │   │   ├── Trxeb2520Node.java
│       │   │   │   ├── Trxeb1120Node.java
│       │   │   │   └── Exp1101Node.java
│       │   │   ├── tyndall
│       │   │   │   └── TyndallNode.java
│       │   │   ├── AbstractNodeGUI.java
│       │   │   ├── z1
│       │   │   │   ├── Z1Node.java
│       │   │   │   └── Z1Gui.java
│       │   │   └── sky
│       │   │       ├── RadioWrapper.java
│       │   │       ├── SkyGui.java
│       │   │       ├── TelosNode.java
│       │   │       ├── SkyNode.java
│       │   │       ├── MoteIVNode.java
│       │   │       └── CC2420Node.java
│       │   ├── debug
│       │   │   ├── StabFile.java
│       │   │   ├── StabFunction.java
│       │   │   ├── DwarfReader.java
│       │   │   ├── StabType.java
│       │   │   └── StabDebug.java
│       │   ├── Main.java
│       │   ├── plugin
│       │   │   └── ContikiChecker.java
│       │   ├── chip
│       │   │   ├── Memory.java
│       │   │   ├── SPICommand.java
│       │   │   ├── CC2420.java
│       │   │   ├── SPIData.java
│       │   │   ├── M25P16.java
│       │   │   ├── CC2520.java
│       │   │   ├── MMA7260QT.java
│       │   │   ├── M25P80.java
│       │   │   ├── Storage.java
│       │   │   ├── TR1001.java
│       │   │   ├── AT45DB.java
│       │   │   ├── RFSource.java
│       │   │   ├── Button.java
│       │   │   ├── Enc28J60.java
│       │   │   ├── PacketListener.java
│       │   │   ├── CC1120.java
│       │   │   ├── CC2520SPI.java
│       │   │   ├── RFListener.java
│       │   │   ├── TMP112.java
│       │   │   ├── MemoryStorage.java
│       │   │   ├── SHT11.java
│       │   │   ├── Beeper.java
│       │   │   ├── I2CUnit.java
│       │   │   ├── TemperatureChip.java
│       │   │   ├── ChannelListener.java
│       │   │   ├── CC1101.java
│       │   │   ├── FileStorage.java
│       │   │   ├── DS2411.java
│       │   │   ├── ExternalFlash.java
│       │   │   ├── Accelerometer.java
│       │   │   ├── Leds.java
│       │   │   └── Radio802154.java
│       │   ├── extutil
│       │   │   ├── highlight
│       │   │   │   ├── HighlightSourceViewer.java
│       │   │   │   ├── JavaScanner.java
│       │   │   │   ├── Symbol.java
│       │   │   │   ├── TokenTypes.java
│       │   │   │   ├── CScanner.java
│       │   │   │   ├── Scanner.java
│       │   │   │   ├── LineNumberedBorder.java
│       │   │   │   ├── Scan.java
│       │   │   │   ├── Token.java
│       │   │   │   ├── SyntaxHighlighter.java
│       │   │   │   └── TextScanner.java
│       │   │   └── jfreechart
│       │   │       ├── DataSourceSampler.java
│       │   │       ├── DataChart.java
│       │   │       ├── LineSampleChart.java
│       │   │       ├── LineChart.java
│       │   │       └── JFreeWindowDataHandler.java
│       │   ├── profiler
│       │   │   ├── SimpleProfiler.java
│       │   │   ├── CallEntry.java
│       │   │   └── CallListener.java
│       │   ├── core
│       │   │   ├── RTC.java
│       │   │   ├── Memory.java
│       │   │   ├── RegisterMonitor.java
│       │   │   ├── BreakpointException.java
│       │   │   ├── MemoryMonitor.java
│       │   │   ├── DisAsm.java
│       │   │   ├── DMA.java
│       │   │   ├── ConfigurationChangeListener.java
│       │   │   ├── PortListenerProxy.java
│       │   │   ├── EmulationLogger.java
│       │   │   ├── GenericUSCI.java
│       │   │   ├── Profiler.java
│       │   │   ├── PortListener.java
│       │   │   ├── ADCInput.java
│       │   │   ├── IOSegment.java
│       │   │   ├── Chip.java
│       │   │   ├── PMM.java
│       │   │   ├── CRC16.java
│       │   │   ├── MSP430.java
│       │   │   ├── FlashSegment.java
│       │   │   ├── DbgInstruction.java
│       │   │   ├── LogListener.java
│       │   │   ├── InterruptMultiplexer.java
│       │   │   ├── SimEvent.java
│       │   │   ├── EventListener.java
│       │   │   ├── EmulationException.java
│       │   │   ├── RAMOffsetSegment.java
│       │   │   ├── UnifiedClockSystem.java
│       │   │   ├── MSP430Config.java
│       │   │   ├── USCI.java
│       │   │   ├── EventSource.java
│       │   │   ├── ADC12.java
│       │   │   ├── ADC12Plus.java
│       │   │   ├── USARTSource.java
│       │   │   ├── Multiplier.java
│       │   │   ├── Flash.java
│       │   │   ├── StatusRegister.java
│       │   │   ├── TimeEvent.java
│       │   │   ├── Multiplier32.java
│       │   │   ├── StateChangeListener.java
│       │   │   ├── SimEventListener.java
│       │   │   ├── GlobalWatchedMemory.java
│       │   │   ├── MSP430Core.java
│       │   │   ├── USART.java
│       │   │   ├── EventQueue.java
│       │   │   ├── Watchdog.java
│       │   │   ├── USARTListener.java
│       │   │   ├── IOUnit.java
│       │   │   ├── BasicClockModule.java
│       │   │   ├── RAMSegment.java
│       │   │   ├── FlashRange.java
│       │   │   ├── RF1A.java
│       │   │   ├── NoMemSegment.java
│       │   │   ├── SFR.java
│       │   │   ├── SFRModule.java
│       │   │   ├── WatchedMemory.java
│       │   │   ├── MSP430Constants.java
│       │   │   ├── InterruptHandler.java
│       │   │   ├── AES128.java
│       │   │   ├── ClockSystem.java
│       │   │   ├── SysReg.java
│       │   │   ├── OperatingModeListener.java
│       │   │   ├── IOPort.java
│       │   │   ├── Loggable.java
│       │   │   ├── DMATrigger.java
│       │   │   ├── PMMDummy.java
│       │   │   └── Timer.java
│       │   ├── emulink
│       │   │   └── EmuLink.java
│       │   ├── config
│       │   │   ├── MSP430f1611Config.java
│       │   │   ├── MSP430f5437Config.java
│       │   │   ├── MSP430f2617Config.java
│       │   │   ├── MSP430f149Config.java
│       │   │   └── CC430f5137Config.java
│       │   └── util
│       │       ├── NetworkConnection.java
│       │       ├── GDBStubs.java
│       │       ├── StatCommands.java
│       │       ├── ArgumentManager.java
│       │       ├── StackMonitor.java
│       │       ├── Test.java
│       │       ├── DotDiagram.java
│       │       ├── DebugInfo.java
│       │       ├── Utils.java
│       │       ├── ELFException.java
│       │       ├── TSPTest.java
│       │       ├── MultiDataSource.java
│       │       ├── DefaultEmulationLogger.java
│       │       ├── NetworkPacket.java
│       │       ├── PluginRepository.java
│       │       ├── ELFSection.java
│       │       ├── OperatingModeStatistics.java
│       │       ├── ELFProgram.java
│       │       ├── ArrayUtils.java
│       │       ├── ELFDebug.java
│       │       ├── ProxySupport.java
│       │       ├── IHexReader.java
│       │       ├── PrefixConfigManager.java
│       │       ├── ArrayFIFO.java
│       │       ├── ELF.java
│       │       ├── DataSource.java
│       │       ├── ComponentRegistry.java
│       │       ├── ActiveComponent.java
│       │       ├── MapEntry.java
│       │       ├── CCITT_CRC.java
│       │       ├── MapTable.java
│       │       ├── ConfigManager.java
│       │       ├── PluginBundle.java
│       │       └── ServiceComponent.java
│       └── json
│           ├── JSONObject.java
│           ├── JSONAware.java
│           ├── ParseException.java
│           ├── JSONStreamAware.java
│           └── JSONArray.java
├── CHANGE_LOG.txt
├── scripts
│   ├── autorun.sc
│   └── duty.sc
├── build.xml
└── firmware
    ├── wismote
    │   └── blink.wismote
    ├── exp5438
    │   ├── testcase-shift-fcf.exp5438
    │   ├── testcase-bits.exp5438
    │   ├── testcase-shift-fcf.txt
    │   └── testcase-hdrsize.exp5438
    ├── esb
    │   └── sensor-demo.esb
    ├── tyndall
    │   ├── blink.tyndall
    │   └── blink.ihex
    ├── z1
    │   └── blink.z1
    └── sky
        ├── blink.sky
        ├── cputest.sky
        ├── timertest.sky
        └── energest-demo.sky

```

`/home/deadbytes/Documents/mspsim/tests/msp430setup.c`:

```c
/*
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: msp430setup.c,v 1.2 2007/01/22 15:45:04 nfi Exp $
 *
 * -----------------------------------------------------------------
 *
 * Author  : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : 2007-01-22
 * Updated : $Date: 2007/01/22 15:45:04 $
 *           $Revision: 1.2 $
 */

#include "msp430setup.h"
#if defined(__GNUC__) && (__GNUC__ >= 9)
#include <msp430.h>
#elif __MSPGCC__
#include <msp430.h>
#include <msp430libc.h>
#include <legacymsp430.h>
#include <sys/crtld.h>
#else /* __MSPGCC__ */
#include <io.h>
#include <signal.h>
#include <sys/unistd.h>
#endif /* __MSPGCC__ */
#include <stdio.h>

/*--------------------------------------------------------------------------*/
/* RS232 Interface */
/*--------------------------------------------------------------------------*/

static int (* input_handler)(unsigned char) = NULL;

/*---------------------------------------------------------------------------*/
ISR(USART1RX, rs232_rx_usart1)
{
  /* Check status register for receive errors. - before reading RXBUF since
     it clears the error and interrupt flags */
  if(!(URCTL1 & RXERR) && input_handler != NULL) {
    input_handler(RXBUF1);

  } else {
    /* Else read out the char to clear the I-flags, etc. */
    RXBUF1;
  }
}
/*--------------------------------------------------------------------------*/
void
rs232_init(void)
{

  /* RS232 */
  UCTL1 = CHAR;                         /* 8-bit character */
  UTCTL1 = SSEL1;                       /* UCLK = MCLK */

  rs232_set_speed(RS232_57600);

  input_handler = NULL;

  ME2 |= (UTXE1 | URXE1);                 /* Enable USART1 TXD/RXD */
  IE2 |= URXIE1;                        /* Enable USART1 RX interrupt  */
}
/*---------------------------------------------------------------------------*/
void
rs232_send(char c)
{
  /* Loop until the transmission buffer is available. */
  while ((IFG2 & UTXIFG1) == 0);

  /* Transmit the data. */
  TXBUF1 = c;
}
/*---------------------------------------------------------------------------*/
void
rs232_set_speed(unsigned char speed)
{
  if(speed == RS232_19200) {
    /* Set RS232 to 19200 */
    UBR01 = 0x80;                         /* 2,457MHz/19200 = 128 -> 0x80 */
    UBR11 = 0x00;                         /* */
    UMCTL1 = 0x00;                        /* no modulation  */
  } else if(speed == RS232_38400) {
    /* Set RS232 to 38400 */
    UBR01 = 0x40;                         /* 2,457MHz/38400 = 64 -> 0x40 */
    UBR11 = 0x00;                         /* */
    UMCTL1 = 0x00;                        /* no modulation  */
  } else if(speed == RS232_57600) {
    UBR01 = 0x2a;                         /* 2,457MHz/57600 = 42.7 -> 0x2A */
    UBR11 = 0x00;                         /* */
    UMCTL1 = 0x5b;                        /* */
  } else if(speed == RS232_115200) {
    UBR01 = 0x15;                         /* 2,457MHz/115200 = 21.4 -> 0x15 */
    UBR11 = 0x00;                         /* */
    UMCTL1 = 0x4a;                        /* */
  } else {
    rs232_set_speed(RS232_57600);
  }
}
/*---------------------------------------------------------------------------*/
void
rs232_set_input(int (*f)(unsigned char))
{
  input_handler = f;
}
/*--------------------------------------------------------------------------*/
#if defined(__GNUC__) && (__GNUC__ >= 9)
int
write(int fd, const char *buf, int len)
{
  int i = 0;
  for(; i < len && buf[i]; i++) {
    rs232_send(buf[i]);
  }
  return i;
}
#else
int
putchar(int c)
{
  rs232_send(c);
  return c;
}
#endif
/*--------------------------------------------------------------------------*/




/*---------------------------------------------------------------------------*/
void
esb_sensors_init(void)
{
  P5SEL &= ~(1 << 5);
  P5DIR |= (1 << 5);
}
/*---------------------------------------------------------------------------*/
void
esb_sensors_on(void)
{
  P5OUT &= ~(1 << 5);
}
/*---------------------------------------------------------------------------*/
void
esb_sensors_off(void)
{
  P5OUT |= (1 << 5);
}
/*---------------------------------------------------------------------------*/




/*---------------------------------------------------------------------------*/
/* CPU INIT */
/*--------------------------------------------------------------------------*/

static void
msp430_init_dco(void)
{
    /* This code taken from the FU Berlin sources and reformatted. */

#define DELTA    600

  unsigned int compare, oldcapture = 0;
  unsigned int i;


  BCSCTL1 = 0xa4; /* ACLK is devided by 4. RSEL=6 no division for MCLK
		     and SSMCLK. XT2 is off. */

  BCSCTL2 = 0x00; /* Init FLL to desired frequency using the 32762Hz
		     crystal DCO frquenzy = 2,4576 MHz  */

  WDTCTL = WDTPW + WDTHOLD;             /* Stop WDT */
  BCSCTL1 |= DIVA1 + DIVA0;             /* ACLK = LFXT1CLK/8 */
  for(i = 0xffff; i > 0; i--);          /* Delay for XTAL to settle */

  CCTL2 = CCIS0 + CM0 + CAP;            // Define CCR2, CAP, ACLK
  TACTL = TASSEL1 + TACLR + MC1;        // SMCLK, continous mode


  while(1) {

    while((CCTL2 & CCIFG) != CCIFG);    /* Wait until capture occured! */
    CCTL2 &= ~CCIFG;                    /* Capture occured, clear flag */
    compare = CCR2;                     /* Get current captured SMCLK */
    compare = compare - oldcapture;     /* SMCLK difference */
    oldcapture = CCR2;                  /* Save current captured SMCLK */
    
    if(DELTA == compare) {
      break;                            /* if equal, leave "while(1)" */
    } else if(DELTA < compare) {        /* DCO is too fast, slow it down */
      DCOCTL--;
      if(DCOCTL == 0xFF) {              /* Did DCO role under? */
	BCSCTL1--;
      }
    } else {                            /* -> Select next lower RSEL */
      DCOCTL++;
      if(DCOCTL == 0x00) {              /* Did DCO role over? */
	BCSCTL1++;
      }
                                        /* -> Select next higher RSEL  */
    }
  }

  CCTL2 = 0;                            /* Stop CCR2 function */
  TACTL = 0;                            /* Stop Timer_A */

  BCSCTL1 &= ~(DIVA1 + DIVA0);          /* remove /8 divisor from ACLK again */
}
/*---------------------------------------------------------------------------*/
static void
init_ports(void)
{
  /* Turn everything off, device drivers are supposed to enable what is
   * really needed!
   */

  /* All configured for digital I/O */
#ifdef P1SEL
  P1SEL = 0;
#endif
#ifdef P2SEL
  P2SEL = 0;
#endif
#ifdef P3SEL
  P3SEL = 0;
#endif
#ifdef P4SEL
  P4SEL = 0;
#endif
#ifdef P5SEL
  P5SEL = 0;
#endif
#ifdef P6SEL
  P6SEL = 0;
#endif

  /* All available inputs */
#ifdef P1DIR
  P1DIR = 0;
  P1OUT = 0;
#endif
#ifdef P2DIR
  P2DIR = 0;
  P2OUT = 0;
#endif
#ifdef P3DIR
  P3DIR = 0;
  P3OUT = 0;
#endif
#ifdef P4DIR
  P4DIR = 0;
  P4OUT = 0;
#endif

#ifdef P5DIR
  P5DIR = 0;
  P5OUT = 0;
#endif

#ifdef P6DIR
  P6DIR = 0;
  P6OUT = 0;
#endif

  P1IE = 0;
  P2IE = 0;
}
/*---------------------------------------------------------------------------*/
static void init_ports_toberemoved() {
    ////////// Port 1 ////
  P1SEL = 0x00;
  P1DIR = 0x81;       // Outputs: P10=IRSend, P17=RS232RTS
                      // Inputs: P11=Light, P12=IRRec, P13=PIR, P14=Vibration,
                      //         P15=Clockalarm, P16=RS232CTS
  P1OUT = 0x00;

  ////////// Port 2 ////
  P2SEL = 0x00;       // No Sels
  P2DIR = 0x7F;       // Outpus: P20..P23=Leds+Beeper, P24..P26=Poti
                      // Inputs: P27=Taster
  P2OUT = 0x77;

  ////////// Port 3 ////
  P3SEL = 0xE0;       // Sels for P34..P37 to activate UART,
  P3DIR = 0x5F;       // Inputs: P30..P33=CON4, P35/P37=RXD Transceiver/RS232
                      // OutPuts: P36/P38=TXD Transceiver/RS232
  P3OUT = 0xE0;       // Output a Zero on P34(TXD Transceiver) and turn SELECT off when receiving!!!

  ////////// Port 4 ////
  P4SEL = 0x00;       // CON5 Stecker
  P4DIR = 0xFF;
  P4OUT = 0x00;

  ////////// Port 5 ////
  P5SEL = 0x00;       // P50/P51= Clock SDA/SCL, P52/P53/P54=EEPROM SDA/SCL/WP
  P5DIR = 0xDA;       // P56/P57=Transceiver CNTRL0/1
  P5OUT = 0x0F;

  ////////// Port 6 ////
  P6SEL = 0x00;       // P60=Microphone, P61=PIR digital (same as P13), P62=PIR analog
  P6DIR = 0x00;       // P63=extern voltage, P64=battery voltage, P65=Receive power
  P6OUT = 0x00;
}
/*--------------------------------------------------------------------------*/
void
msp430_setup(void)
{
  dint();
  init_ports();
  msp430_init_dco();
  eint();

  init_ports_toberemoved();

  esb_sensors_init();
  esb_sensors_on();

  rs232_init();
}

```

`/home/deadbytes/Documents/mspsim/tests/cputest.c`:

```c
/*
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 * $Id: cputest.c,v 1.19 2007/10/24 22:17:46 nfi Exp $
 *
 * -----------------------------------------------------------------
 *
 * Author  : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : 2006-03-07
 * Updated : $Date: 2007/10/24 22:17:46 $
 *           $Revision: 1.19 $
 */

#include "msp430setup.h"
#include <stdio.h>
#include <string.h>
#if defined(__GNUC__) && (__GNUC__ >= 9)
#include <msp430.h>
#include <stdarg.h>
#elif __MSPGCC__
#include <msp430.h>
#include <legacymsp430.h>
#define eint() __eint()
#define dint() __dint()
#else /* __MSPGCC__ */
#include <signal.h>
#include <io.h>
#endif /* __MSPGCC__ */

/* From Adams test-suite */
#define TEST(...) if(__VA_ARGS__) {					 \
                    printf("OK: " #__VA_ARGS__ " passed at %s:%d\n", __FILE__,__LINE__); \
                  } else {						 \
                    printf("FAIL: " #__VA_ARGS__ " failed at %s:%d\n", __FILE__,__LINE__); \
                  }

#define TEST2(text,...) if(__VA_ARGS__) {					 \
                    printf("OK: " #text " passed at %s:%d\n", __FILE__,__LINE__); \
                  } else {						 \
                    printf("FAIL: " #text " failed at %s:%d\n", __FILE__,__LINE__); \
                  }

#define assertTrue(...) TEST(__VA_ARGS__)
#define assertFalse(...) TEST(!(__VA_ARGS__))

#define assertTrue2(text,...) TEST2(text,__VA_ARGS__)
#define assertFalse2(text,...) TEST2(text,!(__VA_ARGS__))

static int testzero(int hm)
{
  return hm > 0;
}

static int caseID = 0;

/*---------------------------------------------------------------------------*/
static int pos = 0;
static unsigned int times[10];
ISR(TIMERB1, timerb1)
{
  if(TBIV == 2) {
    if(pos < 10) {
      times[pos] = TBR;
      pos++;
      TBCCR1 = TBCCR1 + 100;
    }
  }
}
/*---------------------------------------------------------------------------*/

static void initTest() {
  caseID = 0;
}

static void testCase(char *description) {
  caseID++;
  printf("-------------\n");
  printf("TEST %d: %s\n", caseID, description);
}

static void testSimple() {
  int a,b,c;
  a = 1; b = 2; c = 4;
  testCase("Arithmetic Operations");

  assertTrue((a << b) == 4);
  assertTrue((c >> a) == 2);

  assertFalse(0 > 0);
  assertFalse(a > b);

  assertFalse(testzero(0));
}

static void testIntegers() {
  int a,b,c;
  int t[3];
  testCase("Integer Operations");
  a = 1; b = 2; c = -42;
  t[0] = 1;
  t[1] = 2;
  t[2] = 3;
  assertTrue(a == 1);
  assertTrue((b + c) == -40);
  assertTrue(t[0] == 1);
  assertTrue(t[1] == 2);
  assertTrue(t[t[0]] == 2);
  assertTrue((a+b) == 3);
  assertTrue((b-a) == 1);
  assertTrue((a-b) == -1);
  assertTrue((a*b) == 2);
  assertTrue(a > 0);
  assertTrue(b > a);
  assertTrue(b != a);
  assertTrue((a ^ b) == 3);
  assertTrue((a ^ 4) == 5);
  assertTrue((a ^ a) == 0);
  assertFalse(a > b);

  a = 15;
  b = 17;
  assertTrue((a & ~b) == 14);
}

static void testFloats() {
  int i;
  float f;
  i = 2;
  f = 0.5;
  testCase("Float Operations");
  assertTrue((i * f) == 1);
  i++;
  assertTrue((i * f) == 1.5);
}

static void testStrings() {
  char buf[10];

  testCase("String Operations");
  sprintf(buf, "test");
  assertTrue2("test => test", strcmp(buf, "test") == 0);
  sprintf(buf, "%c", 'a');
  assertTrue2("buf == 'a'", strcmp(buf, "a") == 0);
}

/*--------------------------------------------------------------------------*/

static int id(int first, ...)
{
  va_list marker;
  va_start( marker, first );
  first = va_arg( marker, int);
  va_end( marker );
  return first;
}

static void testFunctions() {
  volatile int i;

  testCase("Functions");
  i = 47;

/*   printf("i=%d i+1=%d id(i)=%d\n", i, i + 1, id(0, i)); */

  assertTrue(i == 47);
  assertTrue(id(0,47) == 47);
  assertTrue(id(0,i) == 47);
}

/*--------------------------------------------------------------------------*/

static void testModulo() {
  int c;
  testCase("Modulo");

  for(c = 2; c >= 0; c--) {
    if((c % 5) == 0) {
      assertTrue(c != 1);
    }
/*     printf("(%d,%d,%d)\n", c, (c % 5), c==1); */
/*     printf("(%d,%d,%d)\n", c, (c % 5), c==1); */
  }
}

/*--------------------------------------------------------------------------*/

/* Bit field tests */

static struct {
  char green:4, yellow:4, red:4;
} leds;

static struct {
  char green:2, yellow:2, red:2;  /* These bit fields should really be
				     only one bit wide, but that
				     crashed gcc... */
} invert;

#ifndef BV
#define BV(n) (1 << (n))
#endif

void testBis() {
  P4DIR |= BV(2) | BV(5) | BV(6);
  assertTrue(P4DIR == 100);
}

static void testBitFields() {
  static int pelle = 0;

  testCase("Bit field Operations");

  P4DIR = 0;
  testBis();

  leds.green = 1;
  leds.yellow = 1;
  leds.red = 1;

  assertTrue(leds.green > 0);
  assertTrue(leds.yellow > 0);
  assertTrue(leds.red > 0);

  leds.green -= 1;
  assertTrue(leds.green == 0);

  pelle = 0x4711;

  invert.green = 1;
  invert.yellow = 1;
  invert.red = 1;

  assertTrue(invert.green > 0);
  assertTrue(invert.yellow > 0);
  assertTrue(invert.red > 0);

  invert.green ^= 1;
  assertTrue(invert.green == 0);

  assertTrue(pelle == 0x4711);
}


/*--------------------------------------------------------------------------*/
static int flag;
ISR(USART0TX, usart_tx_test0)
{
  printf("*IRQ: Flags:%d %d\n", IFG1, UTCTL0);
  flag++;
}

static void testUSART() {
  int delay = 10000;
  testCase("Bit USART Operations");
  flag = 0xff;
  UCTL0 = CHAR;                         /* 8-bit character */
  UTCTL0 = SSEL1;                       /* UCLK = MCLK */
  ME1 |= (UTXE0 | URXE0);                 /* Enable USART0 TXD/RXD */
  IE1 |= UTXIE0;                        /* Enable USART0 TX interrupt  */
  TXBUF_0 = 'a';

  while(flag == 0) {
  }
  while(delay-- > 0);

  printf("output finished...\n");
}

static void testTimer() {
  int i;
  unsigned int time;
  int result;
  pos = 0;
  dint();
  /* Select SMCLK (2.4576MHz), clear TAR; This makes the rtimer count
     the number of processor cycles executed by the CPU. */
  //TBCTL = TBSSEL1 | TBCLR;
  /* Select ACLK 32768Hz clock, divide by 1 (was ID_3 / 8 previously) */
  TBCTL = TBSSEL0 | TBCLR | ID_0;

  /* Start Timer_B in continuous mode. */
  TBCTL |= MC1;

  TBR = 0;
  TBCCR1 = 100;

  /* CCR1 interrupt enabled, interrupt occurs when timer equals CCR1. */
  /* Should be set here, since setting TBR to zero can cause triggering */
  /* if CCR1 = 0 */
  TBCCTL1 = CCIE;

  /* Enable interrupts. */
  eint();

  while (pos < 10) {
	  printf(".");
  }
  printf("\n");

  for (i = 0; i < pos; i++) {
	  unsigned int t = 100 + i * 100;
	  printf("Trigg time %d => %u\n", i + 1, times[i]);
	  assertTrue(times[i] >= t && times[i] < t + 2);
  }

  printf("Start modulo\n");
  time = TBR;
  result = 47;
  for (i = 0; i < 1000; i++) {
    result = result + i % 27;
  }
  printf("Elapsed %i %i\n",TBR - time, result);


}

#define TARGET_DCO_KHZ 4096
#define ACLK_KHZ 32
#define ACLK_CALIB_PERIOD 8
#define TARGET_DCO_DELTA (TARGET_DCO_KHZ / ACLK_KHZ) * ACLK_CALIB_PERIOD

void set_dco_calib( int calib )
{
  BCSCTL1 = (BCSCTL1 & ~0x07) | ((calib >> 8) & 0x07);
  DCOCTL = calib & 0xff;
}

uint16_t test_calib_busywait_delta( int calib )
{
  int8_t aclk_count = 2;
  uint16_t dco_prev = 0;
  uint16_t dco_curr = 0;

  set_dco_calib( calib );

  while( aclk_count-- > 0 )
    {
      TBCCR0 = TBR + ACLK_CALIB_PERIOD; // set next interrupt
      TBCCTL0 &= ~CCIFG; // clear pending interrupt
      while( (TBCCTL0 & CCIFG) == 0 ); // busy wait
      dco_prev = dco_curr;
      dco_curr = TAR;
    }
  return dco_curr - dco_prev;
}

  // busyCalibrateDCO
  // Should take about 9ms if ACLK_CALIB_PERIOD=8.
  // DCOCTL and BCSCTL1 are calibrated when done.
void busyCalibrateDco()
{
  // --- variables ---
  int calib;
  int step;
  int tmp;
  // --- calibrate ---

  // --- setup ---

  TACTL = TASSEL1 | MC1; // source SMCLK, continuous mode, everything else 0
  TBCTL = TBSSEL0 | MC1; // Aclk?
  BCSCTL1 = XT2OFF | RSEL2;
  BCSCTL2 = 0;
  TBCCTL0 = CM0;

  // Binary search for RSEL,DCO,DCOMOD.
  // It's okay that RSEL isn't monotonic.

  for( calib=0,step=0x800; step!=0; step>>=1 )
    {
      // if the step is not past the target, commit it
      printf(" step: %d\n", step);
      if((tmp = test_calib_busywait_delta(calib|step)) <= TARGET_DCO_DELTA )
      {
        calib |= step;
        printf(" committed: tmp = %d\n", tmp);
      }
    }

    // if DCOx is 7 (0x0e0 in calib), then the 5-bit MODx is not useable, set it to 0
  if( (calib & 0x0e0) == 0x0e0 )
    calib &= ~0x01f;

  set_dco_calib( calib );
}



/*--------------------------------------------------------------------------*/

int
main(void)
{
  msp430_setup();

  initTest();

  testSimple();
  testIntegers();
  testFloats();
  testStrings();
  testBitFields();
  testFunctions();
  testModulo();
  testUSART();
  testTimer();
  busyCalibrateDco();
  /*  printf("PROFILE\n"); */
  printf("EXIT\n");

  /* Short delay to allow serial output to finish */
  __delay_cycles(2000);

return 0;
}

```

`/home/deadbytes/Documents/mspsim/tests/msp430setup.h`:

```h
/*
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: msp430setup.h,v 1.1 2007/01/22 15:12:27 nfi Exp $
 *
 * -----------------------------------------------------------------
 *
 * Author  : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : 2007-01-22
 * Updated : $Date: 2007/01/22 15:12:27 $
 *           $Revision: 1.1 $
 */

#ifndef __MSP430SETUP_H__
#define __MSP430SETUP_H__

#if defined(__GNUC__) && (__GNUC__ >= 9)
#define ISR(a,b) void __attribute__((interrupt(a ## _VECTOR))) b(void)
#define eint() __eint()
#define dint() __dint()
#elif defined(__GNUC__)  &&  defined(__MSP430__)
     /* This is the MSPGCC compiler */
#define ISR(a,b) interrupt(a ## _VECTOR) b(void)
#endif

void msp430_setup(void);

#define RS232_19200 1
#define RS232_38400 2
#define RS232_57600 3
#define RS232_115200 4

/**
 * \brief      Set an input handler for incoming RS232 data
 * \param f    A pointer to a byte input handler
 *
 *             This function sets the input handler for incoming RS232
 *             data. The input handler function is called for every
 *             incoming data byte. The function is called from the
 *             RS232 interrupt handler, so care must be taken when
 *             implementing the input handler to avoid race
 *             conditions.
 *
 *             The return value of the input handler affects the sleep
 *             mode of the CPU: if the input handler returns non-zero
 *             (true), the CPU is awakened to let other processing
 *             take place. If the input handler returns zero, the CPU
 *             is kept sleeping.
 */
void rs232_set_input(int (* f)(unsigned char));

/**
 * \brief      Configure the speed of the RS232 hardware
 * \param speed The speed
 *
 *             This function configures the speed of the RS232
 *             hardware. The allowed parameters are RS232_19200,
 *             RS232_38400, RS232_57600, and RS232_115200.
 */
void rs232_set_speed(unsigned char speed);

/**
 * \brief      Print a text string on RS232
 * \param str  A pointer to the string that is to be printed
 *
 *             This function prints a string to RS232. The string must
 *             be terminated by a null byte. The RS232 module must be
 *             correctly initalized and configured for this function
 *             to work.
 */
void rs232_print(char *text);

/**
 * \brief      Print a character on RS232
 * \param c    The character to be printed
 *
 *             This function prints a character to RS232. The RS232
 *             module must be correctly initalized and configured for
 *             this function to work.
 */
void rs232_send(char c);

#endif /* __MSP430SETUP_H__ */

```

`/home/deadbytes/Documents/mspsim/tests/timertest.c`:

```c
/*
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 * $Id: cputest.c,v 1.19 2007/10/24 22:17:46 nfi Exp $
 *
 * -----------------------------------------------------------------
 *
 * Author  : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : 2006-03-07
 * Updated : $Date: 2007/10/24 22:17:46 $
 *           $Revision: 1.19 $
 */

#include "msp430setup.h"
#if defined(__GNUC__) && (__GNUC__ >= 9)
#include <msp430.h>
#elif __MSPGCC__
#include <msp430.h>
#include <legacymsp430.h>
#else /* __MSPGCC__ */
#include <signal.h>
#include <io.h>
#endif /* __MSPGCC__ */
#include <string.h>
#include <stdio.h>

/* From Adams test-suite */
#define TEST(...) if(__VA_ARGS__) {					 \
                    printf("OK: " #__VA_ARGS__ " passed at %s:%d\n", __FILE__,__LINE__); \
                  } else {						 \
                    printf("FAIL: " #__VA_ARGS__ " failed at %s:%d\n", __FILE__,__LINE__); \
                  }

#define TEST2(text,...) if(__VA_ARGS__) {					 \
                    printf("OK: " #text " passed at %s:%d\n", __FILE__,__LINE__); \
                  } else {						 \
                    printf("FAIL: " #text " failed at %s:%d\n", __FILE__,__LINE__); \
                  }

#define assertTrue(...) TEST(__VA_ARGS__)
#define assertFalse(...) TEST(!(__VA_ARGS__))

#define assertTrue2(text,...) TEST2(text,__VA_ARGS__)
#define assertFalse2(text,...) TEST2(text,!(__VA_ARGS__))

static int caseID = 0;

#define RTIMER_ARCH_SECOND 4096
#define CLOCK_SECOND 128
#define INTERVAL (RTIMER_ARCH_SECOND / CLOCK_SECOND)

/*---------------------------------------------------------------------------*/
static int pos = 0;
static volatile unsigned int ticka0 = 0;
static volatile unsigned int count = 0;
static volatile unsigned int seconds = 0;
static volatile unsigned int last_tar = 0;

ISR(TIMERA1, timera1)
{
  if(TAIV == 2) {
    eint();
    do {
      TACCR1 += INTERVAL;
      ++count;

      if (count == 5) {
	for (pos = 0; pos < 2000; pos++) {
	  last_tar = TAR;
	}
      }

      if(count % CLOCK_SECOND == 0) {
	++seconds;
      }
    } while((TACCR1 - TAR) > INTERVAL);
    last_tar = TAR;
  }
}


/*---------------------------------------------------------------------------*/
ISR(TIMERA0, timera0)
{
  ticka0++;
  TACCR0 += 4;
}
/*---------------------------------------------------------------------------*/
void
rtimer_arch_init(void)
{
}

/*---------------------------------------------------------------------------*/

static void initTest() {
  caseID = 0;
}

static void testCase(char *description) {
  caseID++;
  printf("-------------\n");
  printf("TEST %d: %s\n", caseID, description);
}

static void testTimers() {
  unsigned int counter = 0;

  testCase("Timers");

  dint();
  /* Timer A1 */
  /* Select ACLK 32768Hz clock, divide by 8 */
  TACTL = TASSEL0 | TACLR | ID_3;
  /* Initialize ccr1 to create the X ms interval. */
  /* CCR1 interrupt enabled, interrupt occurs when timer equals CCR1. */
  TACCTL1 = CCIE;
  /* Interrupt after X ms. */
  TACCR1 = INTERVAL;
  /* Start Timer_A in continuous mode. */
  TACTL |= MC1;
  count = 0;

  /* Timer A0 */
  /* CCR0 interrupt enabled, interrupt occurs when timer equals CCR0. */
  TACCTL0 = CCIE;
  TACCR0 = 40;

  /* Enable interrupts. */
  eint();


  for(counter = 0; ticka0 < 100 && counter < 2000; counter++) {
    printf("Timer a0:%d\n", ticka0);
  }
  assertTrue(ticka0 >= 100);
  assertTrue(count > 10);
}

int
main(void)
{
  msp430_setup();

  initTest();

  testTimers();

  printf("EXIT\n");

  /* Short delay to allow serial output to finish */
  __delay_cycles(2000);

  return 0;
}

```

`/home/deadbytes/Documents/mspsim/tests/Makefile`:

```
.SUFFIXES:

#MCU=msp430f149
MCU=msp430f1611

### Compiler definitions
CC       = msp430-gcc
LD       = msp430-ld
AS       = msp430-as
AR       = msp430-ar
OBJCOPY  = msp430-objcopy
STRIP    = msp430-strip
BSL      = msp430-bsl
CFLAGSNO = -I. -Wall -mmcu=$(MCU) -g -gstabs+
CFLAGS  += $(CFLAGSNO) -Os

SOURCES := msp430setup.c

OBJECTS := $(SOURCES:.c=.o)

#all:	cputest.ihex
all:	cputest.firmware timertest.firmware


%.firmware:	%.o $(OBJECTS)
	$(CC) $(CFLAGS) -Wl,-Map=$(@:.firmware=.map) -o $@ $^

%.ihex: %.firmware
	$(OBJCOPY) $^ -O ihex $@

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

%.u:	%.ihex
	msp430-jtag -eI $^

clean:
	rm -f *~ *.lst *.map *.o *.ihex *.firmware

```

`/home/deadbytes/Documents/mspsim/license.txt`:

```txt
Copyright (c) 2007, Swedish Institute of Computer Science.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the Institute nor the names of its contributors
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

```

`/home/deadbytes/Documents/mspsim/README.md`:

```md
### MSPSim version 0.9x

MSPSim is a Java-based instruction level emulator of the MSP430 series
microprocessor and emulation of some sensor networking
platforms. Supports loading of IHEX and ELF firmware files, and has
some tools for monitoring stack, setting breakpoints, and profiling.

### System requirements

You need a recent Java to run MSPSim. Java 11 or newer is recommended.
The current version of MSPSim also requires ant for compiling.

### Building MSPSim

You will build MSPSim by typing

> ant

### Running examples

Run the default example on the ESB node emulator by typing:

> ant runesb

(here you can pass the PIR with the mouse and click on the
 user button to get reaction from the example application).

Run the default example on the Sky node emulator by typing:

> ant runsky

(this is a leds-blinker only and does not react to any mouse
 movements or button clicks).

### Main Features

- Instruction level emulation of MSP430 microprocessor
- Supports loading of ELF and IHEX files
- Easy to add external components that emulates external HW
- Supports monitoring of registers, adding breakpoints, etc.
- Built-in profiling of executed code
- Statistics for various components modes (on/off, LPM modes, etc).
- Emulates some external hardware such as TR1001 and CC2420.
- Command Line Interface, CLI, for setting up breakpoints and output
  to files or windows.
- GDB remote debugging support (initial)

* What is emulated of the MSP430
- CPU (instruction level simulation)
- Timer A/B subsystem
- USARTs
- Digital I/O
- Multiplication unit
- Basic A/D subsystem (not complete)
- Watchdog

### Limitations of the emulation (some of them) on version 0.9x

- Currently, the emulator runs as if it can use all memory as RAM
  (e.g. flash writes, etc not supported)
- No DMA implementation
- Timer system not 100% emulated

```

`/home/deadbytes/Documents/mspsim/lib/jfreechart-licence-LGPL.txt`:

```txt
		  GNU LESSER GENERAL PUBLIC LICENSE
		       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

		  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.
  
  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

			    NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

		     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!



```

`/home/deadbytes/Documents/mspsim/lib/JSON-SIMPLE-LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/net/CC2420PacketHandler.java`:

```java
/**
 * Copyright (c) 2009, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 *
 * Author  : Joakim Eriksson
 * Created :  mar 2009
 * Updated : $Date:$
 *           $Revision:$
 */

package se.sics.mspsim.net;

import java.io.PrintStream;

import se.sics.jipv6.core.AbstractPacketHandler;
import se.sics.jipv6.core.Packet;
import se.sics.mspsim.chip.RFListener;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.util.Utils;

public class CC2420PacketHandler extends AbstractPacketHandler implements RFListener {

  public static final String CC2420_LEN = "cc2420.len";
  
  private static final int SFD_SEARCH = 1;
  private static final int LEN = 2;
  private static final int PACKET = 3;  
 
  private static final byte[] PREAMBLE = {0, 0, 0, 0, 0x7a};
 
  private PrintStream out;
  
  byte[] packetBuffer = new byte[256];
  int mode = SFD_SEARCH;
  int pos;
  int packetLen;
  int sfdSearch = 0;
  
  MSP430Core cpu;
  public CC2420PacketHandler(MSP430Core cpu) {
    this.cpu = cpu;
  }
  
  public void receivedByte(byte data) {
    packetBuffer[pos++] = data;
    switch (mode) {
    case SFD_SEARCH:
      if (sfdSearch < 4 && data == 0)
        sfdSearch++;
      if (sfdSearch == 4 && data == 0x7a) {
        mode = LEN;
        sfdSearch = 0;
      }
      break;
    case LEN:
      mode = PACKET;
      packetLen = data & 0xff;
      System.out.println("Packet len: " + packetLen);
      break;
    case PACKET:
      if (pos == packetLen + PREAMBLE.length + 1) {
        /* the packet is in!!! */
//        CC2420Packet packet = new CC2420Packet();
//        packet.setPayload(packetBuffer, PREAMBLE.length + 1, packetLen - 2);
        Packet packet = new Packet();
        packet.setBytes(packetBuffer, PREAMBLE.length + 1, packetLen - 2);
        packet.setAttribute(CC2420_LEN, packet.getTotalLength());
        dispatch(-1, packet);
        System.out.println("CC2420: Packet received");

        /* this is a packet that has passed the stack! */
        mode = SFD_SEARCH;
        pos = 0;
      }
      break;
    }
  }

  
  public void printPacket(PrintStream out, Packet packet) {
    int payloadLen = packet.getAttributeAsInt(CC2420_LEN);
    out.print("CC2420 | len:" + payloadLen + " | ");
    for (int i = 0; i < payloadLen; i++) {
      out.print(Utils.hex8(packet.getData(i) & 0xff));
      if ((i & 3) == 3) {
        out.print(" ");
      }
    }
    out.println();
  }

  public void sendPacket(Packet packet) {
    final Packet sendPacket = packet;
    byte[] size = new byte[1];
    byte[] crc = new byte[2];
    size[0] = (byte) ((packet.getTotalLength() + 2)& 0xff);
    packet.prependBytes(size);
    packet.prependBytes(PREAMBLE);
    packet.appendBytes(crc);
    byte[] data = packet.getBytes();
    System.out.println("Should send packet to radio!!!! " + packet.getTotalLength());
    // Stuff to send to radio!!!
    TimeEvent te = new TimeEvent(0) {
      public void execute(long t) {
        System.out.println("CC2420: Packet to send: ");
        byte[] buffer = sendPacket.getBytes();
        for (int i = 0; i < buffer.length; i++) {
          System.out.print(Utils.hex8(buffer[i]));
          out.print(Utils.hex8(buffer[i]));
        }
        /* send to output + two additional bytes...! */
        out.println();
      }
    };
    /* schedule packet delivery in 10 ms */
    cpu.scheduleTimeEventMillis(te, 10);
  }


  public void setOutput(PrintStream out) {
    this.out = out;
  }

  public void packetReceived(Packet container) {
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/DoubleBarChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * DoubleBarChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;
import java.awt.Graphics2D;

/**
 *
 */
public class DoubleBarChart extends DoubleSerieChart {

  public DoubleBarChart() {
    // Do nothing
  }

  public DoubleBarChart(String name) {
    setName(name);
  }

  public void drawChart(Graphics2D g, double xfac, double yfac,
      int width, int height)
  {
    double[] data = this.data;
    if (data != null) {
      int minWidth = 1;
      if (xfac > 1) {
        minWidth = (int) (xfac + 0.9);
      }
      for (int i = 0, n = data.length; i < n; i++) {
        int y = (int) (yfac * data[i]);
        g.fillRect((int) (xfac * i), height - y, minWidth + 1, y + 1);
      }
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/WindowManager.java`:

```java
package se.sics.mspsim.ui;

public interface WindowManager {
  public ManagedWindow createWindow(String name);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/ControlUI.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ControlUI
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;
import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.GridLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import javax.swing.*;

import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.SimEvent;
import se.sics.mspsim.core.SimEventListener;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.DebugInfo;
import se.sics.mspsim.util.ELF;
import se.sics.mspsim.util.ServiceComponent;

public class ControlUI extends JPanel implements ActionListener, SimEventListener, ServiceComponent {

  private static final long serialVersionUID = -2431892192775232653L;

  private static final String TITLE = "MSPSim monitor";

  private ManagedWindow window;
  private JButton controlButton;
  private MSP430 cpu;
  private GenericNode node;
  private DebugUI dui;

  private ELF elfData;
  private SourceViewer sourceViewer;

  private Action stepAction;
  private ComponentRegistry registry;

  private Status status = Status.STOPPED;

  private String name;

  public ControlUI() {
    super(new GridLayout(0, 1));
  }

  private void setup() {
    if (window != null) return;
    this.cpu = (MSP430) registry.getComponent("cpu");
    this.node = (GenericNode) registry.getComponent("node");
    elfData = (ELF) registry.getComponent("elf");

    WindowManager wm = (WindowManager) registry.getComponent("windowManager");
    window = wm.createWindow("ControlUI");
    JPanel jp = new JPanel();
    jp.setLayout(new BorderLayout());

    jp.add(this, BorderLayout.WEST);
    jp.add(dui = new DebugUI(cpu), BorderLayout.CENTER);
    window.add(jp);

    createButton("Debug On");
    controlButton = createButton(cpu.isRunning() ? "Stop" : "Run");

    JButton stepButton = new JButton();
    // Allow the button to get the same height as the other buttons.
    stepButton.setMaximumSize(new Dimension(60, Short.MAX_VALUE));

    SpinnerNumberModel stepsModel = new SpinnerNumberModel();
    stepsModel.setValue(1);
    stepsModel.setMinimum(1);
    JSpinner stepsSpinner = new JSpinner(stepsModel);

    JPanel stepsPanel = new JPanel();
    stepsPanel.setLayout(new BoxLayout(stepsPanel, BoxLayout.LINE_AXIS));
    stepsPanel.add(stepButton);
    stepsPanel.add(stepsSpinner);
    add(stepsPanel);

    stepAction = new AbstractAction("Step") {
      private static final long serialVersionUID = 1L;

      public void actionPerformed(ActionEvent e) {
        stepButton.setEnabled(false);
        int steps = (int)stepsSpinner.getValue();
        for (int i = 0; i < steps; i++) {
          try {
            ControlUI.this.node.step();
          } catch (Exception e2) {
            e2.printStackTrace();
          }
        }
	  dui.updateRegs();
	  dui.repaint();
	  if (elfData != null && sourceViewer != null
	      && sourceViewer.isVisible()) {
	    int pc = ControlUI.this.cpu.getPC();
	    DebugInfo dbg = elfData.getDebugInfo(pc);
	    if (dbg != null) {
	      if (ControlUI.this.cpu.getDebug()) {
		System.out.println("looking up $" + Integer.toString(pc, 16) +
				   " => " + dbg.getFile() + ':' +
				   dbg.getLine());
	      }
	      sourceViewer.viewFile(dbg.getPath(), dbg.getFile());
	      sourceViewer.viewLine(dbg.getLine());
	    }
	  }
        stepButton.setEnabled(true);
	}
      };
    stepAction.putValue(Action.MNEMONIC_KEY, KeyEvent.VK_S);
    stepAction.setEnabled(!cpu.isRunning());
    stepButton.setAction(stepAction);

    createButton("Stack Trace");

    if (elfData != null) {
      createButton("Show Source");
    }
    createButton("Profile Dump");

    // Setup standard actions
    stepButton.registerKeyboardAction(stepAction,
                                      KeyStroke.getKeyStroke(KeyEvent.VK_S,
                                                             InputEvent.CTRL_DOWN_MASK),
                                      JComponent.WHEN_IN_FOCUSED_WINDOW);

    cpu.addSimEventListener(this);

    window.setVisible(true);
  }

  public void setSourceViewer(SourceViewer viewer) {
    sourceViewer = viewer;
  }

  private JButton createButton(String text) {
    JButton jb = new JButton(text);
    jb.addActionListener(this);
    add(jb);
    return jb;
  }

  private void updateCPUPercent() {
    window.setTitle(TITLE + "  CPU On: " + cpu.getCPUPercent() + "%");
  }

  public void actionPerformed(ActionEvent ae) {
    String cmd = ae.getActionCommand();
    updateCPUPercent();
    if ("Debug On".equals(cmd)) {
      cpu.setDebug(true);
      ((JButton) ae.getSource()).setText("Debug Off");

    } else if ("Debug Off".equals(cmd)) {
      cpu.setDebug(false);
      ((JButton) ae.getSource()).setText("Debug On");

    } else if ("Run".equals(cmd)) {
      node.start();
      
    } else if ("Stop".equals(cmd)) {
      node.stop();
      
    } else if ("Profile Dump".equals(cmd)) {
      if (cpu.getProfiler() != null) {
	cpu.getProfiler().printProfile(System.out);
      } else {
	System.out.println("*** No profiler available");
      }
      //     } else if ("Single Step".equals(cmd)) {
      //       cpu.step();
//       dui.repaint();
    } else if ("Show Source".equals(cmd)) {
      int pc = cpu.getPC();
      if (elfData != null) {
	DebugInfo dbg = elfData.getDebugInfo(pc);
	if (dbg != null) {
	  if (cpu.getDebug()) {
	    System.out.println("looking up $" + Integer.toString(pc, 16) +
			       " => " + dbg.getFile() + ':' + dbg.getLine());
	  }
	  if (sourceViewer != null) {
	    sourceViewer.viewFile(dbg.getPath(), dbg.getFile());
	    sourceViewer.viewLine(dbg.getLine());
	  } else {
	    System.out.println("File: " + dbg.getFile());
	    System.out.println("LineNr: " + dbg.getLine());
	  }
	}
      }
    } else if ("Stack Trace".equals(cmd)) {
      cpu.getProfiler().printStackTrace(System.out);
    }
    dui.updateRegs();
  }

  public void simChanged(SimEvent event) {
    switch (event.getType()) {
    case START:
    case STOP:
      java.awt.EventQueue.invokeLater(() -> {
        if (cpu.isRunning()) {
          controlButton.setText("Stop");
          stepAction.setEnabled(false);
        } else {
          controlButton.setText("Run");
          stepAction.setEnabled(true);
        }
      });
      break;
    }
  }

  public Status getStatus() {
      return status;
  }
  
  public String getName() {
      return name;
  }

  public void init(String name, ComponentRegistry registry) {
      this.name = name;
      this.registry = registry;
  }

  public void start() {
      setup();
      status = Status.STARTED;
      window.setVisible(true);
  }

  public void stop() {
      status = Status.STOPPED;
      window.setVisible(false);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/BarChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 *  BarChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;
import java.awt.Graphics2D;

/**
 *
 */
public class BarChart extends IntSerieChart {

  public BarChart() {
    // Do nothing
  }

  public BarChart(String name) {
    setName(name);
  }

  public void drawChart(Graphics2D g, double xfac, double yfac, int width, int height) {
    int[] data = this.data;
    if (data != null) {
      int minWidth = 1;
      if (xfac > 1) minWidth = (int) (xfac + 0.9);
      for (int i = 0, n = data.length; i < n; i++) {
        int y = (int) (yfac * data[i]);
        g.fillRect((int) (xfac * i), height - y, minWidth + 1, y + 1);
      }
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/StackUI.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * StackUI
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.ui;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;

import javax.swing.JPanel;

import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.RegisterMonitor;
import se.sics.mspsim.core.Memory.AccessMode;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.MapTable;
import se.sics.mspsim.util.ServiceComponent;

public class StackUI extends JPanel implements ServiceComponent {

  private static final long serialVersionUID = 8648239617509299768L;

  private static final int STACK_FRAME = 1024;
  private int updateCyclePeriod = 2500;

  private final MSP430 cpu;
  private int heapStartAddress = -1;
  private int stackStartAddress = -1;
  private ChartPanel chartPanel;
  private LineChart minStackChart;
  private LineChart maxStackChart;
  private LineChart maxUsageStackChart;
  
//  private DotDiagram diagram;
  private int[] minData = new int[STACK_FRAME];
  private int[] maxData = new int[STACK_FRAME];
  private int[] maxUsageData = new int[STACK_FRAME];
  private int[] minCache = new int[STACK_FRAME];
  private int[] maxCache = new int[STACK_FRAME];
  private int[] maxUsageCache = new int[STACK_FRAME];
//  private String[] notes = new String[STACK_FRAME];

  private long lastCycles = 0;
  private int pos = 0;

  private boolean update = false;

  private Status status = Status.STOPPED;

  private ComponentRegistry registry;

  private ManagedWindow window;
  private RegisterMonitor registerMonitor;

  private String name;

  private boolean increasePos = false;
      
  public StackUI(MSP430 cpu) {
    this(cpu, 2500);
  }

  public StackUI(MSP430 cpu, int updateCyclePeriod) {
    super(new BorderLayout());
    this.updateCyclePeriod = updateCyclePeriod;
    this.cpu = cpu;

//    diagram = new DotDiagram(2);
//    diagram.setDotColor(0, Color.green);
//    diagram.setDotColor(1, Color.green);
//    diagram.addConstant(Color.red,
//        this.stackStartAddress - this.heapStartAddress);
//    diagram.setShowGrid(true);
//    add(diagram, BorderLayout.CENTER);
  }

  public void requestIncreasePos() {
    increasePos = true;
  }
  
  private void setup() {
      if (chartPanel != null) return;

      if (this.heapStartAddress < 0 && cpu.getDisAsm() != null) {
          MapTable mapTable = cpu.getDisAsm().getMap();
          if (mapTable != null) {
              this.heapStartAddress = mapTable.heapStartAddress;
              this.stackStartAddress = mapTable.stackStartAddress;
          }
      }
      if (this.stackStartAddress < 0) {
          // Did not find stack information in the firmware. Use CPU RAM
          // boundary as most compilers will use this as stack.
          this.stackStartAddress = cpu.config.ramStart + cpu.config.ramSize;
      }
      chartPanel = new ChartPanel();

      if (this.stackStartAddress > 0 && this.heapStartAddress > 0) {
          ConstantLineChart maxChart = new ConstantLineChart("Max", this.stackStartAddress - this.heapStartAddress);
          maxChart.setConfig("color", Color.red);
          chartPanel.addChart(maxChart);
      }

      minStackChart = new LineChart("Min Stack");
      minStackChart.setConfig("color", Color.green);
      chartPanel.addChart(minStackChart);

      maxStackChart = new LineChart("Max Stack");
      maxStackChart.setConfig("color", Color.green);
      chartPanel.addChart(maxStackChart);

      maxUsageStackChart = new LineChart("Max usage");
      maxUsageStackChart.setConfig("color", Color.blue);
      chartPanel.addChart(maxUsageStackChart);

      chartPanel.setAxisChart(maxStackChart);
      
      add(chartPanel, BorderLayout.CENTER);
      chartPanel.setMinimumSize(new Dimension(320, 200));
      setPreferredSize(new Dimension(320, 200));
      setSize(320, 200);
      setMinimumSize(new Dimension(320, 200));
      
      WindowManager wm = registry.getComponent(WindowManager.class);
      if (wm != null) {
          window = wm.createWindow("stackui");
          window.add(this);
      }

      registerMonitor = new RegisterMonitor.Adapter() {
          private int m = 0;
          public void notifyWriteBefore(int register, int data, AccessMode mode) {
              int size = stackStartAddress - data;
              if (minData[pos] > size) {
                  minData[pos] = size;
              }
              if (m < size) {
                m = size;
              }
              if (maxData[pos] < size) {
                  maxData[pos] = size;
              }
              if ((updateCyclePeriod > 0 && cpu.cpuCycles - lastCycles > updateCyclePeriod)
                  || increasePos) {
                increasePos = false;
                  lastCycles = cpu.cpuCycles;
//                    System.out.println("STACK UPDATE: " + type + "," + adr + "," + data + "," + pos);
                  
                  pos = (pos + 1) % minData.length;
                  minData[pos] = Integer.MAX_VALUE;
                  maxUsageData[pos] = m;
                  maxData[pos] = 0;
                  update = true;
                  repaint();
//                    this.notes[pos] = null;
//                    diagram.setData(0, this.minData, pos, this.minData.length);
//                    diagram.setDataWithNotes(1, this.maxData, notes, pos, this.maxData.length);
              }
          }
      };
  }

  public void paint(Graphics g) {
    if (update) {
      update = false;

      int p = pos;
      copy(this.minData, this.minCache, p);
      copy(this.maxData, this.maxCache, p);
      copy(this.maxUsageData, this.maxUsageCache, p);
      minStackChart.setData(this.minCache);
      maxStackChart.setData(this.maxCache);
      maxUsageStackChart.setData(this.maxUsageCache);
    }
    super.paint(g);
  }


  private void copy(int[] data1, int[] data2, int p) {
    if (p + 1 < data1.length) {
      System.arraycopy(data1, p + 1, data2, 0, data1.length - p - 1);
    }
    if (p > 0) {
      System.arraycopy(data1, 0, data2, data1.length - p, p);
    }
  }

  public Status getStatus() {
    return status;
  }

  public void init(String name, ComponentRegistry registry) {
    this.registry = registry;
    this.name = name;
  }

  public String getName() {
    return name;
  }

  public void start() {
    setup();
    status = Status.STARTED;
    cpu.addRegisterWriteMonitor(MSP430.SP, registerMonitor);
    window.setVisible(true);
  }

  public void stop() {
    status = Status.STOPPED;
    window.setVisible(false);
    if (registerMonitor != null) {
        cpu.removeRegisterWriteMonitor(MSP430.SP, registerMonitor);
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/SerialMon.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * SerialMon
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.ui;
import java.awt.BorderLayout;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.ArrayDeque;

import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;

import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.ServiceComponent;

public class SerialMon implements USARTListener, StateChangeListener, ServiceComponent {

  private static final int MAX_LINES = 200;

  private String name;
  private ServiceComponent.Status status = Status.STOPPED;

  private final USARTSource usart;
  private final String title;  

  private JFrame window;
  private JTextArea textArea;
  private JTextField commandField;
  private String[] history = new String[50];
  private int historyPos = 0;
  private int historyCount = 0;
  private String text = "*** Serial mon for MSPsim ***\n";

  private ArrayDeque<String> sendQueue = new ArrayDeque<String>(8);
  private int sendIndex;

  private int lines = 1;
  private boolean isUpdatePending = false;

  public SerialMon(USARTSource usart, String title) {
    this.usart = usart;
    this.title = title;
  }

  public Status getStatus() {
    return status;
  }

  public String getName() {
    return name;
  }

  public final void init(String name, ComponentRegistry registry) {
    this.name = name;
  }

  private void initGUI() {
    window = new JFrame(title);
//     window.setBounds(100, 100, 400,340);
    window.add(new JScrollPane(textArea = new JTextArea(20, 40),
			       JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
			       JScrollPane.HORIZONTAL_SCROLLBAR_NEVER),
	       BorderLayout.CENTER);
    textArea.setText(text);
    textArea.setEditable(false);

    JPopupMenu popupMenu = new JPopupMenu();
    JMenuItem clearItem = new JMenuItem("Clear");
    clearItem.addActionListener(new ActionListener() {

      public void actionPerformed(ActionEvent e) {
        textArea.setText("");
        lines = 0;
      }

    });
    popupMenu.add(clearItem);
    textArea.setComponentPopupMenu(popupMenu);

    commandField = new JTextField();
    commandField.addActionListener(new ActionListener() {

      public void actionPerformed(ActionEvent e) {
        String command = commandField.getText().trim();
        if (command.length() > 0) {
          if (sendCommand(command)) {
            int previous = historyCount - 1;
            if (previous < 0) previous += history.length;
            if (!command.equals(history[previous])) {
                history[historyCount] = command;
                historyCount = (historyCount + 1) % history.length;
            }
            historyPos = historyCount;
            commandField.setText("");
          } else {
            commandField.getToolkit().beep();
          }
        }
      }

    });
    commandField.addKeyListener(new KeyAdapter() {

      @Override
      public void keyPressed(KeyEvent e) {
        switch (e.getKeyCode()) {
        case KeyEvent.VK_UP: {
          int nextPos = (historyPos + history.length - 1) % history.length;
          if (nextPos == historyCount || history[nextPos] == null) {
            commandField.getToolkit().beep();
          } else {
            String cmd = commandField.getText().trim();
            if (cmd.length() > 0) {
              history[historyPos] = cmd;
            }
            historyPos = nextPos;
            commandField.setText(history[historyPos]);
          }
          break;
        }
        case KeyEvent.VK_DOWN: {
          int nextPos = (historyPos + 1) % history.length;
          if (nextPos == historyCount) {
            historyPos = nextPos;
            commandField.setText("");
          } else if (historyPos == historyCount || history[nextPos] == null) {
            commandField.getToolkit().beep();
          } else {
            String cmd = commandField.getText().trim();
            if (cmd.length() > 0) {
              history[historyPos] = cmd;
            }
            historyPos = nextPos;
            commandField.setText(history[historyPos]);
          }
          break;
        }
        }
      }

    });
    window.add(commandField, BorderLayout.SOUTH);

    String key = "usart." + name;
    WindowUtils.restoreWindowBounds(key, window);
    WindowUtils.addSaveOnShutdown(key, window);
  }

  public void start() {
    if (window == null) {
      initGUI();
      usart.addUSARTListener(this);
      usart.addStateChangeListener(this);
    }
    window.setVisible(true);
    status = Status.STARTED;
  }

  public final void stop() {
    status = Status.STOPPED;
    if (window != null) {
      window.setVisible(false);
    }
    usart.removeUSARTListener(this);
    usart.removeStateChangeListener(this);
  }

  public void dataReceived(USARTSource source, int data) {
    if (data == '\n') {
      if (lines >= MAX_LINES) {
	int index = text.indexOf('\n');
	text = text.substring(index + 1);
      } else {
	lines++;
      }
    }
    text += (char)data;

    // Collapse several immediate updates
    if (!isUpdatePending) {
      isUpdatePending = true;
      EventQueue.invokeLater(new Runnable() {
	  public void run() {
	    isUpdatePending = false;

	    final String newText = text;
	    textArea.setText(newText);
	    textArea.setCaretPosition(newText.length());
	    textArea.repaint();
	  }
	});
    }
  }


  // -------------------------------------------------------------------
  // KeyListener
  // -------------------------------------------------------------------

  protected boolean sendCommand(String command) {
    synchronized (sendQueue) {
      /* Do not queue too many commands */
      if (sendQueue.size() == 8) {
        commandField.setEnabled(false);
        return false;
      }
      sendQueue.add(command);
    }
    sendNext();
    return true;
  }

  public void stateChanged(Object source, int oldState, int newState) {
    if (newState == USARTListener.RXFLAG_CLEARED) {
      sendNext();
    }
  }

  private void sendNext() {
    boolean updateCommand = false;
    char c;
    while (usart.isReceiveFlagCleared()) {
      synchronized (sendQueue) {
        String next = sendQueue.peekFirst();
        if (next == null) {
          break;
        }
        if (sendIndex == next.length()) {
          sendQueue.removeFirst();
          sendIndex = 0;
          c = '\n';
          updateCommand = true;
        } else {
          c = next.charAt(sendIndex++);
        }
      }
      usart.byteReceived((byte)c);
      dataReceived(usart, c);
    }
    if (updateCommand && !commandField.isEnabled()) {
      EventQueue.invokeLater(new Runnable() {
        public void run() {
          commandField.setEnabled(true);
        }
      });
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/ConsoleUI.java`:

```java
/**
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: ChartPanel.java 740 2010-07-19 12:53:27Z nifi $
 *
 * -----------------------------------------------------------------
 *
 * ConsoleUI
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : March 20 2010
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.ui;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.StringSelection;
import java.awt.datatransfer.Transferable;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayDeque;

import javax.swing.JComponent;
import javax.swing.Timer;

import se.sics.mspsim.cli.CommandHandler;

/* Console UI for command line interfaces
 *
 * TODO
 * - add setting selection
 * - scrollbar for view-history.
 *
 */
public class ConsoleUI extends JComponent {

  private static final long serialVersionUID = -4398393961025971500L;

  private Timer timer;

  private String[] history = new String[200];
  private int pos;

  /* this is the "edit" line */
  private char[] chars = new char[1024];

  /* up to 200 visible lines */
  private String[] lines = new String[200];

  private int lineCount = 0;
  private int lastVisible = 0;

  /* the lines that are on the screen */
  /*
   * will be rendered line-by-line from line 0 to line "bottomLine"
   */

  private String[] screenLines = new String[50];
  /* size of lines */
  int lineWidth = 40;

  private ArrayDeque<String> commands = new ArrayDeque<String>();

  private int len = 0;
  private int back = 0;

  private int charWidth = 7;
  private int charHeight = 11;
  private int bottomLine = 30;

  private CommandHandler commandHandler;

  /* editor variables */
  private boolean insert = true;
  private boolean editing = false;
  private boolean cursor;

  private int editPos = 0;
  private int cursorX = 0;
  private int minCursorX = 0;
  private int cursorY = 0;

  private boolean selectActive = false;
  private int selectStartX = 0;
  private int selectStartY = 0;
  private int selectEndX = 0;
  private int selectEndY = 0;


  private static int MIN_X = 8;
  
  public ConsoleUI() {
    setFont(Font.decode("Courier-12"));
    setOpaque(true);
    setFocusable(true);
    setFocusTraversalKeysEnabled(false);

    MouseAdapter mouseHandler = new MouseAdapter() {
      public void mouseReleased(MouseEvent e) {
        if (e.getButton() == MouseEvent.BUTTON1) {
          selectActive = false;
          selectEndX = (e.getX() - 10) / charWidth;
          selectEndY = (e.getY() - 4) / charHeight;
          repaint();
        }
      }

      public void mousePressed(MouseEvent e) {
        if (e.getButton() == MouseEvent.BUTTON1) {
          selectActive = true;
          selectStartX = selectEndX = (e.getX() - 10) / charWidth;
          selectStartY = selectEndY = (e.getY() - 4) / charHeight;
        }
      }

      public void mouseDragged(MouseEvent e) {
        if (selectActive) {
          selectEndX = (e.getX() - 10) / charWidth;
          selectEndY = (e.getY() - 4) / charHeight;
          repaint();
        }
      }
    };
    addMouseListener(mouseHandler);
    addMouseMotionListener(mouseHandler);
    addKeyListener(new KeyListener() {
      public void keyTyped(KeyEvent e) {
        switch (e.getKeyChar()) {
        case 1: /* Ctrl-A */
          cursorX = minCursorX;
          editPos = 0;
          break;
        case 2: /* Ctrl-B */
          if (editPos > 0) {
            editPos--;
            cursorX--;
          }
          break;
        case 4: /* Ctrl-D */
          removeChar(false);
          break;
        case 5: /* Ctrl-E */
          cursorX = len + minCursorX;
          editPos = len;
          break;
        case 6: /* Ctrl-F */
          if (editPos < len) {
            cursorX++;
            editPos++;
          }
          break;
        case 11: /* Ctrl-K */
          if (editPos < len) {
            // TODO copy to clipboard
            len = editPos;
            layoutRows();
            repaint();
          }
          break;
        case 12: /* Ctrl-L */
          cursorY = 0;
          lastVisible = 0;
          lines[0] = null;
          layoutRows();
          repaint();
          break;
        case 14:
          setHistory(-1);
          break;
        case 16:
          setHistory(1);
          break;
        case 3: /* Ctrl-C */
          copySelection();
          break;
        case 22: /* Ctrl-V */
        case 25: /* Ctrl-Y */
          paste(getClipboardContents());
          break;
        case KeyEvent.VK_ENTER:
          handleChar('\n');
          break;
        case KeyEvent.VK_BACK_SPACE:
        case KeyEvent.VK_DELETE:
          removeChar(e.getKeyChar() == KeyEvent.VK_BACK_SPACE);
          break;
        default:
          handleChar(e.getKeyChar());
        }
      }

      public void keyReleased(KeyEvent e) {
      }

      public void keyPressed(KeyEvent e) {
        switch (e.getKeyCode()) {
        case KeyEvent.VK_RIGHT:
          if (editPos < len) {
            cursorX++;
            editPos++;
          }
          break;
        case KeyEvent.VK_LEFT:
          if (editPos > 0) {
            editPos--;
            cursorX--;
          }
          break;
        case KeyEvent.VK_HOME:
          cursorX = minCursorX;
          editPos = 0;
          break;
        case KeyEvent.VK_END:
          cursorX = len + minCursorX;
          editPos = len;
          break;
        case KeyEvent.VK_UP:
          setHistory(1);
          break;
        case KeyEvent.VK_DOWN:
          setHistory(-1);
          break;
        }
        layoutRows();
        repaint();
      }
    });
    output('>');
    timer = new Timer(500, new ActionListener() {
      public void actionPerformed(ActionEvent arg0) {
        flashCursor();
      }
    });
    timer.start();
  }

  @Override
  public void setVisible(boolean visible) {
    super.setVisible(visible);
    if (timer == null) {
      // Ignore
    } else if (visible) {
      timer.start();
    } else {
      timer.stop();
    }
  }

  private void removeChar(boolean back) {
    if ((back && editPos > 0) || (!back && editPos < len)) {
      int ep = editPos - (back ? 1 : 0);
      System.arraycopy(chars, ep + 1, chars, ep, len - ep);
      if (back) {
        cursorX--;
        editPos--;
      }
      len--;
      layoutRows();
      repaint();
    }
  }

  private void paste(String s) {
    for (int i = 0; s != null && i < s.length(); i++) {
      handleChar(s.charAt(i));
    }
  }

  private void handleChar(char c) {
    switch (c) {
    case '\n':
      String line = new String(chars, 0, len);
      if (line.trim().length() > 0)
        history[pos++] = line;
      addLine(currentOutput.toString() + line);
      if (pos >= history.length)
        pos = 0;
      back = 0;
      executeCommand(line);
      break;
    default:
      if (insert && editPos < len) {
        System.arraycopy(chars, editPos, chars, editPos + 1, len - editPos);
      }
      chars[editPos++] = c;
      cursorX++;
      len++;
      editing = true;
    }
    /*
     * complete re-layout - needs to be optimized later - layout is only needed
     * for last "row" that is under editing.
     */
    layoutRows();
    repaint();
  }

  private void executeCommand(String line) {
    synchronized (commands) {
      commands.add(line);
      commands.notify();
    }
  }

  private void copySelection() {
    if (selectEndX != selectStartX || selectEndY != selectStartY) {
      int x = selectStartX;
      int xe = selectEndX;
      int y = selectStartY;
      int ye = selectEndY;
      if (selectEndY < selectStartY || selectStartY == selectEndY
          && selectEndX < selectStartX) {
        x = selectEndX;
        xe = selectStartX;
        y = selectEndY;
        ye = selectStartY;
      }
      StringBuilder selection = new StringBuilder();
      for (int i = y; i < ye; i++) {
        String data = screenLines[i];
        if (data.length() > x) {
          selection.append(data.substring(x, data.length())).append('\n');
          x = 0;
        }
      }
      if (screenLines[ye].length() > xe) {
        selection.append(screenLines[ye].substring(x, xe));
      }
      StringSelection stringSelection = new StringSelection(
          selection.toString());
      Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
      clipboard.setContents(stringSelection, null);
    }
  }

  /**
   * Get the String residing on the clipboard.
   */
  public String getClipboardContents() {
    Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();
    Transferable contents = clipboard.getContents(null);
    if ((contents != null)
        && contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      try {
        return (String) contents.getTransferData(DataFlavor.stringFlavor);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    return null;
  }

  /* make the "screen" lines the correct ones. */
  /*
   * This will NOT handle the current EDIT line(s) This is used for "refreshing"
   * the screen completely. It is possible to just scroll upwards if just adding
   * another "last" line.
   */
  int scrCursorX = 0;
  int scrCursorY = 0;

  private int layoutRows() {
      
    scrCursorX = cursorX;
    scrCursorY = cursorY;

    /* bottom line is the last visible line */
    int scrLine = bottomLine;

    int fetchLine = lastVisible - 1;
    /* wrap fetch-line if needed - or possibly move back to just 0 */
    if (fetchLine == -1) {
        fetchLine += lineCount == lines.length ? lines.length : 1;
    }
    /* actual last visible line */
    String ll = currentOutput.toString() + new String(chars, 0, len);
    while (scrLine >= 0 && fetchLine >= 0 && ll != null) {
      int neededRows = 1 + (ll.length() / lineWidth);
      int lastStartPos = (neededRows - 1) * lineWidth;
      int lastEndPos = ll.length();

      while (neededRows > 0 && scrLine >= 0) {
        screenLines[scrLine] = ll.substring(lastStartPos, lastEndPos);
        scrLine--;
        neededRows--;
        lastEndPos = lastStartPos;
        lastStartPos -= lineWidth;
      }
      ll = lines[fetchLine--];
      /* wrap if needed */
      if (fetchLine == -1 && lineCount == lines.length) {
          fetchLine = lines.length - 1;
      }
    }
    return bottomLine - scrLine;
  }

  private void setHistory(int diff) {
    back += diff;
    if (back < 0)
      back = 0;
    String historyLine = history[((pos - back) + history.length)
        % history.length];
    if (historyLine == null) {
      back = 0;
      return;
    }
    char[] arr = historyLine.toCharArray();
    System.arraycopy(arr, 0, chars, 0, arr.length);
    len = arr.length;
    cursorX = minCursorX + len;
    editPos = len;
    editing = true;
    /* layout and repaint */
    layoutRows();
    repaint();
  }

  private void flashCursor() {
    cursor = !cursor;
    repaint(MIN_X + (cursorX % lineWidth) * charWidth, 10 + cursorY * charHeight,
        charWidth, 2);
  }

  StringBuffer currentOutput = new StringBuffer();

  int oldBottomLine = 0;
  protected void paintComponent(Graphics g) {
    int pos = 0;
    int w = getWidth() - 8;
    int h = getHeight() - 15;
        
    Rectangle clip = g.getClipBounds();
    if (w / charWidth != lineWidth || h / charHeight != bottomLine) {
      lineWidth = w / charWidth;
      bottomLine = h / charHeight;

      if (oldBottomLine != bottomLine) {
          if (cursorY > bottomLine) cursorY = bottomLine;
          if (screenLines.length < bottomLine) {
              screenLines = new String[(h / charHeight) + 10];
          }
          int rowCount = layoutRows();
          if (cursorY < rowCount) cursorY = rowCount;
          oldBottomLine = bottomLine;
      } else {
          /* no Y-size change */
          layoutRows();
      }
    }
    g.setColor(getBackground());
    g.fillRect(clip.x, clip.y, clip.width, clip.height);
    g.setColor(getForeground());

    if (selectEndX != selectStartX || selectEndY != selectStartY) {
      g.setColor(Color.LIGHT_GRAY);
      int x = selectStartX;
      int xe = selectEndX;
      int y = selectStartY;
      int ye = selectEndY;
      if (selectEndY < selectStartY || selectStartY == selectEndY
          && selectEndX < selectStartX) {
        x = selectEndX;
        xe = selectStartX;
        y = selectEndY;
        ye = selectStartY;
      }
      for (; y < ye; y++) {
        g.fillRect(MIN_X + x * charWidth, y * charHeight, w, charHeight + 2);
        x = 0;
      }
      g.fillRect(MIN_X + x * charWidth, ye * charHeight, (xe - x) * charWidth,
          charHeight + 2);
      g.setColor(getForeground());
    }

    /* reserved... => scr */
    int i = bottomLine;
    pos = cursorY * charHeight;
    while (i >= 0 && screenLines[i] != null) {
      g.drawString(screenLines[i], MIN_X, 10 + pos);
      pos -= charHeight;
      i--;
    }

    if (cursor) {
      g.fillRect(MIN_X + (cursorX % lineWidth) * charWidth, 10 + cursorY
          * charHeight, charWidth, 2);
    }
  }

  StringBuffer buffer = new StringBuffer();

  /* add a line to the "visible" screen */
  private void addLine(String line) {
    lines[lastVisible] = line;
    currentOutput.setLength(0);
    if (cursorY < bottomLine) {
      cursorY++;
    }
    lastVisible++;

    if (lineCount < lines.length) lineCount++;
    
    if (lastVisible >= lines.length) {
        lastVisible = 0;
    }
    /* editor is reset too */
    editPos = minCursorX = cursorX = len = 0;

    if (editing != false && buffer.length() > 0) {
      /*
       * set edit to false so we do not get here again before end of "printout".
       */
      editing = false;
      String s = buffer.toString();
      for (int i = 0; i < s.length(); i++) {
        addChar(s.charAt(i));
      }
      buffer.setLength(0);
    }
    editing = false;
    layoutRows();
    repaint();
  }

  /* just print space instead of tabs */
  String tabs = "           ";

  /* print char to the shell */
  public void output(int c) {
    if (!editing) {
      addChar(c);
    } else {
      /* ignore or buffer when in edit mode (add buffer later) */
      buffer.append((char) c);
    }
  }

  private void addChar(int c) {
    if (c == '\t') {
      int p = 8 - (cursorX & 7);
      currentOutput.append(tabs.substring(0, p));
      cursorX += p;
      minCursorX += p;
    } else if (c == '\n') {
      addLine(currentOutput.toString());
      currentOutput.setLength(0);
    } else {
      cursorX++;
      minCursorX++;
      currentOutput.append((char) c);
    }
  }

  public OutputStream getOutputStream() {
    return new OutputStream() {
      public void write(int c) throws IOException {
        output(c);
      }
    };
  }

  public void setCommandHandler(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
    new Thread(new Runnable() {
      public void run() {
        while (true) {
          String command = null;
          try {
            synchronized (commands) {
              while (commands.isEmpty()) {
                commands.wait();
              }
              command = commands.removeFirst();
            }
          } catch (InterruptedException e) {
            e.printStackTrace();
          }
          if (command != null) {
            ConsoleUI.this.commandHandler.lineRead(command);
            output('>');
            layoutRows();
            repaint();
          }
        }
      }
    }).start();
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/WindowUtils.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * WindowUtils
 *
 * Author  : Joakim Eriksson, Niclas Finne, Fredrik Osterlind
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.ui;
import java.awt.Window;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.prefs.Preferences;

public class WindowUtils {

  private static Preferences prefs =
    Preferences.userNodeForPackage(WindowUtils.class);

  private static Hashtable<Window,CloseListener> closeTable;
  private static Hashtable<Window,String> exitTable;

  private WindowUtils() {
  }

  public static void saveWindowBounds(String key, Window window) {
    putWindowBounds(key, window);
    try {
      prefs.flush();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  private static void putWindowBounds(String key, Window window) {
    prefs.put("window." + key + ".bounds", getBounds(window));
  }

  public static void restoreWindowBounds(String key, Window window) {
    setBounds(window, prefs.get("window." + key + ".bounds", null));
  }

  private static String getBounds(Window window) {
    return "" + window.getX()
      + ',' + window.getY()
      + ',' + window.getWidth()
      + ',' + window.getHeight();
  }

  private static void setBounds(Window window, String bounds) {
    String[] b;
    if ((bounds != null)
	&& ((b = bounds.split(",")) != null)
	&& b.length == 4) {
      try {
	window.setBounds(Integer.parseInt(b[0]),
			 Integer.parseInt(b[1]),
			 Integer.parseInt(b[2]),
			 Integer.parseInt(b[3]));
      } catch (Exception e) {
	e.printStackTrace();
	window.pack();
      }
    } else {
      window.setLocationByPlatform(true);
      window.pack();
    }
  }

  public static void clearState() {
    try {
      prefs.clear();
    } catch (Exception e) {
      e.printStackTrace();
    }
  }

  public synchronized static void addSaveOnClose(String key, Window window) {
    if (closeTable == null) {
      closeTable = new Hashtable<Window,CloseListener>();
    }
    if (closeTable.get(window) == null) {
      CloseListener c = new CloseListener(key);
      window.addWindowListener(c);
      closeTable.put(window, c);
    }
  }

  public synchronized static void removeSaveOnClose(Window window) {
    if (closeTable != null) {
      CloseListener c = closeTable.remove(window);
      if (c != null) {
	window.removeWindowListener(c);
      }
    }
  }

  public synchronized static void addSaveOnShutdown(String key, Window window) {
    if (exitTable == null) {
      exitTable = new Hashtable<Window,String>();
      Runtime.getRuntime().addShutdownHook(new ShutdownHandler());
    }
    exitTable.put(window, key);
  }

  public synchronized static void removeSaveOnShutdown(Window window) {
    if (exitTable != null) {
      exitTable.remove(window);
    }
  }



  // -------------------------------------------------------------------
  // Main
  // -------------------------------------------------------------------

  public static void main(String[] args) {
    if (args.length != 1 || !args[0].equals("-clearState")) {
      System.err.println("Usage: WindowUtils -clearState");
      System.exit(1);
    }
    clearState();
  }


  // -------------------------------------------------------------------
  // CloseListener
  // -------------------------------------------------------------------

  private static class CloseListener extends WindowAdapter {

    private String key;

    public CloseListener(String key) {
      this.key = key;
    }

    public void windowClosing(WindowEvent e) {
      Window source = (Window) e.getSource();
      saveWindowBounds(key, source);
      source.removeWindowListener(this);
      closeTable.remove(source);
    }

  }


  // -------------------------------------------------------------------
  // Shutdown handler
  // -------------------------------------------------------------------

  private static class ShutdownHandler extends Thread {

    public ShutdownHandler() {
      super("WindowUtils-Shutdown");
    }

    public void run() {
      Hashtable<Window,String> table = exitTable;
      if (table != null && table.size() > 0) {
	exitTable = null;

	Enumeration<Window> e = table.keys();
	while(e.hasMoreElements()) {
	  Window w = e.nextElement();
	  putWindowBounds(table.get(w), w);
	}
	try {
	  prefs.flush();
	} catch (Exception e2) {
	  e2.printStackTrace();
	}
      }
    }

  }

} // WindowUtils

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/SourceViewer.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 *
 * -----------------------------------------------------------------
 *
 * Source Viewer
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;


public interface SourceViewer {

  public boolean isVisible();
  public void viewFile(String path, String file);
  public void viewLine(int line);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/LineChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * LineChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;
import java.awt.Graphics2D;

/**
 *
 */
public class LineChart extends IntSerieChart {

  public LineChart() {
    // Do nothing
  }

  public LineChart(String name) {
    setName(name);
  }

  public void drawChart(Graphics2D g, double xfac, double yfac, int width, int height) {
    int[] lastData = this.data;
    if (lastData != null) {
//      int minWidth = 1;
//      if (xfac > 1) minWidth = (int) (xfac + 0.9);
      int lastX = -1;
      int lastY = -1;
      int zero = height;
      if (getMinY() < 0) {
        zero += (int) (yfac * getMinY());
      }
      for (int i = 0, n = lastData.length; i < n; i++) {
        int y = (int) (zero - (yfac * lastData[i]));
        int x = (int) (xfac * i);
        if (lastX != -1) {
          g.drawLine(x, y, lastX, lastY);
        }
        lastX = x;
        lastY = y;
      }
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/ConstantLineChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ConstantLineChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;

import java.awt.Graphics2D;

public class ConstantLineChart extends AbstractChart {

  private int lineY;

  public ConstantLineChart(int y) {
    this.lineY = y;
  }

  public ConstantLineChart(String name, int y) {
    setName(name);
    this.lineY = y;
    updateMinMax();
  }

  public void drawChart(Graphics2D g, double xfac, double yfac, int width, int height) {
    int zero = height;
    if (getMinY() < 0) {
      zero += (int) (yfac * getMinY());
    }
    int y = (int) (zero - (yfac * lineY));
    g.drawLine(0, y, width, y);
  }

  @Override
  protected void updateMinMax() {
    this.minx = 0;
    this.maxx = 1;
    this.miny = this.maxy = lineY;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/DoubleSerieChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * DoubleSerieChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;

/**
 *
 */
public abstract class DoubleSerieChart extends AbstractChart {

  protected double[] data;

  public void setData(double[] data) {
    this.data = data;
    updateMinMax();
  }

  protected void updateMinMax() {
    this.minx = 0;
    this.maxx = data == null ? 0 : data.length;

    if (!autoscale) {
      // Do not update miny, maxy
    } else if (data == null || data.length == 0) {
      miny = maxy = 0.0;
    } else {
      miny = maxy = data[0];
      for (int i = 1, n = data.length; i < n; i++) {
        double v = data[i];
        if (v < miny) miny = v;
        if (v > maxy) maxy = v;
      }
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/ManagedWindow.java`:

```java
package se.sics.mspsim.ui;

import java.awt.Component;

public interface ManagedWindow {

  public void setSize(int width, int height);
  public void setBounds(int x, int y, int width, int height);
  public void pack();

  public void add(Component component);
  public void removeAll();

  public boolean isVisible();

  public void setVisible(boolean b);

  public String getTitle();

  public void setTitle(String string);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/ChartPanel.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ChartPanel
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Insets;
import java.util.Hashtable;

import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.border.Border;

import se.sics.mspsim.util.ArrayUtils;

/**
 *
 */
public class ChartPanel extends JComponent {

  private static final long serialVersionUID = 7243446493049199594L;

  public static final String COLOR_TICK = "color.tick";

  private static final Border DEFAULT_BORDER =
    BorderFactory.createEmptyBorder(10,10,10,10);

  private static final Color[] DEFAULT_COLOR = {
    Color.blue, new Color(0xff008000), Color.red, Color.black
  };

  private static final Color LIGHT_GRAY = new Color(0xff909090);

  private Hashtable<String,Object> config = new Hashtable<String,Object>();
  private Chart[] charts = null;

  private Chart axisChart;

  /**
   *
   */
  public ChartPanel() {
    setForeground(Color.black);
    setBackground(Color.white);
    setBorder(DEFAULT_BORDER);
    setOpaque(true);
  }

  public Chart getAxisChart() {
    return axisChart;
  }

  public void setAxisChart(Chart chart) {
    this.axisChart = chart;
  }

  public synchronized void addChart(Chart chart) {
    charts = ArrayUtils.add(Chart.class, charts, chart);
  }

  public synchronized void removeChart(Chart chart) {
    charts = ArrayUtils.remove(charts, chart);
  }

  public Chart getChart(String name) {
    Chart[] charts = this.charts;
    if (charts != null) {
      for (int i = 0, n = charts.length; i < n; i++) {
        if (name.equals(charts[i].getName())) {
          return charts[i];
        }
      }
    }
    return null;
  }

  public Chart[] getCharts() {
    return charts;
  }

  public Object getConfig(String param) {
    return getConfig(param, null);
  }

  public Object getConfig(String param, Object defVal) {
    Object retVal = config.get(param);
    return retVal != null ? retVal : defVal;
  }

  public void setConfig(String param, Object value) {
    if (value != null) {
      config.put(param, value);
    } else {
      config.remove(param);
    }
  }

  private Color getDefaultColor(int index) {
    return DEFAULT_COLOR[index % DEFAULT_COLOR.length];
  }


  // -------------------------------------------------------------------
  // Paint handling
  // -------------------------------------------------------------------

  protected void paintComponent(Graphics g) {
    Graphics2D g2d = (Graphics2D) g.create();
    try {
      if (isOpaque()) {
        g2d.setColor(getBackground());
        g2d.fillRect(0, 0, getWidth(), getHeight());
      }
      paintCharts(g2d);
    } finally {
      g2d.dispose();
    }
  }

  protected void paintCharts(Graphics2D g) {
    Chart axisChart = this.axisChart;
    Color foreground = getForeground();
    Color tickColor = (Color) getConfig(COLOR_TICK, LIGHT_GRAY);
    FontMetrics fm = getFontMetrics(g.getFont());
    int fmHeight = fm.getAscent();
    Insets insets = getInsets();
    int height = getHeight();
    int width = getWidth();
    int leftInset = 40;
    height -= insets.top + insets.bottom + fmHeight + 2;
    width -= leftInset + insets.left + insets.right + 2;
    g.translate(leftInset + insets.left + 1, insets.top + 1);

    g.setColor(foreground);
    g.drawRect(-1, -1, width + 2, height + 2);

    Chart[] chs = getCharts();
    if (chs != null && chs.length > 0) {
      double totMaxY = Double.MIN_VALUE, totMinY = Double.MAX_VALUE; 
      double totMaxX = Double.MIN_VALUE, totMinX = Double.MAX_VALUE; 

      for (int i = 0, n = chs.length; i < n; i++) {
        Chart chart = chs[i];
        double maxY = chart.getMaxY();
        double minY = chart.getMinY();
        double minX = chart.getMinX();
        double maxX = chart.getMaxX();
        if (maxY >= minY && maxX > minX) {
          if (maxY > totMaxY) totMaxY = maxY;
          if (minY < totMinY) totMinY = minY;

          if (maxX > totMaxX) totMaxX = maxX;
          if (minX < totMinX) totMinX = minX;
        }
      }
      if (totMaxY >= totMinY && totMaxX > totMinX) {
        double yfac = (1.0 * height) / (totMaxY - totMinY);
        double xfac = (1.0 * width) / (totMaxX - totMinX);
        int zero = height;
        if (totMinY < 0) {
          zero += (int) (yfac * totMinY);
        }

        if (axisChart != null) {
//          double maxY = axisChart.getMaxY();
//          double minY = axisChart.getMinY();
//          double minX = axisChart.getMinX();
//          double maxX = axisChart.getMaxX();

//        if (maxY != minY && maxX != minX) {
          // Draw zero line
          g.setColor(tickColor);
          g.drawLine(0, zero, width, zero);
          g.setColor(foreground);
          g.drawString("0", -4 - fm.stringWidth("0"), zero + fmHeight / 2);

          double gridValue = getGridValue(totMinY, totMaxY, 10);
          for (double d = gridValue; d < totMaxY; d += gridValue) {
            int y = (int) (zero - yfac * d);
            String text = "" + (int) d;
            int tlen = fm.stringWidth(text);
            g.setColor(tickColor);
            g.drawLine(0, y, width, y);
            g.setColor(foreground);
            g.drawString(text, -4 - tlen, y + fmHeight / 2);
          }
          for (double d = gridValue; d < -totMinY; d += gridValue) {
            int y = (int) (zero + yfac * d);
            String text = "" + (int) -d;
            int tlen = fm.stringWidth(text);
            g.setColor(tickColor);
            g.drawLine(0, y, width, y);
            g.setColor(foreground);
            g.drawString(text, -4 - tlen, y + fmHeight / 2);
          }

          gridValue = getGridValue(totMinX, totMaxX, 10);
          for (double d = gridValue; d < totMaxX; d += gridValue) {
            int x = (int) (xfac * d);
            String text = "" + (int) d;
            int tlen = fm.stringWidth(text);
            g.setColor(tickColor);
            g.drawLine(x, 0, x, height);
            g.setColor(foreground);
            g.drawString(text, x - tlen / 2, height + fmHeight);
          }
        }

        for (int i = 0, n = chs.length; i < n; i++) {
          Chart chart = chs[i];
          double maxY = chart.getMaxY();
          double minY = chart.getMinY();
          double minX = chart.getMinX();
          double maxX = chart.getMaxX();

          if (maxY < minY || maxX <= minX) {
            // No data in this chart
          } else {
//          double yfac = (1.0 * height) / (maxY - minY);
//          double xfac = (1.0 * width) / (maxX - minX);

            g.setColor((Color) chart.getConfig("color", getDefaultColor(i)));
            chart.drawChart(g, xfac, yfac, width, height);
          }
        }
      }
    }
  }

  private double getGridValue(double totMinX, double totMaxX, int maxCount) {
    double diff = totMaxX - totMinX;
    if (diff <= 0) {
      return 1;
    }
    double d = Math.log(diff) / Math.log(10);
    int z = (int) d;
    if ((d - z) > 0.69) {
      z++;
    }
    if (z < 1) {
      return 1;
    }
    d = Math.pow(10, z - 1);
    if ((diff / (int) (1 * d)) <= maxCount) {
      return (int) (1 * d);
    }
    if ((diff / (int) (2.5 * d)) <= maxCount) {
      return (int) (2.5 * d);
    }
    return (int) (5 * d);
  }


  //-------------------------------------------------------------------
  // Test Main
  // -------------------------------------------------------------------

  public static void main(String[] args) {
    JFrame jf = new JFrame("test charts");
    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    jf.setBounds(100,100,600,400);
    jf.setVisible(true);
    BarChart bc = new BarChart();
    LineChart lc = new LineChart();

    int[] data = new int[40];
    for (int i = 0, n = data.length; i < n; i++) {
      data[i] = (int) ((Math.random() * 300));
    }
    bc.setConfig("color", new Color(0xffb0b0b0));
    bc.setData(data);
    lc.setData(data);

    //    bc.setMinMax(0, 500);
    lc.setMinMax(-4096, 4096);

    ChartPanel chp = new ChartPanel();
    chp.addChart(lc);
    chp.addChart(bc);
    jf.getContentPane().add(chp);
    jf.setVisible(true);

    while(true) {
      try {
        Thread.sleep(100);
      } catch (Exception e) {
        // Ignore interrupts
      }

      int len = 1024;
      data = new int[len];
      for (int i = 0, n = data.length; i < n; i++) {
        data[i] = (int) (2500 - (Math.random() * 5000));
      }
      lc.setData(data);
      chp.repaint();
    }

  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/IntSerieChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * IntSerieChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;

/**
 *
 */
public abstract class IntSerieChart extends AbstractChart {

  protected int[] data;

  public void setData(int[] data) {
    this.data = data;
    updateMinMax();
  }

  protected void updateMinMax() {
    this.minx = 0;
    this.maxx = data == null ? 0 : data.length;

    if (!autoscale) {
      // Do not update miny, maxy
    } else if (data == null || data.length == 0) {
      miny = maxy = 0.0;
    } else {
      miny = maxy = data[0];
      for (int i = 1, n = data.length; i < n; i++) {
        int v = data[i];
        if (v < miny) miny = v;
        if (v > maxy) maxy = v;
      }
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/AbstractChart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * AbstractChart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : May 3 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;

import java.awt.Graphics2D;
import java.util.Hashtable;

/**
 *
 */
public abstract class AbstractChart implements Chart {

  protected String name;
  protected double minx, maxx;
  protected double miny, maxy;
  protected boolean autoscale = true;
  private Hashtable<String,Object> config = new Hashtable<String,Object>();

  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public boolean isAutoscaling() {
    return autoscale;
  }

  public void setAutoscale() {
    if (!this.autoscale) {
      this.autoscale = true;
      updateMinMax();
    }
  }

  public void setMinMax(double minVal, double maxVal) {
    miny = minVal;
    maxy = maxVal;
    autoscale = false;
  }

  public double getMinX() {
    return minx;
  }

  public double getMaxX() {
    return maxx;
  }

  public double getMinY() {
    return miny;
  }

  public double getMaxY() {
    return maxy;
  }

  public Object getConfig(String param) {
    return getConfig(param, null);
  }

  public Object getConfig(String param, Object defVal) {
    Object retVal = config.get(param);
    return retVal != null ? retVal : defVal;
  }

  public void setConfig(String param, Object value) {
    if (value != null) {
      config.put(param, value);
    } else {
      config.remove(param);
    }
  }

  protected abstract void updateMinMax();

  public abstract void drawChart(Graphics2D g, double xfac, double yfac,
      int width, int height);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/Chart.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Chart
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : April 26 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.ui;
import java.awt.Graphics2D;

/**
 *
 */
public interface Chart {

  public String getName();

  public void setAutoscale();
  public void setMinMax(double minValue, double maxValue);

  public double getMaxY();
  public double getMinY();
  public double getMaxX();
  public double getMinX();

  public Object getConfig(String param);
  public Object getConfig(String param, Object defaultValue);
  public void setConfig(String param, Object value);

  public void drawChart(Graphics2D g, double xfac, double yfac, int width, int height);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/JFrameWindowManager.java`:

```java
package se.sics.mspsim.ui;

import java.awt.Component;

import javax.swing.JFrame;

public class JFrameWindowManager implements WindowManager {

    public ManagedWindow createWindow(final String name) {
        ManagedWindow w = new ManagedWindow() {
            private JFrame window = new JFrame(name);
            private boolean restored = false;

            public void setSize(int width, int height) {
                window.setSize(width, height);
            }

            public void setBounds(int x, int y, int width, int height) {
                window.setBounds(x, y, width, height);
            }

            public void pack() {
                window.pack();
            }

            public void add(Component component) {
                window.add(component);
                if (!restored) {
                    restored = true;
                    WindowUtils.restoreWindowBounds(name, window);
                }
            }

            public void removeAll() {
                window.removeAll();
            }

            public boolean isVisible() {
                return window.isVisible();
            }

            public void setVisible(boolean b) {
                if (b != window.isVisible()) {
                    if (b) {
                        WindowUtils.addSaveOnShutdown(name, window);
                    } else {
                        WindowUtils.saveWindowBounds(name, window);
                        WindowUtils.removeSaveOnShutdown(window);
                    }
                }
                window.setVisible(b);
            }

            public String getTitle() {
                return window.getTitle();
            }

            public void setTitle(String name) {
                window.setTitle(name);
            }
        };
        return w;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/CPUHeatMap.java`:

```java
package se.sics.mspsim.ui;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;

import javax.swing.JComponent;
import javax.swing.Timer;

import se.sics.mspsim.core.Memory;
import se.sics.mspsim.core.MemoryMonitor;
import se.sics.mspsim.core.MSP430Core;

public class CPUHeatMap extends JComponent implements MemoryMonitor {

    private static final long serialVersionUID = -7964848220064713887L;

    private Timer ticker;
    
    private ManagedWindow window;
    private BufferedImage heatmap;
    private int[] heatR;
    private int[] heatW;
    private int[] heatE;
    private int heatMax = 0;
    private int mode = 1;
    
    private MSP430Core cpu;
    
    public CPUHeatMap(MSP430Core cpu, WindowManager windowManager) {
        this.cpu = cpu;
        heatR = new int[cpu.MAX_MEM];
        heatW = new int[cpu.MAX_MEM];
        heatE = new int[cpu.MAX_MEM];
        
        window = windowManager.createWindow("CPU Heat Map");
        heatmap = new BufferedImage(128, 512, BufferedImage.TYPE_INT_RGB);
        setPreferredSize(new Dimension(140, 530));
        setOpaque(true);
        window.add(this);
        
        ticker = new Timer(50, new ActionListener() {
            public void actionPerformed(ActionEvent arg0) {
                repaint();
            }
        });
        ticker.start();

        setFocusable(true);
        addKeyListener(new KeyAdapter() {
            public void keyPressed(KeyEvent ke) {
                if (ke.getKeyChar() == 'm') {
                    mode = mode ^ 1;
                }
            }
        });

        window.setVisible(true);
    }

    public void close() {
        if (ticker != null) {
            ticker.stop();
        }
        if (window != null) {
            window.setVisible(false);
            window = null;
        }
    }

    public void updateImage() {
        double factor = 250.0 / heatMax;
        switch (mode) {
        case 0:
            int me, mr, mw;
            for (int i = 0; i < cpu.MAX_MEM; i++) {
                mw = me = mr = 0;
                if (heatW[i] > 0) mw = 80;
                if (heatR[i] > 0) mr = 80;
                if (heatE[i] > 0) me = 80;
                
                heatmap.setRGB(i & 127, i / 128,
                        ((int)(factor * heatW[i] + mw) << 16) |
                        ((int)(factor * heatR[i] + mr) << 8) | 
                        (int)(factor * heatE[i]) + me);
            }
            break;
        case 1:
            /* slow... */
            for (int i = 0; i < cpu.MAX_MEM; i++) {
                int r = heatW[i];
                int g = heatR[i];
                int b = heatE[i];

                heatW[i] = (99 * r) / 100;
                heatR[i] = (99 * g) / 100;
                heatE[i] = (99 * b) / 100;

                if (r > 255) r = 255;
                if (g > 255) g = 255;
                if (b > 255) b = 255;
                
                heatmap.setRGB(i & 127, i / 128, (r << 16) | (g << 8) | b);
            }
            break;
        }
    }
    
    public void paint(Graphics g) {
        updateImage();
        g.drawImage(heatmap, 0, 0, getWidth(), getHeight(), this);
    }

    private void cpuAction(int adr, Memory.AccessType type) {
        int val = 0;
        int f = 1;
        if (mode == 1) f = 40;
        switch (type) {
        case EXECUTE:
            val = heatE[adr] = heatE[adr] + f;
            break;
        case READ:
            val = heatR[adr] = heatR[adr] + f;
            break;
        case WRITE:
            val = heatW[adr] = heatW[adr] + f;
            break;
        }
        if (val > heatMax) {
            heatMax = val;
        }
    }

    @Override
    public void notifyReadBefore(int addr, Memory.AccessMode mode, Memory.AccessType type) {
        cpuAction(addr, type);
    }

    @Override
    public void notifyReadAfter(int addr, Memory.AccessMode mode, Memory.AccessType type) {
    }

    @Override
    public void notifyWriteBefore(int dstAddress, int data, Memory.AccessMode mode) {
        cpuAction(dstAddress, Memory.AccessType.WRITE);
    }

    @Override
    public void notifyWriteAfter(int dstAddress, int data, Memory.AccessMode mode) {
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/ui/DebugUI.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * DebugUI
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.ui;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.GridLayout;
import javax.swing.AbstractListModel;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListCellRenderer;
import se.sics.mspsim.core.DbgInstruction;
import se.sics.mspsim.core.DisAsm;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.util.Utils;

public class DebugUI extends JPanel {

  private static final long serialVersionUID = 2123628878332126912L;

  private JList<DbgInstruction> disList;
  private DbgListModel listModel;
  private JLabel[] regsLabel;
  private MSP430 cpu;

  private DisAsm disAsm;

  /**
   * Creates a new <code>DebugUI</code> instance.
   *
   */
  public DebugUI(MSP430 cpu) {
    this(cpu, true);
  }

  public DebugUI(MSP430 cpu, boolean showRegs) {
    super(new BorderLayout());
    this.cpu = cpu;
    disAsm = cpu.getDisAsm();

    listModel = new DbgListModel();
    disList = new JList<DbgInstruction>(listModel);
    disList.setFont(new Font("courier", Font.PLAIN, 12));
    disList.setCellRenderer(new MyCellRenderer());
    disList.setPreferredSize(new Dimension(500, 350));
    add(disList, BorderLayout.CENTER);

    if (showRegs) {
      JPanel regs = new JPanel(new GridLayout(2,8,4,0));
      regsLabel = new JLabel[16];
      for (int i = 0, n = 16; i < n; i++) {
	regs.add(regsLabel[i] = new JLabel("$0000"));
      }
      add(regs, BorderLayout.SOUTH);
      updateRegs();
    }
  }

  public void updateRegs() {
    if (regsLabel != null) {
      for (int i = 0, n = 16; i < n; i++) {
	regsLabel[i].setText("$" + Utils.hex16(cpu.reg[i]));
      }
    }
    repaint();
  }

  private class DbgListModel extends AbstractListModel<DbgInstruction> {
    private static final long serialVersionUID = -2856626511548201481L;

    int startPos = -1;
    int endPos = -1;
    final int size = 21;

    DbgInstruction[] instructions = new DbgInstruction[size];

    // -------------------------------------------------------------------
    // ListAPI
    // -------------------------------------------------------------------

    @Override
    public int getSize() {
      return size;
    }

    private void checkPC() {
      int pc = cpu.getPC();
      if (pc < startPos || pc > endPos) {
	startPos = pc;
	// recalculate index!!! with PC at the top of the "page"
	int currentPos = pc;
	for (int i = 0, n = size; i < n; i++) {
//        if (cpu.getExecCount(currentPos) == 0) {
//	    inst = new DbgInstruction();
//	    inst.setInstruction(cpu.memory[currentPos] + (cpu.memory[currentPos + 1] << 8), 2);
//	    inst.setASMLine("    " + Utils.hex(currentPos, 4) + " " +
//			    Utils.hex8(cpu.memory[currentPos]) + " " +
//			    Utils.hex8(cpu.memory[currentPos + 1]) +
//			    "       .word " + Utils.hex8(cpu.memory[currentPos]) +
//			    Utils.hex8(cpu.memory[currentPos + 1]));
//	  } else {

          DbgInstruction inst = disAsm.getDbgInstruction(currentPos, cpu);
          inst.setPos(currentPos);
          currentPos += inst.getSize();
          instructions[i] = inst;
	}
	endPos = currentPos;
      }
    }

    // Should cache the current 20 (or size) instructions to get a faster
    // version of this...
    // And have a call to "update" instead...
    @Override
    public DbgInstruction getElementAt(int index) {
      checkPC();
      return instructions[index];
    }
  }

  class MyCellRenderer extends JLabel implements ListCellRenderer<DbgInstruction> {

    private static final long serialVersionUID = -2633138712695105181L;

    public MyCellRenderer() {
      setOpaque(true);
    }

    @Override
    public Component getListCellRendererComponent(
       JList<? extends DbgInstruction> list,
       DbgInstruction instruction,            // instruct to display
       int index,               // cell index
       boolean isSelected,      // is the cell selected
       boolean cellHasFocus)    // the list and the cell have the focus
     {
       String s;
       int pos = 0;
       if (instruction == null) {
           s = "---";
       } else {
           pos = instruction.getPos();
	   s = instruction.getASMLine(false);
	   if (cpu.hasWatchPoint(pos)) {
	     s = "*B " + s;
	   } else {
	     s = "   " + s;
	   }
           if (instruction.getFunction() != null) {
               s += ";   " + instruction.getFunction();
           }
       }
       setText(s);
       if (pos == cpu.getPC()) {
	 setBackground(Color.green);
       } else {
	 if (isSelected) {
	   setBackground(list.getSelectionBackground());
	   setForeground(list.getSelectionForeground());
	 } else {
	   setBackground(list.getBackground());
	   setForeground(list.getForeground());
	 }
       }
       setEnabled(list.isEnabled());
       setFont(list.getFont());
       return this;
     }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/BasicAsyncCommand.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * BasicAsyncCommand
 *
 * Author  : Joakim Eriksson
 * Created : 9 mar 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;

/**
 * @author joakim
 *
 */
public abstract class BasicAsyncCommand extends BasicCommand implements AsyncCommand, Cloneable {

  public BasicAsyncCommand(String cmdHelp, String argHelp) {
    super(cmdHelp, argHelp);
  }
  
  public Command getInstance() {
      try {
          return (Command) this.clone();
      } catch (CloneNotSupportedException e) {
          // TODO Auto-generated catch block
          e.printStackTrace();
      }
      return null;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/BasicLineCommand.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * BasicLineCommand
 *
 * Author  : Joakim Eriksson
 * Created : 9 mar 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;

/**
 * @author joakim
 *
 */
public abstract class BasicLineCommand extends BasicAsyncCommand implements
    LineListener {

  public BasicLineCommand(String cmdHelp, String argHelp) {
    super(cmdHelp, argHelp);
  }

  public void stopCommand(CommandContext context) {
    context.exit(0);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/NetCommands.java`:

```java
/**
 * 
 */
package se.sics.mspsim.cli;

import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.net.CC2420PacketHandler;
import se.sics.jipv6.mac.IEEE802154Handler;
import se.sics.jipv6.mac.LoWPANHandler;
import se.sics.jipv6.core.IPStack;
import se.sics.jipv6.tunnel.TSPClient;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.Utils;

/**
 * @author joakim
 *
 */
public class NetCommands implements CommandBundle {

  private IPStack ipStack;
  public void setupCommands(final ComponentRegistry registry, CommandHandler handler) {
    handler.registerCommand("ipstack", new BasicLineCommand("setup 802.15.4/IP stack", "") {
      CC2420PacketHandler listener;
      public int executeCommand(CommandContext context) {
        MSP430 cpu = registry.getComponent(MSP430.class);
        listener = new CC2420PacketHandler(cpu);
        listener.setOutput(context.out);
        IEEE802154Handler ieeeHandler = new IEEE802154Handler();
        listener.addUpperLayerHandler(0, ieeeHandler);
        ieeeHandler.setLowerLayerHandler(listener);
        ipStack = new IPStack();
        byte[] macAddr = new byte[] {0x2,0x12,0x74,0x00,0x11,0x11,0x12,0x12};
        ipStack.setLinkLayerAddress(macAddr);
        ipStack.setRouter(true);
        LoWPANHandler lowpanHandler = new LoWPANHandler();
        lowpanHandler.setIPStack(ipStack);
        ieeeHandler.addUpperLayerHandler(0, lowpanHandler);
        lowpanHandler.setLowerLayerHandler(ieeeHandler);
        ipStack.setLinkLayerHandler(lowpanHandler);
        context.err.print("IP Stack started");
        return 0;
      }
      
      public void lineRead(String line) {
        if (listener != null) {
          byte[] data = Utils.hexconv(line);
          for (int i = 0; i < data.length; i++) {
            // Currently it will auto print when packet is ready...
            listener.receivedByte(data[i]);
          }
        }
      }
    });

    handler.registerCommand("tspstart", new BasicCommand("starts a TSP tunnel", "<server> <user> <password>") {
      public int executeCommand(CommandContext context) {
        TSPClient tunnel = TSPClient.startTSPTunnel(ipStack, context.getArgument(0),
            context.getArgument(1), context.getArgument(2));
        ipStack.setTunnel(tunnel);
        if (tunnel != null) {
          context.out.print("TSP Tunnel started");
          return 0;
        } else {
          context.out.print("TSP Tunnel failed");
          return 1;
        }
      }
    });
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/FileTarget.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * FileTarget
 *
 * Author  : Joakim Eriksson
 * Created : 14 mar 2008
 * Updated : $Date:$
 *           $Revision:$
 */
package se.sics.mspsim.cli;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Hashtable;

/**
 * @author joakim
 */
public class FileTarget extends Target {

    private final FileWriter out;

    public FileTarget(Hashtable<String,Target> targets, String name, FileWriter out) {
        super(targets, name, true);
        this.out = out;
    }

    protected void handleLine(CommandContext context, String line) {
        try {
            out.write(line);
            out.write('\n');
            out.flush();
        } catch (IOException e) {
            e.printStackTrace(context.err);
        }
    }

    protected void closeTarget() {
        try {
            out.close();
        } catch (IOException e) {
            // Ignore close errors
        }
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/ScriptCommand.java`:

```java
/*
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ScriptCommand
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 21 apr 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.cli;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

/**
 *
 */
public class ScriptCommand extends Command {

  private final File scriptFile;

  public ScriptCommand(File scriptFile) {
    this.scriptFile = scriptFile;
  }

  @Override
  public String getArgumentHelp(String commandName) {
    return null;
  }

  @Override
  public String getCommandHelp(String commandName) {
    return "(implemented as " + scriptFile.getAbsolutePath() + ')';
  }

  @Override
  public int executeCommand(CommandContext context) {
    try {
      BufferedReader in = new BufferedReader(new FileReader(scriptFile));
      try {
        String line;
        while ((line = in.readLine()) != null) {
          line = line.trim();
          if (line.length() > 0 && (line.charAt(0) != '#' || line.startsWith("#!"))) {
            if (context.executeCommand(line) != 0) {
              break;
            }
          }
        }
      } finally {
        in.close();
      }
      return 0;
    } catch (FileNotFoundException e) {
      context.err.println("could not read the script '" + scriptFile + '\'');
      return 1;
    } catch (IOException e) {
      context.err.println("could not read the script '" + scriptFile + '\'');
      e.printStackTrace(context.err);
      return 1;
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/WindowTarget.java`:

```java
package se.sics.mspsim.cli;

import java.awt.Font;
import java.util.Hashtable;

import javax.swing.JComponent;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;

import se.sics.mspsim.extutil.jfreechart.LineChart;
import se.sics.mspsim.extutil.jfreechart.LineSampleChart;
import se.sics.mspsim.ui.ManagedWindow;
import se.sics.mspsim.ui.WindowManager;

public class WindowTarget extends Target {

  private ManagedWindow window;
  // Default in the current version - TODO: replace with better
  private JTextArea jta = new JTextArea(40,80);
  private WindowDataHandler dataHandler = null;

  public WindowTarget(Hashtable<String,Target> targets, String name) {
    super(targets, name, false);
  }

  final void init(WindowManager windowManager) {
    jta.setFont(Font.decode("Courier"));
    jta.setEditable(false);

    window = windowManager.createWindow(getName());
    window.add(new JScrollPane(jta, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER));
    window.setVisible(true);
  }

  protected void handleLine(final CommandContext context, final String line) {
    if (line != null && window != null) {
      java.awt.EventQueue.invokeLater(new Runnable() {
        public void run() {
          processLine(context, line);
        }
      });
    }
  }

  private void processLine(CommandContext context, String line) {
    if (line.startsWith("#!")) {
      line = line.substring(2);
      String[] parts = CommandParser.parseLine(line);
      String cmd = parts[0];
      if ("bounds".equals(cmd)) {
        try {
          window.setBounds(Integer.parseInt(parts[1]), Integer.parseInt(parts[2]),
              Integer.parseInt(parts[3]), Integer.parseInt(parts[4]));
        } catch (Exception e) {
          context.err.println("Could not set bounds: " + line);
        }
      } else if ("title".equals(cmd)) {
        String args = CommandParser.toString(parts, 1, parts.length);
        window.setTitle(args);
        if (dataHandler != null) {
          dataHandler.setProperty("title", new String[] {args});
        }
      } else if ("type".equals(cmd)) {
        if ("line-sample".equals(parts[1])) {
          dataHandler = new LineSampleChart();
        } else if ("line".equals(parts[1])) {
          dataHandler = new LineChart();
        } else {
          context.err.println("Unknown window data handler type: " + parts[1]);
        }
        if (dataHandler != null) {
          System.out.println("Replacing window data handler! " + parts[1] + " " + dataHandler);
          JComponent dataComponent = dataHandler.getComponent();
          window.removeAll();
          window.add(dataComponent);
          String title = window.getTitle();
          if (title != null) {
            // Set title for the new data handler
            dataHandler.setProperty("title", new String[] { title });
          }
          dataComponent.repaint();
        }
      } else if (dataHandler != null) {
        dataHandler.handleCommand(parts);
      } else if ("clear".equals(cmd)) {
        jta.setText("");
      } else if ("tabsize".equals(cmd)) {
        try {
          jta.setTabSize(Integer.parseInt(parts[1]));
        } catch (Exception e) {
          context.err.println("Could not set tab size: " + line);
        }
      } else if ("font".equals(cmd)) {
        jta.setFont(Font.decode(parts[1]));
      }
    } else if (!line.startsWith("#")){
      if (dataHandler != null) {
        dataHandler.lineRead(line);
      } else {
        jta.append(line + '\n');
      }
    }
  }

  protected void closeTarget() {
      if (window != null) {
          window.setVisible(false);
          window = null;
      }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/Target.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Target
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 14 mar 2010
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;

import java.util.ArrayList;
import java.util.Hashtable;

public abstract class Target {

    protected static final boolean DEBUG = false;

    private final Hashtable<String,Target> targets;
    private final String name;
    private final boolean autoclose;
    private ArrayList<CommandContext> contexts = new ArrayList<CommandContext>();

    public Target(Hashtable<String,Target> targets, String name, boolean autoclose) {
        this.targets = targets;
        this.name = name;
        this.autoclose = autoclose;
        targets.put(name, this);
    }

    public String getName() {
        return name;
    }

    public String getStatus() {
        StringBuilder sb = new StringBuilder();
        sb.append(name);
        synchronized (targets) {
            if (contexts != null) {
                sb.append(" \tPIDs: [");
                for (int i = 0, n = contexts.size(); i < n; i++) {
                    int pid = contexts.get(i).getPID();
                    if (i > 0) {
                        sb.append(',');
                    }
                    if (pid < 0) {
                        sb.append('?');
                    } else {
                        sb.append(pid);
                    }
                }
                sb.append(']');
            }
        }
        return sb.toString();
    }

    public final void lineRead(CommandContext context, String line) {
        if (line == null) {
            removeContext(context);
        } else {
            handleLine(context, line);
        }
    }

    protected abstract void handleLine(CommandContext context, String line);

    public void addContext(CommandContext context) {
        boolean added = false;
        synchronized (targets) {
            if (contexts != null) {
                contexts.add(context);
                added = true;
                if (DEBUG) {
                    System.out.println("Target: new writer to " + name
                            + " (" + contexts.size() + ')');
                }
            }
        }
        if (!added) {
            context.kill();
        }
    }

    public void removeContext(CommandContext context) {
        boolean close = false;
        synchronized (targets) {
            if (contexts != null) {
                if (contexts.remove(context)) {
                    if (DEBUG) {
                        System.out.println("Target: removed writer from "
                            + name + " (" + contexts.size() + ')');
                    }
                }
                if (contexts.size() == 0) {
                    close = true;
                }
            }
        }
        if (close && autoclose) {
            close(false);
        }
    }

    public void close() {
        close(true);
    }

    private void close(boolean forceClose) {
        ArrayList<CommandContext> list;
        synchronized (targets) {
            if (contexts == null) {
                // Already closed
                return;
            }
            if (contexts.size() > 0 && !forceClose) {
                // Target still has connected writers.
                return;
            }
            list = contexts;
            contexts = null;
            if (targets.get(name) == this) {
                targets.remove(name);
                if (DEBUG) {
                    System.out.println("Target: closed file " + name);
                }
            }
        }

        if (list != null) {
            // Close any connected writers
            for (CommandContext context : list) {
                context.kill();
            }
        }
        closeTarget();
    }

    protected abstract void closeTarget();

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/ExecCommand.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ExecCommand
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Sun Mar 09 23:15:36 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintStream;

public class ExecCommand extends BasicLineCommand {

  private CommandContext context;
  private Process process;
  private Runner runner;
  private Reader stdout;
  private Reader stderr;
  private PrintStream output;

  public ExecCommand() {
    super("execute the specified command", "<cmd> [args...]");
  }

  public int executeCommand(CommandContext context) {
    this.context = context;

    String[] args = new String[context.getArgumentCount()];
    for (int i = 0, n = args.length; i < n; i++) {
      args[i] = context.getArgument(i);
    }
    String name = args[0];

    try {
      process = Runtime.getRuntime().exec(args);
      stdout = new Reader(name + ".out", this,
			  process.getInputStream(), context.out);
      stdout.start();
      stderr = new Reader(name + ".err", this,
			  process.getErrorStream(), context.err);
      stderr.start();

      output = new PrintStream(process.getOutputStream());

      runner = new Runner(name + ".proc", this);
      runner.start();
    } catch (Exception e) {
      context.err.println("failed to start command: " + e.getMessage());
      return 1;
    }
    return 0;
  }

  public void lineRead(String line) {
    System.out.println("Exec: sending a line: " + line);
    output.println(line);
    output.flush();
  }

  public void stopCommand(CommandContext context) {
    if (runner != null && runner.isRunning) {
      process.destroy();
    } else {
      context.exit(0);
    }
  }


  // -------------------------------------------------------------------
  // Handler for the executer
  // -------------------------------------------------------------------

  private static class Runner extends Thread {

    public ExecCommand command;
    public boolean isRunning;

    public Runner(String name, ExecCommand command) {
      super(name);
      this.command = command;
      this.isRunning = false;
    }

    public void run() {
      int exitValue = -1;
      isRunning = true;
      try {
        command.process.waitFor();

        // Wait for the readers to be finished before reporting about
        // the process exit
        for (int i = 0; i < 5 &&
	       (command.stdout.isAlive() || command.stderr.isAlive());
	     i++) {
          Thread.sleep(300);
        }

        exitValue = command.process.exitValue();

      } catch (InterruptedException e) {
        e.printStackTrace();
      } finally {
        isRunning = false;
        command.context.exit(exitValue);
      }
    }

  } // end of inner class Runner


  // -------------------------------------------------------------------
  // Handler for reading the input streams
  // -------------------------------------------------------------------

  private static class Reader extends Thread {

    private ExecCommand command;
    private PrintStream out;
    private BufferedReader input;

    public Reader(String name, ExecCommand command,
		  InputStream input, PrintStream out) {
      super(name);
      this.command = command;
      this.input = new BufferedReader(new InputStreamReader(input));
      this.out = out;
    }

    public void run() {
      try {
        String line;
        while ((line = input.readLine()) != null) {
	  out.println(line);
	}
      } catch (Exception e) {
	command.context.err.println("* " + getName()
				    + " failed: " + e.getMessage());
      }
    }

  } // end of inner class Reader

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/CommandParser.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * CommandParser
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Sun Mar 2 19:41:00 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;
import java.util.ArrayList;

public class CommandParser {

  private static final int TEXT = 0;
  private static final int ARG = 1;
  private static final int QUOTE = 2;

  private CommandParser() {
    // Prevent instances of this class
  }

  public static String[][] parseCommandLine(String line) {
    return parseLine(line, true, true);
  }

  public static String[] parseLine(String line) {
    String[][] lines = parseLine(line, false, false);
    if (lines != null && lines.length > 0) {
      return lines[0];
    }
    return null;
  }

  public static String[][] parseLine(String line, boolean handlePipes, boolean handleRedirect) {
    line = line.trim();
    if (line.length() == 0 || line.charAt(0) == '#') {
      return null;
    }

    ArrayList<String[]> list = new ArrayList<String[]>();
    ArrayList<String> args = new ArrayList<String>();
    StringBuilder sb = null;
    String redirectCommand = null;
    int redirectFile = -1;
    int state = TEXT;
    int index = 0;
    char quote = 0;

    for (int i = 0, n = line.length(); i < n; i++) {
      char c = line.charAt(i);
      if (c <= 32) {
	// White space
	if (state == ARG) {
	  if (sb == null) {
	    args.add(line.substring(index, i));
	  } else {
	    args.add(sb.append(line.substring(index, i)).toString());
	    sb = null;
	  }
	  state = TEXT;
	}

      } else {
	switch (c) {
	case '\\':
	  i++;
	  if (i >= n) {
	    throw new IllegalArgumentException("unexpected end of line");
	  }
	  if (state == TEXT) {
	    state = ARG;
	  } else {
	    if (sb == null) {
	      sb = new StringBuilder();
	    }
	    sb.append(line.substring(index, i - 1));
	  }
	  index = i;
	  break;
	case '"':
	case '\'':
	  if (state == QUOTE) {
	    if (c == quote) {
	      // End of quote
	      if (sb == null) {
		args.add(line.substring(index, i));
	      } else {
		args.add(sb.append(line.substring(index, i)).toString());
		sb = null;
	      }
	      state = TEXT;
	    }
	  } else {
	    // Start new quote
	    if (state == ARG) {
	      if (sb == null) {
		args.add(line.substring(index, i));
	      } else {
		args.add(sb.append(line.substring(index, i)).toString());
		sb = null;
	      }
	    }
	    index = i + 1;
	    state = QUOTE;
	    quote = c;
	  }
	  break;
//        case '#':
//          if (!handleRedirect) {
//            // No redirect handling. Process as normal character.
//            if (state == TEXT) {
//              index = i;
//              state = ARG;
//            }
//          } else if (state == TEXT && redirectCommand != null && redirectFile == args.size()) {
//            redirectCommand += '#';
//          } else if (state != QUOTE) {
//            throw new IllegalArgumentException("illegal character '#'");
//          }
//          break;
        case '>':
          if (!handleRedirect) {
            // No redirect handling. Process as normal character.
            if (state == TEXT) {
              index = i;
              state = ARG;
            }
          } else if (state != QUOTE) {
            // Redirection
            if (state == ARG) {
              if (sb == null) {
                args.add(line.substring(index, i));
              } else {
                args.add(sb.append(line.substring(index, i)).toString());
                sb = null;
              }
              state = TEXT;
            }

            if (redirectCommand == null) {
              redirectCommand = ">";
              redirectFile = args.size();
            } else if (state == TEXT && redirectFile == args.size()) {
              redirectCommand += '>';
            } else { 
              // Double redirect
              throw new IllegalArgumentException("redirected twice");
            }
          }
          break;
	case '|':
          if (!handlePipes) {
            // No pipe handling. Process as normal character.
            if (state == TEXT) {
              index = i;
              state = ARG;
            }
          } else if (state != QUOTE) {
	    // PIPE
	    if (state == ARG) {
	      if (sb == null) {
		args.add(line.substring(index, i));
	      } else {
		args.add(sb.append(line.substring(index, i)).toString());
		sb = null;
	      }
	    }
	    state = TEXT;
	    if (args.size() == 0) {
	      throw new IllegalArgumentException("empty command");
	    }
	    if (redirectCommand != null) {
	      throw new IllegalArgumentException("pipe can not follow redirection");
	    }
	    list.add(args.toArray(new String[args.size()]));
	    args.clear();
	  }
	  break;
	default:
	  if (state == TEXT) {
	    index = i;
	    state = ARG;
	  }
	  break;
	}
      }
    }
    if (state == QUOTE) {
      throw new IllegalArgumentException("unexpected end of line");
    }
    if (state == ARG) {
      if (sb == null) {
	args.add(line.substring(index));
      } else {
	args.add(sb.append(line.substring(index)).toString());
      }
    }
    String redirectFilename = null;
    if (redirectCommand != null) {
      if (args.size() <= redirectFile) {
        throw new IllegalArgumentException("no redirect target");
      }
      redirectFilename = args.remove(redirectFile);
    }
    if (args.size() > 0) {
      list.add(args.toArray(new String[args.size()]));
    }
    if (redirectCommand != null) {
      list.add(new String[] { redirectCommand, redirectFilename });
    }
    return list.toArray(new String[list.size()][]);
  }

  public static String toString(String[] parts, int start, int end) {
    StringBuilder sb = new StringBuilder();
    for (int i = start; i < end; i++) {
      if (i > start) {
        sb.append(' ');
      }
      sb.append(parts[i]);
    }
    return sb.toString();
  }

//   public static void main(String[] args) {
//     StringBuilder sb = new StringBuilder();
//     for (int i = 0, n = args.length; i < n; i++) {
//       if (i > 0) sb.append(' ');
//       sb.append(args[i]);
//     }
//     String[][] list = parseLine(sb.toString());
//     for (int j = 0, m = list.length; j < m; j++) {
//       String[] a = list[j];
//       System.out.println("PARSED LINE:");
//       for (int i = 0, n = a.length; i < n; i++) {
// 	System.out.println("  ARG " + (i + 1) + ": '" + a[i] + '\'');
//       }
//     }
//   }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/WindowDataHandler.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * WindowDataHandler
 *
 * Author  : Joakim Eriksson
 * Created : 15 apr 2008
 * Updated : $Date:$
 *           $Revision:$
 */
package se.sics.mspsim.cli;

import javax.swing.JComponent;

/**
 * @author joakim
 *
 */
public interface WindowDataHandler extends LineListener {
  public JComponent getComponent();
  public void handleCommand(String[] parts);
  public void setProperty(String name, String[] args);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/LineListener.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * LineListener
 *
 * Author  : Joakim Eriksson
 * Created : 8 mar 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;

/**
 * @author joakim
 *
 */
public interface LineListener {

  public void lineRead(String line);
  
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/AsyncCommand.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * AsyncCommand - a command that will continue its execution after it
 * returns from the executeCommand method.
 *
 * Author  : Joakim Eriksson
 * Created : 9 mar 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;

/**
 * @author joakim
 *
 */
public interface AsyncCommand {
  public void stopCommand(CommandContext context);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/WindowCommands.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: WindowCommands.java 187 2008-03-17 19:34:12Z joxe $
 *
 * -----------------------------------------------------------------
 *
 * WindowCommands - 
 * 
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 9 april 2008
 * Updated : $Date: 2008-03-17 20:34:12 +0100 (Mon, 17 Mar 2008) $
 *           $Revision: 187 $
 */
package se.sics.mspsim.cli;

import java.util.Hashtable;

import se.sics.mspsim.ui.WindowManager;
import se.sics.mspsim.ui.WindowUtils;
import se.sics.mspsim.util.ComponentRegistry;

public class WindowCommands implements CommandBundle {

    private ComponentRegistry registry;
    private final Hashtable<String,Target> windowTargets = new Hashtable<String,Target>();

    public void setupCommands(ComponentRegistry registry, CommandHandler handler) {
        this.registry = registry;
        handler.registerCommand("window", new BasicLineCommand("redirect input to a window", "[-close|-clear|-list] [windowname]") {
            Target wt;
            CommandContext context;
            public int executeCommand(CommandContext context) {
                boolean close = false;
                boolean clear = false;
                boolean list = false;
                String windowName = null;
                this.context = context;
                for (int i = 0; i < context.getArgumentCount(); i++) {
                    String name = context.getArgument(i);
                    if ("-close".equals(name)) {
                        close = true;
                    } else if ("-clear".equals(name)) {
                        clear = true;
                    } else if ("-list".equals(name)) {
                        list = true;
                    } else if (windowName != null) {
                        context.err.println("illegal arguments");
                        context.exit(1);
                        return 1;
                    } else {
                        windowName = name;
                    }
                }
                if (list || windowName == null) {
                    Target tgts[];
                    synchronized (windowTargets) {
                        tgts = windowTargets.values().toArray(new Target[windowTargets.size()]);
                    }
                    if (tgts.length == 0) {
                        context.out.println("There are no open windows.");
                    } else {
                        context.out.println("Window Name   PIDs");
                        for (Target target : tgts) {
                            context.out.println(target.getStatus());
                        }
                    }
                    context.exit(0);
                    return 0;
                }
                if (close) {
                    Target target = windowTargets.get(windowName);
                    if (target != null) {
                        context.out.println("Closing window " + windowName);
                        target.close();
                        context.exit(0);
                        return 0;
                    }
                    context.err.println("Could not find the window " + windowName);
                    context.exit(1);
                    return 1;
                }
                wt = addTarget(context, windowName, clear);
                return 0;
            }

            public void lineRead(String line) {
                wt.lineRead(context, line);
            }

            public void stopCommand(CommandContext context) {
                if (wt != null) {
                    wt.removeContext(context);
                }
            }
        });

        handler.registerCommand("wclear", new BasicCommand("resets stored window positions", "") {
            public int executeCommand(CommandContext context) {
                WindowUtils.clearState();
                return 0;
            }
        });
    }

    protected Target addTarget(CommandContext context, String name, boolean clear) {
        Target target;
        WindowTarget wt = null;
        synchronized (windowTargets) {
            target = windowTargets.get(name);
            if (target == null) {
                target = wt = new WindowTarget(windowTargets, name);
            }
        }
        if (wt != null) {
            wt.init((WindowManager) registry.getComponent("windowManager"));
        }
        if (context.getPID() >= 0) {
            target.addContext(context);
        }
        if (clear) {
            target.lineRead(context, "#!clear");
        }
        return target;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/BasicCommand.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * BasicCommand
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Mon Feb 11 21:28:00 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.cli;


public abstract class BasicCommand extends Command {

  private String argumentHelp;
  private String commandHelp;

  public BasicCommand(String cmdHelp, String argHelp) {
    commandHelp = cmdHelp;
    argumentHelp = argHelp;
  }
  
  public String getArgumentHelp(String commandName) {
    return argumentHelp;
  }

  public String getCommandHelp(String commandName) {
    return commandHelp;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/CommandContext.java`:

```java
package se.sics.mspsim.cli;
import java.io.PrintStream;

import se.sics.mspsim.core.MSP430Constants;
import se.sics.mspsim.util.MapTable;
import se.sics.mspsim.util.Utils;

public class CommandContext {

  private String[] args;
  private String commandLine;
  private MapTable mapTable;
  private int pid = -1;
  private boolean exited = false;
  private Command command;
  
  public PrintStream out;
  public PrintStream err;
  private CommandHandler commandHandler;
  
  public CommandContext(CommandHandler ch, MapTable table, String commandLine, String[] args,
			int pid, Command command, PrintStream out, PrintStream err) {
    this(ch, table, commandLine, args, pid, command);
    setOutput(out, err);
  }
  
  public CommandContext(CommandHandler ch,MapTable table, String commandLine, String[] args,
			int pid, Command command) {
    this.commandLine = commandLine;
    this.args = args;
    this.pid = pid;
    this.mapTable = table;
    this.command = command;
    this.commandHandler = ch;
  }
  
  void setOutput(PrintStream out, PrintStream err) {
    this.out = out;
    this.err = err;
  }
  
  Command getCommand() {
    return command;
  }

  // Called by CommandHandler to stop this command.
  void stopCommand() {
    if (!exited) {
      exited = true;

      if (command instanceof AsyncCommand) {
        AsyncCommand ac = (AsyncCommand) command;
        ac.stopCommand(this);
      }
    }
  }

  String getCommandLine() {
    return commandLine;
  }

  public int getPID() {
    return pid;
  }

  public boolean hasExited() {
    return exited;
  }
  
  /**
   * exit needs to be called as soon as the command is completed (or stopped).
   * @param exitCode - the exit code of the command
   */
  public void exit(int exitCode) {
    // TODO: Clean up can be done now!
    exited = true;
    commandHandler.exit(this, exitCode, pid);
  }

  // Requests that this command chain should be killed. Used by for example
  // FileTarget to close all connected commands when the file is closed.
  void kill() {
    if (!exited) {
      commandHandler.exit(this, -9, pid);
    }
  }

  public MapTable getMapTable() {
    return mapTable;
  }

  public String getCommandName() {
    return args[0];
  }

  public int getArgumentCount() {
    return args.length - 1;
  }
  
  public String getArgument(int index) {
    return args[index + 1];
  }
  
  public int getArgumentAsAddress(int index) {
    String adr = getArgument(index);
    if (adr == null || adr.length() == 0) return 0;
    char c = adr.charAt(0);
    if (!Character.isLetter(c) && c != '_' && c != '.') {
      try {
        return Utils.decodeInt(adr);
      } catch (Exception e) {
        err.println("Illegal address format: " + adr);
      }
    } else {
      // Assume that it is a symbol
      if (mapTable != null) {
        return mapTable.getFunctionAddress(adr);
      }
    }
    return -1;
  }

  public int getArgumentAsRegister(int index) {
    String symbol = getArgument(index);
    for (int i = 0, n = MSP430Constants.REGISTER_NAMES.length; i < n; i++) {
      if (MSP430Constants.REGISTER_NAMES[i].equalsIgnoreCase(symbol)) {
        return i;
      }
    }
    String reg = (symbol.startsWith("R") || symbol.startsWith("r")) ? symbol.substring(1) : symbol;
    try {
      int register = Integer.parseInt(reg);
      if (register >= 0 && register <= 15) {
        return register;
      }
    } catch (Exception e) {
      // Ignore
    }
    err.println("illegal register: " + symbol);
    return -1;
  }

  public int getArgumentAsInt(int index) {
    return getArgumentAsInt(index, 0);
  }

  public int getArgumentAsInt(int index, int defaultValue) {
    try {
      return Utils.decodeInt(getArgument(index));
    } catch (Exception e) {
      err.println("Illegal number format: " + getArgument(index));
      return defaultValue;
    }
  }

  public long getArgumentAsLong(int index) {
    return getArgumentAsLong(index, 0L);
  }

  public long getArgumentAsLong(int index, long defaultValue) {
    try {
      return Utils.decodeLong(getArgument(index));
    } catch (Exception e) {
      err.println("Illegal number format: " + getArgument(index));
      return defaultValue;
    }
  }

  public float getArgumentAsFloat(int index) {
    return getArgumentAsFloat(index, 0f);
  }

  public float getArgumentAsFloat(int index, float defaultValue) {
    try {
      return Float.parseFloat(getArgument(index));
    } catch (Exception e) {
      err.println("Illegal number format: " + getArgument(index));
      return defaultValue;
    }
  }

  public double getArgumentAsDouble(int index) {
    return getArgumentAsDouble(index, 0.0);
  }

  public double getArgumentAsDouble(int index, double defaultValue) {
    String arg = getArgument(index);
    try {
      return Double.parseDouble(arg);
    } catch (Exception e) {
      err.println("Illegal number format: " + getArgument(index));
      return defaultValue;
    }
  }

  public boolean getOption(String optionName) {
      for (int i = 0; i < args.length; i++) {
          if (args[i].equals("-" + optionName)) {
              return true;
          }
      }
      return false;
  }
  
  public boolean getArgumentAsBoolean(int index) {
    String v = getArgument(index);
    return "true".equalsIgnoreCase(v) || "1".equals(v);
  }

  public int executeCommand(String command) {
    return commandHandler.executeCommand(command, this);
  }

  public String toString() {
    return (pid >= 0 ? ("" + pid) : "?") + '\t' + (commandLine == null ? getCommandName() : commandLine);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/CommandBundle.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * CommandBundle
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Mon Feb 11 21:28:00 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.cli;

import se.sics.mspsim.util.ComponentRegistry;

public interface CommandBundle {

  public void setupCommands(ComponentRegistry registry, CommandHandler handler);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/AbstractWindowDataHandler.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: AsyncCommand.java 187 2008-03-17 19:34:12Z joxe $
 *
 * -----------------------------------------------------------------
 *
 *
 * Author  : Joakim Eriksson
 * Created : 9 april 2008
 * Updated : $Date: 2008-03-17 20:34:12 +0100 (Mon, 17 Mar 2008) $
 *           $Revision: 187 $
 */
package se.sics.mspsim.cli;

/**
 * @author joakime
 *
 */
public abstract class AbstractWindowDataHandler implements WindowDataHandler {

  public void handleCommand(String[] parts) {
    String cmd = parts[0];
    if ("set".equals(cmd)) {
      int index = atoi(parts[1], 0);
      String[] args = new String[parts.length - 3];
      System.arraycopy(parts, 3, args, 0, args.length);
      setProperty(index, parts[2], args);
    } else {
      System.err.println("unknown command: " + cmd);
    }
  }

  public abstract void setProperty(int index, String param, String[] args);

  public static int atoi(String data, int defaultValue) {
    try {
      return Integer.parseInt(data);
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }

  public static double atod(String data, double defaultValue) {
    try {
      return Double.parseDouble(data);
    } catch (NumberFormatException e) {
      return defaultValue;
    }
  }  
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/LineOutputStream.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * LineOutputStream
 *
 * Author  : Joakim Eriksson
 * Created : 8 mar 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;

import java.io.IOException;
import java.io.OutputStream;

/**
 * @author joakim
 *
 */
public class LineOutputStream extends OutputStream {

  private StringBuilder line = new StringBuilder();
  private LineListener listener;
  
  public LineOutputStream(LineListener listener) {
    this.listener = listener;
  }

  /* Buffers and calls line listener when a line is complete
   * @see java.io.OutputStream#write(int)
   */
  @Override
  public void write(int c) throws IOException {
    if (c == '\n') {
      listener.lineRead(line.toString());
      line.setLength(0);
    } else if (c != '\r'){
      line.append((char) c);
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/DebugCommands.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Mon Feb 11 2008
 */
package se.sics.mspsim.cli;
import se.sics.mspsim.core.DbgInstruction;
import se.sics.mspsim.core.DisAsm;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.core.LogListener;
import se.sics.mspsim.core.Loggable;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.MSP430Constants;
import se.sics.mspsim.core.Memory;
import se.sics.mspsim.core.Memory.AccessMode;
import se.sics.mspsim.core.Memory.AccessType;
import se.sics.mspsim.core.MemoryMonitor;
import se.sics.mspsim.core.RegisterMonitor;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.DebugInfo;
import se.sics.mspsim.util.ELF;
import se.sics.mspsim.util.GDBStubs;
import se.sics.mspsim.util.MapEntry;
import se.sics.mspsim.util.Utils;

public class DebugCommands implements CommandBundle {
  private long lastCall = 0;
  private long lastWall = 0;
  private ComponentRegistry registry;

  private ELF getELF() {
    return registry.getComponent(ELF.class);
  }

  public void setupCommands(ComponentRegistry registry, CommandHandler ch) {
    this.registry = registry;
    final MSP430 cpu = registry.getComponent(MSP430.class);
    final GenericNode node = registry.getComponent(GenericNode.class, "node");
    if (cpu != null) {
      ch.registerCommand("break", new BasicAsyncCommand("add a breakpoint to a given address or symbol",
          "<address or symbol>") {
        private int address;
        private MemoryMonitor monitor;
        public int executeCommand(final CommandContext context) {
          address = context.getArgumentAsAddress(0);
          if (address < 0) {
            context.err.println("unknown symbol: " + context.getArgument(0));
            return 1;
          }
          monitor = new MemoryMonitor.Adapter() {
              private long lastCycles = -1;
              @Override
              public void notifyReadBefore(int address, AccessMode mode, AccessType type) {
                  if (type == AccessType.EXECUTE && cpu.cycles != lastCycles) {
                      context.out.println("*** Break at $" + cpu.getAddressAsString(address));
                      cpu.triggBreakpoint();
                      lastCycles = cpu.cycles;
                  }
              }
          };
          cpu.addWatchPoint(address, monitor);
          context.err.println("Breakpoint set at $" + cpu.getAddressAsString(address));
          return 0;
        }
        public void stopCommand(CommandContext context) {
          cpu.removeWatchPoint(address, monitor);
        }
      });

      ch.registerCommand("watch",
          new BasicAsyncCommand("add a write/read watch to a given address or symbol", "<address or symbol> [length] [char | hex | break]") {
        int mode = 0;
        int address = 0;
        int length = 1;
        MemoryMonitor monitor;
        public int executeCommand(final CommandContext context) {
          address = context.getArgumentAsAddress(0);
          if (address < 0) {
            context.err.println("unknown symbol: " + context.getArgument(0));
            return -1;
          }
          if (context.getArgumentCount() > 1) {
              for (int i = 1; i < context.getArgumentCount(); i++) {
                  String modeStr = context.getArgument(i);
                  if (Character.isDigit(modeStr.charAt(0))) {
                      length = Integer.parseInt(modeStr);
                  } else if ("char".equals(modeStr)) {
                      mode = Utils.ASCII_UNMODIFIED; // 4
                  } else if ("break".equals(modeStr)) {
                      mode = 10;
                  } else if ("hex".equals(modeStr)) {
                      mode = Utils.HEX; // 2
                  }
              }
          }
          if (length < 1) {
              context.err.println("please specify a length of at least one byte");
              return -1;
          }
          monitor = new MemoryMonitor.Adapter() {
              private void cpuAction(AccessType type, int adr, int data) {
                  if (mode == 0 || mode == 10) {
                      int pc = cpu.getPC();
                      String adrStr = getSymOrAddr(cpu, context, adr);
                      String pcStr = getSymOrAddrELF(cpu, getELF(), pc);
                      String op = "op";
                      if (type == AccessType.READ) {
                          op = "Read";
                      } else if (type == AccessType.WRITE){
                          op = "Write";
                      }
                      context.out.println("*** " + op + " from " + pcStr +
                              ": " + adrStr + " = 0x" + Utils.hex(data, 4));
                      if (mode == 10) {
                          cpu.triggBreakpoint();
                      }
                  } else {
                      if (length > 1) {
                          Memory mem = cpu.getMemory();
                          for (int i = address; i < address + length; i++) {
                              context.out.print(Utils.toString(mem.get(i, AccessMode.BYTE), Utils.BYTE, mode));
                          }
                          context.out.println();
                      } else {
                          context.out.print(Utils.toString(data, Utils.BYTE, mode));
                      }
                  }
              }

            @Override
            public void notifyReadBefore(int addr, AccessMode mode, AccessType type) {
                cpuAction(AccessType.READ, addr, cpu.getMemory().get(addr, mode));
            }
            @Override
            public void notifyWriteBefore(int dstAddress, int data, AccessMode mode) {
                cpuAction(AccessType.WRITE, dstAddress, data);
            }
          };

          for (int i = 0; i < length; i++) {
              cpu.addWatchPoint(address + i, monitor);
          }
          if (length > 1) {
              context.err.println("Watch set at $" + cpu.getAddressAsString(address) + " - $" + cpu.getAddressAsString(address + length - 1));
          } else {
              context.err.println("Watch set at $" + cpu.getAddressAsString(address));
          }
          return 0;
        }

        public void stopCommand(CommandContext context) {
            for (int i = 0; i < length; i++) {
                cpu.removeWatchPoint(address + i, monitor);
            }
            context.exit(0);
        }
      });

      ch.registerCommand("watchreg",
          new BasicAsyncCommand("add a write watch to a given register", "<register> [int]") {
        int watchMode = 0;
        int register = 0;
        RegisterMonitor monitor;
        public int executeCommand(final CommandContext context) {
          register = context.getArgumentAsRegister(0);
          if (register < 0) {
            return -1;
          }
          if (context.getArgumentCount() > 1) {
            String modeStr = context.getArgument(1);
            if ("int".equals(modeStr)) {
              watchMode = 1;
            } else {
              context.err.println("illegal argument: " + modeStr);
              return -1;
            }
          }
          monitor = new RegisterMonitor.Adapter() {
            @Override
            public void notifyWriteBefore(int register, int data, AccessMode mode) {
                if (watchMode == 0) {
                    int pc = cpu.getPC();
                    String adrStr = getRegisterName(register);
                    String pcStr = getSymOrAddrELF(cpu, getELF(), pc);
                    context.out.println("*** Write from " + pcStr +
                            ": " + adrStr + " = " + data);
                } else {
                    context.out.println(data);
                }
            }
          };
          cpu.addRegisterWriteMonitor(register, monitor);
          context.err.println("Watch set for register " + getRegisterName(register));
          return 0;
        }

        public void stopCommand(CommandContext context) {
          cpu.removeRegisterWriteMonitor(register, monitor);
        }
      });

//      ch.registerCommand("clear", new BasicCommand("clear a breakpoint or watch from a given address or symbol", "<address or symbol>") {
//        public int executeCommand(final CommandContext context) {
//          int baddr = context.getArgumentAsAddress(0);
//          cpu.setBreakPoint(baddr, null);
//          return 0;
//        }
//      });

      ch.registerCommand("symbol", new BasicCommand("list matching symbols", "<regexp>") {
        public int executeCommand(final CommandContext context) {
          String regExp = context.getArgument(0);
          MapEntry[] entries = context.getMapTable().getEntries(regExp);
          if (entries.length == 0) {
              context.err.println("Could not find any symbols matching '" + regExp + '\'');
          } else {
              for (MapEntry mapEntry : entries) {
                  int address = mapEntry.getAddress();
                  String file = mapEntry.getFile();
                  if (file == null) {
                      file = "(unspecified)";
                  }
                  context.out.println(" " + mapEntry.getName() + " at $"
                          + cpu.getAddressAsString(address) + " ($"
                          + Utils.hex8(cpu.getMemory().get(address, AccessMode.BYTE))
                          + ' ' + Utils.hex8(cpu.getMemory().get(address + 1, AccessMode.BYTE)) + ") "
                          + mapEntry.getType() + " in file " + file);
              }
          }
          return 0;
        }
      });

      ch.registerCommand("debug", new BasicCommand("set debug to on or off", "[0/1]") {
          public int executeCommand(final CommandContext context) {
              if (context.getArgumentCount() > 0) {
                  cpu.setDebug(context.getArgumentAsBoolean(0));
              }
              context.out.println("Debug is set to " + cpu.getDebug());
              return 0;
          }
      });

      ch.registerCommand("line", new BasicCommand("print line number of address/symbol", "<address or symbol>") {
        public int executeCommand(final CommandContext context) {
          int adr = context.getArgumentAsAddress(0);
          DebugInfo di = getELF().getDebugInfo(adr);
          if (di == null) {
            /* quick hack to test next address too... - since something seems to be off by one sometimes... */
            di = getELF().getDebugInfo(adr + 1);
          }
          if (di != null) {
            di.getLine();
            context.out.println(di);
          } else {
            context.err.println("No line number found for: " + context.getArgument(0));
          }
          return 0;
        }
      });

      if (node != null) {
        ch.registerCommand("stop", new BasicCommand("stop the CPU", "") {
          public int executeCommand(CommandContext context) {
            if (!cpu.isRunning()) {
                context.err.println("CPU is not running");
                return 1;
            }
            node.stop();
            context.out.println("CPU stopped at: $" + cpu.getAddressAsString(cpu.getPC()));
            return 0;
          }
        });
        ch.registerCommand("start", new BasicCommand("start the CPU", "") {
          public int executeCommand(CommandContext context) {
            if (cpu.isRunning()) {
                context.err.println("cpu already running");
                return 1;
            }
            node.start();
            return 0;
          }
        });
        ch.registerCommand("throw", new BasicCommand("throw an Emulation Exception", "[message]") {
            public int executeCommand(CommandContext context) {
                final String msg = context.getArgumentCount() > 0 ? context.getArgument(0) : "by request";
                cpu.scheduleCycleEvent(new TimeEvent(0, "EmulationException") {
                    @Override public void execute(long t) {
                        throw new EmulationException(msg);
                    }}, cpu.cycles);
                return 0;
            }
        });

        ch.registerCommand("step", new BasicCommand("single step the CPU", "[number of instructions]") {
          public int executeCommand(CommandContext context) {
            int nr = context.getArgumentCount() > 0 ? context.getArgumentAsInt(0) : 1;
            long cyc = cpu.cycles;
            if (cpu.isRunning()) {
                context.err.println("Can not single step when emulation is running.");
                return -1;
            }
            try {
              node.step(nr);
            } catch (Exception e) {
              e.printStackTrace(context.out);
            }
            context.out.println("CPU stepped to: $" + cpu.getAddressAsString(cpu.getPC()) +
                " in " + (cpu.cycles - cyc) + " cycles (" + cpu.cycles + ")");
            return 0;
          }
        });

        ch.registerCommand("stepmicro", new BasicCommand("single the CPU specified no micros", "<micro skip> <micro step>") {
          public int executeCommand(CommandContext context) {
            long cyc = cpu.cycles;
            if (cpu.isRunning()) {
                context.err.println("Can not single step when emulation is running.");
                return -1;
            }
            long nxt = 0;
            try {
              nxt = cpu.stepMicros(context.getArgumentAsLong(0), context.getArgumentAsLong(1));
            } catch (Exception e) {
              e.printStackTrace(context.out);
            }
            context.out.println("CPU stepped to: $" + cpu.getAddressAsString(cpu.getPC()) +
                " in " + (cpu.cycles - cyc) + " cycles (" + cpu.cycles + ") - next exec time: " + nxt);
            return 0;
          }
        });

        ch.registerCommand("stack", new BasicCommand("show stack info", "") {
          public int executeCommand(CommandContext context) {
            int stackEnd = context.getMapTable().heapStartAddress;
            int stackStart = context.getMapTable().stackStartAddress;
            int current = cpu.getSP();
            context.out.println("Current stack: $" + cpu.getAddressAsString(current) + " (" + (stackStart - current) + " used of " + (stackStart - stackEnd) + ')');
            return 0;
          }
        });
        ch.registerCommand("print", new BasicCommand("print value of an address or symbol", "<address or symbol>") {
          public int executeCommand(CommandContext context) {
            int adr = context.getArgumentAsAddress(0);
            if (adr >= 0) {
              int value = cpu.memory[adr];
              if (adr >= 0x100 && adr + 1 < cpu.MAX_MEM) {
                  value |= cpu.memory[adr + 1] << 8;
              }
              context.out.println(context.getArgument(0) + " = $" + Utils.hex16(value));
              return 0;
            }
            context.err.println("unknown symbol: " + context.getArgument(0));
            return 1;
          }
        });
        ch.registerCommand("printreg", new BasicCommand("print value of an register", "[register]") {
          public int executeCommand(CommandContext context) {
              if (context.getArgumentCount() > 0) {
                  for (int i = 0, n = context.getArgumentCount(); i < n; i++) {
                      int register = context.getArgumentAsRegister(i);
                      if (i > 0) {
                          context.out.print((i % 6) == 0 ? "\n" : " ");
                      }
                      if (register >= 0) {
                          context.out.print(getRegisterName(i) + "=$" + Utils.hex(cpu.getRegister(register), 4));
                      } else {
                          context.out.print(context.getArgument(i) + "=<not a register>");
                      }
                  }
              } else {
                  for (int i = 0; i < 16; i++) {
                      if (i > 0) {
                          context.out.print((i % 6) == 0 ? "\n" : " ");
                      }
                      context.out.print(getRegisterName(i) + "=$" + Utils.hex(cpu.getRegister(i), 4));
                  }
              }
              context.out.println();
              return 0;
          }
        });
        ch.registerCommand("reset", new BasicCommand("reset the CPU", "") {
          public int executeCommand(CommandContext context) {
            cpu.reset();
            return 0;
          }
        });

        ch.registerCommand("time", new BasicCommand("print the elapse time and cycles", "") {
          public int executeCommand(CommandContext context) {
            long time = (long)cpu.getTimeMillis();
	    long wallDiff = System.currentTimeMillis() - lastWall;
            context.out.println("Emulated time elapsed: " + time + "(ms)  since last: " + (time - lastCall) + " ms" + " wallTime: " +
				wallDiff + " ms speed factor: " +
				(wallDiff == 0 ? "N/A" : "" + (time - lastCall) / wallDiff));
            lastCall = time;
            lastWall = System.currentTimeMillis();
            return 0;
          }
        });

        ch.registerCommand("mem", new BasicCommand("dump memory", "<start address> <num_entries> [type] [hex|char|dis]") {
          public int executeCommand(final CommandContext context) {
            int start = context.getArgumentAsAddress(0);
            if (start < 0) {
              context.err.println("Illegal start address: "
                                  + context.getArgument(0));
              return 1;
            }
            int count = context.getArgumentAsInt(1);
            int mode = Utils.DEC;
            int type = Utils.UBYTE;
            boolean signed = false;
            if (context.getArgumentCount() > 2) {
                int pos = 2;
                int acount = context.getArgumentCount();
                if (acount > 4) acount = 4;
                while (pos < acount) {
                    String tS = context.getArgument(pos++);
                    if ("ubyte".equals(tS)) {
                    } else if ("byte".equals(tS)) {
                        type = Utils.BYTE;
                    } else if ("word".equals(tS)) {
                        type = Utils.WORD;
                    } else if ("uword".equals(tS)) {
                        type = Utils.UWORD;
                    } else if ("hex".equals(tS)) {
                        mode = Utils.HEX;
                    } else if ("char".equals(tS)) {
                        mode = Utils.ASCII;
                        type = Utils.BYTE;
                    } else if ("dis".equals(tS)) {
                        mode = Utils.DIS_ASM;
                        type = Utils.WORD;
                    }
                }
            }
            // Does not yet handle signed data...
            DisAsm disAsm = cpu.getDisAsm();
            for (int i = 0; i < count; i++) {
                if (mode == Utils.DIS_ASM) {
                    DbgInstruction dbg = disAsm.disassemble(start, cpu.memory, cpu.reg, new DbgInstruction(),
                            0);
                    String fkn;
                    if ((fkn = dbg.getFunction()) != null) {
                        context.out.println("//// " + fkn);
                    }
                    context.out.println(dbg.getASMLine(false));
                    start += dbg.getSize();
                } else {
                    int data = 0;
                    data = cpu.memory[start++];
                    if (Utils.size(type) == 2) {
                        data = data  + (cpu.memory[start++] << 8);
                    }
                    context.out.print((mode != Utils.ASCII ? " " : "") + 
                            Utils.toString(data, type, mode));
                }
            }
            context.out.println();
            return 0;
          }
        });

        ch.registerCommand("mset", new BasicCommand("set memory", "<address> [type] <value> [value ...]") {
          public int executeCommand(final CommandContext context) {
            int count = context.getArgumentCount();
            int adr = context.getArgumentAsAddress(0);
            String arg2 = context.getArgument(1);
            int type = Utils.BYTE;
            int mode = Utils.DEC;
            boolean typeRead = false;
            if (count > 2) {
              if ("char".equals(arg2)) {
                mode = Utils.ASCII;
                typeRead = true;
              }
              if ("word".equals(arg2)) {
                type = Utils.WORD;
                typeRead = true;
              }
            }
            for (int i = typeRead ? 2 : 1; i < count; i++) {
              if (mode == Utils.DEC) {
                int val = context.getArgumentAsInt(i);
                AccessMode accessMode = Utils.size(type) == 2 || val > 0xff ? AccessMode.WORD : AccessMode.BYTE;
                try {
                  cpu.getMemory().set(adr, val, accessMode);
                  adr += accessMode.bytes;
                } catch (EmulationException e) {
                  e.printStackTrace(context.out);
                }
              } else if (mode == Utils.ASCII) {
                String data = context.getArgument(i);
                Memory mem = cpu.getMemory();
                for (int j = 0; j < data.length(); j++) {
                  mem.set(adr++, data.charAt(j), AccessMode.BYTE);
                }
              }
            }
            return 0;
          }});

        /******************************************************
         * handle external memory (flash, etc).
         ******************************************************/
        ch.registerCommand("xmem", new BasicCommand("dump flash memory", "<start address> <num_entries> [type]") {
          public int executeCommand(final CommandContext context) {
            se.sics.mspsim.chip.Memory xmem = DebugCommands.this.registry.getComponent(se.sics.mspsim.chip.Memory.class, "xmem");
            if (xmem == null) {
              context.err.println("No xmem component registered");
              return 0;
            }
            int start = context.getArgumentAsAddress(0);
            int count = context.getArgumentAsInt(1);
            int size = 1; // unsigned byte
            boolean signed = false;
            if (context.getArgumentCount() > 2) {
              String tS = context.getArgument(2);
              if ("byte".equals(tS)) {
                signed = true;
              } else if ("word".equals(tS)) {
                signed = true;
                size = 2;
              } else if ("uword".equals(tS)) {
                size = 2;
              }
            }
            // Does not yet handle signed data...
            for (int i = 0; i < count; i++) {
              int data = 0;
              data = xmem.readByte(start++);
              if (size == 2) {
                data = data  + (xmem.readByte(start++) << 8);
              }
              context.out.print(" " + data);
            }
            context.out.println();
            return 0;
          }
        });

        ch.registerCommand("xmset", new BasicCommand("set memory", "<address> <value> [type]") {
          public int executeCommand(final CommandContext context) {
            se.sics.mspsim.chip.Memory xmem = DebugCommands.this.registry.getComponent(se.sics.mspsim.chip.Memory.class, "xmem");
            if (xmem == null) {
              context.err.println("No xmem component registered");
              return 0;
            }
            int adr = context.getArgumentAsAddress(0);
            int val = context.getArgumentAsInt(1);
            boolean word = val > 0xff;
            if (word) {
              xmem.writeByte(adr, val >> 8);
              val = val & 0xff;
              adr++;
            }
            xmem.writeByte(adr, val & 0xff);
            return 0;
          }});

        ch.registerCommand("gdbstubs", new BasicCommand("open up a gdb stubs server for GDB remote debugging", "port") {
          private GDBStubs stubs = null;
          public int executeCommand(CommandContext context) {
            if (stubs != null) {
              context.err.println("GDBStubs already open");
            } else {
              int port = context.getArgumentAsInt(0);
              stubs = new GDBStubs();
              stubs.setupServer(cpu, port);
            }
            return 0;
          }
        });

        ch.registerCommand("log", new BasicAsyncCommand("log a loggable object", "[loggable...]" ) {
            private Loggable[] logs;
            private int[] logLevels;
            private LogListener logListener;

            @Override
            public int executeCommand(final CommandContext context) {
                if (context.getArgumentCount() == 0) {
                    Loggable[] loggable = cpu.getLoggables();
                    for (Loggable unit : loggable) {
                        String id = unit.getID();
                        String name = unit.getName();
                        if (id == name) {
                            context.out.println("  " + id);
                        } else {
                            context.out.println("  " + id + " (" + name + ')');
                        }
                    }
                    context.exit(0);
                    return 0;
                }

                final Loggable[] logs = new Loggable[context.getArgumentCount()];
                for(int i = 0, n = context.getArgumentCount(); i < n; i++) {
                    logs[i] = cpu.getLoggable(context.getArgument(i));
                    if (logs[i] == null) {
                        context.err.println("Can not find loggable '" + context.getArgument(i) + '\'');
                        return 1;
                    }
                }
                logListener = new LogListener() {

                    boolean isLogging(Loggable source) {
                        for(Loggable log : logs) {
                            if (source == log) {
                                return true;
                            }
                        }
                        return false;
                    }

                    @Override
                    public void log(Loggable source, String message) {
                        if (isLogging(source)) {
                            context.out.println(source.getID() + ": " + message);
                        }
                    }

                    @Override
                    public void logw(Loggable source, WarningType type,
                            String message) throws EmulationException {
                        if (isLogging(source)) {
                            context.out.println("# " + source.getID() + "[" + type + "]: " + message);
                        }
                    }

                };
                this.logs = logs;
                cpu.getLogger().addLogListener(logListener);
                logLevels = new int[logs.length];
                int i = 0;
                for(Loggable log : logs) {
                    logLevels[i++] = log.getLogLevel();
                    log.setLogLevel(Loggable.DEBUG);
                }
                return 0;
            }

            public void stopCommand(CommandContext context) {
                if (logListener != null) {
                    cpu.getLogger().removeLogListener(logListener);
                    logListener = null;
                }
                if (logs != null) {
                    int i = 0;
                    for(Loggable log : logs) {
                        if (log.getLogLevel() == Loggable.DEBUG) {
                            log.setLogLevel(logLevels[i]);
                        }
                        i++;
                    }
                }
            }
        });

        ch.registerCommand("trace", new BasicCommand("store a trace of execution positions.", "[trace size | show]") {
            @Override
            public int executeCommand(CommandContext context) {
                if (context.getArgumentCount() > 0) {
                    if ("show".equals(context.getArgument(0))) {
                        int size = cpu.getTraceSize();
                        if (size > 0) {
                            DisAsm disAsm = cpu.getDisAsm();
                            for (int i = 0; i < size; i++) {
                                int pc = cpu.getBackTrace(size - 1 - i);
                                DbgInstruction inst = disAsm.getDbgInstruction(pc, cpu);
                                inst.setPos(pc);
                                context.out.println(inst.getASMLine(false));
                            }
                            return 0;
                        }
                    } else {
                        int newSize = context.getArgumentAsInt(0, -1);
                        if (newSize < 0) {
                            return 1;
                        }
                        cpu.setTrace(newSize);
                    }
                }
                context.out.println("Trace size is set to " + cpu.getTraceSize() + " positions.");
                return 0;
            }
        });

        ch.registerCommand("events", new BasicCommand("print event queues", "") {
            @Override
            public int executeCommand(CommandContext context) {
                cpu.printEventQueues(context.out);
              return 0;
            }
          });
      }
    }
  }

  private static String getSymOrAddr(MSP430 cpu, CommandContext context, int adr) {
    MapEntry me = context.getMapTable().getEntry(adr);
    if (me != null) {
      return me.getName();
    }
    return '$' + cpu.getAddressAsString(adr);
  }

  private static String getSymOrAddrELF(MSP430 cpu, ELF elf, int adr) {
    DebugInfo me = elf.getDebugInfo(adr);
    if (me != null) {
      return me.toString();
    }
    return '$' + cpu.getAddressAsString(adr);
  }

  private static String getRegisterName(int register) {
    if (register >= 0 && register < MSP430Constants.REGISTER_NAMES.length) {
      return MSP430Constants.REGISTER_NAMES[register];
    }
    return "R" + register;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/CommandHandler.java`:

```java
package se.sics.mspsim.cli;
import java.io.File;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Hashtable;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.util.ActiveComponent;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.MapTable;

public class CommandHandler implements ActiveComponent, LineListener {

  private String scriptDirectory = "scripts";

  private Hashtable<String, Command> commands = new Hashtable<String, Command>();

  protected final PrintStream out;
  protected final PrintStream err;
  private MapTable mapTable;
  private ComponentRegistry registry;
  private ArrayList<CommandContext[]> currentAsyncCommands = new ArrayList<CommandContext[]>();
  private int pidCounter = 0;

  public CommandHandler(PrintStream out, PrintStream err) {
    this.out = out;
    this.err = err;

    registerCommands();
  }

  private MapTable getMapTable() {
    if (mapTable == null && registry != null) {
      mapTable = registry.getComponent(MapTable.class);
    }
    return mapTable;
  }

  // Add it to the command table (overwriting anything there)
  public void registerCommand(String cmd, Command command) {
    commands.put(cmd, command);
  }

  @SuppressWarnings("resource")
  public int executeCommand(String commandLine, CommandContext context) {
    String[][] parts;
    final PrintStream cOut = context == null ? this.out : context.out;
    final PrintStream cErr = context == null ? this.err : context.err;
    
    try {
      parts = CommandParser.parseCommandLine(commandLine);
    } catch (Exception e) {
      cErr.println("Error: failed to parse command:");
      e.printStackTrace(cErr);
      return -1;
    }
    if (parts == null || parts.length == 0) {
      // Nothing to execute
      return 0;
    }
    Command[] cmds = createCommands(parts, cErr);
    if(cmds != null && cmds.length > 0) {
      CommandContext[] commands = new CommandContext[parts.length];
      boolean error = false;
      int pid = -1;
      for (int i = 0; i < parts.length; i++) {
        String[] args = parts[i];
        Command cmd = cmds[i];
        if (i == 0 && cmd instanceof AsyncCommand) {
          pid = ++pidCounter;
        }
        commands[i] = new CommandContext(this, getMapTable(), commandLine, args, pid, cmd);
        
        if (i > 0) {
          PrintStream po = new PrintStream(new LineOutputStream((LineListener) commands[i].getCommand()));
          commands[i - 1].setOutput(po, cErr);
        }
        // Last element also needs output!
        if (i == parts.length - 1) {
          commands[i].setOutput(cOut, cErr);
        }
        // TODO: Check if first command is also LineListener and set it up for input!!
      }
      // Execute when all is set-up in opposite order...
      int index = commands.length - 1;
      try {
        for (; index >= 0; index--) {
          int code = commands[index].getCommand().executeCommand(commands[index]);
          if (code != 0) {
            cErr.println("command '" + commands[index].getCommandName() + "' failed with error code " + code);
            error = true;
            break;
          }
        }
      } catch (Exception e) {
        cErr.println("Error: Command failed: " + e.getMessage());
        e.printStackTrace(cErr);
        error = true;
        if (e instanceof EmulationException) {
            throw (EmulationException) e;
        }
      }
      if (error) {
        // Stop any commands that have been started
        for (index++; index < commands.length; index++) {
            commands[index].stopCommand();
        }
        return 1;
      } else if (pid < 0) {
          // The first command is not asynchronous. Make sure all commands have stopped.
          exitCommands(commands);
      } else {
        boolean exited = false;
        for (int i = 0; i < commands.length && !exited; i++) {
            if (commands[i].hasExited()) {
                exited = true;
            }
        }
        if (exited) {
            exitCommands(commands);
        } else {
            synchronized (currentAsyncCommands) {
                currentAsyncCommands.add(commands);
            }
        }
      }
      return 0;
    }
    return -1;
  }

  // This will return an instance that can be configured -
  // which is basically not OK... TODO - fix this!!!
  private Command getCommand(String cmd)  {
    Command command = commands.get(cmd);
    if (command != null) {
        return (Command) command.getInstance();
    }
    File scriptFile = new File(scriptDirectory, cmd);
    if (scriptFile.isFile() && scriptFile.canRead()) {
      return new ScriptCommand(scriptFile);
    }
    return null;
  }

  private Command[] createCommands(String[][] commandList, PrintStream err) {
    Command[] cmds = new Command[commandList.length];
    for (int i = 0; i < commandList.length; i++) {
      Command command = getCommand(commandList[i][0]);
      if (command == null) {
        err.println("CLI: Command not found: \"" + commandList[i][0] + "\". Try \"help\".");
        return null;
      }
      if (i > 0 && !(command instanceof LineListener)) {
        err.println("CLI: Error, command \"" + commandList[i][0] + "\" does not take input.");
        return null;
      }
      // TODO replace with command name
      String argHelp = command.getArgumentHelp(null);
      if (argHelp != null) {
        int requiredCount = 0;
        for (int j = 0, m = argHelp.length(); j < m; j++) {
          if (argHelp.charAt(j) == '<') {
            requiredCount++;
          }
        }
        if (requiredCount > commandList[i].length - 1) {
          // Too few arguments
          err.println("Too few arguments for " + commandList[i][0]);
          err.println("Usage: " + commandList[i][0] + ' ' + argHelp);
          return null;
        }
      }
      cmds[i] = command;
    }
    return cmds;
  }

  public void init(String name, ComponentRegistry registry) {
    this.registry = registry;
  }

  public void start() {
    Object[] commandBundles = registry.getAllComponents(CommandBundle.class);
    if (commandBundles != null) {
      for (int i = 0, n = commandBundles.length; i < n; i++) {
        ((CommandBundle) commandBundles[i]).setupCommands(registry, this);
      }
    }
  }

  private void registerCommands() {
    registerCommand("help", new BasicCommand("show help for the specified command or command list", "[command]") {
      public int executeCommand(CommandContext context) {
        if (context.getArgumentCount() == 0) {
          context.out.println("Available commands:");
          String[] names = commands.keySet().toArray(new String[commands.size()]);
          Arrays.sort(names);
          for(String name : names) {
            Command command = commands.get(name);
            String helpText = command.getCommandHelp(name);
            if (helpText != null) {
              String argHelp = command.getArgumentHelp(name);
              String prefix = argHelp != null ? (' ' + name + ' ' + argHelp) : (' ' + name);
              int n;
              if ((n = helpText.indexOf('\n')) > 0) {
                // Show only first line as short help if help text consists of several lines
                helpText = helpText.substring(0, n);
              }
              context.out.print(prefix);

              int prefixLen = prefix.length();
              if (prefixLen < 8) {
                context.out.print("\t\t\t\t");
              } else if (prefixLen < 16) {
                context.out.print("\t\t\t");
              } else if (prefixLen < 24) {
                context.out.print("\t\t");
              } else if (prefixLen < 32) {
                context.out.print('\t');
              }
              context.out.print(' ');
              context.out.println(helpText);
            }
          }
          return 0;
        }

        String cmd = context.getArgument(0);
        Command command = getCommand(cmd);
        if (command != null) {
          String helpText = command.getCommandHelp(cmd);
          String argHelp = command.getArgumentHelp(cmd);
          context.out.print(cmd);
          if (argHelp != null && argHelp.length() > 0) {
            context.out.print(' ' + argHelp);
          }
          context.out.println();
          if (helpText != null && helpText.length() > 0) {
            context.out.println("  " + helpText);
          }
          return 0;
        }
        context.err.println("Error: unknown command '" + cmd + '\'');
        return 1;
      }
    });

    registerCommand("ps", new BasicCommand("list current executing commands/processes", "") {
      public int executeCommand(CommandContext context) {
        if (currentAsyncCommands.size() > 0) {
            context.out.println(" PID\tCommand");
            for (int i = 0; i < currentAsyncCommands.size(); i++) {
                CommandContext cmd = currentAsyncCommands.get(i)[0];
                context.out.println("  " + cmd);
            }
        } else {
            context.out.println("No executing commands.");
        }
        return 0;
      }
    });

    registerCommand("kill", new BasicCommand("kill a currently executing command", "<process>") {
      public int executeCommand(CommandContext context) {
        int pid = context.getArgumentAsInt(0);
        if (removePid(pid)) {
          return 0;
        }
        context.err.println("could not find the command to kill.");
        return 1;
      }
    });
  }

  public void exit(CommandContext commandContext, int exitCode, int pid) {
    if (pid < 0 || !removePid(pid)) {
      commandContext.stopCommand();
    }
  }

  private boolean removePid(int pid) {
    CommandContext[] contexts = null;
    synchronized (currentAsyncCommands) {
      for (int i = 0, n = currentAsyncCommands.size(); i < n; i++) {
        CommandContext[] cntx = currentAsyncCommands.get(i);
        if (pid == cntx[0].getPID()) {
          contexts = cntx;
          currentAsyncCommands.remove(cntx);
          break;
        }
      }
    }
    return exitCommands(contexts);
  }

  private boolean exitCommands(CommandContext[] contexts) {
      if (contexts != null) {
          for (int i = 0; i < contexts.length; i++) {
              contexts[i].stopCommand();
          }
          return true;
      }
      return false;
  }

  public void lineRead(String line) {
    executeCommand(line, null);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/StreamCommandHandler.java`:

```java
/*
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * StreamCommandHandler
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 13 okt 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.cli;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.io.PrintStream;

/**
 *
 */
public class StreamCommandHandler extends CommandHandler implements Runnable {

  private BufferedReader inReader;
  private boolean workaround = false;
  private boolean exit;
  private String prompt;

  public StreamCommandHandler(InputStream in, PrintStream out, PrintStream err, String prompt) {
    super(out, err);
    this.prompt = prompt;
    this.exit = false;
    this.inReader = new BufferedReader(new InputStreamReader(in));
    registerCommand("workaround", new BasicCommand("activate workaround for Java console input bug", "") {
      public int executeCommand(CommandContext context) {
        workaround = true;
        return 0;
      }     
    });
  }
  
  public void setWorkaround(boolean w) {
    workaround = w;
  }

  public void start() {
    super.start();
    new Thread(this, "cmd").start();
  }

  private String readLine(BufferedReader inReader2) throws IOException {
    if (workaround) {
      StringBuilder str = new StringBuilder();
      while(!exit) {
        if (inReader2.ready()) {
          int c = inReader2.read();
          if (c < 0) {
              // Input stream closed
              return null;
          }
          if (c == '\n') {
            return str.toString();
          }
          if (c != '\r') {
            str.append((char)c);
          }
        } else {
          try {
            Thread.sleep(500);
          } catch (InterruptedException e) {
            throw new InterruptedIOException();
          }
        }
      }
      return null;
    } else {
      return inReader2.readLine();
    }
  }

  public void run() {
    String lastLine = null;
    while(!exit) {
      try {
        out.print(prompt);
        out.flush();
        String line = readLine(inReader);
        if (line == null) {
            // Input stream closed
            exit = true;
            break;
        }
        // Simple execution of last called command line when not running from terminal with history support
        if (((char) 27 + "[A").equals(line)) {
          line = lastLine;
        }
        if (line.length() > 0) {
          lastLine = line;
          lineRead(line);
        }
      } catch (IOException e) {
        e.printStackTrace(err);
        err.println("Command line tool exiting...");
        exit = true;
      }
    }
    try {
        inReader.close();
    } catch (IOException e) {
        err.println("Error closing command line");
        e.printStackTrace(err);
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/ProfilerCommands.java`:

```java
/*
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ProfilerCommands
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 12 maj 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.cli;
import java.util.Properties;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.EventListener;
import se.sics.mspsim.core.EventSource;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.Profiler;
import se.sics.mspsim.profiler.SimpleProfiler;
import se.sics.mspsim.ui.CPUHeatMap;
import se.sics.mspsim.ui.WindowManager;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.StackMonitor;

/**
 *
 */
public class ProfilerCommands implements CommandBundle {

  public void setupCommands(final ComponentRegistry registry, CommandHandler ch) {
    final MSP430 cpu = registry.getComponent(MSP430.class);
    if (cpu != null) {
      ch.registerCommand("profile", new BasicCommand("show profile information",
          "[-clear] [-sort column] [-showcallers] [regexp]") {
        public int executeCommand(final CommandContext context) {
          Profiler profiler = cpu.getProfiler();
          if (profiler == null) {
            context.err.println("No profiler found.");
            return 1;
          }
          String namematch = null;
          String sortMode = null;
          String showCaller = null;
          int i;

          for (i = 0; i < context.getArgumentCount(); i++) {
            String value = context.getArgument(i);
            if ("-clear".equals(value)) {
              profiler.clearProfile();
              context.out.println("Cleared profile information.");
              return 0;
            } else if ("-sort".equals(value)) {
              if (context.getArgumentCount() > i + 1) { 
                sortMode = context.getArgument(i + 1);
                i++;
              } else {
                context.err.println("Missing mode argument for -sort.");
                return 1;
              }
            } else if ("-showcallers".equals(value)) {
              showCaller = value;
            } else if ("--".equals(value)) {
                /* Done with arguments */
                break;
            } else if (value.startsWith("-")) {
                /* Unknown option */
                context.err.println("Unknown option: " + value);
                return 1;
            } else {
                break;
            }
          }
          if (i < context.getArgumentCount()) {
              namematch = context.getArgument(i++);
              if (i < context.getArgumentCount()) {
                  // Multiple patterns
                  namematch = "(" + namematch;
                  for(; i < context.getArgumentCount(); i++) {
                      namematch += "|" + context.getArgument(i);
                  }
                  namematch += ')';
              }
          }

          Properties params = new Properties();
          if (namematch != null) { 
            params.put(Profiler.PARAM_FUNCTION_NAME_REGEXP, namematch);
          }
          if (showCaller != null) { 
            params.put(Profiler.PARAM_PROFILE_CALLERS, showCaller);
          }
          if (sortMode != null) { 
            params.put(Profiler.PARAM_SORT_MODE, sortMode);
          }
          profiler.printProfile(context.out, params);
          return 0;
        }
      });

      ch.registerCommand("stacktrace", new BasicCommand("show stack trace", "") {
        public int executeCommand(CommandContext context) {
          Profiler profiler = cpu.getProfiler();
          if (profiler == null) {
            context.err.println("No profiler found.");
            return 1;
          }
          profiler.printStackTrace(context.out);
          return 0;
        }
      });

      ch.registerCommand("stackprof", new BasicCommand("Start stack profiler", "") {
          public int executeCommand(CommandContext context) {
              new StackMonitor(cpu);
              return 0;
          }
      });
      
//      ch.registerCommand("irqprofile", new BasicCommand("show interrupt profile", "") {
//        public int executeCommand(CommandContext context) {
//          long[] time = cpu.getInterruptTime();
//          long[] ctr = cpu.getInterruptCount();
//          context.out.println("Interrupt statistics");
//          context.out.println("Vector\tAvg\tCount");
//          
//          for (int i = 0; i < ctr.length; i++) {
//            long avg = ctr[i] != 0 ? (time[i] / ctr[i]) : 0;
//            context.out.println(i + "\t" + avg + "\t" + ctr[i]);
//          }
//          return 0;
//        }
//
//      });
      
      ch.registerCommand("logevents", new BasicAsyncCommand("log events", "[chips...]") {
        Chip[] chips;
        EventListener eventListener;
        public int executeCommand(final CommandContext context) {
            if (context.getArgumentCount() == 0) {
                context.out.println("Available chips:");
                for(Chip chip : cpu.getChips()) {
                    String id = chip.getID();
                    String name = chip.getName();
                    if (id == name) {
                        context.out.println("  " + id);
                    } else {
                        context.out.println("  " + id + " (" + name + ')');
                    }
                }
                context.exit(0);
                return 0;
            }
            chips = new Chip[context.getArgumentCount()];
            for(int i = 0, n = chips.length; i < n; i++) {
                chips[i] = cpu.getChip(context.getArgument(i));
                if (chips[i] == null) {
                    context.err.println("Can not find chip: " + context.getArgument(i));
                    return 1;
                }
            }
            eventListener = new EventListener() {
                public void event(EventSource source, String event, Object data) {
                    context.out.println("Event:" + source.getName() + ":" + event);
                }
            };
            for (Chip chip : chips) {
                chip.addEventListener(eventListener);
            }
            return 0;
        }
        public void stopCommand(CommandContext context) {
            for (Chip chip : chips) {
                chip.removeEventListener(eventListener);
            }
        }
      });

      ch.registerCommand("tagprof", new BasicCommand("profile between two events", "") {
        public int executeCommand(CommandContext context) {
          String event1 = context.getArgument(0);
          String event2 = context.getArgument(1);
          String chip1[] = event1.split("\\.");
          String chip2[] = event2.split("\\.");
          Chip chipE1 = cpu.getChip(chip1[0]);
          if (chipE1 == null) {
            context.err.println("Can not find chip: " + chip1[0]);
            return 1;
          }
          Chip chipE2 = cpu.getChip(chip2[0]);
          if (chipE2 == null) {
            context.err.println("Can not find chip: " + chip2[0]);
            return 1;
          }
          Profiler profiler = cpu.getProfiler();
          SimpleProfiler sprof = (SimpleProfiler) profiler;
          sprof.addProfileTag(context.getArgument(2), chipE1, chip1[1],
              chipE2, chip2[1]);
          return 0;
        }
      });      

      ch.registerCommand("printtags", new BasicCommand("print tags profile", "") {
        public int executeCommand(CommandContext context) {
          Profiler profiler = cpu.getProfiler();
          SimpleProfiler sprof = (SimpleProfiler) profiler;
          sprof.printTagProfile(context.out);
          return 0;
        }
      });      

      
      ch.registerCommand("logcalls", new BasicAsyncCommand("log function calls", "") {
        public int executeCommand(CommandContext context) {
          Profiler profiler = cpu.getProfiler();
          if (profiler == null) {
            context.err.println("No profiler found.");
            return 1;
          }
          profiler.setLogger(context.out);
          return 0;
        }
        public void stopCommand(CommandContext context) {
          Profiler profiler = cpu.getProfiler();
          if (profiler != null) {
            profiler.setLogger(null);
          }
        }
      });
      
      ch.registerCommand("profiler", new BasicCommand("configure profiler",
          "<command> <arguments>") {
            public int executeCommand(CommandContext context) {
              // TODO: add more API's to the Profiler???
              SimpleProfiler profiler = (SimpleProfiler) cpu.getProfiler();
              if (profiler == null) {
                context.err.println("No profiler found.");
                return 1;
              }
              String cmd = context.getArgument(0);
              if ("hide".equals(cmd)) {
                for (int j = 1, n = context.getArgumentCount(); j < n; j++) {
                  profiler.addIgnoreFunction(context.getArgument(j));
                }
              } else if ("hideirq".equals(cmd)) {
                profiler.setHideIRQ(context.getArgumentAsBoolean(1));
              }
              return 0;
            }
      });
      
      ch.registerCommand("readmap", new BasicAsyncCommand("read map", "") {
          private CPUHeatMap hm;

          public int executeCommand(CommandContext context) {
              hm = new CPUHeatMap(cpu, registry.getComponent(WindowManager.class));
              cpu.addGlobalMonitor(hm);
              return 0;
          }

          public void stopCommand(CommandContext context) {
              if (hm != null) {
                  cpu.removeGlobalMonitor(hm);
                  hm.close();
                  hm = null;
              }
          }
      });
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/Command.java`:

```java
package se.sics.mspsim.cli;

public abstract class Command {

  /**
   * Returns a text describing this command. First line is a short description that may be followed by
   * more lines with detailed descriptions.
   *
   * @param commandName the name of the command
   * @return a text describing the command
   */
  public abstract String getCommandHelp(String commandName);

  /**
   * Returns a text describing the arguments for this command. Required arguments should be surrounded by
   * '<' and '>', optional arguments should be surrounded by '[' and ']'.
   *
   * @param commandName the name of the command
   * @return a text describing the arguments for this command
   */
  public abstract String getArgumentHelp(String commandName);

  public abstract int executeCommand(CommandContext context);

  /* default behavior is that it returns *this* instance (which might be bad in some cases) */
  public Object getInstance() {
      return this;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/MiscCommands.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * MiscCommands
 *
 * Author  : Joakim Eriksson
 * Created : 9 mar 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.cli;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.regex.Pattern;

import se.sics.mspsim.chip.RFListener;
import se.sics.mspsim.chip.RFSource;
import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.MSP430Constants;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.ConfigManager;
import se.sics.mspsim.util.PluginRepository;
import se.sics.mspsim.util.ServiceComponent;
import se.sics.mspsim.util.Utils;

/**
 * @author joakim
 *
 */
public class MiscCommands implements CommandBundle {

  public void setupCommands(final ComponentRegistry registry, CommandHandler handler) {
    handler.registerCommand("grep", new BasicLineCommand("print lines matching the specified pattern", "[-i] [-v] <regexp>") {
      private PrintStream out;
      private Pattern pattern;
      private boolean isInverted = false;

      public int executeCommand(CommandContext context) {
        int index = 0;
        int flags = 0;
        while (index + 1 < context.getArgumentCount()) {
          if ("-i".equals(context.getArgument(index))) {
            flags |= Pattern.CASE_INSENSITIVE;
          } else if ("-v".equals(context.getArgument(index))) {
            isInverted = true;
          } else {
            context.err.println("unknown option: " + context.getArgument(index));
            return 1;
          }
          index++;
        }
        out = context.out;
        pattern = Pattern.compile(context.getArgument(index), flags);
        return 0;
      }
      public void lineRead(String line) {
        boolean isMatch = pattern.matcher(line).find();
        if(isMatch ^ isInverted) {
          out.println(line);
        }
      }
    });

    handler.registerCommand("timestamp", new BasicLineCommand("print lines prefixed with timestamp as milliseconds or CPU cycles", "[-c]") {
      private PrintStream out;
      private MSP430 cpu;
      boolean useCycles;
      long startTime;

      public int executeCommand(CommandContext context) {
        cpu = registry.getComponent(MSP430.class);
        if (cpu == null) {
          context.err.println("could not access the CPU.");
          return 1;
        }
        out = context.out;
        if (context.getArgumentCount() > 0) {
            if ("-c".equals(context.getArgument(0))) {
                useCycles = true;
            } else {
                context.err.println("unknown argument: " + context.getArgument(0));
                return 1;
            }
        }
        startTime = System.currentTimeMillis() - (long)cpu.getTimeMillis();
        return 0;
      }
      public void lineRead(String line) {
          if (useCycles) {
              out.println(Long.toString(cpu.cycles) + ' ' + line);
          } else {
              out.println(Long.toString(startTime + (long)cpu.getTimeMillis()) + ' ' + line);
          }
      }
    });

    handler.registerCommand("speed", new BasicCommand("set the speed factor for the CPU", "[factor]") {
      public int executeCommand(CommandContext context) {
        MSP430 cpu = registry.getComponent(MSP430.class);
        if (cpu == null) {
          context.err.println("could not access the CPU.");
          return 1;
        } else if (context.getArgumentCount() == 0) {
          /* No speed specified. Simply show current speed. */
        } else {
          double rate = context.getArgumentAsDouble(0);
          if (rate > 0.0) {
            cpu.setExecutionRate(rate);
          } else {
            context.err.println("Speed factor must be larger than zero.");
            return 1;
          }
        }
        double rate = cpu.getExecutionRate();
        context.out.printf("Speed factor is set to %.2f\n", rate);
        return 0;
      }
    });

    handler.registerCommand("echo", new BasicCommand("echo arguments", "") {
      public int executeCommand(CommandContext context) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0, n = context.getArgumentCount(); i < n; i++) {
          if (i > 0) sb.append(' ');
          sb.append(context.getArgument(i));
        }
        context.out.println(sb);
        return 0;
      }
    });
    
    
    handler.registerCommand("source", new BasicCommand("run script", "[-v] <filename>") {
      public int executeCommand(CommandContext context) {
          boolean verbose = false;
          if (context.getArgumentCount() > 1) {
              verbose = "-v".equals(context.getArgument(0));
          }
        File fp = new File(context.getArgument(context.getArgumentCount() - 1));
        if (!fp.canRead()) {
          context.err.println("could not find the script file '" + context.getArgument(0) + "'.");
          return 1;
        }
        try (BufferedReader input = new BufferedReader(new FileReader(fp))) {
          String line;
          while ((line = input.readLine()) != null) {
            if (verbose) context.out.println(line);
            context.executeCommand(line);
          }
        } catch (IOException e) {
          e.printStackTrace(context.err);
          return 1;
        }
        return 0;
      }
    });

    handler.registerCommand("repeat", new BasicAsyncCommand("repeat the specified command line", "[-t delay] [-c count] <command line>") {

      private MSP430 cpu;
      private int period = 1;
      private int count = 0;
      private int maxCount = -1;
      private String commandLine;
      private boolean isRunning = true;

      public int executeCommand(final CommandContext context) {
        int index = 0;
        do {
          String a = context.getArgument(index);
          if (a.startsWith("-")) {
            if (a.equals("-t")) {
              period = context.getArgumentAsInt(index + 1);
              index += 2;
            } else if (a.equals("-c")) {
              maxCount = context.getArgumentAsInt(index + 1);
              index += 2;
            } else {
              context.err.println("illegal option: " + a);
              return 1;
            }
          } else {
            break;
          }
        } while (true);
        if (index + 1 < context.getArgumentCount()) {
          context.err.println("too many arguments");
          return 1;
        }
        commandLine = context.getArgument(index);

        cpu = registry.getComponent(MSP430.class);
        if (cpu == null) {
          context.err.println("could not access the CPU.");
          return 1;
        }

        cpu.scheduleTimeEventMillis(new TimeEvent(0) {

          @Override
          public void execute(long t) {
            if (isRunning) {
              count++;
              context.executeCommand(commandLine);
              if ((maxCount <= 0) || (count < maxCount)) {
                cpu.scheduleTimeEventMillis(this, period * 1000d);
              } else {
                stopCommand(context);
              }
            }
          }

        }, period * 1000d);
        return 0;
      }

      public void stopCommand(CommandContext context) {
        isRunning = false;
        context.err.println("[repeat exit: " + commandLine + ']');
        context.exit(0);
      }
    });

    handler.registerCommand("exec", new ExecCommand());

    handler.registerCommand("trig", new BasicLineCommand("trigg command when getting input", "<command>") {
      String command = null;
      CommandContext context;
      public int executeCommand(CommandContext context) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0, n = context.getArgumentCount(); i < n; i++) {
          if (i > 0) sb.append(' ');
          sb.append(context.getArgument(i));
        }
        command = sb.toString();
        this.context = context;
        return 0;
      }
      public void lineRead(String line) {
        context.executeCommand(command);
      }
    });

    handler.registerCommand("install", new BasicCommand("install and start a plugin", "ClassName [Name]") {
      @Override
      public int executeCommand(CommandContext context) {
        String className = context.getArgument(0);
        String name = className;
        if (context.getArgumentCount() > 1) {
          name = context.getArgument(1);
        }
        if (registry.getComponent(name) != null) {
          context.err.println("Another component with name '" + name + "' is already installed");
          return 1;
        }
        Class<?> pluginClass;
        PluginRepository plugins = registry.getComponent(PluginRepository.class, "pluginRepository");
        try {
          try {
            pluginClass = plugins != null ? plugins.loadClass(className) :
              Class.forName(className);
          } catch (ClassNotFoundException e) {
            String newClassName = "se.sics.mspsim.plugin." + className;
            pluginClass = plugins != null ? plugins.loadClass(newClassName) :
              Class.forName(newClassName);
          }
          Object component = pluginClass.getDeclaredConstructor().newInstance();
          registry.registerComponent(name, component);
          return 0;
        } catch (Exception e1) {
          e1.printStackTrace(context.err);
        }
        return 1;
      }
    });
    
    handler.registerCommand("service", new BasicCommand("handle service plugins", "[-f] [class name|service name] [start|stop]") {
      @Override
      public int executeCommand(CommandContext context) {
        int index = 0;
        boolean verbose = true;
        if (context.getArgumentCount() > 0 && "-f".equals(context.getArgument(index))) {
          index++;
          verbose = false;
        }
        if (context.getArgumentCount() == index) {
          ServiceComponent[] sc = registry.getAllComponents(ServiceComponent.class);
          if (sc.length == 0) {
            context.out.println("No services found.");
          } else {
            for (ServiceComponent service : sc) {
              context.out.printf(" %-20s %s\n", service.getName(), service.getStatus());
            }
          }
          return 0;
        }
        String name = context.getArgument(index++);
        ServiceComponent sc = getServiceForName(registry, name);
        if (sc == null) {
          if (verbose) {
            context.err.println("could not find service '" + name + "'");
            return 1;
          }
          return 0;
        }
        if (context.getArgumentCount() == index) {
          context.out.printf(" %-20s %s\n", sc.getName(), sc.getStatus());
          return 0;
        }
        String operation = context.getArgument(index);
        if ("start".equals(operation)) {
          if (sc.getStatus() == ServiceComponent.Status.STARTED) {
            context.out.println("service " + sc.getName() + " already started");
          } else {
            sc.start();
            context.out.println("service " + sc.getName() + " started");
          }
          return 0;
        }
        if ("stop".equals(operation)) {
          if (sc.getStatus() == ServiceComponent.Status.STOPPED) {
            context.out.println("service " + sc.getName() + " already stopped");
          } else {
            sc.stop();
            context.out.println("service " + sc.getName() + " stopped");
          }
          return 0;
        }
        context.err.println("unknown operation '" + operation + "'");
        return 1;
      }
    });

    handler.registerCommand("rflistener", new BasicLineCommand("an rflistener", "<input|output> <rf-chip>") {
      CommandContext context;
      RFSource source;
      RFListener listener;
      final MSP430 cpu = registry.getComponent(MSP430.class);
      public int executeCommand(CommandContext ctx) {
        this.context = ctx;
        String inout = context.getArgument(0);
        Chip chip = cpu.getChip(context.getArgument(1));
        if (chip == null) {
          context.err.println("Error: could not find chip '" + context.getArgument(1) + '\'');
          return 1;
        }
        if ("output".equals(inout)) {
          if (chip instanceof RFSource) {
            source = (RFSource) chip;
            listener = new RFListener() {
                public void receivedByte(byte data) {
                    context.out.println(Utils.hex8(data));
                }
            };
            source.addRFListener(listener);
          } else {
            context.err.println("Error: chip is not an RF source");
            return 1;
          }
        } else if ("input".equals(inout)){
          listener = (RFListener) chip;
        } else {
          context.err.println("Error: illegal type: " + inout);
          return 1;
        }
        return 0;
      }

      @Override
      public void lineRead(String line) {
        if (listener != null) {
          byte[] data = Utils.hexconv(line);
          if (data != null) {
            context.out.println("RFListener: to radio: " + line);
            for (byte b : data) {
              listener.receivedByte(b);
            }
          } else {
            context.out.println("RFListener: " + line);
          }
        }
      }

      @Override
      public void stopCommand(CommandContext context) {
          if (source != null) {
              source.removeRFListener(listener);
          }
          super.stopCommand(context);
      }

    });

    handler.registerCommand("sysinfo", new BasicCommand("show info about the MSPSim system", "[-registry] [-config]") {
        public int executeCommand(CommandContext context) {
            ConfigManager config = registry.getComponent(ConfigManager.class, "config");
            context.out.println("--------- System info ----------\n");
            context.out.println("MSPSim version: " + MSP430Constants.VERSION);
            context.out.println("Java version  : " + System.getProperty("java.version") + " " +
                    System.getProperty("java.vendor"));
            context.out.println("Firmware      : " + config.getProperty("firmwareFile", "-"));
            context.out.println("AutoloadScript: " + config.getProperty("autoloadScript", "-"));
            context.out.println();
            if (context.getOption("registry")) {
                context.out.println("--------- Registry info --------\n");
                registry.printRegistry(context.out);
            }
            if (context.getOption("config")) {
                context.out.println("--------- Configuration ---------\n");
                config.print(context.out);
            }
            return 0;
        }
    });

    handler.registerCommand("quit", new BasicCommand("exit MSPSim", "") {
        public int executeCommand(CommandContext context) {
          /* TODO: flush all files, etc.... */
          System.exit(0);
          return 0;
        }
      });

    handler.registerCommand("exit", new BasicCommand("exit MSPSim", "") {
        public int executeCommand(CommandContext context) {
            System.exit(0);
            return 0;
        }
    });

    handler.registerCommand("set", new BasicCommand("set a config parameter", "<parameter> <value>") {
        public int executeCommand(CommandContext context) {
            ConfigManager config = registry.getComponent(ConfigManager.class, "config");
            config.setProperty(context.getArgument(0), context.getArgument(1));
            context.out.println("set " + context.getArgument(0) + " to " + context.getArgument(1));
            return 0;
        }
    });

    
  }

  private static ServiceComponent getServiceForName(ComponentRegistry registry, String name) {
    Object o = registry.getComponent(name);
    if (o instanceof ServiceComponent) {
      return (ServiceComponent) o;
    }
    return null;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/FileCommands.java`:

```java
package se.sics.mspsim.cli;

import java.util.Hashtable;

import se.sics.mspsim.util.ComponentRegistry;

public class FileCommands implements CommandBundle {

    private final Hashtable <String,Target> fileTargets = new Hashtable<String,Target>();

    public void setupCommands(final ComponentRegistry registry, CommandHandler handler) {
        // TODO: this should also be "registered" as a "sink".
        // probably this should be handled using ">" instead!
        handler.registerCommand(">", new FileTargetCommand(fileTargets,
            null, "<filename>", false, false));

        handler.registerCommand(">>", new FileTargetCommand(fileTargets,
            null, "<filename>", false, true));

        handler.registerCommand("tee", new FileTargetCommand(fileTargets,
            "redirect to file and standard out", "<filename>", true, true));

        handler.registerCommand("fclose", new BasicCommand("close the specified file", "<filename>") {
          public int executeCommand(CommandContext context) {
            String name = context.getArgument(0);
            Target ft = fileTargets.get(name);
            if (ft != null) {
              context.out.println("Closing file " + name);
              ft.close();
              return 0;
            }
            context.err.println("Could not find the open file " + name);
            return 1;
          }
        });

        handler.registerCommand("files", new BasicCommand("list open files", "") {
          public int executeCommand(CommandContext context) {
            FileTarget[] files = null;
            synchronized (fileTargets) {
                if (fileTargets.size() > 0) {
                    files = fileTargets.values().toArray(new FileTarget[fileTargets.size()]);
                }
            }
            if (files == null) {
              context.out.println("There are no open files.");
            } else {
              for (FileTarget type : files) {
                context.out.println(type.getStatus());
              }
            }
            return 0;
          }
        });
    }
        
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/cli/FileTargetCommand.java`:

```java
package se.sics.mspsim.cli;

import java.io.FileWriter;
import java.io.IOException;
import java.util.Hashtable;

public class FileTargetCommand extends BasicLineCommand {
  private final Hashtable<String,Target> fileTargets;
  private final boolean print;
  private final boolean append;

  private Target ft;
  private CommandContext context;
  
  public FileTargetCommand(Hashtable<String,Target> fileTargets,
        String name, String desc, boolean print, boolean append) {
    super(name, desc);
    this.fileTargets = fileTargets;
    this.print = print;
    this.append = append;
  }

  public int executeCommand(CommandContext context) {
    this.context = context;
    String fileName = context.getArgument(0);
    IOException error = null;
    boolean alreadyOpened = false;

    synchronized (fileTargets) {
      ft = fileTargets.get(fileName);
      if (ft == null) {
        try {
          FileWriter writer = new FileWriter(fileName, append);
          ft = new FileTarget(fileTargets, fileName, writer);
        } catch (IOException e) {
          error = e;
        }
      } else if (!append) {
        alreadyOpened = true;
      }
    }

    if (error != null) {
      error.printStackTrace(context.err);
      return -1;
    }
    if (alreadyOpened) {
      context.err.println("File already opened: can not overwrite");
      return -1;
    }
    if (context.getPID() >= 0) {
      ft.addContext(context);
    }
    return 0;
  }

  public void lineRead(String line) {
    if (print) context.out.println(line);
    ft.lineRead(context, line);
  }

  public void stopCommand(CommandContext context) {
    if (ft != null) {
      ft.removeContext(context);
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/wismote/WismoteNode.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * WismoteNode
 *
 * Author  : Niclas Finne
 */

package se.sics.mspsim.platform.wismote;
import java.io.IOException;
import se.sics.mspsim.chip.Button;
import se.sics.mspsim.chip.CC2520;
import se.sics.mspsim.chip.DS2411;
import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class WismoteNode extends GenericNode implements PortListener, USARTListener {

    // Port 1.
    public static final int DS2411_DATA_PIN = 1;
    public static final int DS2411_DATA = 1 << DS2411_DATA_PIN;

    /* P1.6 - Input: FIFOP from CC2520 */
    /* P1.5 - Input: FIFO from CC2520 */
    /* P1.7 - Input: CCA from CC2520 */
    public static final int CC2520_FIFOP = 6;
    public static final int CC2520_FIFO = 5;
    public static final int CC2520_CCA = 7;
    /* P2.0 - Input: SFD from CC2520 */
    public static final int CC2520_SFD = 0;
    /* P3.0 - Output: SPI Chip Select (CS_N) */
    public static final int CC2520_CHIP_SELECT = 0x01;
    /* P4.3 - Output: VREG_EN to CC2520 */
    public static final int CC2520_VREG = 1 << 3;
    /* P4.4 - Output: RESET_N to CC2520 */
    public static final int CC2520_RESET = 1 << 4;

    /* P1.4 - Button */
    public static final int BUTTON_PIN = 4;

    /* P8.6 - Red (left) led */
    private static final int LEDS_CONF_RED1   = 1 << 6;
    private static final int LEDS_RED1        = 1 << 0;
    /* P5.2 - Green (middle) led */
    private static final int LEDS_CONF_GREEN  = 1 << 4;
    private static final int LEDS_GREEN       = 1 << 1;
    /* P2.4 - Red (right) led */
    private static final int LEDS_CONF_RED2   = 1 << 2;
    private static final int LEDS_RED2        = 1 << 2;

    private static final int[] LEDS = { 0xff2020, 0x20ff20, 0xff2020 };

    //private M25P80 flash;
    //private String flashFile;
    private CC2520 radio;
    private Leds leds;
    private Button button;
    private WismoteGui gui;
    private DS2411 ds2411;

    public WismoteNode() {
        super("Wismote", new MSP430f5437Config());
    }

    public Leds getLeds() {
        return leds;
    }

    public Button getButton() {
        return button;
    }

//    public M25P80 getFlash() {
//        return flash;
//    }

//    public void setFlash(M25P80 flash) {
//        this.flash = flash;
//        registry.registerComponent("xmem", flash);
//    }

    public void dataReceived(USARTSource source, int data) {
        radio.dataReceived(source, data);
        //flash.dataReceived(source, data);
        /* if nothing selected, just write back a random byte to these devs */
        if (!radio.getChipSelect() /*&& !flash.getChipSelect()*/) {
            source.byteReceived(0);
        }
    }

    public void portWrite(IOPort source, int data) {
        switch (source.getPort()) {
        case 1:
            ds2411.dataPin((data & DS2411_DATA) != 0);
            break;
        case 2:
            leds.setLeds(LEDS_GREEN, (data & LEDS_CONF_GREEN) == 0 && (source.getDirection() & LEDS_CONF_GREEN) != 0);
            break;
        case 3:
            // Chip select = active low...
            radio.setChipSelect((data & CC2520_CHIP_SELECT) == 0);
            break;
        case 4:
            //radio.portWrite(source, data);
            //flash.portWrite(source, data);
            radio.setVRegOn((data & CC2520_VREG) != 0);
            break;
        case 5:
            leds.setLeds(LEDS_RED2, (data & LEDS_CONF_RED2) == 0 && (source.getDirection() & LEDS_CONF_RED2) != 0);
            break;
        case 8:
            leds.setLeds(LEDS_RED1, (data & LEDS_CONF_RED1) == 0 && (source.getDirection() & LEDS_CONF_RED1) != 0);
            break;
        }
    }

    private void setupNodePorts() {
//        if (flashFile != null) {
//            setFlash(new FileM25P80(cpu, flashFile));
//        }
        ds2411 = new DS2411(cpu);

        IOPort port1 = cpu.getIOUnit(IOPort.class, "P1");
        port1.addPortListener(this);
        ds2411.setDataPort(port1, DS2411_DATA_PIN);

        IOPort port2 = cpu.getIOUnit(IOPort.class, "P2");
        port2.addPortListener(this);
        cpu.getIOUnit(IOPort.class, "P3").addPortListener(this);
        cpu.getIOUnit(IOPort.class, "P4").addPortListener(this);
        cpu.getIOUnit(IOPort.class, "P5").addPortListener(this);
        cpu.getIOUnit(IOPort.class, "P8").addPortListener(this);

        IOUnit usart0 = cpu.getIOUnit("USCI B0");
        if (usart0 instanceof USARTSource) {

            radio = new CC2520(cpu);
            radio.setGPIO(1, port1, CC2520_FIFO);
            radio.setGPIO(3, port1, CC2520_CCA);
            radio.setGPIO(2, port1, CC2520_FIFOP);
            radio.setGPIO(4, port2, CC2520_SFD);

            ((USARTSource) usart0).addUSARTListener(this);
        } else {
            throw new EmulationException("Could not setup wismote mote - missing USCI B0");
        }
        leds = new Leds(cpu, LEDS);
        button = new Button("Button", cpu, port1, BUTTON_PIN, true);

        IOUnit usart = cpu.getIOUnit("USCI A1");
        if (usart instanceof USARTSource) {
            registry.registerComponent("serialio", usart);
        }
    }

    public void setupNode() {
        // create a filename for the flash file
        // This should be possible to take from a config file later!
        String fileName = config.getProperty("flashfile");
        if (fileName == null) {
            fileName = firmwareFile;
            if (fileName != null) {
                int ix = fileName.lastIndexOf('.');
                if (ix > 0) {
                    fileName = fileName.substring(0, ix);
                }
                fileName = fileName + ".flash";
            }
        }
        if (DEBUG) System.out.println("Using flash file: " + (fileName == null ? "no file" : fileName));

        //this.flashFile = fileName;

        setupNodePorts();

        if (!config.getPropertyAsBoolean("nogui", true)) {
            setupGUI();

            // Add some windows for listening to serial output
            IOUnit usart = cpu.getIOUnit("USCI A1");
            if (usart instanceof USARTSource) {
                SerialMon serial = new SerialMon((USARTSource)usart, "USCI A1 Port Output");
                registry.registerComponent("serialgui", serial);
            }
        }
    }

    public void setupGUI() {
        if (gui == null) {
            gui = new WismoteGui(this);
            registry.registerComponent("nodegui", gui);
        }
    }

    public int getModeMax() {
        return 0;
    }

    public static void main(String[] args) throws IOException {
        WismoteNode node = new WismoteNode();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/wismote/WismoteGui.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 */

package se.sics.mspsim.platform.wismote;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.platform.AbstractNodeGUI;

/**
 * @author Niclas Finne
 */
public class WismoteGui extends AbstractNodeGUI {

    private static final long serialVersionUID = -8713047619139235630L;
    private static final int RED1_X = 172;
    private static final int GREEN_X = 182;
    private static final int RED2_X = 192;
    private static final int LED_Y = 40;
    private static final int LED_HEIGHT = 11;
    private static final int LED_WIDTH = 7;

    private static final Color GREEN_TRANS = new Color(0x40, 0xf0, 0x40, 0xa0);
    private static final Color RED_TRANS = new Color(0xf0, 0x40, 0x40, 0xa0);

    private static final Color GREEN_C = new Color(0xff60ff60);
    private static final Color RED_C = new Color(0xffff8000);

    private static final Color BUTTON_C = new Color(0x60ffffff);

    private static final Rectangle LEDS_BOUNDS = new Rectangle(RED1_X - 2,
            LED_Y - 1, RED2_X - RED1_X + LED_HEIGHT, LED_WIDTH);

    private final WismoteNode node;
    private final StateChangeListener ledsListener = new StateChangeListener() {
        public void stateChanged(Object source, int oldState, int newState) {
            repaint(LEDS_BOUNDS);
        }
    };
    private boolean buttonDown = false;
    private boolean resetDown = false;

    public WismoteGui(WismoteNode node) {
        super("WismoteGui", "images/wismote.jpg");
        this.node = node;
    }

    protected void startGUI() {
        MouseAdapter mouseHandler = new MouseAdapter() {

            // For the button sensor and reset button on the Sky nodes.
            public void mousePressed(MouseEvent e) {
                int x = e.getX();
                int y = e.getY();
                if (x > 6 && x < 19) {
                    if (y > 236 && y < 251) {
                        buttonDown = true;
                        WismoteGui.this.node.getButton().setPressed(true);
                        repaint(7, 237, 11, 13);
                    } else if (y > 268 && y < 282) {
                        resetDown = true;
                        repaint(7, 269, 11, 13);
                    }
                }
            }

            public void mouseReleased(MouseEvent e) {
                if (buttonDown) {
                    buttonDown = false;
                    WismoteGui.this.node.getButton().setPressed(false);
                    repaint(7, 237, 11, 13);

                } else if (resetDown) {
                    int x = e.getX();
                    int y = e.getY();
                    resetDown = false;
                    repaint(7, 269, 11, 13);
                    if (x > 6 && x < 19 && y > 268 && y < 282) {
                        WismoteGui.this.node.getCPU().reset();
                    }
                }
            }
        };

        this.addMouseListener(mouseHandler);
        node.getLeds().addStateChangeListener(ledsListener);
    }

    protected void stopGUI() {
        node.getLeds().removeStateChangeListener(ledsListener);
    }

    protected void paintComponent(Graphics g) {
        Color old = g.getColor();

        super.paintComponent(g);

        // Display all active LEDs
        Leds leds = node.getLeds();
        int l = leds.getLeds();
        if ((l & 1) != 0) {
            g.setColor(RED_TRANS);
            g.fillOval(RED1_X - 2, LED_Y - 1, LED_HEIGHT, LED_WIDTH);
            g.setColor(RED_C);
            g.fillOval(RED1_X, LED_Y, LED_HEIGHT - 5, LED_WIDTH - 2);
        }
        if ((l & 2) != 0) {
            g.setColor(GREEN_TRANS);
            g.fillOval(GREEN_X - 2, LED_Y - 1, LED_HEIGHT, LED_WIDTH);
            g.setColor(GREEN_C);
            g.fillOval(GREEN_X, LED_Y, LED_HEIGHT - 5, LED_WIDTH - 2);
        }
        if ((l & 4) != 0) {
            g.setColor(RED_TRANS);
            g.fillOval(RED2_X - 2, LED_Y - 1, LED_HEIGHT, LED_WIDTH);
            g.setColor(RED_C);
            g.fillOval(RED2_X, LED_Y, LED_HEIGHT - 5, LED_WIDTH - 2);
        }

        if (buttonDown) {
            g.setColor(BUTTON_C);
            g.fillOval(8, 236, 9, 9);
        }
        if (resetDown) {
            g.setColor(BUTTON_C);
            g.fillOval(8, 271, 9, 9);
        }
        g.setColor(old);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/GenericNode.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 * -----------------------------------------------------------------
 *
 * GenericNode
 *
 * Author  : Joakim Eriksson
 */

package se.sics.mspsim.platform;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.net.URISyntaxException;
import java.net.URL;
import javax.swing.JFrame;
import se.sics.mspsim.cli.CommandHandler;
import se.sics.mspsim.cli.DebugCommands;
import se.sics.mspsim.cli.FileCommands;
import se.sics.mspsim.cli.MiscCommands;
import se.sics.mspsim.cli.NetCommands;
import se.sics.mspsim.cli.ProfilerCommands;
import se.sics.mspsim.cli.StreamCommandHandler;
import se.sics.mspsim.cli.WindowCommands;
import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.MSP430Config;
import se.sics.mspsim.core.MSP430Constants;
import se.sics.mspsim.extutil.highlight.HighlightSourceViewer;
import se.sics.mspsim.ui.ConsoleUI;
import se.sics.mspsim.ui.ControlUI;
import se.sics.mspsim.ui.JFrameWindowManager;
import se.sics.mspsim.ui.StackUI;
import se.sics.mspsim.ui.WindowUtils;
import se.sics.mspsim.util.ArgumentManager;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.ConfigManager;
import se.sics.mspsim.util.ELF;
import se.sics.mspsim.util.IHexReader;
import se.sics.mspsim.util.MapTable;
import se.sics.mspsim.util.OperatingModeStatistics;
import se.sics.mspsim.util.PluginRepository;
import se.sics.mspsim.util.StatCommands;

public abstract class GenericNode extends Chip implements Runnable {

  private static final String PROMPT = "MSPSim>";

  protected final MSP430 cpu;
  protected final ComponentRegistry registry;
  protected ConfigManager config;

  protected String firmwareFile = null;
  protected ELF elf;
  protected OperatingModeStatistics stats;


  public GenericNode(String id, MSP430Config config) {
    super(id, new MSP430(0, new ComponentRegistry(), config));
    this.cpu = (MSP430)super.cpu;
    this.registry = cpu.getRegistry();
  }

  public ComponentRegistry getRegistry() {
    return registry;
  }

  public MSP430 getCPU() {
    return cpu;
  }

  public abstract void setupNode();

  public void setCommandHandler(CommandHandler handler) {
    registry.registerComponent("commandHandler", handler);
  }

  public void setupArgs(ArgumentManager config) throws IOException {
    String[] args = config.getArguments();
    if (args.length == 0) {
      System.err.println("Usage: " + getClass().getName() + " <firmware>");
      System.exit(1);
    }
    firmwareFile = args[0];
    if (!(new File(firmwareFile)).exists()) {
      System.err.println("Could not find the firmware file '" + firmwareFile + "'.");
      System.exit(1);
    }
    if (config.getProperty("nogui") == null) {
      config.setProperty("nogui", "false");
    }
    /* Ensure auto-run of a start script */
    if (config.getProperty("autorun") == null) {
      File fp = new File("scripts/autorun.sc");
      if (fp.exists()) {
        config.setProperty("autorun", "scripts/autorun.sc");
      } else {
        try {
          File dir = new File(GenericNode.class.getProtectionDomain().getCodeSource().getLocation().toURI()).getParentFile();
          fp = new File(dir, "scripts/autorun.sc");
          if (fp.exists()) {
            config.setProperty("autorun", fp.getAbsolutePath());
          }
        } catch (URISyntaxException e) {
          // Failed to find auto run script
        }
      }
    }

    if (firmwareFile.endsWith("ihex")) {
      // IHEX Reading
      int[] memory = cpu.memory;
      IHexReader reader = new IHexReader();
      reader.readFile(memory, firmwareFile);
    } else {
      loadFirmware(firmwareFile);
    }
    config.setProperty("firmwareFile", firmwareFile);

    String mapFile = config.getProperty("map");
    if (mapFile != null) {
      MapTable map = new MapTable(mapFile);
      cpu.getDisAsm().setMap(map);
      cpu.setMap(map);
      registry.registerComponent("mapTable", map);
    }
    
    setup(config);


    if (!config.getPropertyAsBoolean("nogui", false)) {
      // Setup control and other UI components
      ControlUI control = new ControlUI();
      registry.registerComponent("controlgui", control);
      registry.registerComponent("stackchart", new StackUI(cpu));
      HighlightSourceViewer sourceViewer = new HighlightSourceViewer();
      // Add the firmware location to the search path
      File fp = new File(firmwareFile).getParentFile();
      if (fp != null) {
          try {
              // Get absolute path
              fp = fp.getCanonicalFile();
          } catch (Exception e) {
              // Ignore
          }
          sourceViewer.addSearchPath(fp);
      }
      control.setSourceViewer(sourceViewer);
    }

    String script = config.getProperty("autorun");
    if (script != null) {
      File fp = new File(script);
      if (fp.canRead()) {
        CommandHandler ch = registry.getComponent(CommandHandler.class, "commandHandler");
        script = script.replace('\\', '/');
        System.out.println("Autoloading script: " + script);
        config.setProperty("autoloadScript", script);
        if (ch != null) {
          ch.lineRead("source \"" + script + '"');
        }
      }
    }

    if (args.length > 1) {
        // Run the following arguments as commands
        CommandHandler ch = registry.getComponent(CommandHandler.class, "commandHandler");
        if (ch != null) {
            for (int i = 1; i < args.length; i++) {
                System.out.println("calling '" + args[i] + "'");
                ch.lineRead(args[i]);
            }
        }
    }
    System.out.println("-----------------------------------------------");
    System.out.println("MSPSim " + MSP430Constants.VERSION + " starting firmware: " + firmwareFile);
    System.out.println("-----------------------------------------------");
    System.out.print(PROMPT);
    System.out.flush();
  }

  public void setup(ConfigManager config) {
    this.config = config;

    registry.registerComponent("cpu", cpu);
    registry.registerComponent("node", this);
    registry.registerComponent("config", config);
    
    CommandHandler ch = registry.getComponent(CommandHandler.class, "commandHandler");

    if (ch == null && config.getPropertyAsBoolean("cli", true)) {
        if (config.getPropertyAsBoolean("jconsole", false)) {
            ConsoleUI console = new ConsoleUI();
            PrintStream consoleStream = new PrintStream(console.getOutputStream());
            ch = new CommandHandler(consoleStream, consoleStream);
            JFrame w = new JFrame("ConsoleUI");
            w.add(console);
            w.setBounds(20, 20, 520, 400);
            w.setLocationByPlatform(true);
            String key = "console";
            WindowUtils.restoreWindowBounds(key, w);
            WindowUtils.addSaveOnShutdown(key, w);
            w.setVisible(true);
            console.setCommandHandler(ch);
        } else {
            ch = new StreamCommandHandler(System.in, System.out, System.err, PROMPT);
        }
        registry.registerComponent("commandHandler", ch);
    }
    
    stats = new OperatingModeStatistics(cpu);
    
    registry.registerComponent("pluginRepository", new PluginRepository());
    registry.registerComponent("debugcmd", new DebugCommands());
    registry.registerComponent("misccmd", new MiscCommands());
    registry.registerComponent("filecmd", new FileCommands());
    registry.registerComponent("statcmd", new StatCommands(cpu, stats));
    registry.registerComponent("wincmd", new WindowCommands());
    registry.registerComponent("profilecmd", new ProfilerCommands());
    registry.registerComponent("netcmd", new NetCommands());
    registry.registerComponent("windowManager", new JFrameWindowManager());

    // Monitor execution
    cpu.setMonitorExec(true);
    
    setupNode();

    registry.start();

    cpu.reset();
  }
  
 
  public void run() {
    if (!cpu.isRunning()) {
      try {
        cpu.cpuloop(); 
      } catch (Exception e) {
        /* what should we do here */
        e.printStackTrace();
      }
    }
  }
  
  public void start() {
    if (!cpu.isRunning()) {
      Thread thread = new Thread(this);
      // Set this thread to normal priority in case the start method was called
      // from the higher priority AWT thread.
      thread.setPriority(Thread.NORM_PRIORITY);
      thread.start();
    }
  }
  
  public void stop() {
    cpu.stop();
  }

  public void step() throws EmulationException {
    step(1);
  }

  // A step that will break out of breakpoints!
  public void step(int nr) throws EmulationException {
    if (!cpu.isRunning()) {
      cpu.stepInstructions(nr);
    }
  }

  public ELF loadFirmware(URL url) throws IOException {
    DataInputStream inputStream = new DataInputStream(url.openStream());
    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
    byte[] firmwareData = new byte[2048];
    int read;
    while ((read = inputStream.read(firmwareData)) != -1) {
      byteStream.write(firmwareData, 0, read);
    }
    inputStream.close();
    ELF elf = new ELF(byteStream.toByteArray());
    elf.readAll();
    return loadFirmware(elf);
  }

  public ELF loadFirmware(String name) throws IOException {
    return loadFirmware(ELF.readELF(firmwareFile = name));
  }

  public ELF loadFirmware(ELF elf) {
    if (cpu.isRunning()) {
        stop();
    }
    this.elf = elf;
    elf.loadPrograms(cpu.memory);
    MapTable map = elf.getMap();
    cpu.getDisAsm().setMap(map);
    cpu.setMap(map);
    registry.registerComponent("elf", elf);
    registry.registerComponent("mapTable", map);
    return elf;
  }

  public int getConfiguration(int param) {
      return 0;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sentillausb/SentillaUSBNode.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * JCreateNode
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 7 jul 2010
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform.sentillausb;
import java.io.IOException;
import se.sics.mspsim.chip.FileStorage;
import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.chip.M25P80;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.sky.CC2420Node;
import se.sics.mspsim.util.ArgumentManager;

/**
 * Emulation of Sentilla Gateway USB Mote
 */
public class SentillaUSBNode extends CC2420Node {

    public static final int MODE_LEDS_OFF = 0;
    public static final int MODE_LEDS_1 = 1;
    public static final int MODE_LEDS_2 = 2;
    public static final int MODE_MAX = MODE_LEDS_2;

    private static final int[] LEDS = { 0xff2020, 0x40ff40 };
    public static final int GREEN_LED = 0x20;
    public static final int RED_LED = 0x10;

    private M25P80 flash;
    private SentillaUSBGui gui;

    private Leds leds;
    boolean redLed;
    boolean greenLed;

    public SentillaUSBNode() {
        super("Sentilla USB");
        setMode(MODE_LEDS_OFF);
    }

    public Leds getLeds() {
        return leds;
    }

    public M25P80 getFlash() {
        return flash;
    }

    public void setFlash(M25P80 flash) {
        this.flash = flash;
        registry.registerComponent("xmem", flash);
    }

    // USART Listener
    @Override
    public void dataReceived(USARTSource source, int data) {
        radio.dataReceived(source, data);
        flash.dataReceived(source, data);
        /* if nothing selected, just write back a random byte to this device */
        if (!radio.getChipSelect() && !flash.getChipSelect()) {
            source.byteReceived(0);
        }
    }

    @Override
    protected void flashWrite(IOPort source, int data) {
        flash.portWrite(source, data);
    }

    @Override
    public void setupNodePorts() {
        super.setupNodePorts();
        leds = new Leds(cpu, LEDS);
        if (getFlash() == null) {
            setFlash(new M25P80(cpu));
        }
        if (flashFile != null) {
            getFlash().setStorage(new FileStorage(flashFile));
        }
    }

    public void setupGUI() {
        if (gui == null) {
            gui = new SentillaUSBGui(this);
            registry.registerComponent("nodegui", gui);
        }
    }

    @Override
    public void portWrite(IOPort source, int data) {
        super.portWrite(source, data);

        if (source == port5) {
            redLed = (data & RED_LED) == 0;
            greenLed = (data & GREEN_LED) == 0;
            leds.setLeds((redLed ? 1 : 0) + (greenLed ? 2 : 0));
            int newMode = (redLed ? 1 : 0) + (greenLed ? 1 : 0);
            setMode(newMode);
        }
    }

    @Override
    public int getModeMax() {
        return MODE_MAX;
    }

    public static void main(String[] args) throws IOException {
        SentillaUSBNode node = new SentillaUSBNode();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sentillausb/SentillaUSBGui.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SentillaUSBGui
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 7 jul 2010
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform.sentillausb;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;

import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.platform.AbstractNodeGUI;

public class SentillaUSBGui extends AbstractNodeGUI {

    private static final long serialVersionUID = -692114865639672141L;

    private static final Color[] RED = new Color[] {
        new Color(0xff, 0x40, 0x40, 0xa0),
        new Color(0xff,0x40,0x40,0xff),
        new Color(0xff,0x60,0x60,0xff),
        new Color(0xff,0xa0,0xa0,0xff)
    };
    private static final Color[] GREEN = new Color[] {
        new Color(0x40, 0xff, 0x40, 0xa0),
        new Color(0x40,0xff,0x40,0xff),
        new Color(0x60,0xff,0x60,0xff),
        new Color(0xa0,0xff,0xa0,0xff)
    };

    private static final int LEDS_GREEN_X = 8;
    private static final int LEDS_RED_X = 126;
    private static final int LEDS_Y = 89;

    private static final Rectangle LEDS_CLIP =
        new Rectangle(LEDS_GREEN_X, LEDS_Y, LEDS_RED_X + 10 - LEDS_GREEN_X, 13);

    private final SentillaUSBNode node;
    private final StateChangeListener ledsListener = new StateChangeListener() {
        public void stateChanged(Object source, int oldState, int newState) {
            repaint(LEDS_CLIP);
        }
    };

    public SentillaUSBGui(SentillaUSBNode node) {
        super("SentillaUSBGui", "images/sentilla-usb.jpg");
        this.node = node;
    }

    @Override
    protected void startGUI() {
        node.getLeds().addStateChangeListener(ledsListener);
    }

    @Override
    protected void stopGUI() {
        node.getLeds().removeStateChangeListener(ledsListener);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        Color old = g.getColor();
        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,
            RenderingHints.VALUE_ANTIALIAS_ON);
        if (node.greenLed) {
            paintLed(g, LEDS_GREEN_X, GREEN);
        }
        if (node.redLed) {
            paintLed(g, LEDS_RED_X, RED);
        }
        g.setColor(old);
    }

    protected void paintLed(Graphics g, int x, Color[] colors) {
        g.setColor(colors[0]);
        g.fillOval(x, LEDS_Y, 10, 13);
        g.setColor(colors[1]);
        g.fillOval(x + 2, LEDS_Y + 2, 6, 7);
        g.setColor(colors[2]);
        g.fillOval(x + 3, LEDS_Y + 3, 4, 5);
        g.setColor(colors[3]);
        g.fillRect(x + 3, LEDS_Y + 3, 2, 2);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/jcreate/JCreateNode.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * JCreateNode
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 7 jul 2010
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform.jcreate;
import java.io.IOException;
import se.sics.mspsim.chip.FileStorage;
import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.chip.M25P80;
import se.sics.mspsim.chip.MMA7260QT;
import se.sics.mspsim.core.ADC12;
import se.sics.mspsim.core.ADCInput;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.sky.CC2420Node;
import se.sics.mspsim.util.ArgumentManager;

/**
 * Emulation of Sentilla JCreate Mote
 */
public class JCreateNode extends CC2420Node {

    public static final int MODE_LEDS_OFF = 0;
    public static final int MODE_MAX = 9;

    private static final int[] LEDS = {
        0xff2020, 0xff2020, 0xff2020, 0xff2020,
        0xff2020, 0xff2020, 0xff2020, 0xff2020
    };

    private Leds leds;
    private MMA7260QT accelerometer;
    private M25P80 flash;

    private JCreateGui gui;

    public JCreateNode() {
        super("Sentilla JCreate");
        setMode(MODE_LEDS_OFF);
    }

    public Leds getLeds() {
        return leds;
    }

    public MMA7260QT getAccelerometer() {
        return accelerometer;
    }

    public M25P80 getFlash() {
        return flash;
    }

    public void setFlash(M25P80 flash) {
        this.flash = flash;
        registry.registerComponent("xmem", flash);
    }

    // USART Listener
    @Override
    public void dataReceived(USARTSource source, int data) {
        radio.dataReceived(source, data);
        flash.dataReceived(source, data);
        /* if nothing selected, just write back a random byte to this device */
        if (!radio.getChipSelect() && !flash.getChipSelect()) {
            source.byteReceived(0);
        }
    }

    @Override
    protected void flashWrite(IOPort source, int data) {
        flash.portWrite(source, data);
    }

    @Override
    public void setupNodePorts() {
        super.setupNodePorts();
        leds = new Leds(cpu, LEDS);
        accelerometer = new MMA7260QT(cpu);
        ADC12 adc = cpu.getIOUnit(ADC12.class, "ADC12");
        adc.setADCInput(4, new ADCInput() {
            public int nextData() {
                return accelerometer.getADCX();
            }
        });
        adc.setADCInput(5, new ADCInput() {
            public int nextData() {
                return accelerometer.getADCY();
            }
        });
        adc.setADCInput(6, new ADCInput() {
            public int nextData() {
                return accelerometer.getADCZ();
            }
        });

        if (getFlash() == null) {
            setFlash(new M25P80(cpu));
        }
        if (flashFile != null) {
            getFlash().setStorage(new FileStorage(flashFile));
        }
    }

    public void setupGUI() {
        if (gui == null) {
            gui = new JCreateGui(this);
            registry.registerComponent("nodegui", gui);
        }
    }

    @Override
    public void portWrite(IOPort source, int data) {
        super.portWrite(source, data);

        if (source == port5) {
            if (leds.getLeds() != (~data & 0xff)) {
                leds.setLeds(~data & 0xff);

                int newMode = 0;
                for (int i = 0; i < 8; i++) {
                    if ((data & (1 << i)) != 0) {
                        newMode++;
                    }
                }
                setMode(newMode);
            }
        } else if (source == port2) {
            int out = source.getOut() & source.getDirection();
            if ((out & 0x08) == 0x08) {
                accelerometer.setMode(MMA7260QT.MODE_ACTIVE);
            } else {
                accelerometer.setMode(MMA7260QT.MODE_SLEEP);
            }
            accelerometer.setSensitivity(out & 0x03);
        }
      }

    @Override
    public int getModeMax() {
        return MODE_MAX;
    }

    public static void main(String[] args) throws IOException {
        JCreateNode node = new JCreateNode();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/jcreate/JCreateGui.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * JCreateGui
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 7 jul 2010
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform.jcreate;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Rectangle;
import java.awt.RenderingHints;

import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.platform.AbstractNodeGUI;

public class JCreateGui extends AbstractNodeGUI {

    private static final long serialVersionUID = -1377998375300964966L;

    private static final Color RED_TRANS = new Color(0xff, 0x40, 0x40, 0xa0);
    private static final Color RED_O = new Color(0xff,0x40,0x40,0xff);
    private static final Color RED_I = new Color(0xff,0x60,0x60,0xff);
    private static final Color RED_CORE = new Color(0xff,0xa0,0xa0,0xff);

    private static final int LEDS_Y = 66;
    private static final int LEDS_X[] = {29, 49, 67, 86, 103, 122, 142, 162};
    private static final Rectangle LEDS_CLIP = new Rectangle(LEDS_X[0], LEDS_Y,
        LEDS_X[LEDS_X.length - 1] + 10 - LEDS_X[0], 10);

    private final JCreateNode node;
    private final StateChangeListener ledsListener = new StateChangeListener() {
        public void stateChanged(Object source, int oldState, int newState) {
            repaint(LEDS_CLIP);
        }
    };

    public JCreateGui(JCreateNode node) {
        super("JCreateGui", "images/jcreate.jpg");
        this.node = node;
    }

    @Override
    protected void startGUI() {
        node.getLeds().addStateChangeListener(ledsListener);
    }

    @Override
    protected void stopGUI() {
        node.getLeds().removeStateChangeListener(ledsListener);
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        Color old = g.getColor();
        // Display all active leds
        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,
            RenderingHints.VALUE_ANTIALIAS_ON);
        int leds = node.getLeds().getLeds();
        for (int i = 0; i < 8; i++) {
            if ((leds & (0x80 >> i)) != 0) {
                paintLed(g, i);
            }
        }
        g.setColor(old);
    }

    protected void paintLed(Graphics g, int led) {
        int x = LEDS_X[led];
        g.setColor(RED_TRANS);
        g.fillOval(x, LEDS_Y, 10, 10);
        g.setColor(RED_O);
        g.fillOval(x + 2, LEDS_Y + 2, 6, 6);
        g.setColor(RED_I);
        g.fillOval(x + 3, LEDS_Y + 3, 4, 4);
        g.setColor(RED_CORE);
        g.fillRect(x + 3, LEDS_Y + 3, 2, 2);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/esb/ESBGui.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ESBGui
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.platform.esb;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;

import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.TargetDataLine;

import se.sics.mspsim.core.ADC12;
import se.sics.mspsim.core.ADCInput;
import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.platform.AbstractNodeGUI;

public class ESBGui extends AbstractNodeGUI implements ADCInput {

  private static final long serialVersionUID = -139331418649524704L;

  public static final int GREEN_X = 2;
  public static final int YELLOW_X = 9;
  public static final int RED_X = 16;
  public static final int LED_Y = 4;
  private static final Rectangle LED_BOUNDS = new Rectangle(GREEN_X - 1, LED_Y - 3, RED_X - GREEN_X + 6, 9);

  public static final Color RED_TRANS = new Color(0xff,0x40,0x40,0xa0);
  public static final Color YELLOW_TRANS = new Color(0xff, 0xff, 0x00, 0xa0);
  public static final Color GREEN_TRANS = new Color(0x40, 0xf0, 0x40, 0xa0);

  public static final Color RED_C = new Color(0xffff6060);
  public static final Color YELLOW_C = new Color(0xffffff00);
  public static final Color GREEN_C = new Color(0xff40ff40);

  private static final float SAMPLE_RATE = 22050;
  private static final int DL_BUFFER_SIZE = 2200;

  private MouseMotionAdapter mouseMotionListener;
  private MouseAdapter mouseListener;

  private final ESBNode node;
  private final StateChangeListener ledsListener = new StateChangeListener() {
      public void stateChanged(Object source, int oldState, int newState) {
          repaint(LED_BOUNDS);
      }
  };
  private boolean buttonDown = false;
  private boolean resetDown = false;

  private TargetDataLine inDataLine;

  public ESBGui(ESBNode esbNode) {
      super("ESBGui", "images/esb.jpg");
      this.node = esbNode;
  }

  @Override
  protected void startGUI() {
    mouseMotionListener = new MouseMotionAdapter() {
      public void mouseMoved(MouseEvent e) {
        //    System.out.println("Mouse moved: " + e.getX() + "," + e.getY());
        int x = e.getX();
        int y = e.getY();
        node.setPIR(x > 18 && x < 80 && y > 35 && y < 100);
        node.setVIB(x > 62 && x < 95 && y > 160 && y < 178);
      }
    };
    addMouseMotionListener(mouseMotionListener);

    mouseListener = new MouseAdapter() {
      // For the button sensor on the ESB nodes.
      public void mousePressed(MouseEvent e) {
        if (e.getButton() == MouseEvent.BUTTON1) {
          int x = e.getX();
          int y = e.getY();
//        System.err.println("PRESSED AT " + x + "," + y
//                + "  IMAGE=" + getNodeImage().getIconWidth()
//                + "x" + getNodeImage().getIconHeight() +
//                "  SIZE=" + getWidth() + "x" + getHeight());

          if (y > 152 && y < 168) {
            if (x > 0 && x < 19) {
              buttonDown = true;
              node.getButton().setPressed(true);
            } else {
              int w = getNodeImage().getIconWidth();
              if (x > w - 20 && x < w) {
                resetDown = true;
              }
            }
          }
        }
      }

      public void mouseReleased(MouseEvent e) {
        if (e.getButton() == MouseEvent.BUTTON1) {
          if (buttonDown) {
            buttonDown = false;
            node.getButton().setPressed(false);
          } else if (resetDown) {
            int x = e.getX();
            int y = e.getY();
            if (y > 152 && y < 168) {
              int w = getNodeImage().getIconWidth();
              if (x > w - 20 && x < w) {
                node.getCPU().reset();
              }
            }
            resetDown = false;
          }
        }
      }
    };
    addMouseListener(mouseListener);

    node.getLeds().addStateChangeListener(ledsListener);

    ADC12 adc = node.getCPU().getIOUnit(ADC12.class, "ADC12");
    if (adc != null) {
      adc.setADCInput(0, this);
    }

    // Just a test... TODO: remove!!!
    try {
      AudioFormat af = new AudioFormat(SAMPLE_RATE, 16, 1, true, false);
      DataLine.Info dlin =
          new DataLine.Info(TargetDataLine.class, af, DL_BUFFER_SIZE);
      inDataLine = (TargetDataLine) AudioSystem.getLine(dlin);

      if (inDataLine == null) {
        System.out.println("No input dataline");
      } else {
        System.out.println("Format: " + inDataLine.getFormat());
        inDataLine.open(inDataLine.getFormat(), DL_BUFFER_SIZE);
        inDataLine.start();
      }
    } catch (Exception e) {
      System.err.println("Failed to get audio data line: " + e.getMessage());
    }
  }

  @Override
  protected void stopGUI() {
      removeMouseMotionListener(mouseMotionListener);
      removeMouseListener(mouseListener);
      node.getLeds().removeStateChangeListener(ledsListener);

      // TODO cleanup
  }

  private byte[] data = new byte[4];
  public int nextData() {
    if (inDataLine != null) {
      inDataLine.read(data, 0, 4);
    }
    //System.out.println("sampled: " + ((data[1] << 8) + data[0]));
    return (((data[1] & 0xff) << 8) | data[0] & 0xff) >> 4;
  }
  
  protected void paintComponent(Graphics g) {
    super.paintComponent(g);

    // Display all active leds
    Color old = g.getColor();
    if (node.greenLed) {
      g.setColor(GREEN_TRANS);
      g.fillOval(GREEN_X - 1, LED_Y - 3, 5, 9);
      g.setColor(GREEN_C);
      g.fillOval(GREEN_X, LED_Y, 3, 4);
    }
    if (node.redLed) {
      g.setColor(RED_TRANS);
      g.fillOval(RED_X - 1, LED_Y - 3, 5, 9);
      g.setColor(RED_C);
      g.fillOval(RED_X, LED_Y, 3, 4);
    }
    if (node.yellowLed) {
      g.setColor(YELLOW_TRANS);
      g.fillOval(YELLOW_X - 1, LED_Y - 3, 5, 9);
      g.setColor(YELLOW_C);
      g.fillOval(YELLOW_X, LED_Y, 3, 4);
    }
    g.setColor(old);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/esb/ESBNode.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ESBNode
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.platform.esb;
import java.io.IOException;

import se.sics.mspsim.chip.Beeper;
import se.sics.mspsim.chip.Button;
import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.chip.TR1001;
import se.sics.mspsim.config.MSP430f149Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USART;
import se.sics.mspsim.extutil.jfreechart.DataChart;
import se.sics.mspsim.extutil.jfreechart.DataSourceSampler;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;
import se.sics.mspsim.util.OperatingModeStatistics;

public class ESBNode extends GenericNode implements PortListener {

  public static final int PIR_PIN = 3;
  public static final int VIB_PIN = 4;
  // Port 2.
  public static final int BUTTON_PIN = 7;

  private IOPort port1;
  private IOPort port2;
  private IOPort port5;

  private static final int[] LEDS = { 0xff2020, 0xffff00, 0x40ff40 };
  public static final int RED_LED = 0x01;
  public static final int GREEN_LED = 0x02;
  public static final int YELLOW_LED = 0x04;
  public static final int BEEPER = 0x08;

  private Leds leds;
  public boolean redLed;
  public boolean greenLed;
  public boolean yellowLed;

  private Button button;

  private TR1001 radio;
  private Beeper beeper;
  private ESBGui gui;

  /**
   * Creates a new <code>ESBNode</code> instance.
   *
   */
  public ESBNode() {
      super("ESB", new MSP430f149Config());
  }

  public Leds getLeds() {
      return leds;
  }

  public Button getButton() {
      return button;
  }

  public Beeper getBeeper() {
      return beeper;
  }

  public void setPIR(boolean hi) {
    port1.setPinState(PIR_PIN, hi ? IOPort.PinState.HI : IOPort.PinState.LOW);
  }

  public void setVIB(boolean hi) {
    port1.setPinState(VIB_PIN, hi ? IOPort.PinState.HI : IOPort.PinState.LOW);
  }

  @Deprecated
  public void setButton(boolean buttonPressed) {
      button.setPressed(buttonPressed);
  }

  public boolean getDebug() {
    return cpu.getDebug();
  }
  public void setDebug(boolean debug) {
    cpu.setDebug(debug);
  }

  public void portWrite(IOPort source, int data) {
    //    System.out.println("ESB: Writing to port: " + data);
    if (source == port2) {
//       System.out.println("ESBNode.PORT2: 0x" + Integer.toString(data,16));
      redLed = (data & RED_LED) == 0;
      greenLed = (data & GREEN_LED) == 0;
      yellowLed = (data & YELLOW_LED) == 0;
      leds.setLeds((greenLed ? 4 : 0) + (yellowLed ? 2 : 0) + (redLed ? 1 : 0));
      beeper.beepOn((data & BEEPER) != 0);

    } else if (source == port5) {
      if ((data & 0xc0) == 0xc0) {
        radio.setMode(TR1001.MODE_RX_ON);
      } else if ((data & 0xc0) == 0x40) {
        radio.setMode(TR1001.MODE_TXRX_ON);
      } else {
        radio.setMode(TR1001.MODE_TXRX_OFF);
      }
    }
  }

  public void setupNodePorts() {
    port1 = cpu.getIOUnit(IOPort.class, "P1");

    port2 = cpu.getIOUnit(IOPort.class, "P2");
    port2.addPortListener(this);
    port5 = cpu.getIOUnit(IOPort.class, "P5");
    port5.addPortListener(this);

    USART usart0 = cpu.getIOUnit(USART.class, "USART0");
    if (usart0 == null) {
        throw new EmulationException("Could not setup mote - missing USART0");
    }
    radio = new TR1001(cpu, usart0);

    leds = new Leds(cpu, LEDS);
    button = new Button("Button", cpu, port2, BUTTON_PIN, true);
    beeper = new Beeper(cpu);

    USART usart = cpu.getIOUnit(USART.class, "USART1");
    if (usart != null) {
        registry.registerComponent("serialio", usart);
    }
  }

  public void setupNode() {
    setupNodePorts();

    if (stats != null) {
      stats.addMonitor(this);
      stats.addMonitor(radio);
      stats.addMonitor(cpu);
    }
    
    if (!config.getPropertyAsBoolean("nogui", true)) {
      setupGUI();

      beeper.setSoundEnabled(true);

      // Add some windows for listening to serial output
      USART usart = cpu.getIOUnit(USART.class, "USART1");
      if (usart != null) {
          SerialMon serial = new SerialMon(usart, "USART1 Port Output");
          registry.registerComponent("serialgui", serial);
      }

      if (stats != null) {
        // A HACK for some "graphs"!!!
        DataChart dataChart =  new DataChart(registry, "Duty Cycle", "Duty Cycle");
        registry.registerComponent("dutychart", dataChart);
        DataSourceSampler dss = dataChart.setupChipFrame(cpu);
        dataChart.addDataSource(dss, "LEDS", stats.getDataSource(getID(), 0, OperatingModeStatistics.OP_INVERT));
        dataChart.addDataSource(dss, "Listen", stats.getDataSource(radio.getID(), TR1001.MODE_RX_ON));
        dataChart.addDataSource(dss, "Transmit", stats.getDataSource(radio.getID(), TR1001.MODE_TXRX_ON));
        dataChart.addDataSource(dss, "CPU", stats.getDataSource(cpu.getID(), MSP430.MODE_ACTIVE));
      }
    }
  }

  public void setupGUI() {
    if (gui == null) {
      gui = new ESBGui(this);
      registry.registerComponent("nodegui", gui);
    }
  }

  public int getModeMax() {
    return 0;
  }

  public static void main(String[] args) throws IOException {
    ESBNode node = new ESBNode();
    ArgumentManager config = new ArgumentManager();
    config.handleArguments(args);
    node.setupArgs(config);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/ti/CC430Node.java`:

```java
package se.sics.mspsim.platform.ti;

import java.io.IOException;

import se.sics.mspsim.config.CC430f5137Config;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class CC430Node extends GenericNode implements PortListener, USARTListener {

    IOPort port1;
    IOPort port3;
    IOPort port4;
    IOPort port5;
    IOPort port7;
    IOPort port8;

    public CC430Node() {
    	/* TODO XXX MSP430F5438 */
        super("CC430", new CC430f5137Config());
    }

    public void dataReceived(USARTSource source, int data) {
    }

    public void portWrite(IOPort source, int data) {
        
    }

    private void setupNodePorts() {
        port1 = cpu.getIOUnit(IOPort.class, "P1");
        port1.addPortListener(this);
        port3 = cpu.getIOUnit(IOPort.class, "P3");
        port3.addPortListener(this);
        port4 = cpu.getIOUnit(IOPort.class, "P4");
        port4.addPortListener(this);
        port5 = cpu.getIOUnit(IOPort.class, "P5");
        port5.addPortListener(this);
        port7 = cpu.getIOUnit(IOPort.class, "P7");
        port7.addPortListener(this);
        port8 = cpu.getIOUnit(IOPort.class, "P8");
        port8.addPortListener(this);

        IOUnit usart0 = cpu.getIOUnit("USCI B0"); 
        if (usart0 instanceof USARTSource) {
            registry.registerComponent("serialio0", usart0);
        }
        
        IOUnit usart = cpu.getIOUnit("USCI A0");
        if (usart instanceof USARTSource) {
            registry.registerComponent("serialio", usart);
        }
    }

    public void setupNode() {
        setupNodePorts();

        if (!config.getPropertyAsBoolean("nogui", true)) {
            // Add some windows for listening to serial output
            IOUnit usart = cpu.getIOUnit("USCI A0");
            if (usart instanceof USARTSource) {
            	SerialMon serial = new SerialMon((USARTSource)usart, "USCI A0 Port Output");
            	registry.registerComponent("serialgui", serial);
            }
        }
    }

    public int getModeMax() {
        return 0;
    }

    public static void main(String[] args) throws IOException {
        CC430Node node = new CC430Node();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/ti/Exp5438Node.java`:

```java
package se.sics.mspsim.platform.ti;

import java.io.IOException;
import se.sics.mspsim.chip.CC2420;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class Exp5438Node extends GenericNode implements PortListener, USARTListener {

    public static final int CC2420_FIFOP = 6; // 1.6
    public static final int CC2420_FIFO = 5; // 1.5
    public static final int CC2420_CCA = 7; // 1.7
    public static final int CC2420_SFD = 3; // 1.3

    /* Output: VREG_EN to CC2420 */
    public static final int CC2420_VREG = (1 << 4); // 1.4
    /* Output: SPI Chip Select (CS_N) */
    public static final int CC2420_CHIP_SELECT = (1 << 0); // 3.0
    public static final int CC2420_RESET = (1 << 2); // 1.2

    IOPort port1;
    IOPort port3;
    IOPort port4;
    IOPort port5;
    IOPort port7;
    IOPort port8;

    public static final int LEDS_CONF_RED    = (1 << 0); // 1.0
    public static final int LEDS_CONF_YELLOW = (1 << 1); // 1.1

    public CC2420 radio;

    public Exp5438Node() {
    	/* TODO XXX MSP430F5438 */
        super("Exp5438", new MSP430f5437Config());
    }

    public void dataReceived(USARTSource source, int data) {
        radio.dataReceived(source, data);

        /* if nothing selected, just write back a random byte to these devs */
        if (!radio.getChipSelect()) {
            source.byteReceived(0);
        }
    }

    public void portWrite(IOPort source, int data) {
        if (source == port3) {
            // Chip select = active low...
            radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
        }
        if (source == port1) {
            radio.setVRegOn((data & CC2420_VREG) != 0);
            //System.out.println("Red led: " + ((data & LEDS_CONF_RED) > 0));
            //System.out.println("Yellow led: " + ((data & LEDS_CONF_YELLOW) > 0));
        }
    }

    private void setupNodePorts() {
        port1 = cpu.getIOUnit(IOPort.class, "P1");
        port1.addPortListener(this);
        port3 = cpu.getIOUnit(IOPort.class, "P3");
        port3.addPortListener(this);
        port4 = cpu.getIOUnit(IOPort.class, "P4");
        port4.addPortListener(this);
        port5 = cpu.getIOUnit(IOPort.class, "P5");
        port5.addPortListener(this);
        port7 = cpu.getIOUnit(IOPort.class, "P7");
        port7.addPortListener(this);
        port8 = cpu.getIOUnit(IOPort.class, "P8");
        port8.addPortListener(this);

        IOUnit usart0 = cpu.getIOUnit("USCI B0"); 
        if (usart0 instanceof USARTSource) {
            radio = new CC2420(cpu);
            radio.setCCAPort(port1, CC2420_CCA);
            radio.setFIFOPPort(port1, CC2420_FIFOP);
            radio.setFIFOPort(port1, CC2420_FIFO);

            ((USARTSource) usart0).addUSARTListener(this);
            radio.setSFDPort(port1, CC2420_SFD);
        } else {
            throw new EmulationException("Could not setup exp5438 mote - missing USCI B0");
        }

        IOUnit usart = cpu.getIOUnit("USCI A1");
        if (usart instanceof USARTSource) {
            registry.registerComponent("serialio", usart);
        }
    }

    public void setupNode() {
        setupNodePorts();

        if (!config.getPropertyAsBoolean("nogui", true)) {
            // Add some windows for listening to serial output
            IOUnit usart = cpu.getIOUnit("USCI A1");
            if (usart instanceof USARTSource) {
            	SerialMon serial = new SerialMon((USARTSource)usart, "USCI A1 Port Output");
            	registry.registerComponent("serialgui", serial);
            }
        }
    }

    public int getModeMax() {
        return 0;
    }

    public static void main(String[] args) throws IOException {
        Exp5438Node node = new Exp5438Node();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/ti/Exp1120Node.java`:

```java
package se.sics.mspsim.platform.ti;

import java.io.IOException;

import se.sics.mspsim.chip.CC1120;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class Exp1120Node extends GenericNode implements PortListener, USARTListener {

	public static final int CC1120_GDO0 = 7; /* 1.7 */
	public static final int CC1120_GDO2 = 3; /* 1.3 */

	public static final int CC1120_CHIP_SELECT = (1 << 0); // 3.0

	IOPort port1;
	IOPort port3;
	IOPort port4;
	IOPort port5;
	IOPort port7;
	IOPort port8;

	public static final int LEDS_CONF_RED    = (1 << 0); // 1.0
	public static final int LEDS_CONF_YELLOW = (1 << 1); // 1.1

	public CC1120 radio;

	public Exp1120Node() {
		super("Exp1120", new MSP430f5437Config());
	}

	public void dataReceived(USARTSource source, int data) {
		radio.dataReceived(source, data);

		/* if nothing selected, just write back a random byte to these devs */
		if (!radio.getChipSelect()) {
			source.byteReceived(0);
		}
	}

	public void portWrite(IOPort source, int data) {
		if (source == port3) {
			// Chip select = active low...
			radio.setChipSelect((data & CC1120_CHIP_SELECT) == 0);
		}
	}

	private void setupNodePorts() {
		port1 = cpu.getIOUnit(IOPort.class, "P1");
		port1.addPortListener(this);
		port3 = cpu.getIOUnit(IOPort.class, "P3");
		port3.addPortListener(this);
		port4 = cpu.getIOUnit(IOPort.class, "P4");
		port4.addPortListener(this);
		port5 = cpu.getIOUnit(IOPort.class, "P5");
		port5.addPortListener(this);
		port7 = cpu.getIOUnit(IOPort.class, "P7");
		port7.addPortListener(this);
		port8 = cpu.getIOUnit(IOPort.class, "P8");
		port8.addPortListener(this);

		IOUnit usart0 = cpu.getIOUnit("USCI B0"); 
		if (usart0 instanceof USARTSource) {
			radio = new CC1120(cpu);
			radio.setGDO0(port1, CC1120_GDO0);
			radio.setGDO2(port1, CC1120_GDO2);
			((USARTSource) usart0).addUSARTListener(this);
		} else {
			throw new EmulationException("Error creating Exp1120Node: no USCI B0");
		}

		IOUnit usart = cpu.getIOUnit("USCI A1");
		if (usart instanceof USARTSource) {
			registry.registerComponent("serialio", usart);
		}
	}

	public void setupNode() {
		setupNodePorts();

		if (!config.getPropertyAsBoolean("nogui", true)) {
			// Add some windows for listening to serial output
			IOUnit usart = cpu.getIOUnit("USCI A1");
			if (usart instanceof USARTSource) {
				SerialMon serial = new SerialMon((USARTSource)usart, "USCI A1 Port Output");
				registry.registerComponent("serialgui", serial);
			}
		}
	}

	public int getModeMax() {
		return 0;
	}

	public static void main(String[] args) throws IOException {
		Exp1120Node node = new Exp1120Node();
		ArgumentManager config = new ArgumentManager();
		config.handleArguments(args);
		node.setupArgs(config);
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/ti/Trxeb2520Node.java`:

```java
package se.sics.mspsim.platform.ti;

import java.io.IOException;

import se.sics.mspsim.chip.CC2520;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.util.ArgumentManager;

public class Trxeb2520Node extends GenericNode implements PortListener, USARTListener {

	/* TrxEB + CC2520EM 2.1.
	 * Assuming non-default GPIO configuration (see trxeb2520 platform) */
    public static final int CC2520_FIFOP = 4; /* GPIO0 - 1.4 */
    public static final int CC2520_FIFO = 4; /* GPIO1 - 3.4 */
    public static final int CC2520_CCA = 3; /* GPIO3 - 1.3 */
    public static final int CC2520_SFD = 2; /* GPIO4 - 1.2 */

    /* Output: VREG_EN to CC2520 */
    public static final int CC2520_VREG = (1 << 7); /* 1.7 */
    /* Output: SPI Chip Select (CS_N) */
    public static final int CC2520_CHIP_SELECT = (1 << 0); /* 3.0 */
    public static final int CC2520_RESET = (1 << 0); /* 8.0 */

	IOPort port1;
	IOPort port3;
	IOPort port4;
	IOPort port5;
	IOPort port7;
	IOPort port8;

	public CC2520 radio;

	public Trxeb2520Node() {
		super("Trxeb2520", new MSP430f5437Config());
	}

	public void dataReceived(USARTSource source, int data) {
		radio.dataReceived(source, data);

		/* if nothing selected, just write back a random byte to these devs */
		if (!radio.getChipSelect()) {
			source.byteReceived(0);
		}
	}

	public void portWrite(IOPort source, int data) {
		if (source == port1) {
			radio.setVRegOn((data & CC2520_VREG) != 0);
		} else if (source == port3) {
			radio.setChipSelect((data & CC2520_CHIP_SELECT) == 0);
		} else if (source == port8) {
//			if ((data & CC2520_RESET) != 0) {
//				radio.notifyReset();
//			}
		} 
	}

	private void setupNodePorts() {
		port1 = cpu.getIOUnit(IOPort.class, "P1");
		port1.addPortListener(this);
		port3 = cpu.getIOUnit(IOPort.class, "P3");
		port3.addPortListener(this);
		port4 = cpu.getIOUnit(IOPort.class, "P4");
		port4.addPortListener(this);
		port5 = cpu.getIOUnit(IOPort.class, "P5");
		port5.addPortListener(this);
		port7 = cpu.getIOUnit(IOPort.class, "P7");
		port7.addPortListener(this);
		port8 = cpu.getIOUnit(IOPort.class, "P8");
		port8.addPortListener(this);

		IOUnit usart0 = cpu.getIOUnit("USCI B0"); 
		if (usart0 instanceof USARTSource) {
			radio = new CC2520(cpu); 
			radio.setGPIO(0, port1, CC2520_FIFOP);
			radio.setGPIO(1, port3, CC2520_FIFO);
			radio.setGPIO(3, port1, CC2520_CCA);
			radio.setGPIO(4, port1, CC2520_SFD);
			((USARTSource) usart0).addUSARTListener(this);
		} else {
			throw new EmulationException("Error creating Trxeb2520Node: no USCI B0");
		}

		IOUnit usart = cpu.getIOUnit("USCI A1");
		if (usart instanceof USARTSource) {
			registry.registerComponent("serialio", usart);
		}
	}

	public void setupNode() {
		setupNodePorts();
	}

	public int getModeMax() {
		return 0;
	}

	public static void main(String[] args) throws IOException {
		Trxeb2520Node node = new Trxeb2520Node();
		ArgumentManager config = new ArgumentManager();
		config.handleArguments(args);
		node.setupArgs(config);
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/ti/Trxeb1120Node.java`:

```java
package se.sics.mspsim.platform.ti;

import se.sics.mspsim.chip.CC1120;
import se.sics.mspsim.chip.Enc28J60;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;

public class Trxeb1120Node extends GenericNode implements PortListener, USARTListener {

	public static final int CC1120_GDO0 = 7; /* 1.7 */
	public static final int CC1120_GDO2 = 3; /* 1.3 */
	public static final int CC1120_CHIP_SELECT = (1 << 0); // 3.0

	public static final int ENC28J60_CLK = 2; /* 10.2 */
	public static final int ENC28J60_MOSI = 1; /* 10.1 */
	public static final int ENC28J60_MISO = 0; /* 10.0 */
	public static final int ENC28J60_CHIP_SELECT = 3; /* 10.3 */

	IOPort port1;
	IOPort port3;
	IOPort port4;
	IOPort port5;
	IOPort port7;
	IOPort port8;
	IOPort port10;

	public CC1120 radio;
	public Enc28J60 enc = null;

	private boolean withEnc;
	
	public Trxeb1120Node(boolean withEnc) {
		super("Trxeb1120", new MSP430f5437Config());

		this.withEnc = withEnc;
	}

	public void dataReceived(USARTSource source, int data) {
		radio.dataReceived(source, data);
		
		/* if nothing selected, just write back a random byte to these devs */
		if (!radio.getChipSelect()) {
			source.byteReceived(0);
		}
	}

	public void portWrite(IOPort source, int data) {
		if (source == port3) {
			// Chip select = active low...
			radio.setChipSelect((data & CC1120_CHIP_SELECT) == 0);
		} else if (withEnc && source == port10) {
			enc.write(port10, data);
		}
	}

	private void setupNodePorts() {
		port1 = cpu.getIOUnit(IOPort.class, "P1");
		port1.addPortListener(this);
		port3 = cpu.getIOUnit(IOPort.class, "P3");
		port3.addPortListener(this);
		port4 = cpu.getIOUnit(IOPort.class, "P4");
		port4.addPortListener(this);
		port5 = cpu.getIOUnit(IOPort.class, "P5");
		port5.addPortListener(this);
		port7 = cpu.getIOUnit(IOPort.class, "P7");
		port7.addPortListener(this);
		port8 = cpu.getIOUnit(IOPort.class, "P8");
		port8.addPortListener(this);

		IOUnit usart0 = cpu.getIOUnit("USCI B0"); 
		if (usart0 instanceof USARTSource) {
			radio = new CC1120(cpu);
			radio.setGDO0(port1, CC1120_GDO0);
			radio.setGDO2(port1, CC1120_GDO2);
			((USARTSource) usart0).addUSARTListener(this);
		} else {
			throw new EmulationException("Error creating Trxeb1120Node: no USCI B0");
		}

		if (withEnc) {
			port10 = cpu.getIOUnit(IOPort.class, "P10");
			port10.addPortListener(this);
			enc = new Enc28J60(cpu, port10, ENC28J60_CLK, ENC28J60_MOSI, ENC28J60_MISO, ENC28J60_CHIP_SELECT);
		}
		
		IOUnit usart = cpu.getIOUnit("USCI A1");
		if (usart instanceof USARTSource) {
			registry.registerComponent("serialio", usart);
		}
	}

	public void setupNode() {
		setupNodePorts();
	}

	public int getModeMax() {
		return 0;
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/ti/Exp1101Node.java`:

```java
package se.sics.mspsim.platform.ti;

import java.io.IOException;

import se.sics.mspsim.chip.CC1101;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class Exp1101Node extends GenericNode implements PortListener, USARTListener {

	public static final int CC1101_GDO0 = 7; /* 1.7 */
	public static final int CC1101_GDO2 = 3; /* 1.3 */

	public static final int CC1101_CHIP_SELECT = (1 << 0); // 3.0

    IOPort port1;
    IOPort port3;
    IOPort port4;
    IOPort port5;
    IOPort port7;
    IOPort port8;

    public static final int LEDS_CONF_RED    = (1 << 0); // 1.0
    public static final int LEDS_CONF_YELLOW = (1 << 1); // 1.1

    public CC1101 radio;

    public Exp1101Node() {
        super("Exp1101", new MSP430f5437Config());
    }

    public void dataReceived(USARTSource source, int data) {
        radio.dataReceived(source, data);

        /* if nothing selected, just write back a random byte to these devs */
        if (!radio.getChipSelect()) {
            source.byteReceived(0);
        }
    }

    public void portWrite(IOPort source, int data) {
		if (source == port3) {
			// Chip select = active low...
			radio.setChipSelect((data & CC1101_CHIP_SELECT) == 0);
		}
    }

    private void setupNodePorts() {
        port1 = cpu.getIOUnit(IOPort.class, "P1");
        port1.addPortListener(this);
        port3 = cpu.getIOUnit(IOPort.class, "P3");
        port3.addPortListener(this);
        port4 = cpu.getIOUnit(IOPort.class, "P4");
        port4.addPortListener(this);
        port5 = cpu.getIOUnit(IOPort.class, "P5");
        port5.addPortListener(this);
        port7 = cpu.getIOUnit(IOPort.class, "P7");
        port7.addPortListener(this);
        port8 = cpu.getIOUnit(IOPort.class, "P8");
        port8.addPortListener(this);

        IOUnit usart0 = cpu.getIOUnit("USCI B0"); 
        if (usart0 instanceof USARTSource) {
            radio = new CC1101(cpu);
			radio.setGDO0(port1, CC1101_GDO0);
			radio.setGDO2(port1, CC1101_GDO2);
            ((USARTSource) usart0).addUSARTListener(this);
        } else {
            throw new EmulationException("Could not setup exp1101 mote - missing USCI B0");
        }

        IOUnit usart = cpu.getIOUnit("USCI A1");
        if (usart instanceof USARTSource) {
            registry.registerComponent("serialio", usart);
        }
    }

    public void setupNode() {
        setupNodePorts();

        if (!config.getPropertyAsBoolean("nogui", true)) {
            // Add some windows for listening to serial output
            IOUnit usart = cpu.getIOUnit("USCI A1");
            if (usart instanceof USARTSource) {
            	SerialMon serial = new SerialMon((USARTSource)usart, "USCI A1 Port Output");
            	registry.registerComponent("serialgui", serial);
            }
        }
    }

    public int getModeMax() {
        return 0;
    }

    public static void main(String[] args) throws IOException {
        Exp1101Node node = new Exp1101Node();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/tyndall/TyndallNode.java`:

```java
package se.sics.mspsim.platform.tyndall;
import java.io.IOException;

import se.sics.mspsim.chip.CC2420;
import se.sics.mspsim.config.MSP430f5437Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class TyndallNode extends GenericNode implements PortListener, USARTListener {

    /* P8.2 - Input: FIFOP from CC2420 */
    /* P8.1 - Input: FIFO from CC2420 */
    /* P8.5 - Input: CCA from CC2420 */
    public static final int CC2420_FIFOP = 2;
    public static final int CC2420_FIFO = 1;
    public static final int CC2420_CCA = 5;

    /* P8.6 - Input: SFD from CC2420 */
    /* P8.3 - Output: VREG_EN to CC2420 */
    /* P3.0 - Output: SPI Chip Select (CS_N) */
    public static final int CC2420_SFD = 6;
    public static final int CC2420_VREG = (1 << 3);
    public static final int CC2420_CHIP_SELECT = 0x01;


    IOPort port1;
    IOPort port3;
    IOPort port4;
    IOPort port5;
    IOPort port7;
    IOPort port8;

    public static final int LEDS_CONF_RED    = 0x08;
    public static final int LEDS_CONF_GREEN  = 0x01;
    public static final int LEDS_CONF_YELLOW = 0x01;

    //private M25P80 flash;
    //private String flashFile;
    public CC2420 radio;


    public TyndallNode() {
        super("Tyndall", new MSP430f5437Config());
    }

//    public M25P80 getFlash() {
//        return flash;
//    }

//    public void setFlash(M25P80 flash) {
//        this.flash = flash;
//        registry.registerComponent("xmem", flash);
//    }

    public void dataReceived(USARTSource source, int data) {
        radio.dataReceived(source, data);
        //flash.dataReceived(source, data);
        /* if nothing selected, just write back a random byte to these devs */
        if (!radio.getChipSelect() /*&& !flash.getChipSelect()*/) {
            source.byteReceived(0);
        }
    }

    public void portWrite(IOPort source, int data) {
        if (source == port7) {
            //System.out.println("LEDS GREEN = " + ((data & LEDS_CONF_GREEN) > 0));
            System.out.println("LEDS RED = " + ((data & LEDS_CONF_RED) > 0));
            //System.out.println("LEDS YELLOW = " + ((data & LEDS_CONF_YELLOW) > 0));
        }
        if (source == port3) {
            // Chip select = active low...
            radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
        }
        if (source == port4) {
            //radio.portWrite(source, data);
            //flash.portWrite(source, data);
        }
        if (source == port8) {
            radio.setVRegOn((data & CC2420_VREG) != 0);
        }
    }

    private void setupNodePorts() {
//        if (flashFile != null) {
//            setFlash(new FileM25P80(cpu, flashFile));
//        }

        port1 = cpu.getIOUnit(IOPort.class, "P1");
        port1.addPortListener(this);
        port3 = cpu.getIOUnit(IOPort.class, "P3");
        port3.addPortListener(this);
        port4 = cpu.getIOUnit(IOPort.class, "P4");
        port4.addPortListener(this);
        port5 = cpu.getIOUnit(IOPort.class, "P5");
        port5.addPortListener(this);
        port7 = cpu.getIOUnit(IOPort.class, "P7");
        port7.addPortListener(this);
        port8 = cpu.getIOUnit(IOPort.class, "P8");
        port8.addPortListener(this);

        IOUnit usart0 = cpu.getIOUnit("USCI B0");
        if (usart0 instanceof USARTSource) {
            radio = new CC2420(cpu);
            radio.setCCAPort(port8, CC2420_CCA);
            radio.setFIFOPPort(port8, CC2420_FIFOP);
            radio.setFIFOPort(port8, CC2420_FIFO);

            ((USARTSource) usart0).addUSARTListener(this);
            radio.setSFDPort(port8, CC2420_SFD);
        } else {
            throw new EmulationException("Could not setup tyndall mote - missing USCI B0");
        }

        IOUnit usart = cpu.getIOUnit("USCI A0");
        if (usart instanceof USARTSource) {
            registry.registerComponent("serialio", usart);
        }
    }

    public void setupNode() {
        // create a filename for the flash file
        // This should be possible to take from a config file later!
        String fileName = config.getProperty("flashfile");
        if (fileName == null) {
            fileName = firmwareFile;
            if (fileName != null) {
                int ix = fileName.lastIndexOf('.');
                if (ix > 0) {
                    fileName = fileName.substring(0, ix);
                }
                fileName = fileName + ".flash";
            }
        }
        if (DEBUG) System.out.println("Using flash file: " + (fileName == null ? "no file" : fileName));

        //this.flashFile = fileName;

        setupNodePorts();

        if (!config.getPropertyAsBoolean("nogui", true)) {
            setupGUI();

            // Add some windows for listening to serial output
            IOUnit usart = cpu.getIOUnit("USCI A0");
            if (usart instanceof USARTSource) {
                SerialMon serial = new SerialMon((USARTSource)usart, "USCI A0 Port Output");
                registry.registerComponent("serialgui", serial);
            }
        }
    }

    public void setupGUI() {
        System.out.println("No gui for Tyndall yet...");
    }

    public int getModeMax() {
        return 0;
    }

    public static void main(String[] args) throws IOException {
        TyndallNode node = new TyndallNode();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/AbstractNodeGUI.java`:

```java
/*
 * Copyright (c) 2009, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * AbstractNodeGUI
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 9 okt 2009
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.io.File;
import java.net.URL;

import javax.swing.ImageIcon;
import javax.swing.JComponent;

import se.sics.mspsim.ui.ManagedWindow;
import se.sics.mspsim.ui.WindowManager;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.ServiceComponent;

public abstract class AbstractNodeGUI extends JComponent implements ServiceComponent {

    private static final long serialVersionUID = 1435276301923987019L;

    private final String windowName;
    private final String nodeImageName;

    private String name;
    private ComponentRegistry registry;

    private ImageIcon nodeImage;
    private ManagedWindow window;

    private ServiceComponent.Status status = Status.STOPPED;


    protected AbstractNodeGUI(String windowName, String imageName) {
        this.windowName = windowName;
        this.nodeImageName = imageName;
        setBackground(Color.black);
        setOpaque(true);
    }

    public Status getStatus() {
        return status;
    }

    public String getName() {
        return name;
    }

    protected ImageIcon getNodeImage() {
        return nodeImage;
    }

    protected ComponentRegistry getRegistry() {
        return registry;
    }

    public final void init(String name, ComponentRegistry registry) {
        this.name = name;
        this.registry = registry;
    }

    public final void start() {
        File fp = new File(nodeImageName);
        if (!fp.canRead()) {
            URL imageURL = getImageURL(nodeImageName);
            if (imageURL == null
                    && !nodeImageName.startsWith("images/")
                    && !nodeImageName.startsWith("/images/")) {
                imageURL = getImageURL("images/" + nodeImageName);
            }
            if (imageURL != null) {
                nodeImage = new ImageIcon(imageURL);
            } else {
                throw new IllegalStateException("image not found: " + nodeImageName);
            }
        } else {
            nodeImage = new ImageIcon(nodeImageName);
        }
        if (nodeImage.getIconWidth() == 0 || nodeImage.getIconHeight() == 0) {
          // Image not found
          throw new IllegalStateException("image not found: " + nodeImageName);
        }
        setPreferredSize(new Dimension(nodeImage.getIconWidth(),
                                       nodeImage.getIconHeight()));

        WindowManager wm = registry.getComponent(WindowManager.class);
        window = wm.createWindow(windowName);
        window.add(this);
        window.pack();

        startGUI();

        status = Status.STARTED;
        window.setVisible(true);
    }

    private URL getImageURL(String image) {
        URL imageURL = getClass().getResource(image);
        if (imageURL == null && !image.startsWith("/")) {
            imageURL = getClass().getResource("/" + image);
        }
        return imageURL;
    }

    public final void stop() {
        status = Status.STOPPED;
        stopGUI();
        if (window != null) {
            window.setVisible(false);
            window = null;
        }
    }

    protected abstract void startGUI();

    protected abstract void stopGUI();

    protected void paintComponent(Graphics g) {
        Color old = g.getColor();
        g.setColor(getBackground());
        g.fillRect(0, 0, getWidth(), getHeight());

        ImageIcon nodeImage = getNodeImage();
        nodeImage.paintIcon(this, g, 0, 0);

        g.setColor(old);
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/z1/Z1Node.java`:

```java
package se.sics.mspsim.platform.z1;

import java.io.IOException;
import se.sics.mspsim.chip.Button;
import se.sics.mspsim.chip.CC2420;
import se.sics.mspsim.chip.FileStorage;
import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.chip.M25P80;
import se.sics.mspsim.config.MSP430f2617Config;
import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.core.USCI;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ArgumentManager;

public class Z1Node extends GenericNode implements PortListener, USARTListener {

    public static final int MODE_LEDS_OFF = 0;
    public static final int MODE_LEDS_1 = 1;
    public static final int MODE_LEDS_2 = 2;
    public static final int MODE_LEDS_3 = 3;
    public static final int MODE_MAX = MODE_LEDS_3;

    // Port 2.5 - Button
    public static final int BUTTON_PIN = 5;

    /* P1.2 - Input: FIFOP from CC2420 */
    /* P1.3 - Input: FIFO from CC2420 */
    /* P1.4 - Input: CCA from CC2420 */
    public static final int CC2420_FIFOP = 2;
    public static final int CC2420_FIFO = 3;
    public static final int CC2420_CCA = 4;

    /* P4.1 - Input: SFD from CC2420 */
    /* P4.5 - Output: VREG_EN to CC2420 */
    /* P3.0 - Output: SPI Chip Select (CS_N) */
    public static final int CC2420_SFD = 1;
    public static final int CC2420_VREG = (1 << 5);
    public static final int CC2420_CHIP_SELECT = 0x01;

    public static final int TMP102_PWR_PIN = 0;
    public static final int TMP102_PWR = 1 << TMP102_PWR_PIN;

    public static final int I2C_DATA_PIN = 1;
    public static final int I2C_DATA = 1 << I2C_DATA_PIN;
    public static final int I2C_CLK_PIN = 2;
    public static final int I2C_CLK = 1 << I2C_CLK_PIN;

    private IOPort port1;
    private IOPort port2;
    private IOPort port3;
    private IOPort port4;
    private IOPort port5;

    public static final int LEDS_CONF_RED    = 0x10;
    public static final int LEDS_CONF_GREEN  = 0x40;
    public static final int LEDS_CONF_BLUE   = 0x20;
    private static final int[] LEDS = { 0xff2020, 0x40ff40, 0x4040ff };

    boolean redLed;
    boolean blueLed;
    boolean greenLed;

    private Leds leds;
    private Button button;
    private Z1Gui gui;

    private CC2420 radio;
//    private TMP102 tmp102;
    private M25P80 flash;
    private String flashFile;

    public Z1Node() {
        super("Z1", new MSP430f2617Config());
        setMode(MODE_LEDS_OFF);
    }

    public Leds getLeds() {
        return leds;
    }

    public Button getButton() {
        return button;
    }

    public M25P80 getFlash() {
        // TODO Replace with M25P16.
        // The Z1 platform has a M25P16 chip with 2MB compared to the M25P80
        // with 1MB but the chips are compatible.
        return flash;
    }

    public void setFlash(M25P80 flash) {
        this.flash = flash;
        registry.registerComponent("xmem", flash);
    }

    public void dataReceived(USARTSource source, int data) {
        // USCI s = (USCI) source;
        radio.dataReceived(source, data);
        flash.dataReceived(source, data);
        /* if nothing selected, just write back a random byte to these devs */
        if (!radio.getChipSelect() && !flash.getChipSelect()) {
            source.byteReceived(0);
        }
    }

    private int lastPort5 = 0;
    public void portWrite(IOPort source, int data) {
        switch (source.getPort()) {
        case 3:
            // Chip select = active low...
            radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
            break;
        case 4:
            radio.setVRegOn((data & CC2420_VREG) != 0);
            //radio.portWrite(source, data);
            flash.portWrite(source, data);
            break;
        case 5: {
            if ((data & (LEDS_CONF_RED|LEDS_CONF_BLUE|LEDS_CONF_GREEN)) !=
                (lastPort5 & (LEDS_CONF_RED|LEDS_CONF_BLUE|LEDS_CONF_GREEN))) {
                redLed = (data & LEDS_CONF_RED) == 0;
                blueLed = (data & LEDS_CONF_BLUE) == 0;
                greenLed = (data & LEDS_CONF_GREEN) == 0;
                leds.setLeds((redLed ? 1 : 0) + (greenLed ? 2 : 0) + (blueLed ? 4 : 0));
                int newMode = (redLed ? 1 : 0) + (greenLed ? 1 : 0) + (blueLed ? 1 : 0);
                setMode(newMode);
            }
            if ((data & TMP102_PWR) != (lastPort5 & TMP102_PWR)) {
//                tmp102.setPowerPin((data & TMP102_PWR) != 0);
            }
            if ((data & (I2C_CLK | I2C_DATA)) != (lastPort5 & (I2C_CLK|I2C_DATA))) {
//                tmp102.setI2CPins((data & I2C_CLK) != 0, (data & I2C_DATA) != 0);
            }
            lastPort5 = data;
            break;
        }
        }
    }

    private void setupNodePorts() {
        port1 = cpu.getIOUnit(IOPort.class, "P1");
//        port1.addPortListener(this);
        port2 = cpu.getIOUnit(IOPort.class, "P2");
//        port2.addPortListener(this);
        port3 = cpu.getIOUnit(IOPort.class, "P3");
        port3.addPortListener(this);
        port4 = cpu.getIOUnit(IOPort.class, "P4");
        port4.addPortListener(this);
        port5 = cpu.getIOUnit(IOPort.class, "P5");
        port5.addPortListener(this);

//        tmp102 = new TMP102(cpu);

        USCI usart0 = cpu.getIOUnit(USCI.class, "USCI B0");
        if (usart0 != null) {
            radio = new CC2420(cpu);
            radio.setCCAPort(port1, CC2420_CCA);
            radio.setFIFOPPort(port1, CC2420_FIFOP);
            radio.setFIFOPort(port1, CC2420_FIFO);

            usart0.addUSARTListener(this);
            radio.setSFDPort(port4, CC2420_SFD);
        } else {
            throw new EmulationException("Could not setup mote - missing USCI B0");
        }

        leds = new Leds(cpu, LEDS);
        button = new Button("Button", cpu, port2, BUTTON_PIN, true);

        IOUnit usart = cpu.getIOUnit("USCI A0");
        if (usart instanceof USARTSource) {
            registry.registerComponent("serialio", usart);
        }

        if (getFlash() == null) {
            setFlash(new M25P80(cpu));
        }
        if (flashFile != null) {
            getFlash().setStorage(new FileStorage(flashFile));
        }
    }

    public void setupNode() {
        // create a filename for the flash file
        // This should be possible to take from a config file later!
        String fileName = config.getProperty("flashfile");
        if (fileName == null) {
            fileName = firmwareFile;
            if (fileName != null) {
                int ix = fileName.lastIndexOf('.');
                if (ix > 0) {
                    fileName = fileName.substring(0, ix);
                }
                fileName = fileName + ".flash";
            }
        }
        if (DEBUG) log("Using flash file: " + (fileName == null ? "no file" : fileName));

        this.flashFile = fileName;

        setupNodePorts();

        if (!config.getPropertyAsBoolean("nogui", true)) {
            setupGUI();

            // Add some windows for listening to serial output
            IOUnit usart = cpu.getIOUnit("USCI A0");
            if (usart instanceof USARTSource) {
                SerialMon serial = new SerialMon((USARTSource)usart, "USCI A0 Port Output");
                registry.registerComponent("serialgui", serial);
            }
        }


    }

    public void setupGUI() {
        if (gui == null) {
            gui = new Z1Gui(this);
            registry.registerComponent("nodegui", gui);
        }
    }

    public int getModeMax() {
        return MODE_MAX;
    }

    public static void main(String[] args) throws IOException {
        Z1Node node = new Z1Node();
        ArgumentManager config = new ArgumentManager();
        config.handleArguments(args);
        node.setupArgs(config);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/z1/Z1Gui.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 */

package se.sics.mspsim.platform.z1;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.platform.AbstractNodeGUI;

public class Z1Gui extends AbstractNodeGUI {

    private static final long serialVersionUID = 7016480889484768582L;

    private static final int GREEN_Y = 88;
    private static final int BLUE_Y = 99;
    private static final int RED_Y = 77;
    private static final int LED_X = 184;
    private static final int LED_WIDTH = 11;
    private static final int LED_HEIGHT = 6;

    private static final Color BLUE_TRANS = new Color(0x80, 0x80, 0xff, 0xa0);
    private static final Color GREEN_TRANS = new Color(0x40, 0xf0, 0x40, 0xa0);
    private static final Color RED_TRANS = new Color(0xf0, 0x40, 0x40, 0xa0);

    private static final Color BLUE_C = new Color(0xffa0a0ff);
    private static final Color GREEN_C = new Color(0xff60ff60);
    private static final Color RED_C = new Color(0xffff8000);

    private static final Color BUTTON_C = new Color(0x60ffffff);

    private static final Rectangle LEDS_BOUNDS =
      new Rectangle(LED_X - 2, RED_Y - 2, LED_WIDTH + 1, BLUE_Y - RED_Y + LED_HEIGHT + 1);

    private boolean buttonDown = false;
    private boolean resetDown = false;

    private final Z1Node node;
    private final StateChangeListener ledsListener = new StateChangeListener() {
        public void stateChanged(Object source, int oldState, int newState) {
            repaint(LEDS_BOUNDS);
        }
    };

    public Z1Gui(Z1Node node) {
        super("Z1Gui", "images/z1.jpg");
        this.node = node;
    }

    protected void startGUI() {
        MouseAdapter mouseHandler = new MouseAdapter() {

            // For the button sensor and reset button on the Sky nodes.
            public void mousePressed(MouseEvent e) {
                int x = e.getX();
                int y = e.getY();
                if (x > 53 && x < 66) {
                    if (y > 231 && y < 246) {
                        buttonDown = true;
                        Z1Gui.this.node.getButton().setPressed(true);
                        repaint(53, 231, 14, 16);
                    } else if (y > 260 && y < 273) {
                        resetDown = true;
                        repaint(53, 260, 14, 13);
                    }
                }
            }

            public void mouseReleased(MouseEvent e) {
                if (buttonDown) {
                    buttonDown = false;
                    Z1Gui.this.node.getButton().setPressed(false);
                    repaint(53, 231, 14, 16);

                } else if (resetDown) {
                    int x = e.getX();
                    int y = e.getY();
                    resetDown = false;
                    if (x > 53 && x < 66 && y > 260 && y < 273) {
                        Z1Gui.this.node.getCPU().reset();
                    }
                    repaint(53, 260, 14, 13);
                }
            }
        };

        this.addMouseListener(mouseHandler);
        node.getLeds().addStateChangeListener(ledsListener);
    }

    protected void stopGUI() {
        node.getLeds().removeStateChangeListener(ledsListener);
    }

    protected void paintComponent(Graphics g) {
        Color old = g.getColor();

        super.paintComponent(g);

        // Display all active leds
        if (node.redLed) {
            g.setColor(RED_TRANS);
            g.fillOval(LED_X - 2, RED_Y - 1, LED_WIDTH, LED_HEIGHT);
            g.setColor(RED_C);
            g.fillOval(LED_X, RED_Y, LED_WIDTH - 5, LED_HEIGHT - 2);
        }
        if (node.greenLed) {
            g.setColor(GREEN_TRANS);
            g.fillOval(LED_X - 2, GREEN_Y - 1, LED_WIDTH, LED_HEIGHT);
            g.setColor(GREEN_C);
            g.fillOval(LED_X, GREEN_Y, LED_WIDTH - 5, LED_HEIGHT - 2);
        }
        if (node.blueLed) {
            g.setColor(BLUE_TRANS);
            g.fillOval(LED_X - 2, BLUE_Y - 1, LED_WIDTH, LED_HEIGHT);
            g.setColor(BLUE_C);
            g.fillOval(LED_X, BLUE_Y, LED_WIDTH - 5, LED_HEIGHT - 2);
        }
        if (buttonDown) {
            g.setColor(BUTTON_C);
            g.fillOval(55, 234, 9, 9);
        }
        if (resetDown) {
            g.setColor(BUTTON_C);
            g.fillOval(55, 262, 9, 9);
        }
        g.setColor(old);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sky/RadioWrapper.java`:

```java
package se.sics.mspsim.platform.sky;
import se.sics.mspsim.chip.CC2420;
import se.sics.mspsim.chip.PacketListener;
import se.sics.mspsim.chip.RFListener;

public class RadioWrapper implements RFListener {

  private final CC2420 radio;
  private PacketListener packetListener;
  int len = 0;
  int pos = 0;
  byte[] buffer = new byte[128];
  
  public RadioWrapper(CC2420 radio) {
    this.radio = radio;
    radio.addRFListener(this);
  }
  
  public synchronized void addPacketListener(PacketListener listener) {
    packetListener = PacketListener.Proxy.INSTANCE.add(packetListener, listener);
  }

  public synchronized void removePacketListener(PacketListener listener) {
    packetListener = PacketListener.Proxy.INSTANCE.remove(packetListener, listener);
  }

  public void packetReceived(byte[] receivedData) {
    // four zero bytes, 7a and then length...
    radio.receivedByte((byte)0);
    radio.receivedByte((byte)0);
    radio.receivedByte((byte)0);
    radio.receivedByte((byte)0);
    radio.receivedByte((byte)0x7a);
   // radio.receivedByte((byte) receivedData.length);
    
    for (int i = 0; i < receivedData.length; i++) {
//      int data = receivedData[i];
//      System.out.println("*** RF (external) Data :" + data + " = $" + Utils.hex8(data) + " => " +
//          (char) data);
     
      radio.receivedByte(receivedData[i]);
    }
  }

  // NOTE: len is not in the packet for now...
  public void receivedByte(byte data) {
    PacketListener listener = this.packetListener;
//    System.out.println("*** RF Data :" + data + " = $" + Utils.hex8(data) + " => " +
//        (char) data);
    if (pos == 5) {
      len = data;
    }
    if (pos == 0) {
        if (listener != null) {
            listener.transmissionStarted();
        }
    }
    buffer[pos++] = data;
    // len + 1 = pos + 5 (preambles)
    if (len > 0 && len + 1 == pos - 5) {
//      System.out.println("***** SENDING DATA from CC2420 len = " + len);
      byte[] packet = new byte[len + 1];
      System.arraycopy(buffer, 5, packet, 0, len + 1);
      if (listener != null) {
          listener.transmissionEnded(packet);
      }
      pos = 0;
      len = 0;
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sky/SkyGui.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SkyGui
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform.sky;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Rectangle;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import se.sics.mspsim.core.StateChangeListener;
import se.sics.mspsim.platform.AbstractNodeGUI;

public class SkyGui extends AbstractNodeGUI {

  private static final long serialVersionUID = 7753659717805292786L;
  
  public static final int GREEN_Y = 40;
  public static final int BLUE_Y = 46;
  public static final int RED_Y = 34;
  public static final int LED_X = 10;

  public static final Color BLUE_TRANS = new Color(0x80,0x80,0xff,0xa0);
  public static final Color GREEN_TRANS = new Color(0x40, 0xf0, 0x40, 0xa0);
  public static final Color RED_TRANS = new Color(0xf0, 0x40, 0x40, 0xa0);

  public static final Color BLUE_C = new Color(0xffa0a0ff);
  public static final Color GREEN_C = new Color(0xff60ff60);
  public static final Color RED_C = new Color(0xffff8000);

  private static final Rectangle LEDS_BOUNDS = new Rectangle(LED_X, RED_Y, 9, BLUE_Y - RED_Y + 5);

  private final MoteIVNode node;
  private final StateChangeListener ledsListener = new StateChangeListener() {
      public void stateChanged(Object source, int oldState, int newState) {
          repaint(LEDS_BOUNDS);
      }
  };

  public SkyGui(MoteIVNode node) {
    super("SkyGui", "images/sky.jpg");
    this.node = node;
  }

  protected void startGUI() {
    MouseAdapter mouseHandler = new MouseAdapter() {

	private boolean buttonDown = false;
	private boolean resetDown = false;

	// For the button sensor and reset button on the Sky nodes.
	public void mousePressed(MouseEvent e) {
	  int x = e.getX();
	  int y = e.getY();
	  if (x > 122 && x < 135) {
	    if (y > 41 && y < 55) {
	      buttonDown = true;
	      SkyGui.this.node.getButton().setPressed(true);
	    } else if (y > 72 && y < 85) {
	      resetDown = true;
	    }
	  }
	}

	public void mouseReleased(MouseEvent e) {
	  if (buttonDown) {
	    buttonDown = false;
	    SkyGui.this.node.getButton().setPressed(false);

	  } else if (resetDown) {
	    int x = e.getX();
	    int y = e.getY();
	    resetDown = false;
	    if (x > 122 && x < 135 && y > 72 && y < 85) {
	      SkyGui.this.node.getCPU().reset();
	    }
	  }
	}
      };

    this.addMouseListener(mouseHandler);
    node.getLeds().addStateChangeListener(ledsListener);
  }

  protected void paintComponent(Graphics g) {
    Color old = g.getColor();

    super.paintComponent(g);

    // Display all active leds
    if (node.redLed) {
      g.setColor(RED_TRANS);
      g.fillOval(LED_X - 2, RED_Y - 1, 9, 5);
      g.setColor(RED_C);
      g.fillOval(LED_X, RED_Y, 4, 3);
    }
    if (node.greenLed) {
      g.setColor(GREEN_TRANS);
      g.fillOval(LED_X - 2, GREEN_Y - 1, 9, 5);
      g.setColor(GREEN_C);
      g.fillOval(LED_X, GREEN_Y, 4, 3);
    }
    if (node.blueLed) {
      g.setColor(BLUE_TRANS);
      g.fillOval(LED_X - 2, BLUE_Y - 1, 9, 5);
      g.setColor(BLUE_C);
      g.fillOval(LED_X, BLUE_Y, 4, 3);
    }
    g.setColor(old);
  }

  protected void stopGUI() {    
      node.getLeds().removeStateChangeListener(ledsListener);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sky/TelosNode.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: TelosNode.java 304 2008-09-06 20:04:45Z joxe $
 *
 * -----------------------------------------------------------------
 *
 * TelosNode
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date: 2008-09-06 22:04:45 +0200 (Sat, 06 Sep 2008) $
 *           $Revision: 304 $
 */

package se.sics.mspsim.platform.sky;
import java.io.IOException;
import se.sics.mspsim.chip.AT45DB;
import se.sics.mspsim.chip.FileStorage;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.util.ArgumentManager;

/**
 * Emulation of Telos Mote (old version of Sky Node)
 * 
 * TODO: Cleanup the MoteIVNode, SkyNode and TelosNode
 */
public class TelosNode extends MoteIVNode {

  // P4.4 - Output: SPI Flash Chip Select
  public static final int FLASH_RESET = (1<<3);
  public static final int FLASH_CS = (1<<4);
  
  private AT45DB flash;

  /**
   * Creates a new <code>TelosNode</code> instance.
   *
   */
  public TelosNode() {
    super("Telos");
  }

  public AT45DB getFlash() {
    return flash;
  }

  public void setFlash(AT45DB flash) {
    this.flash = flash;
  }

  @Override
  protected void flashWrite(IOPort source, int data) {
    flash.setReset((data & FLASH_RESET) == 0);
    flash.setChipSelect((data & FLASH_CS) == 0);
  }

  // USART Listener
  public void dataReceived(USARTSource source, int data) {
    radio.dataReceived(source, data);
    flash.dataReceived(source, data);
  }

  public void setupNodePorts() {
    super.setupNodePorts();
    if (getFlash() == null) {
        setFlash(new AT45DB(cpu));
    }
    if (flashFile != null) {
      getFlash().setStorage(new FileStorage(flashFile));
    }
  }

  public static void main(String[] args) throws IOException {
    TelosNode node = new TelosNode();
    ArgumentManager config = new ArgumentManager();
    config.handleArguments(args);
    node.setupArgs(config);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sky/SkyNode.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SkyNode
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.platform.sky;
import java.io.IOException;
import se.sics.mspsim.chip.FileStorage;
import se.sics.mspsim.chip.M25P80;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.util.ArgumentManager;

/**
 * Emulation of Sky Mote
 */
public class SkyNode extends MoteIVNode {

  private M25P80 flash;

  /**
   * Creates a new <code>SkyNode</code> instance.
   *
   */
  public SkyNode() {
    super("Tmote Sky");
  }

  public M25P80 getFlash() {
    return flash;
  }

  public void setFlash(M25P80 flash) {
    this.flash = flash;
    registry.registerComponent("xmem", flash);
  }

  // USART Listener
  public void dataReceived(USARTSource source, int data) {
    radio.dataReceived(source, data);
    flash.dataReceived(source, data);
    /* if nothing selected, just write back a random byte to these devs */
    if (!radio.getChipSelect() && !flash.getChipSelect()) {
      source.byteReceived(0);
    }
  }

  @Override
  protected void flashWrite(IOPort source, int data) {
    flash.portWrite(source, data);
  }
  
  public void setupNodePorts() {
    super.setupNodePorts();
    if (getFlash() == null) {
        setFlash(new M25P80(cpu));
    }
    if (flashFile != null) {
        getFlash().setStorage(new FileStorage(flashFile));
    }
  }

  public static void main(String[] args) throws IOException {
    SkyNode node = new SkyNode();
    ArgumentManager config = new ArgumentManager();
    config.handleArguments(args);
    node.setupArgs(config);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sky/MoteIVNode.java`:

```java
package se.sics.mspsim.platform.sky;
import se.sics.mspsim.chip.Button;
import se.sics.mspsim.chip.Leds;
import se.sics.mspsim.chip.SHT11;
import se.sics.mspsim.core.IOPort;

public abstract class MoteIVNode extends CC2420Node {

  public static final int MODE_LEDS_OFF = 0;
  public static final int MODE_LEDS_1 = 1;
  public static final int MODE_LEDS_2 = 2;
  public static final int MODE_LEDS_3 = 3;
  public static final int MODE_MAX = MODE_LEDS_3;
  // Port 2.
  public static final int BUTTON_PIN = 7;

  public static final int SHT11_CLK_PIN = 6;
  public static final int SHT11_DATA_PIN = 5;

  public static final int SHT11_CLK = 1 << SHT11_CLK_PIN;
  public static final int SHT11_DATA = 1 << SHT11_DATA_PIN;

  private static final int[] LEDS = { 0xff2020, 0x40ff40, 0x4040ff };
  public static final int BLUE_LED = 0x40;
  public static final int GREEN_LED = 0x20;
  public static final int RED_LED = 0x10;

  public boolean redLed;
  public boolean blueLed;
  public boolean greenLed;

  private Leds leds;
  private Button button;
  public SHT11 sht11;

  public SkyGui gui;

  public MoteIVNode(String id) {
    super(id);
    setMode(MODE_LEDS_OFF);
  }

  public Leds getLeds() {
      return leds;
  }

  public Button getButton() {
      return button;
  } 

  @Deprecated
  public void setButton(boolean buttonPressed) {
      button.setPressed(buttonPressed);
  }

  public void setupNodePorts() {
    super.setupNodePorts();

    leds = new Leds(cpu, LEDS);
    button = new Button("Button", cpu, port2, BUTTON_PIN, true);
    sht11 = new SHT11(cpu);
    sht11.setDataPort(port1, SHT11_DATA_PIN);
  }

  public void setupGUI() {
    if (gui == null) {
      gui = new SkyGui(this);
      registry.registerComponent("nodegui", gui);
    }
  }

  public void portWrite(IOPort source, int data) {
    super.portWrite(source, data);

    if (source == port5) {
      redLed = (data & RED_LED) == 0;
      blueLed = (data & BLUE_LED) == 0;
      greenLed = (data & GREEN_LED) == 0;
      leds.setLeds((redLed ? 1 : 0) + (greenLed ? 2 : 0) + (blueLed ? 4 : 0));
      int newMode = (redLed ? 1 : 0) + (greenLed ? 1 : 0) + (blueLed ? 1 : 0);
      setMode(newMode);
    } else if (source == port1) {
      sht11.clockPin((data & SHT11_CLK) != 0);
      sht11.dataPin((data & SHT11_DATA) != 0);
    }
  }
  
  public int getModeMax() {
    return MODE_MAX;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/platform/sky/CC2420Node.java`:

```java
package se.sics.mspsim.platform.sky;
import se.sics.mspsim.chip.CC2420;
import se.sics.mspsim.chip.DS2411;
import se.sics.mspsim.chip.PacketListener;
import se.sics.mspsim.config.MSP430f1611Config;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.PortListener;
import se.sics.mspsim.core.USART;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.extutil.jfreechart.DataChart;
import se.sics.mspsim.extutil.jfreechart.DataSourceSampler;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.ui.SerialMon;
import se.sics.mspsim.util.ELF;
import se.sics.mspsim.util.NetworkConnection;
import se.sics.mspsim.util.OperatingModeStatistics;

public abstract class CC2420Node extends GenericNode implements PortListener, USARTListener {

    // Port 2.
    public static final int DS2411_DATA_PIN = 4;
    public static final int DS2411_DATA = 1 << DS2411_DATA_PIN;

    /* P1.0 - Input: FIFOP from CC2420 */
    /* P1.3 - Input: FIFO from CC2420 */
    /* P1.4 - Input: CCA from CC2420 */
    public static final int CC2420_FIFOP = 0;
    public static final int CC2420_FIFO = 3;
    public static final int CC2420_CCA = 4;

    /* P4.1 - Input: SFD from CC2420 */
    /* P4.5 - Output: VREG_EN to CC2420 */
    /* P4.2 - Output: SPI Chip Select (CS_N) */
    public static final int CC2420_SFD = 1;
    public static final int CC2420_VREG = (1 << 5);
    public static final int CC2420_CHIP_SELECT = 0x04;

    protected IOPort port1;
    protected IOPort port2;
    protected IOPort port4;
    protected IOPort port5;

    public CC2420 radio;
    public DS2411 ds2411;

    protected String flashFile;

    public CC2420Node(String id) {
        /* this should be a config for the MSP430x1611 */
        super(id, new MSP430f1611Config());
    }

    public void setDebug(boolean debug) {
        cpu.setDebug(debug);
    }

    public boolean getDebug() {
        return cpu.getDebug();
    }

    public ELF getElfInfo() {
        return elf;
    }

    public void setNodeID(int id) {
        ds2411.setMACID(id & 0xff, id & 0xff, id & 0xff, (id >> 8) & 0xff, id & 0xff, id & 0xff);
    }

    public void setupNodePorts() {
        ds2411 = new DS2411(cpu);

        port1 = cpu.getIOUnit(IOPort.class, "P1");
        port1.addPortListener(this);

        port2 = cpu.getIOUnit(IOPort.class, "P2");
        ds2411.setDataPort(port2, DS2411_DATA_PIN);
        port2.addPortListener(this);

        port4 = cpu.getIOUnit(IOPort.class, "P4");
        port4.addPortListener(this);

        port5 = cpu.getIOUnit(IOPort.class, "P5");
        port5.addPortListener(this);

        USART usart0 = cpu.getIOUnit(USART.class, "USART0");
        radio = new CC2420(cpu);
        radio.setCCAPort(port1, CC2420_CCA);
        radio.setFIFOPPort(port1, CC2420_FIFOP);
        radio.setFIFOPort(port1, CC2420_FIFO);

        usart0.addUSARTListener(this);
        radio.setSFDPort(port4, CC2420_SFD);

        USART usart = cpu.getIOUnit(USART.class, "USART1");
        if (usart != null) {
            registry.registerComponent("serialio", usart);
        }
    }

    public void setupNode() {
        // create a filename for the flash file
        // This should be possible to take from a config file later!
        String fileName = config.getProperty("flashfile");
        if (fileName == null) {
            fileName = firmwareFile;
            if (fileName != null) {
                int ix = fileName.lastIndexOf('.');
                if (ix > 0) {
                    fileName = fileName.substring(0, ix);
                }
                fileName = fileName + ".flash";
            }
        }
        if (DEBUG) System.out.println("Using flash file: " + (fileName == null ? "no file" : fileName));

        this.flashFile = fileName;

        setupNodePorts();

        if (stats != null) {
            stats.addMonitor(this);
            stats.addMonitor(radio);
            stats.addMonitor(cpu);
        }
        if (!config.getPropertyAsBoolean("nogui", true)) {
            setupGUI();

            // Add some windows for listening to serial output
            USART usart = cpu.getIOUnit(USART.class, "USART1");
            if (usart != null) {
                SerialMon serial = new SerialMon(usart, "USART1 Port Output");
                registry.registerComponent("serialgui", serial);
            }
            if (stats != null) {
                // A HACK for some "graphs"!!!
                DataChart dataChart =  new DataChart(registry, "Duty Cycle", "Duty Cycle");
                registry.registerComponent("dutychart", dataChart);
                DataSourceSampler dss = dataChart.setupChipFrame(cpu);
                dataChart.addDataSource(dss, "LEDS", stats.getDataSource(getID(), 0, OperatingModeStatistics.OP_INVERT));
                dataChart.addDataSource(dss, "Listen", stats.getDataSource(radio.getID(), CC2420.MODE_RX_ON));
                dataChart.addDataSource(dss, "Transmit", stats.getDataSource(radio.getID(), CC2420.MODE_TXRX_ON));
                dataChart.addDataSource(dss, "CPU", stats.getDataSource(cpu.getID(), MSP430.MODE_ACTIVE));
            }
        }

        if (config.getPropertyAsBoolean("enableNetwork", false)) {
            final NetworkConnection network = new NetworkConnection();
            final RadioWrapper radioWrapper = new RadioWrapper(radio);
            radioWrapper.addPacketListener(new PacketListener() {
                public void transmissionStarted() {
                }
                public void transmissionEnded(byte[] receivedData) {
//                    System.out.println("**** Sending data len = " + receivedData.length);
//                    for (int i = 0; i < receivedData.length; i++) {
//                        System.out.println("Byte: " + Utils.hex8(receivedData[i]));
//                    }
                    network.dataSent(receivedData);
                }
            });

            network.addPacketListener(new PacketListener() {
                public void transmissionStarted() {
                }
                public void transmissionEnded(byte[] receivedData) {
//                    System.out.println("**** Receiving data = " + receivedData.length);
                    radioWrapper.packetReceived(receivedData);
                }
            });
        }
    }

    public void setupGUI() {
    }

    public void portWrite(IOPort source, int data) {
        if (source == port4) {
            // Chip select = active low...
            radio.setChipSelect((data & CC2420_CHIP_SELECT) == 0);
            radio.setVRegOn((data & CC2420_VREG) != 0);
            //radio.portWrite(source, data);
            flashWrite(source, data);
        } else if (source == port2) {
            ds2411.dataPin((data & DS2411_DATA) != 0);
        }
    }

    protected abstract void flashWrite(IOPort source, int data);

    public abstract void dataReceived(USARTSource source, int data);

    public void stateChanged(int state) {
        // Ignore UART state changes by default
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/debug/StabFile.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * StabDebug
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2009
 * Updated : $Date: 2010-07-09 23:22:13 +0200 (Fri, 09 Jul 2010) $
 *           $Revision: 717 $
 */

package se.sics.mspsim.debug;

import java.util.ArrayList;
import java.util.HashMap;
import se.sics.mspsim.debug.StabDebug.Stab;

public class StabFile {

    public int startAddress;

    public String path;
    public String file;

    public int stabIndex;
    
    private ArrayList<StabFunction> functions = new ArrayList<StabFunction>();
    private HashMap<String, StabType> types = new HashMap<String,StabType>();
    private StabFunction lastFunction;
    
    public void handleStabs(Stab[] stabs) {
        int i = stabIndex;
        while(i < stabs.length) {
            StabDebug.Stab stab = stabs[i];
            System.out.println("Handling stab: " + stab);
            switch(stab.type) {
            case StabDebug.N_SO:
                if (stab.value != startAddress) {
                    return;
                }
                if (stab.data.length() > 0) {
                    if (path == null) {
                        path = stab.data;
                    } else if (file == null) {
                        file = stab.data;
                    }
                }
                i++;
                break;
            case StabDebug.N_FUN:
                i += addFunction(i, stabs);
                break;
            case StabDebug.N_LSYM:
                i += addType(i, stabs);
                break;
            default:
                i++;
            }
        }
    }
    
    private int addType(int i, Stab[] stabs) {
        Stab stab = stabs[i];
        StabType type = new StabType(stab, types);
        types.put(type.name, type);
        types.put(type.internalName, type);
        return 1;
    }

    private int addFunction(int i, Stab[] stabs) {
        int index = i;
        Stab stab = stabs[index];
        /* name:ReturnType */
        if (stab.data.length() == 0) {
           /* just ens last function */
           if (lastFunction != null) {
               lastFunction.endAddress = lastFunction.startAddress + stab.value;
           }
           return 1;
        }
        StabFunction fun = new StabFunction();
        functions.add(fun);
        lastFunction = fun;
        String[] fname = stab.data.split(":");
        fun.name = fname[0];
        fun.returnType = fname[1];
        fun.startAddress = stab.value;
        fun.startLine = stab.desc;
        index++;

        while (index < stabs.length && isParam(stabs[index])) {
            fun.addParameter(stabs[index]);
            index++;
        }

        return index - i;
    }

    private boolean isParam(Stab stab) {
        return (stab.type == StabDebug.N_REG_PARAM ||
            stab.type == StabDebug.N_VAR_PARAM);
    }

    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("File: " + path + file + " starts at: " + startAddress + "\n");
        for (int i = 0; i < functions.size(); i++) {
            sb.append("  ").append(functions.get(i)).append("\n");
        }
        return sb.toString();
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/debug/StabFunction.java`:

```java

package se.sics.mspsim.debug;

import java.util.ArrayList;
import se.sics.mspsim.util.Utils;
import se.sics.mspsim.debug.StabDebug.Stab;

public class StabFunction {

    public String name;
    public String returnType; /* string representation of return type */
    public ArrayList<Param> params;
    public int endAddress;
    public int startAddress;
    public int startLine;

    public void addParameter(Stab stab) {
        if (params == null) params = new ArrayList<Param>();
        String[] name = stab.data.split(":");
        params.add(new Param(name[0]));
    }
    
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Function: " + name);
        if (params != null) {
            sb.append("(");
            for (int i = 0; i < params.size(); i++) {
                if (i > 0) sb.append(", ");
                sb.append(params.get(i).name);
            }
            sb.append(")");
            sb.append(" at ").append(Utils.hex16(startAddress));
            sb.append(" - ").append(Utils.hex16(endAddress));
        }
        return sb.toString();
    }
    
    static class Param {
        String name;
        Param(String name) {
            this.name = name;
        }
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/debug/DwarfReader.java`:

```java
/**
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * DwarfReader
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date: 2010-07-09 23:22:13 +0200 (Fri, 09 Jul 2010) $
 *           $Revision: 717 $
 */

package se.sics.mspsim.debug;

import java.io.File;
import java.util.ArrayList;

import se.sics.mspsim.util.DebugInfo;
import se.sics.mspsim.util.ELF;
import se.sics.mspsim.util.ELFDebug;
import se.sics.mspsim.util.ELFSection;
import se.sics.mspsim.util.Utils;

public class DwarfReader implements ELFDebug {

    public static final boolean DEBUG = false;

    /* Operands for lines */
    public static final int    DW_LNS_EXT = 0;

    public static final int    DW_LNS_copy = 1;
    public static final int    DW_LNS_advance_pc = 2;
    public static final int    DW_LNS_advance_line = 3;
    public static final int    DW_LNS_set_file = 4;
    public static final int    DW_LNS_set_column = 5;
    public static final int    DW_LNS_negate_stmt = 6;
    public static final int    DW_LNS_set_basic_block = 7;
    public static final int    DW_LNS_const_add_pc = 8;
    public static final int    DW_LNS_fixed_advance_pc = 9;
    public static final int    DW_LNS_set_prologue_end = 10;
    public static final int    DW_LNS_set_epilogue_begin = 11;
    public static final int    DW_LNS_set_isa = 12;

    /* Extended operands (preceded by DW_LNS_EXT + len) */
    public static final int    DW_LNE_end_sequence = 1;
    public static final int    DW_LNE_set_address = 2;
    public static final int    DW_LNE_define_file = 3;
    public static final int    DW_LNE_set_discriminator = 4; /* DWARF > 2.0 */

    ELF elfFile;

    /* Address ranges */
    static class Arange {
        int length;
        int version;
        int offset;
        int addressSize;
        int segmentSize;
    }

    static class LineEntry {
        int address;
        int line;
        int file;
        LineEntry(int line, int adr, int file) {
            this.line = line;
            this.address = adr;
            this.file = file;
        }
    }
    /* Line number lookup data */
    static class LineData {
        String[] includeDirs;
        String[] sourceFiles;
        LineEntry[] lineEntries;
    }

    ArrayList<LineData> lineInfo = new ArrayList<LineData>();

    /* some state for the line number handling */
    private int lineAddress;
    private int lineFile;
    private int lineLine;
    private int lineColumn;
    private boolean isBasicBlock = false;
    private boolean isStatement = false;
    private boolean endSequence = false;

    private ArrayList<Arange> aranges = new ArrayList<Arange>();

    public DwarfReader(ELF elfFile) {
        this.elfFile = elfFile;
    }

    public void read() {
        for (int i = 0; i < elfFile.getSectionCount(); i++) {
            ELFSection sec = elfFile.getSection(i);
            String name = sec.getSectionName();
            if (DEBUG) System.out.println("DWARF Section: " + name);
            if (".debug_aranges".equals(name)) {
                readAranges(sec);
            } else if (".debug_line".equals(name)) {
                readLines(sec);
            }
        }
    }

    private void readLines(ELFSection sec) {
        if (DEBUG) {
            System.out.println("DWARF Line - ELF Section length: " + sec.getSize());
        }

        sec.reset();
        int endPos = 0;
        ArrayList<LineEntry> lineData = new ArrayList<LineEntry>();
        while (sec.getPosition() < sec.getSize()) {
            if (DEBUG) System.out.println(" --- Reading debug info --- ");
            /* here starts the reading of one file's (?) debug info */
            int totLen = sec.readElf32();
            int version = sec.readElf16();
            int proLen = sec.readElf32();
            int minOpLen = sec.readElf8();

            int defaultIsStmt = sec.readElf8();
            int lineBase = Integer.valueOf(sec.readElf8()).byteValue();
            int lineRange = sec.readElf8();
            int opcodeBase = sec.readElf8();

            endPos += 4 + totLen;
            if (DEBUG) {
                System.out.println("Line total length: " + totLen + " endPos: " + endPos);
                System.out.println("Line pro length: " + proLen);
                System.out.println("Line version: " + version);
            }

            if (DEBUG) {
                System.out.println("Line base  : " + lineBase);
                System.out.println("Line range : " + lineRange);
                System.out.println("Line - Opcode base: " + opcodeBase);
            }

            /* first char of includes (skip opcode lens)... */
            for (int i = 0; i < opcodeBase - 1; i++) {
                sec.readElf8();
            }

            //        pos = pos + 15 + opcodeBase - 1;
            //        System.out.println("Line pos = " + pos + " sec-pos = " + sec.getPosition());
            if (DEBUG) System.out.println("Line --- include files ---");
            ArrayList<String> directories = new ArrayList<String>();
            directories.add("./");
            ArrayList<String> files = new ArrayList<String>();
            StringBuilder sb = new StringBuilder();

            /* if first char is zero => no more include directories... */
            int c;
            while ((c = sec.readElf8()) != 0) {
                sb.append((char)c);
                while((c = sec.readElf8()) != 0) {
                  sb.append((char) c);
                }

                if (DEBUG) System.out.println("Line: include file: " + sb.toString());
                directories.add(sb.toString());
                sb.setLength(0);
            }

            if (DEBUG) System.out.println("Line --- source files ---");
            long dirIndex = 0;
            long time = 0;
            long size = 0;
            while ((c = sec.readElf8()) != 0) {
                sb.append((char)c);
                while((c = sec.readElf8()) != 0) {
                  sb.append((char) c);
                }

                dirIndex = sec.readLEB128();
                time = sec.readLEB128();
                size = sec.readLEB128();

                if (DEBUG) System.out.println("Line: source file: " + sb.toString() + "  dir: " + dirIndex + " size: " + size);
                files.add(directories.get((int) dirIndex) + "/" + sb.toString());
                sb.setLength(0);
            }


            /* Now we should have entered the position of the "code" for generating the
             * line <=> address table
             */
            if (DEBUG) {
                System.out.println("Line: position: " + sec.getPosition() + " endPos: " + endPos);
                System.out.println("Line: first bytes of the machine: ");
                System.out.print("Line: ");
            }

            while (sec.getPosition() < endPos) {
                /* reset the "state" of the state machine (6.2.2 spec) */
                lineAddress = 0;
                lineFile = 1;
                lineLine = 1;
                lineColumn = 0;
                endSequence = false;
                isStatement = defaultIsStmt != 0;
                isBasicBlock = false;

                lineData.clear();

                while(!endSequence) {
                    int opCode = sec.readElf8();
                    if (DEBUG) System.out.print("POS: " + sec.getPosition() + " INS: " + Utils.hex8(opCode) + " ");
                    switch(opCode) {
                    case DW_LNS_EXT:
                        /* extended opcodes */
                        int len = (int) sec.readLEB128();
                        int extPos = sec.getPosition();
                        int extIns = sec.readElf8();
                        if (DEBUG) System.out.println("EXT: " + Utils.hex8(extIns) + " LEN: " + len);
                        switch(extIns) {
                        case DW_LNE_end_sequence:
                            endSequence = true;
                            lineData.add(new LineEntry(lineLine, lineAddress, lineFile));

                            lineAddress = 0;
                            lineFile = 1;
                            lineLine = 1;
                            lineColumn = 0;
                            isStatement = defaultIsStmt != 0;
                            isBasicBlock = false;

                            if (DEBUG) System.out.println("Line: End sequence executed!!!");
                            break;
                        case DW_LNE_set_address:
                            if (len == 3) {
                                lineAddress = sec.readElf16();
                            } else if (len == 5) {
                                lineAddress = sec.readElf32();
                            } else {
                                throw new IllegalStateException("No support for " + (len - 1) + " bytes addresses");
                            }
                            if (DEBUG) System.out.println("Line: Set address to: " + Utils.hex16(lineAddress) +
                                    " (len: " + len + ")");
                            break;
                        case DW_LNE_define_file: {
                          /* XXX TODO Implement me */
                          String filename = sec.readString();
                          long directoryIndex = sec.readLEB128();
                          long lastModified = sec.readLEB128();
                          long fileSize = sec.readLEB128();
                          if (DEBUG) System.out.println("Line: Should define the file '" + filename + "' dir "
                                  + directoryIndex + " modified " + lastModified + " size " + fileSize);
                          break;
                        }
                        case DW_LNE_set_discriminator: // DWARF 4.0?
                            /* currently just read it but ignore it - TODO: use this info */
                          /*reg_discriminator = */sec.readElf8();
                          if (DEBUG) System.out.println("Line: Should support DW_LNE_set_discriminator");
                          break;
                        default:
                          /* XXX TODO Implement me */
                          if (DEBUG) System.out.println("Line: unhandled EXT instr: " + Utils.hex8(extIns));
                        }
                        if (sec.getPosition() != extPos + len) {
                            throw new IllegalStateException("*** ERROR posistion is not as exepected!!!!" + (extPos + len) + " is " +
                                    sec.getPosition());
                        }
                        break;
                    case DW_LNS_copy:
                        /* copy data to matrix... */
                        if (DEBUG) System.out.println("Line: copy data (" + lineLine + "," +
                                Utils.hex16(lineAddress) + ") to matrix...");
                        lineData.add(new LineEntry(lineLine, lineAddress, lineFile));
                        isBasicBlock = false;
                        break;
                    case DW_LNS_advance_pc:
                        long add = sec.readLEB128();
                        lineAddress += minOpLen * add;
                        if (DEBUG) System.out.println("Line: Increased address to: " + Utils.hex16(lineAddress));
                        break;
                    case DW_LNS_advance_line:
                        long addLine = sec.readLEB128S();
                        lineLine += addLine;
                        if (DEBUG) System.out.println("Line: Increased line to: " + lineLine +
                                " (incr: " + addLine + ")");
                        break;
                    case DW_LNS_set_file:
                        lineFile = (int) sec.readLEB128();
                        if (DEBUG) System.out.println("Line: Set file to: " + lineFile);
                        break;
                    case DW_LNS_set_column:
                        lineColumn = (int) sec.readLEB128();
                        if (DEBUG) System.out.println("Line: set column to: " + lineColumn);
                        break;
                    case DW_LNS_negate_stmt:
                        isStatement = !isStatement;
                        if (DEBUG) System.out.println("Line: Negated is statement");
                        break;
                    case DW_LNS_set_basic_block:
                        isBasicBlock = true;
                        if (DEBUG) System.out.println("Line: Set basic block to true");
                        break;
                    case DW_LNS_const_add_pc:
                        if (DEBUG) System.out.println("Line: *** Should add const to PC - but how much - same as FF??");
                        {
                          int adjustedOpcode = 255 - opcodeBase;
                          int operationAdvance = adjustedOpcode / lineRange;
                          lineAddress += minOpLen * operationAdvance;
                        }

                        break;
                    case DW_LNS_fixed_advance_pc:
                        int incr = sec.readElf16();
                        lineAddress += incr;
                        if (DEBUG) System.out.println("Line: *** Increased address to: " + Utils.hex16(lineAddress));
                        break;
                    case DW_LNS_set_prologue_end:
                      /*reg_prologue_end = true;*/
                      break;
                    case  DW_LNS_set_epilogue_begin:
                      /*reg_epilogue_begin = true;*/
                      break;
                    case  DW_LNS_set_isa:
                      /*reg_isa = (int) */ sec.readLEB128();
                      break;
                    default:
                        if (DEBUG) {
                            System.out.println("INS: " + Utils.hex8(opCode) + " AINS: " + Utils.hex8(opCode - opcodeBase)
                                    + " lineRange: " + lineRange);
                        }

                        int adjustedOpcode = opCode - opcodeBase;
                        int operationAdvance = adjustedOpcode / lineRange;

                        int lineInc = lineBase + (adjustedOpcode % lineRange);
                        lineLine += lineInc;

                        lineAddress += minOpLen * operationAdvance;
                        lineData.add(new LineEntry(lineLine, lineAddress, lineFile));
                        isBasicBlock = false;

                        if (DEBUG) System.out.println("Line: *** Special operation => addr: " +
                                Utils.hex16(lineAddress) + " Line: " + lineLine + " lineInc: " + lineInc);
                    }
                }
                if (DEBUG) System.out.println("Line - Position " + sec.getPosition() + " totLen: " + totLen +
                        " endPos: " + endPos);

                if (lineData.size() > 0) {
                    /* create a block of line-address data that can be used for lookup later.*/
                    LineData lineTable = new LineData();
                    lineTable.lineEntries = lineData.toArray(new LineEntry[0]);
                    lineTable.includeDirs = directories.toArray(new String[0]);
                    lineTable.sourceFiles = files.toArray(new String[0]);
                    lineInfo.add(lineTable);
                }
            }
        }

        /* Now we have some tables of data where it should be possible to sort out which
         * addresses correspond to which lines!?
         */


        if (DEBUG) {
            for (LineData data : lineInfo) {
                System.out.println("Compiled file: " + data.sourceFiles[0]);
                System.out.println("Start address: " +
                        Utils.hex16(data.lineEntries[0].address));
                System.out.println("End  address: " +
                        Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address));
                System.out.println("Size: " +
                        Utils.hex16(data.lineEntries[data.lineEntries.length - 1].address - data.lineEntries[0].address));
            }
        }
    }

    /* DWARF - address ranges information */
    private void readAranges(ELFSection sec) {
        if (DEBUG) System.out.println("DWARF Aranges - ELF Section length: " + sec.getSize());
        int pos = 0;
        int index = 0;
        do {
            Arange arange = new Arange();
            /* here we should read the address data */
            arange.length = sec.readElf32(pos + 0); /* length not including the length field */
            arange.version = sec.readElf16(pos + 4); /* version */
            arange.offset = sec.readElf32(pos + 6); /* 4 byte offset into debug_info section (?)*/
            arange.addressSize = sec.readElf8(pos + 10); /* size of address */
            arange.segmentSize = sec.readElf8(pos + 11); /* size of segment descriptor */
            if (DEBUG) {
                System.out.println("DWARF: aranges no " + index);
                System.out.println("DWARF: Length: " + arange.length);
                System.out.println("DWARF: Version: " + arange.version);
                System.out.println("DWARF: Offset: " + arange.offset);
                System.out.println("DWARF: Address size: " + arange.addressSize);
            }

            index++;
            pos += 12;
            if (arange.addressSize == 2) {
                /* these needs to be added too! */
                int addr, len;
                do {
                    addr = sec.readElf16(pos);
                    len = sec.readElf16(pos + 2);
                    pos += 4;
                    if (DEBUG) System.out.println("DWARF: ($" + Utils.hex16(addr) + "," + len + ")");
                } while (addr != 0 || len != 0);
            }
        } while (pos < sec.getSize());
    }

    /* Access methods for data... */
    public DebugInfo getDebugInfo(int address) {
        for (int i = 0; i < lineInfo.size(); i++) {
            LineData data = lineInfo.get(i);
            int start = data.lineEntries[0].address;
            int end = data.lineEntries[data.lineEntries.length - 1].address;
            /* XXX ignore all line entries starting on address 0 */
            if (start == 0) continue;

            if (address <= end && address >= start) {
                for (int j = 0; j < data.lineEntries.length; j++) {
                  LineEntry lineEntry = data.lineEntries[j];
                  int startEntry = lineEntry.address;
                  int endEntry;
                  if (j+1 < data.lineEntries.length) {
                    endEntry = data.lineEntries[j+1].address-1;
                  } else {
                    /* do not match prologue entries */
                    continue;
                  }
                  if (address >= startEntry &&
                      address <= endEntry) {
                    return new DebugInfo(lineEntry.line, null, data.sourceFiles[lineEntry.file-1], "* not available");
                  }
                }
            }
        }
        return null;
    }

    public ArrayList<Integer> getExecutableAddresses() {
        ArrayList<Integer> executableAddresses = new ArrayList<Integer>();
        for (LineData data: lineInfo) {
            for (LineEntry entry: data.lineEntries) {
                executableAddresses.add(entry.address);
            }
        }
	return executableAddresses;
    }

    public String[] getSourceFiles() {
        String[] sourceFilesArray = new String[lineInfo.size()];
        for (int i = 0; i < lineInfo.size(); i++) {
            sourceFilesArray[i] = lineInfo.get(i).sourceFiles[0];
        }

        return sourceFilesArray;
    }

    public static void main(String[] args) throws Exception {
      /* This method goes through all possible executable addresses, and
       * generates an output comparable to that of msp430-addr2line. */

      /* Example usage:
       * > java se/sics/mspsim/debug/DwarfReader hello-world.sky > cmp.dwarfmspsim */
      /* Example output:
       * 0x00000000
       * ??:0
       * 0x00000001
       * ??:0
       * ... */

      /* Comparison with msp430-addr2line output example:
       * > for A in {0..65535}; do printf "%x\n" $A; done > TMP
       * > cat TMP | msp430-addr2line -p -a -s -e hello-world.sky > cmp.addr2line
       * > rm TMP
       *
       * > diff -y --suppress-common-lines cmp.addr2line cmp.dwarfmspsim */

      ELF elf = ELF.readELF(args[0]);
      DwarfReader dwarfReader = new DwarfReader(elf);
      dwarfReader.read();
      if (args.length > 1) {
        int address = Integer.parseInt(args[1], 16);
        DebugInfo debugInfo = dwarfReader.getDebugInfo(address);
        if (debugInfo == null) {
          System.out.println(String.format("0x%08x", address) + ": "
              + "??" + ":" + "0");
        } else {
          System.out.println(String.format("0x%08x", address) + ": "
              + new File(debugInfo.getFile()).getName() + ":" + debugInfo.getLine());
        }
      } else {
        for (int address = 0; address <= 0xffff; address++) {
          DebugInfo debugInfo = dwarfReader.getDebugInfo(address);
          if (debugInfo == null) {
            System.out.println(String.format("0x%08x", address) + ": "
                + "??" + ":" + "0");
          } else {
            System.out.println(String.format("0x%08x", address) + ": "
                + new File(debugInfo.getFile()).getName() + ":" + debugInfo.getLine());
          }
        }
      }
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/debug/StabType.java`:

```java
package se.sics.mspsim.debug;

import java.util.HashMap;
import se.sics.mspsim.debug.StabDebug.Stab;

public class StabType {

    String name;
    String internalName;
    int size;
    boolean signed;
    StabType typeDef;

    private HashMap<String,StabType> types;

    /* typical stab that define a type */
    /* int:t(0,1)=r(0,1);-32768;32767; */
    public StabType(Stab stab, HashMap<String,StabType> types) {
        this.types = types;
        String typeDef = stab.data;
        String[] parts = typeDef.split(":");
        name = parts[0];
        parts = parts[1].split("=");
        internalName = parts[0];
        if (!handleKnown(name)) {
            for (int i = 0; i < parts.length; i++) {
                handleTypeDef(parts[i]);
            }
        }
    }

    public int getSize() {
        if (typeDef != null) return typeDef.getSize();
        return size;
    }

    private void signed(int size) {
        this.size = size;
        signed = true;
    }
    
    private void unsigned(int size) {
        this.size = size;
        signed = false;
    }
    
    /* handle the known types */
    private boolean handleKnown(String name) {
        if ("int".equals(name)) {
            signed(2);
        } else if ("unsigned int".equals(name)) {
            unsigned(2);
        } else if ("char".equals(name)) {
            unsigned(1);
        } else if ("unsigned char".equals(name)) {
            unsigned(1);
        } else if ("signed char".equals(name)) {
            signed(1);
        } else if ("long int".equals(name)) {
            signed(4);
        } else if ("long unsigned int".equals(name)) {
            unsigned(4);
        } else if ("long long int".equals(name)) {
            signed(8);
        } else {
            return false;
        }
        return true;
    }

    /* format:
     *  r(0,1);-321768;32767; (int)
     *  R3;8;0;
     *  r(0,1);4;0; (float)
     *  or (0,1) => same as type t(0,1)
     *   */
    private void handleTypeDef(String def) {
        if (def.startsWith("(")) {
            StabType tDef = types.get("t" + def);
            if (tDef != null) {
                typeDef = tDef;
            } else {
                System.out.println("ERROR: can not find: " + def);
            }
        }
    }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/debug/StabDebug.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * StabDebug
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date: 2010-07-09 23:22:13 +0200 (Fri, 09 Jul 2010) $
 *           $Revision: 717 $
 */

package se.sics.mspsim.debug;
import java.util.ArrayList;

import se.sics.mspsim.util.DebugInfo;
import se.sics.mspsim.util.ELF;
import se.sics.mspsim.util.ELFDebug;
import se.sics.mspsim.util.ELFSection;
import se.sics.mspsim.util.Utils;

public class StabDebug implements ELFDebug {

  private Stab[] stabs;

  public static final int N_FUN = 0x24;
  public static final int N_STSYM = 0x26; // Data segment file-scope variable; 
  public static final int N_LCSYM = 0x28; // BSS segment file-scope variable;
  public static final int N_REG_PARAM= 0x40;
  public static final int N_VAR_PARAM= 0xa0;
  public static final int N_SLINE = 0x44;
  public static final int N_SO = 0x64; // filename and path
  public static final int N_LSYM = 0x80; // stack var, typdef or struct

  public static final boolean DEBUG = false;

  ELFSection dbgStab;
  ELFSection dbgStabStr;

  public StabDebug(ELF elf, ELFSection stab, ELFSection stabstr) {
    dbgStab = stab;
    dbgStabStr = stabstr;

    int len = dbgStab.getSize();
    int count = len / dbgStab.getEntrySize();
    int addr = dbgStab.getOffset();

    if (DEBUG) {
      System.out.println("Number of stabs:" + count);
    }
    stabs = new Stab[count];
    for (int i = 0, n = count; i < n; i++) {
      elf.setPos(addr);
      int nI = elf.readElf32();
      String stabData = elf.dbgStabStr.getName(nI);
      int type = elf.readElf8();
      int other = elf.readElf8();
      int desc = elf.readElf16();
      int value = elf.readElf32();
      stabs[i] = new Stab(stabData, type, other, desc, value);

      if (DEBUG) {
	System.out.println("Stab: " + Utils.hex8(type) +
			   " '" + stabData + "' o:" + other
			   + " d:" + desc + " v:" + value);
      }
      addr += dbgStab.getEntrySize();
    }
    // getStabFiles();
  }

  public StabFile[] getStabFiles() {
      ArrayList<StabFile> files = new ArrayList<>();
      StabFile currentFile = null;
      for (int i = 0, n = stabs.length; i < n; i++) {
          Stab stab = stabs[i];
          switch(stab.type) {
          case N_SO:
              if (currentFile == null || currentFile.startAddress != stab.value) {
                  /* end of file ? */
                  currentFile = new StabFile();
                  files.add(currentFile);
                  currentFile.startAddress = stab.value;
                  currentFile.stabIndex = i;
                  currentFile.handleStabs(stabs);
                  System.out.println("Found: " + currentFile);
              }
              break;
          }
      }
      return files.toArray(new StabFile[0]);
  }
  
  
  /* Just pick up file + some other things */
  public DebugInfo getDebugInfo(int address) {
    String currentPath = null;
    String currentFile = null;
    String currentFunction = null;
    int lastAddress = 0;
    int currentLine = 0;
    int currentLineAdr = 0;
    for (int i = 0, n = stabs.length; i < n; i++) {
      Stab stab = stabs[i];
      switch(stab.type) {
      case N_SO:
	if (stab.value < address) {
	  if (stab.data != null && stab.data.endsWith("/")) {
	    currentPath = stab.data;
          } else {
	    currentFile = stab.data;
          }
          lastAddress = stab.value;
          currentFunction = null;
        } else {
	  /* requires sorted order of all file entries in stab section */
	  if (DEBUG) {
	    System.out.println("FILE: Already passed address..." +
			       currentPath + " " +
			       currentFile + " " + currentFunction);
	  }
	  return null;
	}
	break;
      case N_SLINE:
	if (currentPath != null) { /* only files with path... */
	  if (currentLineAdr < address) {
	    currentLine = stab.desc;
	    currentLineAdr = lastAddress + stab.value;
	    if (currentLineAdr >= address) {
	      // Finished!!!
	      if (DEBUG) {
		System.out.println("File: " + currentPath + " " + currentFile);
		System.out.println("Function: " + currentFunction);
		System.out.println("Line No: " + currentLine);
	      }
	      return new DebugInfo(currentLine, currentPath, currentFile,
				   currentFunction);
	    }
	  }
	}
	break;
      case N_FUN:
	if (stab.value < address) {
	  currentFunction = stab.data;
	  lastAddress = stab.value;
	} else {
	  if (DEBUG) {
	    System.out.println("FUN: Already passed address...");
	  }
	  return null;
	}
	break;
      }
    }
    return null;
  }

  public ArrayList<Integer> getExecutableAddresses() {
    ArrayList<Integer> allAddresses = new ArrayList<>();

    int address = Integer.MAX_VALUE;

    String currentPath = null;
    String currentFile = null;
    String currentFunction = null;
    int lastAddress = 0;
//    int currentLine = 0;
    int currentLineAdr = 0;
    for (Stab stab : stabs) {
      switch(stab.type) {
      case N_SO:
        if (stab.value < address) {
          if (stab.data != null && stab.data.endsWith("/")) {
            currentPath = stab.data;
            lastAddress = stab.value;
            allAddresses.add(lastAddress);
            currentFunction = null;
          } else {
            currentFile = stab.data;
            lastAddress = stab.value;
            allAddresses.add(lastAddress);
            currentFunction = null;
          }
        } else {
          /* requires sorted order of all file entries in stab section */
          if (DEBUG) {
            System.out.println("FILE: Already passed address..." +
                currentPath + " " +
                currentFile + " " + currentFunction);
          }
          return allAddresses;
        }
        break;
      case N_SLINE:
        if (currentPath != null) { /* only files with path... */
          if (currentLineAdr < address) {
//            currentLine = stab.desc;
            currentLineAdr = lastAddress + stab.value;
            allAddresses.add(currentLineAdr);
            /*if (currentLineAdr >= address) {
              // Finished!!!
              if (DEBUG) {
                System.out.println("File: " + currentPath + " " + currentFile);
                System.out.println("Function: " + currentFunction);
                System.out.println("Line No: " + currentLine);
              }
              return new DebugInfo(currentLine, currentPath, currentFile,
                  currentFunction);
            }*/
          }
        }
        break;
      case N_FUN:
        if (stab.value < address) {
          currentFunction = stab.data;
          lastAddress = stab.value;
          allAddresses.add(lastAddress);
        } else {
          if (DEBUG) {
            System.out.println("FUN: Already passed address...");
          }
          return allAddresses;
        }
        break;
      }
    }
    return allAddresses;
}

  public String[] getSourceFiles() {
    String currentPath = null;
    String currentFile = null;
    ArrayList<String> sourceFiles = new ArrayList<>();

    for (Stab stab : stabs) {
      if (stab.type == N_SO) {
        if (stab.data != null && stab.data.endsWith("/")) {
          currentPath = stab.data;
        } else {
          currentFile = stab.data;

          if (currentFile != null && currentFile.length() > 0) {
            if (currentPath == null) {
              sourceFiles.add(currentFile);
            } else {
              sourceFiles.add(currentPath + currentFile);
            }
          }
        }
      }
    }

    String[] sourceFilesArray = new String[sourceFiles.size()];
    for (int i=0; i < sourceFilesArray.length; i++) {
      sourceFilesArray[i] = sourceFiles.get(i);
    }

    return sourceFilesArray;
  }

  public static class Stab {

    public String data;
    public int type;
    public int other;
    public int desc;
    public int value;

    Stab(String data, int type, int other, int desc, int value) {
      this.data = data;
      this.type = type;
      this.other = other;
      this.desc = desc;
      this.value = value;
    }
    
   public String toString() {
        return "" + Integer.toHexString(type) + " " + data +
            "   [" + other + "," + desc + "," + value + "]";
    }
  }

} // StabDebug

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/Main.java`:

```java
/*
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Main
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 6 nov 2008
 */

package se.sics.mspsim;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;

import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.util.ArgumentManager;

/**
 *
 */
public class Main {

  public static GenericNode createNode(String className) {
    try {
      Class<? extends GenericNode> nodeClass = Class.forName(className).asSubclass(GenericNode.class);
      return nodeClass.getDeclaredConstructor().newInstance();
    } catch (ClassNotFoundException | ClassCastException | InstantiationException | IllegalAccessException e) {
      // Can not find specified class, or wrong class type, or failed to instantiate
    } catch (InvocationTargetException | NoSuchMethodException e) {
        e.printStackTrace();
    }
      return null;
  }

  public static String getNodeTypeByPlatform(String platform) {
      if ("jcreate".equals(platform)) {
          return "se.sics.mspsim.platform.jcreate.JCreateNode";
      }
      if ("sentilla-usb".equals(platform)) {
          return "se.sics.mspsim.platform.sentillausb.SentillaUSBNode";
      }
      if ("esb".equals(platform)) {
          return "se.sics.mspsim.platform.esb.ESBNode";
      }
      if ("exp5438".equals(platform)) {
          return "se.sics.mspsim.platform.ti.Exp5438Node";
      }
      if ("exp1101".equals(platform)) {
          return "se.sics.mspsim.platform.ti.Exp1101Node";
      }
      if ("exp1120".equals(platform)) {
          return "se.sics.mspsim.platform.ti.Exp1120Node";
      }
      if ("cc430".equals(platform)) {
          return "se.sics.mspsim.platform.ti.CC430Node";
      }
      // Try to guess the node type.
      return "se.sics.mspsim.platform." + platform + '.'
          + Character.toUpperCase(platform.charAt(0))
          + platform.substring(1).toLowerCase() + "Node";
  }

  public static void main(String[] args) throws IOException {
    ArgumentManager config = new ArgumentManager();
    config.handleArguments(args);

    String nodeType = config.getProperty("nodeType");
    String platform = nodeType;
    GenericNode node;
    if (nodeType == null) {
      platform = config.getProperty("platform");
      if (platform == null) {
          // Default platform
          platform = "sky";

          // Guess platform based on firmware filename suffix.
          // TinyOS's firmware files are often named 'main.exe'.
          String[] a = config.getArguments();
          if (a.length > 0 && !"main.exe".equals(a[0])) {
              int index = a[0].lastIndexOf('.');
              if (index > 0) {
                  platform = a[0].substring(index + 1);
              }
          }
      }
      nodeType = getNodeTypeByPlatform(platform);
    }
    node = createNode(nodeType);
    if (node == null) {
      System.err.println("MSPSim does not currently support the platform '" + platform + "'.");
      System.exit(1);
    }
    node.setupArgs(config);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/plugin/ContikiChecker.java`:

```java
/*
 * Copyright (c) 2009, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ContikiChecker
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 7 sep 2009
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.plugin;
import java.util.Hashtable;

import se.sics.mspsim.cli.BasicAsyncCommand;
import se.sics.mspsim.cli.CommandContext;
import se.sics.mspsim.cli.CommandHandler;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.Memory.AccessMode;
import se.sics.mspsim.core.MemoryMonitor;
import se.sics.mspsim.core.Profiler;
import se.sics.mspsim.profiler.CallEntry;
import se.sics.mspsim.profiler.CallListener;
import se.sics.mspsim.util.ActiveComponent;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.MapEntry;

/**
 *
 */
public class ContikiChecker implements CallListener, ActiveComponent {

    private ComponentRegistry registry;

    private CommandContext context;
    private MemoryMonitor monitor;
    private MSP430 cpu;
    private Profiler profiler;

    private Hashtable<String,Integer> callTable = new Hashtable<String,Integer>();
    private int callCount = 0;

    public void init(String name, ComponentRegistry registry) {
        this.registry = registry;
    }

    public void start() {
        CommandHandler commandHandler = (CommandHandler) registry.getComponent("commandHandler");
        if (commandHandler != null) {
            commandHandler.registerCommand("contikichecker", new BasicAsyncCommand("enable the Contiki checker", "") {

                @Override
                public int executeCommand(final CommandContext context) {
                    if (profiler != null) {
                        context.err.println("already running");
                        return 1;
                    }
                    cpu = registry.getComponent(MSP430.class);
                    profiler = cpu.getProfiler();
                    if (profiler == null) {
                        context.err.println("no profiler available");
                        return 1;
                    }
                    ContikiChecker.this.context = context;
                    profiler.addCallListener(ContikiChecker.this);

                    context.out.println("Installing watchpoints...");
                    monitor = new MemoryMonitor.Adapter() {
                        @Override
                        public void notifyWriteBefore(int dstAddress, int data, AccessMode mode) {
                            context.out.println("Warning: write to " + dstAddress +
                                    " from " + profiler.getCall(0));
                                //profiler.printStackTrace(context.out);
                        }
                    };
                    for (int i = 0; i < 0x100; i++) {
                        cpu.addWatchPoint(i, monitor);
                    }
                    return 0;
                }

                public void stopCommand(CommandContext context) {
                    if (monitor != null) {
                        for (int i = 0; i < 0x100; i++) {
                            cpu.removeWatchPoint(i, monitor);
                        }
                        monitor = null;
                        cpu = null;
                    }
                    if (profiler != null) {
                        profiler.removeCallListener(ContikiChecker.this);
                        profiler = null;
                    }
                    ContikiChecker.this.context = null;
                }});
        }
    }

    public void functionCall(Profiler source, CallEntry callEntry) {
        MapEntry entry = callEntry.getFunction();
        // Check for function calls before <prefix>_init() has been called.
        String name = entry.getName();
        if (name != null && callTable.get(name) == null) {
            boolean addEntry = true;
            int index = name.indexOf('_');
            if (index > 0 && !name.endsWith("_init")) {
                int lastIndex = name.lastIndexOf('_');
                String init1 = name.substring(0, index + 1) + "init";
                String init2 = index != lastIndex ? (name.substring(0, lastIndex + 1) + "init") : null;
                if (callTable.get(init1) == null && (init2 == null || callTable.get(init2) == null)) {
                    // Warning, lookup in case an init function exists
                    if (context.getMapTable().getFunctionAddress(init1) > 0) {
                        //context.err.println("ContikiChecker: warning, " + name + " is called before " + init1);
                        //profiler.printStackTrace(context.err);
                        addEntry = false;
                    } else if (init2 != null && context.getMapTable().getFunctionAddress(init2) > 0) {
                        //context.err.println("ContikiChecker: warning, " + name + " is called before " + init2);
                        //profiler.printStackTrace(context.err);
                        addEntry = false;
                    }
                }
            }
            if (addEntry) {
                callTable.put(name, ++callCount);
            }
        }
    }

    public void functionReturn(Profiler source, CallEntry entry) {
        // Ignore returns
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Memory.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * Memory
 *
 * Author  : Joakim Eriksson
 * Created : Sept 15 22:00:00 2008
 * Updated : $Date: 2008-03-11 16:32:12 +0100 (ti, 11 mar 2008) $
 *           $Revision: 177 $
 */
package se.sics.mspsim.chip;

public interface Memory {

    public int readByte(int address);
    public void writeByte(int dstAddress, int dst);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/SPICommand.java`:

```java
/**
 * Copyright (c) 2012 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 */

package se.sics.mspsim.chip;

import java.util.ArrayList;

public class SPICommand {

    private static final boolean DEBUG = false;

/*
 * MEMXCP 0 1 0 1 0 1 0 p c c c c c c c c a a a a e e e e a a a a a a a a e e e e e e e e
 */
    public final static int DYNAMIC_LENGTH = 0xffff;

    public final String name;
    public final int mask;
    public final int value;
    public final int bitCount;
    public final int commandLen;

    private final BitField[] bitFields;

    public static class BitField {
        public final String name;
        public final int startBit;
        public final int endBit;
        public final int firstMask;

        public BitField(String currentName, int start, int c) {
            name = currentName;
            startBit = start;
            endBit = c;
            firstMask = 0xff >> (startBit & 7);
        }

        public int getValue(SPIData spiData) {
            int value;
            int firstByte = startBit / 8;
            int lastByte = endBit / 8;
            int nrBitsRoll = 7 - endBit & 7;
            value = spiData.getSPIData(firstByte) & firstMask;

            for (int i = firstByte + 1; i < lastByte + 1; i++) {
                value = (value << 8) + spiData.getSPIData(i);
            }
            value = value >> nrBitsRoll;

            return value;
        }
    }

    SPICommand(String pattern) {
        String[] subs = pattern.split(" ");
        this.name = subs[0];

        ArrayList<BitField> bitFields = new ArrayList<BitField>();
        int value = 0;
        int mask = 0;
        int bitCount = 0;
        int c = 0;
        int start = 0;
        String currentName = "-";
        for (int i = 1; i < subs.length; i++) {
            /* not more than first byte */
            if (subs[i].equals("1")) {
                if (c < 8) {
                    value = (value << 1) + 1;
                    mask = (mask << 1) | 1;
                    bitCount++;
                }
            } else if (subs[i].equals("0")) {
                if (c < 8) {
                    value = (value << 1);
                    mask = (mask << 1) | 1;
                    bitCount++;
                }
            } else if (subs[i].equals(currentName)) {
                /* do nothing */
            } else {
                if (start != 0) {
                    if (DEBUG) System.out.println("Bitfield: " + currentName + ": [" +
                            start + " - " + (c - 1) + "]");
                    bitFields.add(new BitField(currentName, start, c - 1));
                } else {
                    if (DEBUG) System.out.printf("C: %d value: 0x%02x  mask: 0x%02x\n", c, value, mask);
                    if (c < 8) {
                        value = value << (8 - c);
                        mask = mask << (8 - c);
                    }
                }
                currentName = subs[i];
                start = c;
            }
            c++;
        }
        if (start != 0) {
            if (DEBUG) System.out.print("Bitfield: " + currentName + ": [" +
                    start + " - " + (c - 1) + "]  ");
            bitFields.add(new BitField(currentName, start, c - 1));
        }

        int commandLen = c / 8;
        if ("...".equals(currentName)) {
            commandLen = DYNAMIC_LENGTH;
        }
        if (DEBUG) System.out.printf("value 0x%02x mask 0x%02x len 0x%02x\n", value, mask, commandLen);

        this.value = value;
        this.mask = mask;
        this.bitCount = bitCount;
        this.commandLen = commandLen;
        this.bitFields = bitFields.toArray(new BitField[bitFields.size()]);
    }

    /* return -1 if no match */
    /* or len of the rest of the arguments if any more */
    public int matchSPI(int spiData) {
        if ((spiData & mask) == value) {
            return commandLen;
        }
        return -1;
    }

    /* do nothing here...  - override if needed */
    public boolean dataReceived(int data) {
        return true;
    }

    /* for any command that is executable (finite commands) */
    public void executeSPICommand() {
        System.out.println("SPI Command " + name + " not implemented...");
    }

    public BitField getBitField(String fieldName) {
        for (BitField b : bitFields) {
            if (b.name.equals(fieldName)) {
                return b;
            }
        }
        /* not existing ... */
        throw new IllegalArgumentException("No bitfield with name " + fieldName + " exists for " + name);
    }

    @Override
    public String toString() {
        return "SPICommand[" + name + ']';
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/CC2420.java`:

```java
/**
 * Copyright (c) 2007-2012 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * CC2420
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 *
 */

package se.sics.mspsim.chip;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;
import se.sics.mspsim.util.ArrayFIFO;
import se.sics.mspsim.util.CCITT_CRC;
import se.sics.mspsim.util.Utils;

public class CC2420 extends Radio802154 implements USARTListener {

  public enum Reg {
    SNOP, SXOSCON, STXCAL, SRXON, /* 0x00 */
    STXON, STXONCCA, SRFOFF, SXOSCOFF, /* 0x04 */
    SFLUSHRX, SFLUSHTX, SACK, SACKPEND, /* 0x08 */
    SRXDEC, STXENC, SAES, foo,   /* 0x0c */
    MAIN, MDMCTRL0, MDMCTRL1, RSSI, /* 0x10 */ 
    SYNCWORD, TXCTRL, RXCTRL0, RXCTRL1, /* 0x14 */
    FSCTRL, SECCTRL0, SECCTRL1, BATTMON, /* 0x18 */
    IOCFG0, IOCFG1, MANFIDL, MANFIDH, /* 0x1c */
    FSMTC, MANAND, MANOR, AGCCTRL, /* 0x20 */
    AGCTST0, AGCTST1, AGCTST2, FSTST0, /* 0x24 */
    FSTST1, FSTST2, FSTST3, RXBPFTST, /* 0x28 */
    FSMSTATE, ADCTST, DACTST, TOPTST,
    RESERVED, RES1, RES2, RES3,  /* 0x30 */
    RES4, RES5, RES6, RES7,
    RES8, RES9, RESa, RESb,
    RESc, RESd, TXFIFO, RXFIFO
  };

  public enum SpiState {
    WAITING, WRITE_REGISTER, READ_REGISTER, RAM_ACCESS,
    READ_RXFIFO, WRITE_TXFIFO
  };


  public static final int REG_SNOP		= 0x00;
  public static final int REG_SXOSCON	        = 0x01;
  public static final int REG_STXCAL		= 0x02;
  public static final int REG_SRXON		= 0x03;
  public static final int REG_STXON		= 0x04;
  public static final int REG_STXONCCA	        = 0x05;
  public static final int REG_SRFOFF		= 0x06;
  public static final int REG_SXOSCOFF	        = 0x07;
  public static final int REG_SFLUSHRX	        = 0x08;
  public static final int REG_SFLUSHTX	        = 0x09;
  public static final int REG_SACK		= 0x0A;
  public static final int REG_SACKPEND	        = 0x0B;
  public static final int REG_SRXDEC		= 0x0C;
  public static final int REG_STXENC		= 0x0D;
  public static final int REG_SAES		= 0x0E;
  public static final int REG_foo		= 0x0F;
  public static final int REG_MAIN		= 0x10;
  public static final int REG_MDMCTRL0	        = 0x11;
  public static final int REG_MDMCTRL1	        = 0x12;
  public static final int REG_RSSI		= 0x13;
  public static final int REG_SYNCWORD	        = 0x14;
  public static final int REG_TXCTRL		= 0x15;
  public static final int REG_RXCTRL0	        = 0x16;
  public static final int REG_RXCTRL1	        = 0x17;
  public static final int REG_FSCTRL		= 0x18;
  public static final int REG_SECCTRL0	        = 0x19;
  public static final int REG_SECCTRL1       	= 0x1A;
  public static final int REG_BATTMON   	= 0x1B;
  public static final int REG_IOCFG0		= 0x1C;
  public static final int REG_IOCFG1		= 0x1D;
  public static final int REG_MANFIDL   	= 0x1E;
  public static final int REG_MANFIDH   	= 0x1F;
  public static final int REG_FSMTC		= 0x20;
  public static final int REG_MANAND		= 0x21;
  public static final int REG_MANOR		= 0x22;
  public static final int REG_AGCCTRL    	= 0x23;
  public static final int REG_AGCTST0   	= 0x24;
  public static final int REG_AGCTST1   	= 0x25;
  public static final int REG_AGCTST2   	= 0x26;
  public static final int REG_FSTST0		= 0x27;
  public static final int REG_FSTST1		= 0x28;
  public static final int REG_FSTST2		= 0x29;
  public static final int REG_FSTST3		= 0x2A;
  public static final int REG_RXBPFTST    	= 0x2B;
  public static final int REG_FSMSTATE   	= 0x2C;
  public static final int REG_ADCTST		= 0x2D;
  public static final int REG_DACTST		= 0x2E;
  public static final int REG_TOPTST		= 0x2F;
  public static final int REG_RESERVED   	= 0x30;
  /* 0x31 - 0x3D not used */
  public static final int REG_TXFIFO		= 0x3E;
  public static final int REG_RXFIFO		= 0x3F;

  public static final int STATUS_XOSC16M_STABLE = 1 << 6;
  public static final int STATUS_TX_UNDERFLOW   = 1 << 5;
  public static final int STATUS_ENC_BUSY	    = 1 << 4;
  public static final int STATUS_TX_ACTIVE	= 1 << 3;
  public static final int STATUS_LOCK	= 1 << 2;
  public static final int STATUS_RSSI_VALID	= 1 << 1;

  // IOCFG0 Register Bit masks
  public static final int BCN_ACCEPT = (1<<11);
  public static final int FIFO_POLARITY = (1<<10);
  public static final int FIFOP_POLARITY = (1<<9);
  public static final int SFD_POLARITY = (1<<8);
  public static final int CCA_POLARITY = (1<<7);
  public static final int POLARITY_MASK = FIFO_POLARITY | FIFOP_POLARITY | SFD_POLARITY | CCA_POLARITY;
  public static final int FIFOP_THR = 0x7F;

  // IOCFG1 Register Bit Masks
  public static final int SFDMUX = 0x3E0;
  public static final int CCAMUX = 0x1F;

  public static final int SFDMUX_SHIFT = 5;
  public static final int CCAMUX_SHIFT = 0;

  // CCAMUX values
  public static final int CCAMUX_CCA = 0;
  public static final int CCAMUX_XOSC16M_STABLE = 24;

  // MDMCTRO0 values
  public static final int ADR_DECODE = (1 << 11);
  public static final int ADR_AUTOCRC = (1 << 5);
  public static final int AUTOACK = (1 << 4);
  public static final int PREAMBLE_LENGTH = 0x0f;
  
  // RAM Addresses
  public static final int RAM_TXFIFO	= 0x000;
  public static final int RAM_RXFIFO	= 0x080;
  public static final int RAM_KEY0	= 0x100;
  public static final int RAM_RXNONCE	= 0x110;
  public static final int RAM_SABUF	= 0x120;
  public static final int RAM_KEY1	= 0x130;
  public static final int RAM_TXNONCE	= 0x140;
  public static final int RAM_CBCSTATE	= 0x150;
  public static final int RAM_IEEEADDR	= 0x160;
  public static final int RAM_PANID	= 0x168;
  public static final int RAM_SHORTADDR	= 0x16A;

  public static final int SHORT_ADDRESS = 2;
  public static final int LONG_ADDRESS = 3;

  
  // The Operation modes of the CC2420
  public static final int MODE_TXRX_OFF = 0x00;
  public static final int MODE_RX_ON = 0x01;
  public static final int MODE_TXRX_ON = 0x02;
  public static final int MODE_POWER_OFF = 0x03;
  public static final int MODE_MAX = MODE_POWER_OFF;
  private static final String[] MODE_NAMES = new String[] {
    "off", "listen", "transmit", "power_off"
  };

  // State Machine - Datasheet Figure 25 page 44
  public enum RadioState {
     VREG_OFF(-1),
     POWER_DOWN(0),
     IDLE(1),
     RX_CALIBRATE(2),
     RX_SFD_SEARCH(3),
     RX_WAIT(14),
     RX_FRAME(16),
     RX_OVERFLOW(17),
     TX_CALIBRATE(32),
     TX_PREAMBLE(34),
     TX_FRAME(37),
     TX_ACK_CALIBRATE(48),
     TX_ACK_PREAMBLE(49),
     TX_ACK(52),
     TX_UNDERFLOW(56);

     private final int state;
     RadioState(int stateNo) {
       state = stateNo;
     }

     public int getFSMState() {
       return state;
     }
  };
  
  // FCF High
  public static final int FRAME_TYPE = 0x07;
  public static final int SECURITY_ENABLED = (1<<3);
  public static final int FRAME_PENDING = (1<<4);
  public static final int ACK_REQUEST = (1<<5);
  public static final int INTRA_PAN = (1<<6);

  public static final int TYPE_BEACON_FRAME = 0x00;
  public static final int TYPE_DATA_FRAME = 0x01;
  public static final int TYPE_ACK_FRAME = 0x02;
  public static final int TYPE_CMD_FRAME = 0x03;
  
  // FCF Low
  public static final int DESTINATION_ADDRESS_MODE = 0x30;
  public static final int SOURCE_ADDRESS_MODE = 0x3;

  // Position of SEQ-NO in ACK packet...
  public static final int ACK_SEQPOS = 3;
  
  private RadioState stateMachine = RadioState.VREG_OFF;

  // 802.15.4 symbol period in ms
  public static final double SYMBOL_PERIOD = 0.016; // 16 us

  // when reading registers this flag is set!
  public static final int FLAG_READ = 0x40;

  public static final int FLAG_RAM = 0x80;
  // When accessing RAM the second byte of the address contains
  // a flag indicating read/write
  public static final int FLAG_RAM_READ = 0x20;
  private static final int[] BC_ADDRESS = new int[] {0xff, 0xff};
  
  private SpiState state = SpiState.WAITING;
  private int usartDataPos;
  private int usartDataAddress;
  private int usartDataValue;
  private int shrPos;
  private int txfifoPos;
  private boolean txfifoFlush;	// TXFIFO is automatically flushed on next write
  private int rxfifoReadLeft; // number of bytes left to read from current packet
  private int rxlen;
  private int rxread;
  private int zeroSymbols;
  private boolean ramRead = false;

  /* RSSI is an externally set value of the RSSI for this CC2420 */
  /* low RSSI => CCA = true in normal mode */

  private int rssi = -100;
  private static int RSSI_OFFSET = -45; /* cc2420 datasheet */
  /* current CCA value */
  private boolean cca = false;

  /* This is the magical LQI */
  private int corrval = 37;

  /* FIFOP Threshold */
  private int fifopThr = 64;

  /* if autoack is configured or if */
  private boolean autoAck = false;
  private boolean shouldAck = false;
  private boolean addressDecode = false;
  private boolean ackRequest = false;
  private boolean autoCRC = false;

  // Data from last received packet
  private int dsn = 0;
  private int fcf0 = 0;
  private int fcf1 = 0;
  private int frameType = 0;
  private boolean crcOk = false;
  
  private int activeFrequency = 0;
  private int activeChannel = 0;

  //private int status = STATUS_XOSC16M_STABLE | STATUS_RSSI_VALID;
  private int status = 0;

  private int[] registers = new int[64];
  // More than needed...
  private int[] memory = new int[512];

  // Buffer to hold 5 byte Synchronization header, as it is not written to the TXFIFO
  private byte[] SHR = new byte[5];

  private boolean chipSelect;

  private IOPort ccaPort = null;
  private int ccaPin;

  private IOPort fifopPort = null;
  private int fifopPin;

  private IOPort fifoPort = null;
  private int fifoPin;

  private IOPort sfdPort = null;
  private int sfdPin;

  private int txCursor;
  private boolean on;

  private TimeEvent oscillatorEvent = new TimeEvent(0, "CC2420 OSC") {
    public void execute(long t) {
      status |= STATUS_XOSC16M_STABLE;
      if (logLevel > INFO) log("Oscillator Stable Event.");
      setState(RadioState.IDLE);
      if( (registers[REG_IOCFG1] & CCAMUX) == CCAMUX_XOSC16M_STABLE) {
        updateCCA();
      } else {
        if(logLevel > INFO) log("CCAMUX != CCA_XOSC16M_STABLE! Not raising CCA");
      }
    }
  };

  private TimeEvent vregEvent = new TimeEvent(0, "CC2420 VREG") {
    public void execute(long t) {
      if(logLevel > INFO) log("VREG Started at: " + t + " cyc: " +
          cpu.cycles + " " + getTime());
      on = true;
      setState(RadioState.POWER_DOWN);
      updateCCA();
    }
  };

  private TimeEvent sendEvent = new TimeEvent(0, "CC2420 Send") {
    public void execute(long t) {
      txNext();
    }
  };

  private TimeEvent ackEvent = new TimeEvent(0, "CC2420 Ack") {
      public void execute(long t) {
        ackNext();
      }
    };
  
  private TimeEvent shrEvent = new TimeEvent(0, "CC2420 SHR") {
    public void execute(long t) {
      shrNext();
    }
  };

  private TimeEvent symbolEvent = new TimeEvent(0, "CC2420 Symbol") {
    public void execute(long t) {
      switch(stateMachine) {
      case RX_CALIBRATE:
        setState(RadioState.RX_SFD_SEARCH);
        break;
        /* this will be called 8 symbols after first SFD_SEARCH */
      case RX_SFD_SEARCH:
        status |= STATUS_RSSI_VALID;
        updateCCA();
        break;

      case TX_CALIBRATE:
        setState(RadioState.TX_PREAMBLE);
        break;

      case RX_WAIT:
        setState(RadioState.RX_SFD_SEARCH);
        break;

      case TX_ACK_CALIBRATE:
          setState(RadioState.TX_ACK_PREAMBLE);
          break;
      }
    }
  };
  private boolean currentCCA;
  private boolean currentSFD;
  private boolean currentFIFO;
  private boolean currentFIFOP;
  private boolean overflow = false;
  private boolean frameRejected = false;

  public interface StateListener {
    public void newState(RadioState state);
  }

  private StateListener stateListener = null;
  private int ackPos;
  /* type = 2 (ACK), third byte needs to be sequence number... */
  private int[] ackBuf = {0x05, 0x02, 0x00, 0x00, 0x00, 0x00};
  private boolean ackFramePending = false;
  private CCITT_CRC rxCrc = new CCITT_CRC();
  private CCITT_CRC txCrc = new CCITT_CRC();

  private ArrayFIFO rxFIFO;
  
  public void setStateListener(StateListener listener) {
    stateListener = listener;
  }

  public RadioState getState() {
      return stateMachine;
  }

  public CC2420(MSP430Core cpu) {
      super("CC2420", "Radio", cpu);
      rxFIFO = new ArrayFIFO("RXFIFO", memory, RAM_RXFIFO, 128);
      
    registers[REG_SNOP] = 0;
    registers[REG_TXCTRL] = 0xa0ff;
    setModeNames(MODE_NAMES);
    setMode(MODE_POWER_OFF);
    currentFIFOP = false;
    rxFIFO.reset();
    overflow = false;
    reset();
  }
  
  private void reset() {
      setReg(REG_MDMCTRL0, 0x0ae2);
      registers[REG_RSSI] =  0xE000 | (registers[REG_RSSI]  & 0xFF);
  }
  
  private boolean setState(RadioState state) {
    if(logLevel > INFO) log("State transition from " + stateMachine + " to " + state);
    stateMachine = state;
    /* write to FSM state register */
    registers[REG_FSMSTATE] = state.getFSMState();

    switch(stateMachine) {

    case VREG_OFF:
      if (logLevel > INFO) log("VREG Off.");
      flushRX();
      flushTX();
      status &= ~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
      crcOk = false;
      reset();
      setMode(MODE_POWER_OFF);
      updateCCA();
      break;

    case POWER_DOWN:
      rxFIFO.reset();
      status &= ~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
      crcOk = false;
      reset();
      setMode(MODE_POWER_OFF);
      updateCCA();
      break;

    case RX_CALIBRATE:
      /* should be 12 according to specification */
      setSymbolEvent(12);
      setMode(MODE_RX_ON);
      break;
    case RX_SFD_SEARCH:
      zeroSymbols = 0;
      /* eight symbols after first SFD search RSSI will be valid */
      if ((status & STATUS_RSSI_VALID) == 0) {
          setSymbolEvent(8);
      }
//      status |= STATUS_RSSI_VALID;
      updateCCA();
      setMode(MODE_RX_ON);
      break;

    case TX_CALIBRATE:
      /* 12 symbols calibration, and one byte's wait since we deliver immediately
       * to listener when after calibration?
       */
      setSymbolEvent(12 + 2);
      setMode(MODE_TXRX_ON);
      break;

    case TX_PREAMBLE:
      shrPos = 0;
      SHR[0] = 0;
      SHR[1] = 0;
      SHR[2] = 0;
      SHR[3] = 0;
      SHR[4] = 0x7A;
      shrNext();
      break;

    case TX_FRAME:
      txfifoPos = 0;
      // Reset CRC ok flag to disable software acknowledgments until next received packet 
      crcOk = false;
      txNext();
      break;

    case RX_WAIT:
      setSymbolEvent(8);
      setMode(MODE_RX_ON);
      break;
      
    case IDLE:
      status &= ~STATUS_RSSI_VALID;
      setMode(MODE_TXRX_OFF);
      updateCCA();
      break;
      
    case TX_ACK_CALIBRATE:
        /* TX active during ACK + NOTE: we ignore the SFD when receiving full packets so
         * we need to add another extra 2 symbols here to get a correct timing */
        status |= STATUS_TX_ACTIVE;
        setSymbolEvent(12 + 2 + 2);
        setMode(MODE_TXRX_ON);
      break;
    case TX_ACK_PREAMBLE:
        /* same as normal preamble ?? */
        shrPos = 0;
        SHR[0] = 0;
        SHR[1] = 0;
        SHR[2] = 0;
        SHR[3] = 0;
        SHR[4] = 0x7A;
        shrNext();
        break;
    case TX_ACK:
        ackPos = 0;
        // Reset CRC ok flag to disable software acknowledgments until next received packet 
        crcOk = false;
        ackNext();
        break;
    case RX_FRAME:
        /* mark position of frame start - for rejecting when address is wrong */
        rxFIFO.mark();
        rxread = 0;
        frameRejected = false;
        shouldAck = false;
        crcOk = false;
        break;
    }

    /* Notify state listener */
    if (stateListener != null) {
        stateListener.newState(stateMachine);
    }
    stateChanged(stateMachine.state);

    return true;
  }

  private void rejectFrame() {
      // Immediately jump to SFD Search again... something more???
      /* reset state */
      rxFIFO.restore();
      setSFD(false);
      setFIFO(rxFIFO.length() > 0);
      frameRejected = true;
  }
  
  /* variables for the address recognition */
  int destinationAddressMode = 0;
  boolean decodeAddress = false;
  /* Receive a byte from the radio medium
   * @see se.sics.mspsim.chip.RFListener#receivedByte(byte)
   */
  public void receivedByte(byte data) {
      // Received a byte from the "air"

      if (logLevel > INFO)
        log("RF Byte received: " + Utils.hex8(data) + " state: " + stateMachine + " noZeroes: " + zeroSymbols +
              ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? "" : " *** Ignored"));

      if(stateMachine == RadioState.RX_SFD_SEARCH) {
          // Look for the preamble (4 zero bytes) followed by the SFD byte 0x7A
          if(data == 0) {
              // Count zero bytes
              zeroSymbols++;
          } else if(zeroSymbols >= 4 && data == 0x7A) {
              // If the received byte is !zero, we have counted 4 zero bytes prior to this one,
              // and the current received byte == 0x7A (SFD), we're in sync.
              // In RX mode, SFD goes high when the SFD is received
              setSFD(true);
              if (logLevel > INFO) log("RX: Preamble/SFD Synchronized.");
              setState(RadioState.RX_FRAME);
          } else {
              /* if not four zeros and 0x7A then no zeroes... */
              zeroSymbols = 0;
          }

      } else if(stateMachine == RadioState.RX_FRAME) {
          if (overflow) {
              /* if the CC2420 RX FIFO is in overflow - it needs a flush before receiving again */
          } else if(rxFIFO.isFull()) {
              setRxOverflow();
          } else {
              if (!frameRejected) {
                  rxFIFO.write(data);
                  if (rxread == 0) {
                      rxCrc.setCRC(0);
                      rxlen = data & 0xff;
                      //System.out.println("Starting to get packet at: " + rxfifoWritePos + " len = " + rxlen);
                      decodeAddress = addressDecode;
                      if (logLevel > INFO) log("RX: Start frame length " + rxlen);
                      // FIFO pin goes high after length byte is written to RXFIFO
                      setFIFO(true);
                  } else if (rxread < rxlen - 1) {
                      /* As long as we are not in the length or FCF (CRC) we count CRC */
                      rxCrc.addBitrev(data & 0xff);
                      if (rxread == 1) {
                          fcf0 = data & 0xff;
                          frameType = fcf0 & FRAME_TYPE;
                      } else if (rxread == 2) {
                          fcf1 = data & 0xff;
                          if (frameType == TYPE_DATA_FRAME || frameType == TYPE_CMD_FRAME) {
                              ackRequest = (fcf0 & ACK_REQUEST) > 0;
                              destinationAddressMode = (fcf1 >> 2) & 3;
                              /* check this !!! */
                              if (addressDecode && destinationAddressMode != LONG_ADDRESS &&
                                      destinationAddressMode != SHORT_ADDRESS) {
                                  rejectFrame();
                              }
                          } else if (frameType == TYPE_BEACON_FRAME ||
                                  frameType == TYPE_ACK_FRAME){
                              decodeAddress = false;
                              ackRequest = false;
                          } else if (addressDecode) {
                              /* illegal frame when decoding address... */
                              rejectFrame();
                          }
                      } else if (rxread == 3) {
                          // save data sequence number
                          dsn = data & 0xff;
                      } else if (decodeAddress) {
                          boolean flushPacket = false;
                          /* here we decode the address !!! */
                          if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
                              /* here we need to check that this address is correct compared to the stored address */
                              flushPacket = !rxFIFO.tailEquals(memory, RAM_IEEEADDR, 8);
                              flushPacket |= !rxFIFO.tailEquals(memory, RAM_PANID, 2, 8)
                                      && !rxFIFO.tailEquals(BC_ADDRESS, 0, 2, 8);
                              decodeAddress = false;
                          } else if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5){
                              /* should check short address */
                              flushPacket = !rxFIFO.tailEquals(BC_ADDRESS, 0, 2)
                                      && !rxFIFO.tailEquals(memory, RAM_SHORTADDR, 2);
                              flushPacket |= !rxFIFO.tailEquals(memory, RAM_PANID, 2, 2)
                                      && !rxFIFO.tailEquals(BC_ADDRESS, 0, 2, 2);
                              decodeAddress = false;
                          }
                          if (flushPacket) {
                              rejectFrame();
                          }
                      }
                  }

                  /* In RX mode, FIFOP goes high when the size of the first enqueued packet exceeds
                   * the programmable threshold and address recognition isn't ongoing */ 
                  if (currentFIFOP == false
                          && rxFIFO.length() <= rxlen + 1
                          && !decodeAddress && !frameRejected
                          && rxFIFO.length() > fifopThr) {
                      setFIFOP(true);
                      if (logLevel > INFO) log("RX: FIFOP Threshold reached - setting FIFOP");
                  }
              }

              if (rxread++ == rxlen) {
                  if (frameRejected) {
                      if (logLevel > INFO) log("Frame rejected - setting SFD to false and RXWAIT\n");
                      setSFD(false);
                      setState(RadioState.RX_WAIT);
                      return;
                  }
                  // In RX mode, FIFOP goes high, if threshold is higher than frame length....

                  // Here we check the CRC of the packet!
                  //System.out.println("Reading from " + ((rxfifoWritePos + 128 - 2) & 127));
                  int crc = rxFIFO.get(-2) << 8;
                  crc += rxFIFO.get(-1); //memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];

                  crcOk = crc == rxCrc.getCRCBitrev();
                  if (logLevel > INFO && !crcOk) {
                      log("CRC not OK: recv:" + Utils.hex16(crc) + " calc: " + Utils.hex16(rxCrc.getCRCBitrev()));
                  }
                  // Should take a RSSI value as input or use a set-RSSI value...
                  rxFIFO.set(-2, registers[REG_RSSI] & 0xff); 
                  rxFIFO.set(-1, (corrval & 0x7F) | (crcOk ? 0x80 : 0));
                  //          memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] = ;
                  //          // Set CRC ok and add a correlation - TODO: fix better correlation value!!!
                  //          memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)] = 37 |
                  //              (crcOk ? 0x80 : 0);

                  /* set FIFOP only if this is the first received packet - e.g. if rxfifoLen is at most rxlen + 1
                   * TODO: check what happens when rxfifoLen < rxlen - e.g we have been reading before FIFOP */
                  if (rxFIFO.length() <= rxlen + 1) {
                      setFIFOP(true);
                  } else {
                      if (logLevel > INFO) log("Did not set FIFOP rxfifoLen: " + rxFIFO.length() + " rxlen: " + rxlen);
                  }
                  setSFD(false);
                  if (logLevel > INFO) log("RX: Complete: packetStart: " + rxFIFO.stateToString());

                  /* if either manual ack request (shouldAck) or autoack + ACK_REQ on package do ack! */
                  /* Autoack-mode + good CRC => autoack */
                  if (((autoAck && ackRequest) || shouldAck) && crcOk) {
                      setState(RadioState.TX_ACK_CALIBRATE);
                  } else {
                      setState(RadioState.RX_WAIT);
                  }
              }
          }
      }
  }

  private void setReg(int address, int data) {
      int oldValue = registers[address];
      switch(address){
        case REG_RSSI:
          registers[address] = (registers[address] & 0xFF) | (data & 0xFF00);
          break;
        default:
          registers[address] = data;
      }
      switch(address) {
      case REG_IOCFG0:
          fifopThr = data & FIFOP_THR;
          if (logLevel > INFO) log("IOCFG0: 0x" + Utils.hex16(oldValue) + " => 0x" + Utils.hex16(data));
          if ((oldValue & POLARITY_MASK) != (data & POLARITY_MASK)) {
              // Polarity has changed - must update pins
              setFIFOP(currentFIFOP);
              setFIFO(currentFIFO);
              setSFD(currentSFD);
              setCCA(currentCCA);
          }
          break;
      case REG_IOCFG1:
          if (logLevel > INFO)
            log("IOCFG1: SFDMUX "
                          + ((registers[address] & SFDMUX) >> SFDMUX_SHIFT)
                          + " CCAMUX: " + ((registers[address] & CCAMUX) >> CCAMUX_SHIFT));
          updateCCA();
          break;
      case REG_MDMCTRL0:
          addressDecode = (data & ADR_DECODE) != 0;
          autoCRC = (data & ADR_AUTOCRC) != 0;
          autoAck = (data & AUTOACK) != 0;
          break;
      case REG_FSCTRL: {
          ChannelListener listener = this.channelListener;
          if (listener != null) {
              int oldChannel = activeChannel;
              updateActiveFrequency();
              if (oldChannel != activeChannel) {
                  listener.channelChanged(activeChannel);
              }
          }
          break;
      }
      }
      configurationChanged(address, oldValue, data);
  }

  public void dataReceived(USARTSource source, int data) {
    int oldStatus = status;
    if (logLevel > INFO) {
      log("byte received: " + Utils.hex8(data) +
          " (" + ((data >= ' ' && data <= 'Z') ? (char) data : '.') + ')' +
          " CS: " + chipSelect + " SPI state: " + state + " StateMachine: " + stateMachine);
    }

    if (!chipSelect) {
      // Chip is not selected

    } else if (stateMachine != RadioState.VREG_OFF) {
      switch(state) {
      case WAITING:
        if ((data & FLAG_READ) != 0) {
          state = SpiState.READ_REGISTER;
        } else {
          state = SpiState.WRITE_REGISTER;
        }
        if ((data & FLAG_RAM) != 0) {
          state = SpiState.RAM_ACCESS;
          usartDataAddress = data & 0x7f;
        } else {
          // The register address
          usartDataAddress = data & 0x3f;

          if (usartDataAddress == REG_RXFIFO) {
            // check read/write???
            //          log("Reading RXFIFO!!!");
            state = SpiState.READ_RXFIFO;
          } else if (usartDataAddress == REG_TXFIFO) {
            state = SpiState.WRITE_TXFIFO;
          }
        }
        if (data < 0x0f) {
          strobe(data);
          state = SpiState.WAITING;
        }
        usartDataPos = 0;
        // Assuming that the status always is sent back???
        //source.byteReceived(status);
        break;
                
      case WRITE_REGISTER:
        if (usartDataPos == 0) {
          source.byteReceived(registers[usartDataAddress] >> 8);
          // set the high bits
          usartDataValue = data << 8;
          // registers[usartDataAddress] = (registers[usartDataAddress] & 0xff) | (data << 8);
          usartDataPos = 1;
        } else {
          source.byteReceived(registers[usartDataAddress] & 0xff);
          // set the low bits
          usartDataValue |= data;
          // registers[usartDataAddress] = (registers[usartDataAddress] & 0xff00) | data;

          if (logLevel > INFO) {
            log("wrote to " + Utils.hex8(usartDataAddress) + " = " + usartDataValue);
          }
          setReg(usartDataAddress, usartDataValue);
          /* register written - go back to waiting... */
          state = SpiState.WAITING;
        }
        break;
      case READ_REGISTER:
        if (usartDataPos == 0) {
          source.byteReceived(registers[usartDataAddress] >> 8);
          usartDataPos = 1;
        } else {
          source.byteReceived(registers[usartDataAddress] & 0xff);
          if (logLevel > INFO) {
            log("read from " + Utils.hex8(usartDataAddress) + " = "
                + registers[usartDataAddress]);
          }
          state = SpiState.WAITING;
        }
        return;
        //break;
      case READ_RXFIFO: {
          int fifoData = rxFIFO.read(); 
          if (logLevel > INFO) log("RXFIFO READ: " + rxFIFO.stateToString());
          source.byteReceived(fifoData);

          /* first check and clear FIFOP - since we now have read a byte! */
          if (currentFIFOP && !overflow) {
              /* FIFOP is lowered when rxFIFO is lower than or equal to fifopThr */
              if(rxFIFO.length() <= fifopThr) {
                  if (logLevel > INFO) log("*** FIFOP cleared at: " + rxFIFO.stateToString());
                  setFIFOP(false);
              }
          }

          /* initiate read of another packet - update some variables to keep track of packet reading... */
          if (rxfifoReadLeft == 0) {
              rxfifoReadLeft = fifoData;
              if (logLevel > INFO) log("Init read of packet - len: " + rxfifoReadLeft +
                      " fifo: " + rxFIFO.stateToString());
          } else if (--rxfifoReadLeft == 0) {
              /* check if we have another packet in buffer */
              if (rxFIFO.length() > 0) {
                  /* check if the packet is complete or longer than fifopThr */
                  if (rxFIFO.length() > rxFIFO.peek(0) ||
                          (rxFIFO.length() > fifopThr && !decodeAddress && !frameRejected)) {
                      if (logLevel > INFO) log("More in FIFO - FIFOP = 1! plen: " + rxFIFO.stateToString());
                      if (!overflow) setFIFOP(true);
                  }
              }
          }
          // Set the FIFO pin low if there are no more bytes available in the RXFIFO.
          if (rxFIFO.length() == 0) {
              if (logLevel > INFO) log("Setting FIFO to low (buffer empty)");
              setFIFO(false);
          }
      }
      return; /* avoid returning the status byte */
      case WRITE_TXFIFO:
        if(txfifoFlush) {
          txCursor = 0;
          txfifoFlush = false;
        }
        if (logLevel > INFO) log("Writing data: " + data + " to tx: " + txCursor);

        if(txCursor == 0) {
          if ((data & 0xff) > 127) {
            logger.logw(this, WarningType.EXECUTION, "CC2420: Warning - packet size too large: " + (data & 0xff));
          }
        } else if (txCursor > 127) {
          logger.logw(this, WarningType.EXECUTION, "CC2420: Warning - TX Cursor wrapped");
          txCursor = 0;
        }
        memory[RAM_TXFIFO + txCursor] = data & 0xff;
        txCursor++;
        if (sendEvents) {
          sendEvent("WRITE_TXFIFO", null);
        }
        break;
      case RAM_ACCESS:
        if (usartDataPos == 0) {
          usartDataAddress |= (data << 1) & 0x180;
          ramRead = (data & FLAG_RAM_READ) != 0;
          if (logLevel > INFO) {
            log("Address: " + Utils.hex16(usartDataAddress) + " read: " + ramRead);
          }
          usartDataPos++;
        } else {
          if (!ramRead) {
            memory[usartDataAddress++] = data;
            if (usartDataAddress >= 0x180) {
              logger.logw(this, WarningType.EXECUTION, "CC2420: Warning - RAM position too big - wrapping!");
              usartDataAddress = 0;
            }
            if (logLevel > INFO && usartDataAddress == RAM_PANID + 2) {
              log("Pan ID set to: 0x" +
                  Utils.hex8(memory[RAM_PANID]) +
                  Utils.hex8(memory[RAM_PANID + 1]));
            }
          } else {
            //log("Read RAM Addr: " + address + " Data: " + memory[address]);  
            source.byteReceived(memory[usartDataAddress++]);
            if (usartDataAddress >= 0x180) {
              logger.logw(this, WarningType.EXECUTION, "CC2420: Warning - RAM position too big - wrapping!");
              usartDataAddress = 0;
            }
            return;
          }
        }
        break;
      }
      source.byteReceived(oldStatus);  
    } else {
        /* No VREG but chip select */
        source.byteReceived(0);
        logw(WarningType.EXECUTION, "**** Warning - writing to CC2420 when VREG is off!!!");
    }
  }

  // Needs to get information about when it is possible to write
  // next data...
  private void strobe(int data) {
    // Resets, on/off of different things...
    if (logLevel > INFO) {
      log("Strobe on: " + Utils.hex8(data) + " => " + Reg.values()[data]);
    }

    if( (stateMachine == RadioState.POWER_DOWN) && (data != REG_SXOSCON) ) {
      if (logLevel > INFO) log("Got command strobe: " + data + " in POWER_DOWN.  Ignoring.");
      return;
    }

    switch (data) {
    case REG_SNOP:
      if (logLevel > INFO) log("SNOP => " + Utils.hex8(status) + " at " + cpu.cycles);
      break;
    case REG_SRXON:
      if(stateMachine == RadioState.IDLE) {
        setState(RadioState.RX_CALIBRATE);
        //updateActiveFrequency();
        if (logLevel > INFO) {
            log("Strobe RX-ON!!!");
        }
      } else {
        if (logLevel > INFO) log("WARNING: SRXON when not IDLE");
      }

      break;
    case REG_SRFOFF:
      if (logLevel > INFO) {
        log("Strobe RXTX-OFF!!! at " + cpu.cycles);
        if (stateMachine == RadioState.TX_ACK ||
              stateMachine == RadioState.TX_FRAME ||
              stateMachine == RadioState.RX_FRAME) {
          log("WARNING: turning off RXTX during " + stateMachine);
        }
      }
      setState(RadioState.IDLE);
      break;
    case REG_STXON:
      // State transition valid from IDLE state or all RX states
      if( (stateMachine == RadioState.IDLE) || 
          (stateMachine == RadioState.RX_CALIBRATE) ||
          (stateMachine == RadioState.RX_SFD_SEARCH) ||
          (stateMachine == RadioState.RX_FRAME) ||
          (stateMachine == RadioState.RX_OVERFLOW) ||
          (stateMachine == RadioState.RX_WAIT)) {
        status |= STATUS_TX_ACTIVE;
        setState(RadioState.TX_CALIBRATE);
        if (sendEvents) {
          sendEvent("STXON", null);
        }
        // Starting up TX subsystem - indicate that we are in TX mode!
        if (logLevel > INFO) log("Strobe STXON - transmit on! at " + cpu.cycles);
      }
      break;
    case REG_STXONCCA:
      // Only valid from all RX states,
      // since CCA requires ??(look this up) receive symbol periods to be valid
      if( (stateMachine == RadioState.RX_CALIBRATE) ||
          (stateMachine == RadioState.RX_SFD_SEARCH) ||
          (stateMachine == RadioState.RX_FRAME) ||
          (stateMachine == RadioState.RX_OVERFLOW) ||
          (stateMachine == RadioState.RX_WAIT)) {
        
        if (sendEvents) {
          sendEvent("STXON_CCA", null);
        }
        
        if(cca) {
          status |= STATUS_TX_ACTIVE;
          setState(RadioState.TX_CALIBRATE);
          if (logLevel > INFO) log("Strobe STXONCCA - transmit on! at " + cpu.cycles);
        }else{
          if (logLevel > INFO) log("STXONCCA Ignored, CCA false");
        }
      }
      break;
    case REG_SFLUSHRX:
      flushRX();
      break;
    case REG_SFLUSHTX:
      if (logLevel > INFO) log("Flushing TXFIFO");
      flushTX();
      break;
    case REG_SXOSCON:
      //log("Strobe Oscillator On");
      startOscillator();
      break;
    case REG_SXOSCOFF:
      //log("Strobe Oscillator Off");
      stopOscillator();
      break;
    case REG_SACK:
    case REG_SACKPEND:
        // Set the frame pending flag for all future autoack based on SACK/SACKPEND
        ackFramePending = data == REG_SACKPEND;
        if (stateMachine == RadioState.RX_FRAME) {
            shouldAck = true;
        } else if (crcOk) {
            setState(RadioState.TX_ACK_CALIBRATE);
        }
        break;
    default:
      if (logLevel > INFO) {
        log("Unknown strobe command: " + data);
      }
    break;
    }
  }

  private void shrNext() {
    if(shrPos == 5) {
      // Set SFD high
      setSFD(true);

      if (stateMachine == RadioState.TX_PREAMBLE) {
          setState(RadioState.TX_FRAME);
      } else if (stateMachine == RadioState.TX_ACK_PREAMBLE) {
          setState(RadioState.TX_ACK);
      } else {
          logw(WarningType.EMULATION_ERROR,
                  "Can not move to TX_FRAME or TX_ACK after preamble since radio is in wrong mode: " +
                  stateMachine);
      }
    } else {
      if (rfListener != null) {
        if (logLevel > INFO) log("transmitting byte: " + Utils.hex8(SHR[shrPos]));
        rfListener.receivedByte(SHR[shrPos]);
      }
      shrPos++;
      cpu.scheduleTimeEventMillis(shrEvent, SYMBOL_PERIOD * 2);
    }
  }

  private void txNext() {
    if(txfifoPos <= memory[RAM_TXFIFO]) {
      int len = memory[RAM_TXFIFO] & 0xff;
      if (txfifoPos == len - 1) {
          txCrc.setCRC(0);
          for (int i = 1; i < len - 1; i++) {
            txCrc.addBitrev(memory[RAM_TXFIFO + i] & 0xff);
          }
          memory[RAM_TXFIFO + len - 1] = txCrc.getCRCHi();
          memory[RAM_TXFIFO + len] = txCrc.getCRCLow();
      }
      if (txfifoPos > 0x7f) {
        logw(WarningType.EXECUTION, "**** Warning - packet size too large - repeating packet bytes txfifoPos: " + txfifoPos);
      }
      if (rfListener != null) {
        if (logLevel > INFO) log("transmitting byte: " + Utils.hex8(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));
        rfListener.receivedByte((byte)(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));
      }
      txfifoPos++;
      // Two symbol periods to send a byte...
      cpu.scheduleTimeEventMillis(sendEvent, SYMBOL_PERIOD * 2);
    } else {
      if (logLevel > INFO) log("Completed Transmission.");
      status &= ~STATUS_TX_ACTIVE;
      setSFD(false);
      if (overflow) {
        /* TODO: is it going back to overflow here ?=? */
        setState(RadioState.RX_OVERFLOW);
      } else {
        setState(RadioState.RX_CALIBRATE);
      }
      /* Back to RX ON */
      setMode(MODE_RX_ON);
      txfifoFlush = true;
    }
  }

  private void ackNext() {
      if (ackPos < ackBuf.length) {
          if(ackPos == 0) {
              txCrc.setCRC(0);
              if (ackFramePending) {
                  ackBuf[1] |= FRAME_PENDING;
              } else {
                  ackBuf[1] &= ~FRAME_PENDING;
              }
              // set dsn
              ackBuf[3] = dsn;
              int len = 4;
              for (int i = 1; i < len; i++) {
                  txCrc.addBitrev(ackBuf[i] & 0xff);
              }
              ackBuf[4] = txCrc.getCRCHi();
              ackBuf[5] = txCrc.getCRCLow();
          }
          if (rfListener != null) {
              if (logLevel > INFO) log("transmitting byte: " + Utils.hex8(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));

              rfListener.receivedByte((byte)(ackBuf[ackPos] & 0xFF));
          }
          ackPos++;
          // Two symbol periods to send a byte...
          cpu.scheduleTimeEventMillis(ackEvent, SYMBOL_PERIOD * 2);
      } else {
          if (logLevel > INFO) log("Completed Transmission of ACK.");
          status &= ~STATUS_TX_ACTIVE;
          setSFD(false);
          setState(RadioState.RX_CALIBRATE);
          /* Back to RX ON */
          setMode(MODE_RX_ON);
      }
  }


  private void setSymbolEvent(int symbols) {
    double period = SYMBOL_PERIOD * symbols;
    cpu.scheduleTimeEventMillis(symbolEvent, period);
    //log("Set Symbol event: " + period);
  }

  private void startOscillator() {
    // 1ms crystal startup from datasheet pg12
    cpu.scheduleTimeEventMillis(oscillatorEvent, 1);
  }

  private void stopOscillator() {
    status &= ~STATUS_XOSC16M_STABLE;
    setState(RadioState.POWER_DOWN);
    if (logLevel > INFO) log("Oscillator Off.");
    // Reset state
    setFIFOP(false);
  }

  private void flushRX() {
    if (logLevel > INFO) {
      log("Flushing RX len = " + rxFIFO.length());
    }
    rxFIFO.reset();
    setSFD(false);
    setFIFOP(false);
    setFIFO(false);
    overflow = false;
    /* goto RX Calibrate */
    if( (stateMachine == RadioState.RX_CALIBRATE) ||
        (stateMachine == RadioState.RX_SFD_SEARCH) ||
        (stateMachine == RadioState.RX_FRAME) ||
        (stateMachine == RadioState.RX_OVERFLOW) ||
        (stateMachine == RadioState.RX_WAIT)) {
      setState(RadioState.RX_SFD_SEARCH);
    }
  }

  // TODO: update any pins here?
  private void flushTX() {
    txCursor = 0;
  }
  
  private void updateCCA() {
    boolean oldCCA = cca;
    int ccaMux = (registers[REG_IOCFG1] & CCAMUX);

    if (ccaMux == CCAMUX_CCA) {
      /* If RSSI is less than -95 then we have CCA / clear channel! */
      cca = (status & STATUS_RSSI_VALID) > 0 && (byte)(registers[REG_RSSI] & 0xFF) < (byte)(registers[REG_RSSI] >> 8);
      //log("CCA: " + cca  + " - " +  (byte)(registers[REG_RSSI] & 0xFF) + " "  + (byte)(registers[REG_RSSI] >> 8));
    } else if (ccaMux == CCAMUX_XOSC16M_STABLE) {
      cca = (status & STATUS_XOSC16M_STABLE) > 0;
    }
    
    if (cca != oldCCA) {
      setInternalCCA(cca);
    }
  }

  private void setInternalCCA(boolean clear) {
    setCCA(clear);
    if (logLevel > INFO) log("Internal CCA: " + clear);
  }

  private void setSFD(boolean sfd) {
    currentSFD = sfd;
    if( (registers[REG_IOCFG0] & SFD_POLARITY) == SFD_POLARITY)
      sfdPort.setPinState(sfdPin, sfd ? IOPort.PinState.LOW : IOPort.PinState.HI);
    else 
      sfdPort.setPinState(sfdPin, sfd ? IOPort.PinState.HI : IOPort.PinState.LOW);
    if (logLevel > INFO) log("SFD: " + sfd + "  " + cpu.cycles);
  }

  private void setCCA(boolean cca) {
    currentCCA = cca;
    if (logLevel > INFO) log("Setting CCA to: " + cca);
    if( (registers[REG_IOCFG0] & CCA_POLARITY) == CCA_POLARITY)
      ccaPort.setPinState(ccaPin, cca ? IOPort.PinState.LOW : IOPort.PinState.HI);
    else
      ccaPort.setPinState(ccaPin, cca ? IOPort.PinState.HI : IOPort.PinState.LOW);
  }

  private void setFIFOP(boolean fifop) {
    currentFIFOP = fifop;
    if (logLevel > INFO) log("Setting FIFOP to " + fifop);
    if( (registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) {
      fifopPort.setPinState(fifopPin, fifop ? IOPort.PinState.LOW : IOPort.PinState.HI);
    } else {
      fifopPort.setPinState(fifopPin, fifop ? IOPort.PinState.HI : IOPort.PinState.LOW);
    }
  }

  private void setFIFO(boolean fifo) {
    currentFIFO = fifo;
    if (logLevel > INFO) log("Setting FIFO to " + fifo);
    if((registers[REG_IOCFG0] & FIFO_POLARITY) == FIFO_POLARITY) {
      fifoPort.setPinState(fifoPin, fifo ? IOPort.PinState.LOW : IOPort.PinState.HI);
    } else {
      fifoPort.setPinState(fifoPin, fifo ? IOPort.PinState.HI : IOPort.PinState.LOW);
    }
  }

  private void setRxOverflow() {
    if (logLevel > INFO) log("RXFIFO Overflow! Read Pos: " + rxFIFO.stateToString());
    setFIFOP(true);
    setFIFO(false);
    setSFD(false);
    overflow = true;
    shouldAck = false;
    setState(RadioState.RX_OVERFLOW);
  }
  
  
  /*****************************************************************************
   *  External APIs for simulators simulating Radio medium, etc.
   * 
   *****************************************************************************/
  @Override
  public boolean isReadyToReceive() {
      return getState() == RadioState.RX_SFD_SEARCH;
  }

  public void updateActiveFrequency() {
    /* INVERTED: f = 5 * (c - 11) + 357 + 0x4000 */
    activeFrequency = registers[REG_FSCTRL] - 357 + 2405 - 0x4000;
    activeChannel = (registers[REG_FSCTRL] - 357 - 0x4000)/5 + 11;
  }

  public int getActiveFrequency() {
    updateActiveFrequency();
    return activeFrequency;
  }

  public int getActiveChannel() {
    updateActiveFrequency();
    return activeChannel;
  }

  public int getOutputPowerIndicator() {
    return (registers[REG_TXCTRL] & 0x1f);
  }

  public int getOutputPowerIndicatorMax() {
      return 31;
  }

  /**
   * This is actually the "CORR" value.
   * @param lqi The Corr-val
   * @sa CC2420 Datasheet
   */
  public void setLQI(int lqi){
      if(lqi < 0) lqi = 0;
      else if(lqi > 0x7f ) lqi = 0x7f;
      corrval = lqi;
  }

  public int getLQI() {
      return corrval;
  }

  public void setRSSI(int power) {
    final int minp = -128 + RSSI_OFFSET;
    final int maxp = 127 + RSSI_OFFSET;
    if (power < minp) {
        power = -minp;
    }
    if(power > maxp){
        power = maxp;
    }

    if (logLevel > INFO) log("external setRSSI to: " + power);

    rssi = power;
    registers[REG_RSSI] = (registers[REG_RSSI] & 0xFF00) | ((power - RSSI_OFFSET) & 0xFF);
    updateCCA();
  }

  public int getRSSI() {
    return rssi;
  }

  public int getOutputPower() {
    /* From CC2420 datasheet */
    int indicator = getOutputPowerIndicator();
    if (indicator >= 31) {
      return 0;
    } else if (indicator >= 27) {
      return -1;
    } else if (indicator >= 23) {
      return -3;
    } else if (indicator >= 19) {
      return -5;
    } else if (indicator >= 15) {
      return -7;
    } else if (indicator >= 11) {
      return -10;
    } else if (indicator >= 7) {
      return -15;
    } else if (indicator >= 3) {
      return -25;
    }

    /* Unknown */
    return -100;
  }

  @Override
  public int getOutputPowerMax() {
      return 0;
  }

  public void notifyReset() {
    super.notifyReset();
    setChipSelect(false);
    status &= ~STATUS_TX_ACTIVE;
    setVRegOn(false);
  }

  public void setVRegOn(boolean newOn) {
    if(on == newOn) return;

    if(newOn) {
      // 0.6ms maximum vreg startup from datasheet pg 13
      // but Z1 platform does not work with 0.1 so trying with lower...
      cpu.scheduleTimeEventMillis(vregEvent, 0.05);
      if (logLevel > INFO) log("Scheduling vregEvent at: cyc = " + cpu.cycles +
         " target: " + vregEvent.getTime() + " current: " + cpu.getTime());
    } else {
      on = false;
      setState(RadioState.VREG_OFF);
    }
  }

  public void setChipSelect(boolean select) {
    chipSelect = select;
    if (!chipSelect) {
      if (state == SpiState.WRITE_REGISTER && usartDataPos == 1) {
          // Register write incomplete. Do a 8 bit register write.
          usartDataValue = (registers[usartDataAddress] & 0xff) | (usartDataValue & 0xff00);
          if (logLevel > INFO) {
              log("wrote 8 MSB to 0x" + Utils.hex8(usartDataAddress) + " = " + usartDataValue);
          }
          setReg(usartDataAddress, usartDataValue);
      }
      state = SpiState.WAITING;
    }

    if (logLevel > INFO) {
      log("setting chipSelect: " + chipSelect);
    }
  }

  public boolean getChipSelect() {
    return chipSelect;
  }
  
  public void setCCAPort(IOPort port, int pin) {
    ccaPort = port;
    ccaPin = pin;
  }

  public void setFIFOPPort(IOPort port, int pin) {
    fifopPort = port;
    fifopPin = pin;
  }

  public void setFIFOPort(IOPort port, int pin) {
    fifoPort = port;
    fifoPin = pin;
  }

  public void setSFDPort(IOPort port, int pin) {
    sfdPort = port;
    sfdPin = pin;
  }


  // -------------------------------------------------------------------
  // Methods for accessing and writing to registers, etc from outside
  // And for receiving data
  // -------------------------------------------------------------------

  public int getRegister(int register) {
    return registers[register];
  }

  public void setRegister(int register, int data) {
    registers[register] = data;
  }

  /*****************************************************************************
   * Chip APIs
   *****************************************************************************/

  public int getModeMax() {
    return MODE_MAX;
  }

  private String getLongAddress() {
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < 8; i++) {
        if ((i % 2 == 0) && i > 0) {
            sb.append(':');
        }
        sb.append(Utils.hex8(memory[RAM_IEEEADDR + 7 - i]));
      }
      return sb.toString();
  }

  public String info() {
    updateActiveFrequency();
    return " VREG_ON: " + on + "  Chip Select: " + chipSelect +
    "  OSC Stable: " + ((status & STATUS_XOSC16M_STABLE) > 0) + 
    "\n RSSI Valid: " + ((status & STATUS_RSSI_VALID) > 0) + "  CCA: " + cca +
    "\n FIFOP: " + currentFIFOP + " threshold: " + fifopThr +
    " polarity: " + ((registers[REG_IOCFG0] & FIFOP_POLARITY) == FIFOP_POLARITY) +
    "  FIFO: " + currentFIFO + "  SFD: " + currentSFD + 
    "\n " + rxFIFO.stateToString() + " expPacketLen: " + rxlen +
    "\n Radio State: " + stateMachine + "  SPI State: " + state + 
    "\n AutoACK: " + autoAck + "  AddrDecode: " + addressDecode + "  AutoCRC: " + autoCRC +
    "\n PanID: 0x" + Utils.hex8(memory[RAM_PANID + 1]) + Utils.hex8(memory[RAM_PANID]) +
    "  ShortAddr: 0x" + Utils.hex8(memory[RAM_SHORTADDR + 1]) + Utils.hex8(memory[RAM_SHORTADDR]) +
    "  LongAddr: 0x" + getLongAddress() +
    "\n Channel: " + activeChannel +
    "  Output Power: " + getOutputPower() + "dB (" + getOutputPowerIndicator() + '/' + getOutputPowerIndicatorMax() +
    ")\n";
  }

  public void stateChanged(int state) {
  }

  /* return data in register at the correct position */
  public int getConfiguration(int parameter) {
      return registers[parameter];
  }
  
} // CC2420

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/SPIData.java`:

```java
/**
 * Copyright (c) 2012 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 */
package se.sics.mspsim.chip;

public interface SPIData {

    public int getSPIData(int offset);
    public int getSPIDataLen();
    public void outputSPI(int data);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/M25P16.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;

import se.sics.mspsim.core.MSP430Core;

/**
 * @author Niclas Finne
 */
public class M25P16 extends M25P80 {

    public static final int MEMORY_SIZE = 2 * 1024 * 1024;

    public M25P16(MSP430Core cpu) {
        super("M25P16", cpu);
    }

    @Override
    public int getSize() {
      return MEMORY_SIZE;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/CC2520.java`:

```java
/**
 * Copyright (c) 2012 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * CC2520
 *
 * Author  : Joakim Eriksson, Niclas Finne
 */

package se.sics.mspsim.chip;
import se.sics.mspsim.core.*;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.ArrayFIFO;
import se.sics.mspsim.util.CCITT_CRC;
import se.sics.mspsim.util.Utils;

public class CC2520 extends Radio802154 implements USARTListener, SPIData {

    public static class GPIO {
        private IOPort port;
        private int pin;

        boolean polarity = true;
        boolean isActive;

        public void setConfig(IOPort port, int pin) {
            this.port = port;
            this.pin = pin;
            port.setPinState(pin, isActive == polarity ? IOPort.PinState.HI : IOPort.PinState.LOW);
        }

        public boolean isActive() {
            return isActive;
        }

        public void setActive(boolean isActive) {
            if (this.isActive != isActive) {
                this.isActive = isActive;
                if (port != null) {
                    port.setPinState(pin, isActive == polarity ? IOPort.PinState.HI : IOPort.PinState.LOW);
                }
            }
        }

        public void setPolarity(boolean polarity) {
            if (this.polarity != polarity) {
                this.polarity = polarity;
                if (port != null) {
                    port.setPinState(pin, isActive == polarity ? IOPort.PinState.HI : IOPort.PinState.LOW);
                }
            }
        }
    }

    // FREG definitions (BSET/BCLR supported)
    public final static int REG_FRMFILT0            = 0x000;
    public final static int REG_FRMFILT1            = 0x001;
    public final static int REG_SRCMATCH            = 0x002;
    public final static int REG_SRCSHORTEN0         = 0x004;
    public final static int REG_SRCSHORTEN1         = 0x005;
    public final static int REG_SRCSHORTEN2         = 0x006;
    public final static int REG_SRCEXTEN0           = 0x008;
    public final static int REG_SRCEXTEN1           = 0x009;
    public final static int REG_SRCEXTEN2           = 0x00A;
    public final static int REG_FRMCTRL0            = 0x00C;
    public final static int REG_FRMCTRL1            = 0x00D;
    public final static int REG_RXENABLE0           = 0x00E;
    public final static int REG_RXENABLE1           = 0x00F;
    public final static int REG_EXCFLAG0            = 0x010;
    public final static int REG_EXCFLAG1            = 0x011;
    public final static int REG_EXCFLAG2            = 0x012;
    public final static int REG_EXCMASKA0           = 0x014;
    public final static int REG_EXCMASKA1           = 0x015;
    public final static int REG_EXCMASKA2           = 0x016;
    public final static int REG_EXCMASKB0           = 0x018;
    public final static int REG_EXCMASKB1           = 0x019;
    public final static int REG_EXCMASKB2           = 0x01A;
    public final static int REG_EXCBINDX0           = 0x01C;
    public final static int REG_EXCBINDX1           = 0x01D;
    public final static int REG_EXCBINDY0           = 0x01E;
    public final static int REG_EXCBINDY1           = 0x01F;
    public final static int REG_GPIOCTRL0           = 0x020;
    public final static int REG_GPIOCTRL1           = 0x021;
    public final static int REG_GPIOCTRL2           = 0x022;
    public final static int REG_GPIOCTRL3           = 0x023;
    public final static int REG_GPIOCTRL4           = 0x024;
    public final static int REG_GPIOCTRL5           = 0x025;
    public final static int REG_GPIOPOLARITY        = 0x026;
    public final static int REG_GPIOCTRL            = 0x028;
    public final static int REG_DPUCON              = 0x02A;
    public final static int REG_DPUSTAT             = 0x02C;
    public final static int REG_FREQCTRL            = 0x02E;
    public final static int REG_FREQTUNE            = 0x02F;
    public final static int REG_TXPOWER             = 0x030;
    public final static int REG_TXCTRL              = 0x031;
    public final static int REG_FSMSTAT0            = 0x032;
    public final static int REG_FSMSTAT1            = 0x033;
    public final static int REG_FIFOPCTRL           = 0x034;
    public final static int REG_FSMCTRL             = 0x035;
    public final static int REG_CCACTRL0            = 0x036;
    public final static int REG_CCACTRL1            = 0x037;
    public final static int REG_RSSI                = 0x038;
    public final static int REG_RSSISTAT            = 0x039;
    public final static int REG_TXFIFO_BUF          = 0x03A;
    public final static int REG_RXFIRST             = 0x03C;
    public final static int REG_RXFIFOCNT           = 0x03E;
    public final static int REG_TXFIFOCNT           = 0x03F;

    // SREG definitions (BSET/BCLR unsupported)
    public final static int REG_CHIPID              = 0x040;
    public final static int REG_VERSION             = 0x042;
    public final static int REG_EXTCLOCK            = 0x044;
    public final static int REG_MDMCTRL0            = 0x046;
    public final static int REG_MDMCTRL1            = 0x047;
    public final static int REG_FREQEST             = 0x048;
    public final static int REG_RXCTRL              = 0x04A;
    public final static int REG_FSCTRL              = 0x04C;
    public final static int REG_FSCAL0              = 0x04E;
    public final static int REG_FSCAL1              = 0x04F;
    public final static int REG_FSCAL2              = 0x050;
    public final static int REG_FSCAL3              = 0x051;
    public final static int REG_AGCCTRL0            = 0x052;
    public final static int REG_AGCCTRL1            = 0x053;
    public final static int REG_AGCCTRL2            = 0x054;
    public final static int REG_AGCCTRL3            = 0x055;
    public final static int REG_ADCTEST0            = 0x056;
    public final static int REG_ADCTEST1            = 0x057;
    public final static int REG_ADCTEST2            = 0x058;
    public final static int REG_MDMTEST0            = 0x05A;
    public final static int REG_MDMTEST1            = 0x05B;
    public final static int REG_DACTEST0            = 0x05C;
    public final static int REG_DACTEST1            = 0x05D;
    public final static int REG_ATEST               = 0x05E;
    public final static int REG_DACTEST2            = 0x05F;
    public final static int REG_PTEST0              = 0x060;
    public final static int REG_PTEST1              = 0x061;
    public final static int REG_RESERVED            = 0x062;
    public final static int REG_DPUBIST             = 0x07A;
    public final static int REG_ACTBIST             = 0x07C;
    public final static int REG_RAMBIST             = 0x07E;

    // Instructions
    public final static int INS_SNOP                = 0x00;
    public final static int INS_IBUFLD              = 0x02;
    public final static int INS_SIBUFEX             = 0x03;
    public final static int INS_SSAMPLECCA          = 0x04;
    public final static int INS_SRES                = 0x0F;
    public final static int INS_MEMRD               = 0x10;
    public final static int INS_MEMWR               = 0x20;
    public final static int INS_RXBUF               = 0x30;
    public final static int INS_RXBUFCP             = 0x38;
    public final static int INS_RXBUFMOV            = 0x32;
    public final static int INS_TXBUF               = 0x3A;
    public final static int INS_TXBUFCP             = 0x3E;
    public final static int INS_RANDOM              = 0x3C;
    public final static int INS_SXOSCON             = 0x40;
    public final static int INS_STXCAL              = 0x41;
    public final static int INS_SRXON               = 0x42;
    public final static int INS_STXON               = 0x43;
    public final static int INS_STXONCCA            = 0x44;
    public final static int INS_SRFOFF              = 0x45;
    public final static int INS_SXOSCOFF            = 0x46;
    public final static int INS_SFLUSHRX            = 0x47;
    public final static int INS_SFLUSHTX            = 0x48;
    public final static int INS_SACK                = 0x49;
    public final static int INS_SACKPEND            = 0x4A;
    public final static int INS_SNACK               = 0x4B;
    public final static int INS_SRXMASKBITSET       = 0x4C;
    public final static int INS_SRXMASKBITCLR       = 0x4D;
    public final static int INS_RXMASKAND           = 0x4E;
    public final static int INS_RXMASKOR            = 0x4F;
    public final static int INS_MEMCP               = 0x50;
    public final static int INS_MEMCPR              = 0x52;
    public final static int INS_MEMXCP              = 0x54;
    public final static int INS_MEMXWR              = 0x56;
    public final static int INS_BCLR                = 0x58;
    public final static int INS_BSET                = 0x59;
    public final static int INS_CTR                 = 0x60;
    public final static int INS_CBCMAC              = 0x64;
    public final static int INS_UCBCMAC             = 0x66;
    public final static int INS_CCM                 = 0x68;
    public final static int INS_UCCM                = 0x6A;
    public final static int INS_ECB                 = 0x70;
    public final static int INS_ECBO                = 0x72;
    public final static int INS_ECBX                = 0x74;
    public final static int INS_ECBXO               = 0x76;
    public final static int INS_INC                 = 0x78;
    public final static int INS_ABORT               = 0x7F;
    public final static int INS_REGRD               = 0x80;
    public final static int INS_REGWR               = 0xC0;

    // Status register flags
    public static final int STATUS_XOSC16M_STABLE   = 1 << 7;
    public static final int STATUS_RSSI_VALID       = 1 << 6;
    public static final int STATUS_EXCEPTION_CHA    = 1 << 5;
    public static final int STATUS_EXCEPTION_CHB    = 1 << 4;
    public static final int STATUS_DPU_H            = 1 << 3;
    public static final int STATUS_DPU_L            = 1 << 2;
    public static final int STATUS_TX_ACTIVE        = 1 << 1;
    public static final int STATUS_RX_ACTIVE        = 1 << 0;

    // Exceptions (bits in the EXCFLAGx memory)
    public final static int EXC_RF_IDLE             = 1 << 0;
    public final static int EXC_TX_FRM_DONE         = 1 << 1;
    public final static int EXC_RX_FRM_ABORTED      = 0x20;
    public final static int EXC_RX_FRM_UNDERFLOW    = 0x20;

    // RAM Addresses
    public static final int RAM_TXFIFO              = 0x100;
    public static final int RAM_RXFIFO              = 0x180;
    public static final int RAM_IEEEADDR            = 0x3EA;
    public static final int RAM_PANID               = 0x3F2;
    public static final int RAM_SHORTADDR           = 0x3F4;
//    public static final int RAM_KEY0                = 0x100;
//    public static final int RAM_RXNONCE             = 0x110;
//    public static final int RAM_SABUF               = 0x120;
//    public static final int RAM_KEY1                = 0x130;
//    public static final int RAM_TXNONCE             = 0x140;
//    public static final int RAM_CBCSTATE            = 0x150;

    /* one single byte instruction can be stored in the IBUF */
    int instructionBuffer = 0;

    // IOCFG0 memory Bit masks
    public static final int BCN_ACCEPT = (1<<11);
    public static final int FIFOP_THR = 0x7F;

    // IOCFG1 memory Bit Masks
//    public static final int SFDMUX = 0x3E0;
//    public static final int CCAMUX = 0x1F;

    // CCAMUX values
//    public static final int CCAMUX_CCA = 0;
//    public static final int CCAMUX_XOSC16M_STABLE = 24;

    // FRMFILT0/FRMCTRL0 values
    public static final int FRAME_FILTER = (1 << 0);
    public static final int AUTOCRC      = (1 << 6);
    public static final int AUTOACK      = (1 << 5);

    // FRMFILT1
    public static final int ACCEPT_FT_4TO7_RESERVED = (1 << 7);
    public static final int ACCEPT_FT_3_MAC_CMD     = (1 << 6);
    public static final int ACCEPT_FT_2_ACK         = (1 << 5);
    public static final int ACCEPT_FT_1_DATA        = (1 << 4);
    public static final int ACCEPT_FT_0_BEACON      = (1 << 3);

    public static final int SHORT_ADDRESS = 2;
    public static final int LONG_ADDRESS = 3;


    // The Operation modes of the CC2520
    public static final int MODE_TXRX_OFF = 0x00;
    public static final int MODE_RX_ON = 0x01;
    public static final int MODE_TXRX_ON = 0x02;
    public static final int MODE_POWER_OFF = 0x03;
    public static final int MODE_MAX = MODE_POWER_OFF;
    private static final String[] MODE_NAMES = new String[] {
        "off", "listen", "transmit", "power_off"
    };

    // State Machine - Datasheet Figure 30 page 85
    public enum RadioState {
        VREG_OFF(-2),
        POWER_DOWN(-1),
        IDLE(0),
        RX_CALIBRATE(2),
        RX_SFD_SEARCH(3),
        RX_WAIT(14),
        RX_FRAME(15),
        RX_OVERFLOW(17),
        TX_CALIBRATE(32),
        TX_PREAMBLE(34),
        TX_FRAME(37),
        TX_ACK_CALIBRATE(48),
        TX_ACK_PREAMBLE(49),
        TX_ACK(52),
        TX_UNDERFLOW(56);

        private final int state;
        RadioState(int stateNo) {
            state = stateNo;
        }

        public int getFSMState() {
            return state;
        }
    };

    // FCF High
    public static final int FRAME_TYPE        = 0x07;
    public static final int SECURITY_ENABLED  = (1 << 3);
    public static final int FRAME_PENDING     = (1 << 4);
    public static final int ACK_REQUEST       = (1 << 5);
    public static final int INTRA_PAN         = (1 << 6);

    public static final int TYPE_BEACON_FRAME = 0x00;
    public static final int TYPE_DATA_FRAME   = 0x01;
    public static final int TYPE_ACK_FRAME    = 0x02;

    // FCF Low
    public static final int DESTINATION_ADDRESS_MODE = 0x30;
    public static final int SOURCE_ADDRESS_MODE = 0x3;

    // Position of SEQ-NO in ACK packet...
    public static final int ACK_SEQPOS = 3;

    private RadioState stateMachine = RadioState.VREG_OFF;

    // 802.15.4 symbol period in ms
    public static final double SYMBOL_PERIOD = 0.016; // 16 us

    private static final int[] BC_ADDRESS = new int[] {0xff, 0xff};

    private int shrPos;
    private int txfifoPos;
    private boolean txfifoFlush;  // TXFIFO is automatically flushed on next write
    private int rxfifoReadLeft;   // number of bytes left to read from current packet
    private int rxlen;
    private int rxread;
    private int zeroSymbols;

    /* RSSI is an externally set value of the RSSI for this CC2520 */
    /* low RSSI => CCA = true in normal mode */

    private int rssi = -100;
    private static int RSSI_OFFSET = -45; /* cc2520 datasheet */

    /* This is the magical LQI */
    private int corrval = 37;

    /* FIFOP Threshold */
    private int fifopThr = 0x40;

    /* Configuration for frame filtering and auto acknowledgments */
    private boolean frameFilter = false;
    private boolean autoAck = false;
    private boolean shouldAck = false;
    private boolean ackRequest = false;
    private boolean autoCRC = false;

    // Data from last received packet
    private int dsn = 0;
    private int fcf0 = 0;
    private int fcf1 = 0;
    private int frameType = 0;
    private boolean crcOk = false;

    private int activeFrequency = 0;
    private int activeChannel = 0;

    //private int status = STATUS_XOSC16M_STABLE | STATUS_RSSI_VALID;
    private int status = 0;

    private final int[] memory = new int[0x400]; /* total memory */

    private CC2520SPI cc2520SPI = new CC2520SPI(this);
    private SPICommand command;
    private int[] spiData = new int[20]; /* SPI data buffer */
    private int spiLen;

    // Buffer to hold 5 byte Synchronization header, as it is not written to the TXFIFO
    private final byte[] SHR = new byte[5];

    /* the data that should be SPI response */
    private int outputSPI;

    private boolean chipSelect;
    private final GPIO[] gpio = new GPIO[6];
    private GPIO ccaGPIO;
    private GPIO fifopGPIO;
    private GPIO fifoGPIO;
    private GPIO sfdGPIO;
    private boolean currentFIFO;
    private boolean currentFIFOP;

    /* current CCA value */
    private boolean currentCCA = false;

    private int txCursor;
    private boolean isRadioOn;

    private TimeEvent oscillatorEvent = new TimeEvent(0, "CC2520 OSC") {
        public void execute(long t) {
            status |= STATUS_XOSC16M_STABLE;
            if(DEBUG) log("Oscillator Stable Event.");
            setState(RadioState.IDLE);
            updateCCA();
        }
    };

    private TimeEvent vregEvent = new TimeEvent(0, "CC2520 VREG") {
        public void execute(long t) {
            if(DEBUG) log("VREG Started at: " + t + " cyc: " +
                    cpu.cycles + " " + getTime());
            isRadioOn = true;
            setState(RadioState.POWER_DOWN);
            updateCCA();
        }
    };

    private TimeEvent sendEvent = new TimeEvent(0, "CC2520 Send") {
        public void execute(long t) {
            txNext();
        }
    };

    private TimeEvent ackEvent = new TimeEvent(0, "CC2520 Ack") {
        public void execute(long t) {
            ackNext();
        }
    };

    private TimeEvent shrEvent = new TimeEvent(0, "CC2520 SHR") {
        public void execute(long t) {
            shrNext();
        }
    };

    private TimeEvent symbolEvent = new TimeEvent(0, "CC2520 Symbol") {
        public void execute(long t) {
            switch(stateMachine) {
            case RX_CALIBRATE:
                setState(RadioState.RX_SFD_SEARCH);
                break;
                /* this will be called 8 symbols after first SFD_SEARCH */
            case RX_SFD_SEARCH:
                status |= STATUS_RSSI_VALID;
                memory[REG_RSSISTAT] = 1;
                updateCCA();
                break;

            case TX_CALIBRATE:
                setState(RadioState.TX_PREAMBLE);
                break;

            case RX_WAIT:
                setState(RadioState.RX_SFD_SEARCH);
                break;

            case TX_ACK_CALIBRATE:
                setState(RadioState.TX_ACK_PREAMBLE);
                break;

            default:
                // Ignore other states
                break;
            }
        }
    };
    private boolean overflow = false;
    private boolean frameRejected = false;

    private int ackPos;
    /* type = 2 (ACK), third byte needs to be sequence number... */
    private int[] ackBuf = {0x05, 0x02, 0x00, 0x00, 0x00, 0x00};
    private boolean ackFramePending = false;
    private CCITT_CRC rxCrc = new CCITT_CRC();
    private CCITT_CRC txCrc = new CCITT_CRC();

    private final ArrayFIFO rxFIFO = new ArrayFIFO("RXFIFO", memory, 128, 128);

    public CC2520(MSP430Core cpu) {
        super("CC2520", "Radio", cpu);

        for (int i = 0; i < gpio.length; i++) {
            gpio[i] = new GPIO();
        }

        setModeNames(MODE_NAMES);
        setMode(MODE_POWER_OFF);
        rxFIFO.reset();
        overflow = false;
        reset();
    }

    public RadioState getState() {
        return stateMachine;
    }

    private int getFCFReservedMask() {
        return (memory[REG_FRMFILT0] >> 4) & 7;
    }

    private int getFCFMaxFrameVersion() {
        return (memory[REG_FRMFILT0] >> 2) & 3;
    }

    private void updateGPIOConfig() {
        int bit = 1;
        for (GPIO io : gpio) {
            io.setPolarity((memory[REG_GPIOPOLARITY] & bit) > 0);
            bit = bit << 1;
        }
    }

    public int getFooterLength() {
    	if (autoCRC) {
    		return 2;
    	}
    	return 0;
    }
    
    private void reset() {
        // FCF max fram version = 3 and frame filtering enabled
        memory[REG_FRMFILT0] = 0x0d;
        frameFilter = true;
        memory[REG_FRMFILT1] = 0x78;
        // autocrc enabled, autoack disabled
        memory[REG_FRMCTRL0] = 0x40;
        autoCRC = true;
        autoAck = false;

        memory[REG_MDMCTRL0] = 0x45;
        memory[REG_MDMCTRL1] = 0x3e;
        memory[REG_FSMSTAT0] = 0;
        memory[REG_FSMSTAT1] = 0;
        memory[REG_RSSISTAT] = 0;
        memory[REG_TXPOWER] = 0x06;
        memory[REG_FIFOPCTRL] = fifopThr = 0x40;
        memory[REG_FREQCTRL] = 0x0b;

        /* back to default configuration of GPIOs */
        memory[REG_GPIOPOLARITY] = 0x3f;
        updateGPIOConfig();

        fifoGPIO = gpio[1];
        fifopGPIO = gpio[2];
        ccaGPIO = gpio[3];
        sfdGPIO = gpio[4];

        setFIFO(false);
        setFIFOP(false);
        setSFD(false);
        updateCCA();
    }

    private boolean setState(RadioState state) {
        if(DEBUG) log("State transition from " + stateMachine + " to " + state);
        stateMachine = state;
        /* write to FSM state register */
        memory[REG_FSMSTAT0] = (memory[REG_FSMSTAT0] & 0x3f);//state.getFSMState();

        switch(stateMachine) {

        case VREG_OFF:
            if (DEBUG) log("VREG Off.");
            flushRX();
            flushTX();
            status &= ~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
            memory[REG_RSSISTAT] = 0;
            crcOk = false;
            reset();
            setMode(MODE_POWER_OFF);
            updateCCA();
            break;

        case POWER_DOWN:
            rxFIFO.reset();
            status &= ~(STATUS_RSSI_VALID | STATUS_XOSC16M_STABLE);
            memory[REG_RSSISTAT] = 0;
            crcOk = false;
            reset();
            setMode(MODE_POWER_OFF);
            updateCCA();
            break;

        case RX_CALIBRATE:
            /* should be 12 according to specification */
            setSymbolEvent(12);
            setMode(MODE_RX_ON);
            break;
        case RX_SFD_SEARCH:
            zeroSymbols = 0;
            /* eight symbols after first SFD search RSSI will be valid */
            if ((status & STATUS_RSSI_VALID) == 0) {
                setSymbolEvent(8);
            }
            //      status |= STATUS_RSSI_VALID;
            updateCCA();
            setMode(MODE_RX_ON);
            break;

        case TX_CALIBRATE:
            /* 12 symbols calibration, and one byte's wait since we deliver immediately
             * to listener when after calibration?
             */
            setSymbolEvent(12 + 2);
            setMode(MODE_TXRX_ON);
            break;

        case TX_PREAMBLE:
            shrPos = 0;
            SHR[0] = 0;
            SHR[1] = 0;
            SHR[2] = 0;
            SHR[3] = 0;
            SHR[4] = 0x7A;
            shrNext();
            break;

        case TX_FRAME:
            txfifoPos = 0;
            // Reset CRC ok flag to disable software acknowledgments until next received packet
            crcOk = false;
            txNext();
            break;

        case RX_WAIT:
            setSymbolEvent(8);
            setMode(MODE_RX_ON);
            break;

        case IDLE:
            status &= ~STATUS_RSSI_VALID;
            memory[REG_RSSISTAT] = 0;
            setMode(MODE_TXRX_OFF);
            updateCCA();
            break;

        case TX_ACK_CALIBRATE:
            /* TX active during ACK + NOTE: we ignore the SFD when receiving full packets so
             * we need to add another extra 2 symbols here to get a correct timing */
            status |= STATUS_TX_ACTIVE;
            memory[REG_FSMSTAT1] |= (1 << 1);
            setSymbolEvent(12 + 2 + 2);
            setMode(MODE_TXRX_ON);
            break;
        case TX_ACK_PREAMBLE:
            /* same as normal preamble ?? */
            shrPos = 0;
            SHR[0] = 0;
            SHR[1] = 0;
            SHR[2] = 0;
            SHR[3] = 0;
            SHR[4] = 0x7A;
            shrNext();
            break;
        case TX_ACK:
            ackPos = 0;
            // Reset CRC ok flag to disable software acknowledgments until next received packet
            crcOk = false;
            ackNext();
            break;
        case RX_FRAME:
            /* mark position of frame start - for rejecting when address is wrong */
            rxFIFO.mark();
            rxread = 0;
            frameRejected = false;
            shouldAck = false;
            crcOk = false;
            break;

        case RX_OVERFLOW:
            break;

        case TX_UNDERFLOW:
            // TODO handle TX underflow
            break;
        }

        /* Notify state listener */
        stateChanged(stateMachine.state);

        return true;
    }

    private void rejectFrame() {
        // Immediately jump to SFD Search again... something more???
        /* reset state */
        rxFIFO.restore();
        setSFD(false);
        setFIFO(rxFIFO.length() > 0);
        frameRejected = true;
    }

    /* variables for the address recognition */
    int destinationAddressMode = 0;
    boolean decodeAddress = false;
    /* Receive a byte from the radio medium
     * @see se.sics.mspsim.chip.RFListener#receivedByte(byte)
     */
    public void receivedByte(byte data) {
        // Received a byte from the "air"

        if (DEBUG)
            log("RF Byte received: " + Utils.hex8(data) + " state: " + stateMachine + " noZeroes: " + zeroSymbols +
                    ((stateMachine == RadioState.RX_SFD_SEARCH || stateMachine == RadioState.RX_FRAME) ? "" : " *** Ignored"));

        if(stateMachine == RadioState.RX_SFD_SEARCH) {
            // Look for the preamble (4 zero bytes) followed by the SFD byte 0x7A
            if(data == 0) {
                // Count zero bytes
                zeroSymbols++;
            } else if(zeroSymbols >= 4 && data == 0x7A) {
                // If the received byte is !zero, we have counted 4 zero bytes prior to this one,
                // and the current received byte == 0x7A (SFD), we're in sync.
                // In RX mode, SFD goes high when the SFD is received
                setSFD(true);
                if (DEBUG) log("RX: Preamble/SFD Synchronized.");
                setState(RadioState.RX_FRAME);
            } else {
                /* if not four zeros and 0x7A then no zeroes... */
                zeroSymbols = 0;
            }

        } else if(stateMachine == RadioState.RX_FRAME) {
            if (overflow) {
                /* if the CC2520 RX FIFO is in overflow - it needs a flush before receiving again */
            } else if(rxFIFO.isFull()) {
                setRxOverflow();
            } else {
                if (!frameRejected) {
                    rxFIFO.write(data);
                    if (rxread == 0) {
                        rxCrc.setCRC(0);
                        rxlen = data & 0xff;
                        //System.out.println("Starting to get packet at: " + rxfifoWritePos + " len = " + rxlen);
                        decodeAddress = frameFilter;
                        if (DEBUG) log("RX: Start frame length " + rxlen);
                        // FIFO pin goes high after length byte is written to RXFIFO
                        setFIFO(true);
                    } else if (rxread < rxlen - 1) {
                        /* As long as we are not in the length or FCF (CRC) we count CRC */
                        rxCrc.addBitrev(data & 0xff);
                        if (rxread == 1) {
                            fcf0 = data & 0xff;
                            frameType = fcf0 & FRAME_TYPE;
                        } else if (rxread == 2) {
                            fcf1 = data & 0xff;

                            if (frameFilter
                                    && (((getFCFReservedMask() & (((fcf0 & 3) << 1) | (fcf1 & 1))) != 0)
                                            || (getFCFMaxFrameVersion() < ((fcf0 >> 2) & 3)))) {
                                // Illegal frame version or reserved bits set
                                rejectFrame();
                            } else if (frameType == TYPE_DATA_FRAME) {
                                ackRequest = (fcf0 & ACK_REQUEST) > 0;
                                destinationAddressMode = (fcf1 >> 2) & 3;
                                /* check this !!! */
                                if (frameFilter) {
                                    if ((destinationAddressMode != LONG_ADDRESS
                                            && destinationAddressMode != SHORT_ADDRESS)
                                            || (memory[REG_FRMFILT1] & ACCEPT_FT_1_DATA) == 0) {
                                        rejectFrame();
                                    }
                                }
                            } else if (frameType == TYPE_ACK_FRAME) {
                                decodeAddress = false;
                                ackRequest = false;
                                if (frameFilter) {
                                    if (rxlen != 5
                                            || (memory[REG_FRMFILT1] & ACCEPT_FT_2_ACK) == 0) {
                                        rejectFrame();
                                    }
                                }
                            } else if (frameType == TYPE_BEACON_FRAME) {
                                decodeAddress = false;
                                ackRequest = false;
                                destinationAddressMode = (fcf1 >> 2) & 3;
                                if (frameFilter) {
                                    if (rxlen < 9
                                            || (memory[REG_FRMFILT1] & ACCEPT_FT_0_BEACON) == 0
                                            || destinationAddressMode != 0) {
                                        rejectFrame();
                                    }
                                }
                            } else if (frameFilter) {
                                /* illegal frame when decoding address... */
                                rejectFrame();
                            }
                        } else if (rxread == 3) {
                            // save data sequence number
                            dsn = data & 0xff;
                        } else if (decodeAddress) {
                            boolean flushPacket = false;
                            /* here we decode the address !!! */
                            if (destinationAddressMode == LONG_ADDRESS && rxread == 8 + 5) {
                                /* here we need to check that this address is correct compared to the stored address */
                                flushPacket = !rxFIFO.tailEquals(memory, RAM_IEEEADDR, 8);
                                flushPacket |= !rxFIFO.tailEquals(memory, RAM_PANID, 2, 8)
                                        && !rxFIFO.tailEquals(BC_ADDRESS, 0, 2, 8);
                                decodeAddress = false;
                            } else if (destinationAddressMode == SHORT_ADDRESS && rxread == 2 + 5){
                                /* should check short address */
                                flushPacket = !rxFIFO.tailEquals(BC_ADDRESS, 0, 2)
                                        && !rxFIFO.tailEquals(memory, RAM_SHORTADDR, 2);
                                flushPacket |= !rxFIFO.tailEquals(memory, RAM_PANID, 2, 2)
                                        && !rxFIFO.tailEquals(BC_ADDRESS, 0, 2, 2);
                                decodeAddress = false;
                            }
                            if (flushPacket) {
                                rejectFrame();
                            }
                        }
                    }

                    /* In RX mode, FIFOP goes high when the size of the first enqueued packet exceeds
                     * the programmable threshold and address recognition isn't ongoing */
                    if (currentFIFOP == false
                            && rxFIFO.length() <= rxlen + 1
                            && !decodeAddress && !frameRejected
                            && rxFIFO.length() > fifopThr) {
                        setFIFOP(true);
                        if (DEBUG) log("RX: FIFOP Threshold reached - setting FIFOP");
                    }
                }

                if (rxread++ == rxlen) {
                    if (frameRejected) {
                        if (DEBUG) log("Frame rejected - setting SFD to false and RXWAIT\n");
                        setSFD(false);
                        setState(RadioState.RX_WAIT);
                        return;
                    }
                    // In RX mode, FIFOP goes high, if threshold is higher than frame length....

                    // Here we check the CRC of the packet!
                    //System.out.println("Reading from " + ((rxfifoWritePos + 128 - 2) & 127));
                    if (autoCRC) {
                        int crc = rxFIFO.get(-2) << 8;
                        crc += rxFIFO.get(-1); //memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)];

                        crcOk = crc == rxCrc.getCRCBitrev();
                        if (DEBUG && !crcOk) {
                            log("CRC not OK: recv:" + Utils.hex16(crc) + " calc: " + Utils.hex16(rxCrc.getCRCBitrev()));
                        }
                        // Should take a RSSI value as input or use a set-RSSI value...
                        rxFIFO.set(-2, memory[REG_RSSI] & 0xff);
                        rxFIFO.set(-1, (corrval & 0x7F) | (crcOk ? 0x80 : 0));
                        //          memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 2) & 127)] = ;
                        //          // Set CRC ok and add a correlation - TODO: fix better correlation value!!!
                        //          memory[RAM_RXFIFO + ((rxfifoWritePos + 128 - 1) & 127)] = 37 |
                        //              (crcOk ? 0x80 : 0);
                    } else {
                    	crcOk = true;
                    }

                    /* set FIFOP only if this is the first received packet - e.g. if rxfifoLen is at most rxlen + 1
                     * TODO: check what happens when rxfifoLen < rxlen - e.g we have been reading before FIFOP */
                    if (rxFIFO.length() <= rxlen + 1) {
                        setFIFOP(true);
                    } else {
                        if (DEBUG) log("Did not set FIFOP rxfifoLen: " + rxFIFO.length() + " rxlen: " + rxlen);
                    }
                    setSFD(false);
                    if (DEBUG) log("RX: Complete: packetStart: " + rxFIFO.stateToString());

                    /* if either manual ack request (shouldAck) or autoack + ACK_REQ on package do ack! */
                    /* Autoack-mode + good CRC => autoack */
                    if (((autoAck && ackRequest) || shouldAck) && crcOk) {
                        setState(RadioState.TX_ACK_CALIBRATE);
                    } else {
                        setState(RadioState.RX_WAIT);
                    }
                }
            }
        }
    }

    /* API used in CC2520 SPI for both memory and registers */
    void writeMemory(int address, int data) {
//        System.out.printf("CC2520: writing to %x => %x\n", address, data);
        int oldValue = memory[address];
        memory[address] = data;
        switch(address) {
        case REG_FRMFILT0:
            frameFilter = (data & FRAME_FILTER) != 0;
            break;
        case REG_FRMCTRL0:
            autoCRC = (data & AUTOCRC) != 0;
            autoAck = (data & AUTOACK) != 0;
            break;
        case REG_TXPOWER:
            if (!isDefinedTxPower(data)) {
                logw(WarningType.EXECUTION, "*** Warning - writing an undefined TXPOWER value (0x"
                        + Utils.hex8(data) + ") to CC2520!!!");
            }
            break;
        case REG_FIFOPCTRL:
            fifopThr = data & FIFOP_THR;
            if (DEBUG) log("FIFOPCTRL: 0x" + Utils.hex16(oldValue) + " => 0x" + Utils.hex16(data));
            break;
        case REG_GPIOPOLARITY:
            if (DEBUG) log("GIOPOLARITY: 0x" + Utils.hex16(oldValue) + " => 0x" + Utils.hex16(data));
            if (oldValue != data) {
                updateGPIOConfig();
            }
            break;
            //        case REG_IOCFG1:
            //            if (DEBUG)
            //                log("IOCFG1: SFDMUX "
            //                        + ((memory[address] & SFDMUX) >> SFDMUX)
            //                        + " CCAMUX: " + (memory[address] & CCAMUX));
            //            updateCCA();
            //            break;
        case REG_GPIOCTRL0:
			/*
			 * XXX TODO Implement support for GPIO control. Below example code
			 * demonstrates how GPIO0 is set to fifop functionality (0x28).
			 */
			if (data == 0x28) {
				fifopGPIO = gpio[0];
			}
        	break;
        case REG_FSCTRL: {
            ChannelListener listener = this.channelListener;
            if (listener != null) {
                int oldChannel = activeChannel;
                updateActiveFrequency();
                if (oldChannel != activeChannel) {
                    listener.channelChanged(activeChannel);
                }
            }
            break;
        }
        }
        configurationChanged(address, oldValue, data);
    }

    int readMemory(int address) {
        switch(address) {
        case REG_RXFIFOCNT:
        	return rxFIFO.length();
        }
        return memory[address];
    }

    @Override
    public void dataReceived(USARTSource source, int data) {
        outputSPI = status; /* if nothing replace the outputSPI it will be output */
        if (DEBUG) {
            log("byte received: " + Utils.hex8(data) +
                    " (" + ((data >= ' ' && data <= 'Z') ? (char) data : '.') + ')' +
                    " CS: " + chipSelect + " SPI(" + spiLen + "): " + (command == null ? "<waiting>" : command.name)
                    + " State: " + stateMachine);
        }

        if (!chipSelect) {
            // Chip is not selected
            return;
        }

        if (stateMachine == RadioState.VREG_OFF) {
            /* No VREG but chip select */
            source.byteReceived(0);
            logw(WarningType.EXECUTION, "**** Warning - writing to CC2520 when VREG is off!!!");
            return;
        }

        if (command == null) {
            command = cc2520SPI.getCommand(data);
            if (command == null) {
                logw(WarningType.EMULATION_ERROR, "**** Warning - not implemented command on SPI: " + data);
            } else if (DEBUG) {
                if (!"SNOP".equals(command.name)) {
                    log("SPI command: " + command.name);
                }
            }
        }

        /* command handling */
        spiData[spiLen] = data;
        /* ensure that we do not store too many SPI data items */
        if (spiLen < (spiData.length - 1)) {
            spiLen++;
        }

        if (command != null) {
            command.dataReceived(data);
            if (spiLen == command.commandLen) {
//                System.out.println("CC2520 Executing command: " + command.name);
                command.executeSPICommand();
                command = null;
                spiLen = 0;
            }
        }
        source.byteReceived(outputSPI);
    }

    void rxon() {
        if(stateMachine == RadioState.IDLE) {
            setState(RadioState.RX_CALIBRATE);
            //updateActiveFrequency();
            if (DEBUG) {
                log("Strobe RX-ON!!!");
            }
        } else {
            if (DEBUG) log("WARNING: SRXON when not IDLE");
        }
    }

    void rxtxoff() {
        if (DEBUG) {
            log("Strobe RXTX-OFF!!! at " + cpu.cycles);
            if (stateMachine == RadioState.TX_ACK ||
                    stateMachine == RadioState.TX_FRAME ||
                    stateMachine == RadioState.RX_FRAME) {
                log("WARNING: turning off RXTX during " + stateMachine);
            }
        }
        setState(RadioState.IDLE);
    }

    void stxon() {
        // State transition valid from IDLE state or all RX states
        if( (stateMachine == RadioState.IDLE) ||
                (stateMachine == RadioState.RX_CALIBRATE) ||
                (stateMachine == RadioState.RX_SFD_SEARCH) ||
                (stateMachine == RadioState.RX_FRAME) ||
                (stateMachine == RadioState.RX_OVERFLOW) ||
                (stateMachine == RadioState.RX_WAIT)) {
            status |= STATUS_TX_ACTIVE;
            memory[REG_FSMSTAT1] |= (1 << 1);
            setState(RadioState.TX_CALIBRATE);
            if (sendEvents) {
                sendEvent("STXON", null);
            }
            // Starting up TX subsystem - indicate that we are in TX mode!
            if (DEBUG) log("Strobe STXON - transmit on! at " + cpu.cycles);
        }
    }

    void stxoncca() {
        // Only valid from all RX states,
        // since CCA requires ??(look this up) receive symbol periods to be valid
        if( (stateMachine == RadioState.RX_CALIBRATE) ||
                (stateMachine == RadioState.RX_SFD_SEARCH) ||
                (stateMachine == RadioState.RX_FRAME) ||
                (stateMachine == RadioState.RX_OVERFLOW) ||
                (stateMachine == RadioState.RX_WAIT)) {

            if (sendEvents) {
                sendEvent("STXON_CCA", null);
            }

            if(currentCCA) {
                status |= STATUS_TX_ACTIVE;
                memory[REG_FSMSTAT1] |= (1 << 1);
                setState(RadioState.TX_CALIBRATE);
                if (DEBUG) log("Strobe STXONCCA - transmit on! at " + cpu.cycles);
            }else{
                if (DEBUG) log("STXONCCA Ignored, CCA false");
            }
        }
    }

    void sack(boolean pend) {
        // Set the frame pending flag for all future autoack based on SACK/SACKPEND
        ackFramePending = pend;
        if (stateMachine == RadioState.RX_FRAME) {
            shouldAck = true;
        } else if (crcOk) {
            setState(RadioState.TX_ACK_CALIBRATE);
        }
    }

    private void shrNext() {
        if(shrPos == 5) {
            // Set SFD high
            setSFD(true);

            if (stateMachine == RadioState.TX_PREAMBLE) {
                setState(RadioState.TX_FRAME);
            } else if (stateMachine == RadioState.TX_ACK_PREAMBLE) {
                setState(RadioState.TX_ACK);
            } else {
                log("Can not move to TX_FRAME or TX_ACK after preamble since radio is in wrong mode: " +
                        stateMachine);
            }
        } else {
            if (rfListener != null) {
                if (DEBUG) log("transmitting byte: " + Utils.hex8(SHR[shrPos]));
                rfListener.receivedByte(SHR[shrPos]);
            }
            shrPos++;
            cpu.scheduleTimeEventMillis(shrEvent, SYMBOL_PERIOD * 2);
        }
    }

    private void txNext() {
        if(txfifoPos <= memory[RAM_TXFIFO]) {
            int len = memory[RAM_TXFIFO] & 0xff;
            
            if (autoCRC) {
                if (txfifoPos == len - 1) {
                    txCrc.setCRC(0);
                    for (int i = 1; i < len - 1; i++) {
                        txCrc.addBitrev(memory[RAM_TXFIFO + i] & 0xff);
                    }
                    memory[RAM_TXFIFO + len - 1] = txCrc.getCRCHi();
                    memory[RAM_TXFIFO + len] = txCrc.getCRCLow();
                }
            }
            
            if (txfifoPos > 0x7f) {
                logw(WarningType.EXECUTION, "**** Warning - packet size too large - repeating packet bytes txfifoPos: " + txfifoPos);
            }
            if (rfListener != null) {
                if (DEBUG) log("transmitting byte: " + Utils.hex8(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));
                rfListener.receivedByte((byte)(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));
            }
            txfifoPos++;
            // Two symbol periods to send a byte...
            cpu.scheduleTimeEventMillis(sendEvent, SYMBOL_PERIOD * 2);
        } else {
            if (DEBUG) log("Completed Transmission.");
            status &= ~STATUS_TX_ACTIVE;
            memory[REG_FSMSTAT1] &= ~(1 << 1);
            setSFD(false);
            if (overflow) {
                /* TODO: is it going back to overflow here ?=? */
                setState(RadioState.RX_OVERFLOW);
            } else {
                setState(RadioState.RX_CALIBRATE);
            }
            /* Back to RX ON */
            setMode(MODE_RX_ON);
            txfifoFlush = true;
        }
    }

    private void ackNext() {
        if (ackPos < ackBuf.length) {
            if(ackPos == 0) {
                txCrc.setCRC(0);
                if (ackFramePending) {
                    ackBuf[1] |= FRAME_PENDING;
                } else {
                    ackBuf[1] &= ~FRAME_PENDING;
                }
                // set dsn
                ackBuf[3] = dsn;
                int len = 4;
                for (int i = 1; i < len; i++) {
                    txCrc.addBitrev(ackBuf[i] & 0xff);
                }
                ackBuf[4] = txCrc.getCRCHi();
                ackBuf[5] = txCrc.getCRCLow();
            }
            if (rfListener != null) {
                if (DEBUG) log("transmitting byte: " + Utils.hex8(memory[RAM_TXFIFO + (txfifoPos & 0x7f)] & 0xFF));

                rfListener.receivedByte((byte)(ackBuf[ackPos] & 0xFF));
            }
            ackPos++;
            // Two symbol periods to send a byte...
            cpu.scheduleTimeEventMillis(ackEvent, SYMBOL_PERIOD * 2);
        } else {
            if (DEBUG) log("Completed Transmission of ACK.");
            status &= ~STATUS_TX_ACTIVE;
            memory[REG_FSMSTAT1] &= ~(1 << 1);
            setSFD(false);
            setState(RadioState.RX_CALIBRATE);
            /* Back to RX ON */
            setMode(MODE_RX_ON);
        }
    }


    private void setSymbolEvent(int symbols) {
        double period = SYMBOL_PERIOD * symbols;
        cpu.scheduleTimeEventMillis(symbolEvent, period);
        //log("Set Symbol event: " + period);
    }

    void startOscillator() {
        // 1ms crystal startup from datasheet pg12
        cpu.scheduleTimeEventMillis(oscillatorEvent, 1);
    }

    void stopOscillator() {
        status &= ~STATUS_XOSC16M_STABLE;
        setState(RadioState.POWER_DOWN);
        if (DEBUG) log("Oscillator Off.");
        // Reset state
        setFIFOP(false);
    }

    void flushRX() {
        if (DEBUG) {
            log("Flushing RX len = " + rxFIFO.length());
        }
        rxFIFO.reset();
        setSFD(false);
        setFIFOP(false);
        setFIFO(false);
        overflow = false;
        /* goto RX Calibrate */
        if( (stateMachine == RadioState.RX_CALIBRATE) ||
                (stateMachine == RadioState.RX_SFD_SEARCH) ||
                (stateMachine == RadioState.RX_FRAME) ||
                (stateMachine == RadioState.RX_OVERFLOW) ||
                (stateMachine == RadioState.RX_WAIT)) {
            setState(RadioState.RX_SFD_SEARCH);
        }
    }

    void writeTXFIFO(int data) {
        if(txfifoFlush) {
            txCursor = 0;
            txfifoFlush = false;
        }
        if (DEBUG) log("Writing data: " + data + " to tx: " + txCursor);

        if(txCursor == 0) {
            if ((data & 0xff) > 127) {
                logger.logw(this, WarningType.EXECUTION, "CC2520: Warning - packet size too large: " + (data & 0xff));
            }
        } else if (txCursor > 127) {
            logger.logw(this, WarningType.EXECUTION, "CC2520: Warning - TX Cursor wrapped");
            txCursor = 0;
        }
        memory[RAM_TXFIFO + txCursor] = data & 0xff;
        txCursor++;
        if (sendEvents) {
            sendEvent("WRITE_TXFIFO", null);
        }
    }

    // TODO: update any pins here?
    void flushTX() {
        txCursor = 0;
    }

    private void updateCCA() {
         boolean oldCCA = currentCCA;

         currentCCA = (status & STATUS_RSSI_VALID) > 0 && rssi < -95;

         if (currentCCA != oldCCA) {
             ccaGPIO.setActive(currentCCA);
             if (currentCCA) {
                 memory[REG_FSMSTAT1] |= 1 << 4;
             } else {
                 memory[REG_FSMSTAT1] &= ~(1 << 4);
             }
             if (DEBUG) log("Setting CCA to: " + currentCCA);
         }
    }

    private void setSFD(boolean sfd) {
        sfdGPIO.setActive(sfd);
        if (sfd) {
            memory[REG_FSMSTAT1] |= 1 << 5;
        } else {
            memory[REG_FSMSTAT1] &= ~(1 << 5);
        }
        if (DEBUG) log("SFD: " + sfd + "  " + cpu.cycles);
    }

    private void setFIFOP(boolean fifop) {
        currentFIFOP = fifop;
        fifopGPIO.setActive(fifop);
        if (fifop) {
            memory[REG_FSMSTAT1] |= 1 << 6;
        } else {
            memory[REG_FSMSTAT1] &= ~(1 << 6);
        }
        if (DEBUG) log("Setting FIFOP to " + fifop);
    }

    private void setFIFO(boolean fifo) {
        currentFIFO = fifo;
        fifoGPIO.setActive(fifo);
        if (fifo) {
            memory[REG_FSMSTAT1] |= 1 << 7;
        } else {
            memory[REG_FSMSTAT1] &= ~(1 << 7);
        }
        if (DEBUG) log("Setting FIFO to " + fifo);
    }

    private void setRxOverflow() {
        if (DEBUG) log("RXFIFO Overflow! Read Pos: " + rxFIFO.stateToString());
        setFIFOP(true);
        setFIFO(false);
        setSFD(false);
        overflow = true;
        shouldAck = false;
        setState(RadioState.RX_OVERFLOW);
    }


    /*****************************************************************************
     *  External APIs for simulators simulating Radio medium, etc.
     *
     *****************************************************************************/

    @Override
    public boolean isReadyToReceive() {
        return getState() == RadioState.RX_SFD_SEARCH;
    }

    private void updateActiveFrequency() {
        /* INVERTED: f = 5 * (c - 11) + 357 + 0x4000 */
        int freg = memory[REG_FREQCTRL] & 0x7f;
        activeFrequency =  freg + 2394;
        activeChannel = 11 + (freg - 11) / 5;
    }

    @Override
    public int getActiveFrequency() {
        updateActiveFrequency();
        return activeFrequency;
    }

    @Override
    public int getActiveChannel() {
        updateActiveFrequency();
        return activeChannel;
    }

    /**
     * This is actually the "CORR" value.
     * @param lqi The Corr-val
     * @sa CC2520 Datasheet
     */
    @Override
    public void setLQI(int lqi){
        if(lqi < 0) {
            lqi = 0;
        } else if(lqi > 0x7f ) {
            lqi = 0x7f;
        }
        corrval = lqi;
    }

    @Override
    public int getLQI() {
        return corrval;
    }

    @Override
    public void setRSSI(int power) {
        final int minp = -128 + RSSI_OFFSET;
        final int maxp = 128 + RSSI_OFFSET;
        if (power < minp) {
            power = -minp;
        }
        if(power > maxp){
            power = maxp;
        }

        if (DEBUG) log("external setRSSI to: " + power);

        rssi = power;
        memory[REG_RSSI] = power - RSSI_OFFSET;
        updateCCA();
    }

    @Override
    public int getRSSI() {
        return rssi;
    }

    private boolean isDefinedTxPower(int txpower) {
        switch (txpower) {
        case 0xf7:
        case 0xf2:
        case 0xab:
        case 0x88:
        case 0x81:
        case 0x32:
        case 0x2c:
        case 0x13:
        case 0x03:
            return true;
        default:
            return false;
        }
    }

    @Override
    public int getOutputPowerIndicator() {
        // Higher TXPOWER value does not always mean higher transmission power.
        // Instead of using the TXPOWER value, the output power is mapped into 9 classes.
        int txpower = memory[REG_TXPOWER];
        if (txpower >= 0xf7) {
            return 9;
        }
        if (txpower >= 0xf2) {
            return 8;
        }
        if (txpower >= 0xab) {
            return 7;
        }
        if (txpower >= 0x88) {
            return 3;
        }
        if (txpower >= 0x81) {
            return 4;
        }
        if (txpower >= 0x32) {
            return 5;
        }
        if (txpower >= 0x2c) {
            return 2;
        }
        if (txpower >= 0x13) {
            return 6;
        }
        if (txpower >= 0x03) {
            return 1;
        }
        /* Unknown */
        return 0;
//        return memory[REG_TXPOWER];
    }

    @Override
    public int getOutputPowerIndicatorMax() {
        return 9;
//        return 255;
    }

    @Override
    public int getOutputPower() {
        /* From CC2520 datasheet, table 17 */
        int txpower = memory[REG_TXPOWER];
        if (txpower >= 0xf7) {
            return 5;
        }
        if (txpower >= 0xf2) {
            return 3;
        }
        if (txpower >= 0xab) {
            return 2;
        }
        if (txpower >= 0x88) {
            return -4;
        }
        if (txpower >= 0x81) {
            return -2;
        }
        if (txpower >= 0x32) {
            return 0;
        }
        if (txpower >= 0x2c) {
            return -7;
        }
        if (txpower >= 0x13) {
            return 1;
        }
        if (txpower >= 0x03) {
            return -18;
        }
        /* Unknown */
        return -100;
    }

    @Override
    public int getOutputPowerMax() {
        return 5;
    }

    @Override
    public void notifyReset() {
        super.notifyReset();
        setChipSelect(false);
        status &= ~STATUS_TX_ACTIVE;
        memory[REG_FSMSTAT1] &= ~(1 << 1);
        setVRegOn(false);
        reset();
    }

    public void setVRegOn(boolean newOn) {
        if(isRadioOn == newOn) return;

        if(newOn) {
            // 0.6ms maximum vreg startup from datasheet pg 13
            // but Z1 platform does not work with 0.1 so trying with lower...
            cpu.scheduleTimeEventMillis(vregEvent, 0.05);
            if (DEBUG) log("Scheduling vregEvent at: cyc = " + cpu.cycles +
                    " target: " + vregEvent.getTime() + " current: " + cpu.getTime());
        } else {
            isRadioOn = false;
            setState(RadioState.VREG_OFF);
        }
    }

    public void setChipSelect(boolean select) {
        chipSelect = select;
        if (!chipSelect) {
            spiLen = 0;
            if (command != null) {
                command.executeSPICommand();
            }
            command = null;
        }

        if (DEBUG) {
            log("ChipSelect: " + chipSelect);
        }
    }

    public boolean getChipSelect() {
        return chipSelect;
    }

    public void setGPIO(int index, IOPort port, int pin) {
        gpio[index].setConfig(port, pin);
    }


    /*****************************************************************************
     * Chip APIs
     *****************************************************************************/

    @Override
    public int getModeMax() {
        return MODE_MAX;
    }

    private String getLongAddress() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 8; i++) {
            if ((i % 2 == 0) && i > 0) {
                sb.append(':');
            }
            sb.append(Utils.hex8(memory[RAM_IEEEADDR + 7 - i]));
        }
        return sb.toString();
    }

    @Override
    public String info() {
        updateActiveFrequency();
        String commandStr = command == null ? "<waiting>" : command.name;
        return " VREG_ON: " + isRadioOn + "  Chip Select: " + chipSelect +
                "  OSC Stable: " + ((status & STATUS_XOSC16M_STABLE) > 0) +
                "  GPIO Polarity: 0x" + Utils.hex8(memory[REG_GPIOPOLARITY]) +
                "\n RSSI Valid: " + ((status & STATUS_RSSI_VALID) > 0) + "  CCA: " + currentCCA +
                "\n FIFOP: " + currentFIFOP + " threshold: " + fifopThr + "  FIFO: " + currentFIFO + "  SFD: " + sfdGPIO.isActive() +
                "\n " + rxFIFO.stateToString() + " expPacketLen: " + rxlen +
                "\n Radio State: " + stateMachine + "  SPI State: " + commandStr +
                "\n AutoACK: " + autoAck + "  AddrDecode: " + frameFilter + "  AutoCRC: " + autoCRC +
                "\n PanID: 0x" + Utils.hex8(memory[RAM_PANID + 1]) + Utils.hex8(memory[RAM_PANID]) +
                "  ShortAddr: 0x" + Utils.hex8(memory[RAM_SHORTADDR + 1]) + Utils.hex8(memory[RAM_SHORTADDR]) +
                "  LongAddr: 0x" + getLongAddress() +
                "\n Channel: " + activeChannel +
                "  Output Power: " + getOutputPower() + "dB (" + getOutputPowerIndicator() + '/' + getOutputPowerIndicatorMax() +
                ") txpower: 0x" + Utils.hex8(memory[REG_TXPOWER]) +
                "\n";
    }

    @Override
    public void stateChanged(int state) {
    }

    /* return data in register at the correct position */
    @Override
    public int getConfiguration(int parameter) {
        return memory[parameter];
    }


    /* For SPI Commands */
    @Override
    public int getSPIData(int offset) {
        return spiData[offset];
    }

    @Override
    public int getSPIDataLen() {
        return spiLen;
    }

    @Override
    public void outputSPI(int data) {
        outputSPI = data;
    }

    /* reads one byte from RX fifo */
    void readRXFifo() {
        int fifoData = rxFIFO.read();
        if (DEBUG) log("RXFIFO READ: " + rxFIFO.stateToString());
        outputSPI = fifoData;

        /* first check and clear FIFOP - since we now have read a byte! */
        if (currentFIFOP && !overflow) {
            /* FIFOP is lowered when rxFIFO is lower than or equal to fifopThr */
            if(rxFIFO.length() <= fifopThr) {
                if (DEBUG) log("*** FIFOP cleared at: " + rxFIFO.stateToString());
                setFIFOP(false);
            }
        }

        /* initiate read of another packet - update some variables to keep track of packet reading... */
        if (rxfifoReadLeft == 0) {
            rxfifoReadLeft = fifoData;
            if (DEBUG) log("Init read of packet - len: " + rxfifoReadLeft +
                    " fifo: " + rxFIFO.stateToString());
        } else if (--rxfifoReadLeft == 0) {
            /* check if we have another packet in buffer */
            if (rxFIFO.length() > 0) {
                /* check if the packet is complete or longer than fifopThr */
                if (rxFIFO.length() > rxFIFO.peek(0) ||
                        (rxFIFO.length() > fifopThr && !decodeAddress && !frameRejected)) {
                    if (DEBUG) log("More in FIFO - FIFOP = 1! plen: " + rxFIFO.stateToString());
                    if (!overflow) setFIFOP(true);
                }
            }
        }
        // Set the FIFO pin low if there are no more bytes available in the RXFIFO.
        if (rxFIFO.length() == 0) {
            if (DEBUG) log("Setting FIFO to low (buffer empty)");
            setFIFO(false);
        }
    }

} // CC2520

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/MMA7260QT.java`:

```java
/*
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * MMA7260QT
 *
 * Authors : Niclas Finne
 * Created : 7 jul 2010
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.chip;
import se.sics.mspsim.core.MSP430Core;

/**
 * MMA7260QT - 1.5g-6g Three Axis Low-g Micromachined Accelerometer
 */
public class MMA7260QT extends Accelerometer {

    public static final int MODE_SLEEP = 0x00;
    public static final int MODE_ACTIVE = 0x01;
    private static final String[] MODE_NAMES = new String[] {
      "sleep", "active"
    };
    private static final float[] GSELECT = new float[] {
        1.5f, 2, 4, 6
    };

    private int gSelect = 0;

    public MMA7260QT(MSP430Core cpu) {
        super("MMA7260QT", cpu);
        setModeNames(MODE_NAMES);
        setMode(MODE_SLEEP);

        // Set initial state: x=4094, y=2715, z=2715
        setPosition(1.0, -0.0156, -0.0156);
    }

    private int convertToADC(double x) {
        if (x > 1.0) {
            x = 1.0;
        } else if (x < -1.0) {
            x = -1.0;
        }
        return 2047 + (int) (x * 2047);
    }

    public int getADCX() {
        return convertToADC(getX());
    }

    public int getADCY() {
        return convertToADC(getY());
    }

    public int getADCZ() {
        return convertToADC(getZ());
    }

    public int getSensitivity() {
        return gSelect;
    }

    public String getSensitivityAsString() {
        return GSELECT[gSelect] + "g (" + (int)(1200/GSELECT[gSelect]) + "mV/g)";
    }

    public void setSensitivity(int gSelect) {
        this.gSelect = gSelect & 0x03;
    }

    @Override
    public void setMode(int mode) {
        super.setMode(mode);
    }

    @Override
    public int getModeMax() {
        return MODE_NAMES.length;
    }

    @Override
    public String info() {
        return "Mode: " + getModeName(getMode())
        + " Sensitivity: " + getSensitivityAsString()
        + String.format(" [x=%.2f (%d),y=%.2f (%d),z=%.2f (%d)]",
                getX(), getADCX(), getY(), getADCY(), getZ(), getADCZ());
    }

    /* currently just return the gSelect as configuration */
    @Override
    public int getConfiguration(int parameter) {
        return gSelect;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/M25P80.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: M25P80.java 177 2008-03-11 15:32:12Z nifi $
 *
 * -----------------------------------------------------------------
 *
 * ExtFlash
 *
 * Author  : Joakim Eriksson, Fredrik Osterlind
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date: 2008-03-11 16:32:12 +0100 (ti, 11 mar 2008) $
 *           $Revision: 177 $
 */

package se.sics.mspsim.chip;
import java.io.IOException;
import java.util.Arrays;

import se.sics.mspsim.core.*;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

public class M25P80 extends ExternalFlash implements USARTListener, PortListener, Memory {

  public static final int WRITE_STATUS = 0x01;
  public static final int PAGE_PROGRAM = 0x02;
  public static final int READ_DATA = 0x03;
  public static final int WRITE_DISABLE = 0x04;
  public static final int READ_STATUS = 0x05;
  public static final int WRITE_ENABLE = 0x06;
  public static final int READ_DATA_FAST = 0x0b;
  public static final int READ_IDENT = 0x9f;
  public static final int SECTOR_ERASE = 0xd8;
  public static final int BULK_ERASE = 0xc7;
  public static final int DEEP_POWER_DOWN = 0xb9;
  public static final int WAKE_UP = 0xab;

  public static final int STATUS_MASK = 0x9C;

  public static final int MEMORY_SIZE = 1024 * 1024;
  
  public static final int CHIP_SELECT = 0x10;

  private static final double PROGRAM_PAGE_MILLIS = 1.0; // 0.8 - 5 ms
  private static final double SECTOR_ERASE_MILLIS = 800; // 800 - 3 000 ms 

  private int state = 0;
  private boolean chipSelect;

  private int pos;
  private int status = 0;

  private boolean writeEnable = false;
  private boolean writing = false;

  private int[] identity = new int[] {
      0x20,0x20,0x14,0x10,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
  };
  private int readAddress;
  private int loadedAddress = -1;
  private int blockWriteAddress;
  private byte[] readMemory = new byte[256];
  private byte[] buffer = new byte[256];

  private TimeEvent writeEvent = new TimeEvent(0, "M25P80 Writing") {
    public void execute(long t) {
      writing = false;
    }};

  protected M25P80(String id, MSP430Core cpu) {
      super(id, "External Flash", cpu);
  }

  public M25P80(MSP430Core cpu) {
      super("M25P80", "External Flash", cpu);
  }

  @Override
  public void notifyReset() {
    writing = false;
  }

  public int getStatus() {
    return status | (writeEnable ? 0x02 : 0x00) | (writing ? 0x01 : 0x00);
  }

  public void stateChanged(int state) {
  }

  public void dataReceived(USARTSource source, int data) {
    if (chipSelect) {
      if (DEBUG) {
        log("byte received: " + data);
      }
      switch(state) {
      case READ_STATUS:
          if (DEBUG) {
            log("Read status => " + getStatus() + " from $" + Utils.hex(cpu.getPC(), 4));
          }
          source.byteReceived(getStatus());
          return;
      case READ_IDENT:
        source.byteReceived(identity[pos]);
        pos++;
        if (pos >= identity.length) {
          pos = 0;
        }
        return;
      case WRITE_STATUS:
        status = data & STATUS_MASK;
        source.byteReceived(0);
        return;
      case READ_DATA:
        if (pos < 3) {
          readAddress = (readAddress << 8) + data;
          source.byteReceived(0);
          pos++;
          if (DEBUG && pos == 3) {
            log("reading from $" + Integer.toHexString(readAddress));
          }
        } else {
          source.byteReceived(readMemory(readAddress++));
          if (readAddress > 0xfffff) {
             readAddress = 0;
          }
        }
        return;
      case SECTOR_ERASE:
        if (pos < 3) {
          readAddress = (readAddress << 8) + data;
          source.byteReceived(0);
          pos++;
          if (pos == 3) {
            // Clear buffer
            sectorErase(readAddress);
          }
        }
        return;
      case PAGE_PROGRAM:
        if (pos < 3) {
          readAddress = (readAddress << 8) + data;
          source.byteReceived(0);
          pos++;
          if (pos == 3) {
            // Clear buffer
            Arrays.fill(buffer, (byte) 0xff);
            blockWriteAddress = readAddress & 0xfff00;
            if (DEBUG) {
              log("programming at $" + Integer.toHexString(readAddress));
            }
          }
        } else {
          // Do the programming!!!
          source.byteReceived(0);
          writeBuffer((readAddress++) & 0xff, data);
        }
        return;
      }
      if (DEBUG) {
        log("new command: " + data);
      }
      switch (data) {
      case WRITE_ENABLE:
        if (DEBUG) {
          log("Write Enable");
        }
        writeEnable = true;
        break;
      case WRITE_DISABLE:
        if (DEBUG) {
          log("Write Disable");
        }
        writeEnable = false;
        break;
      case READ_IDENT:
        if (DEBUG) {
          log("Read ident.");
        }
        state = READ_IDENT;
        pos = 0;
        source.byteReceived(0);
        return;
      case READ_STATUS:
        state = READ_STATUS;
        source.byteReceived(0);
        return;
      case WRITE_STATUS:
        if (DEBUG) {
          log("Write status");
        }
        state = WRITE_STATUS;
        break;
      case READ_DATA:
        if (DEBUG) {
          log("Read Data");
        }
        state = READ_DATA;
        pos = readAddress = 0;
        break;
      case PAGE_PROGRAM:
        if (DEBUG) {
          log("Page Program");
        }
        state = PAGE_PROGRAM;
        pos = readAddress = 0;
        break;
      case SECTOR_ERASE:
        if (DEBUG) {
          log("Sector Erase");
        }
        state = SECTOR_ERASE;
        pos = 0;
        break;
      case BULK_ERASE:
        log("Bulk Erase");
        break;
      }
      source.byteReceived(0);
    }
  }

  /***********************************************
   * Memory interface methods
   ***********************************************/
  public int readByte(int address) {
    byte[] data = new byte[256];
    try {
      loadMemory(address, data);
    } catch (IOException e) {
      e.printStackTrace();
    }
    return ~data[address & 0xff];
  }
  
  public void writeByte(int address, int data) {
    byte[] mem = new byte[256];
    try {
      loadMemory(address, mem);
      mem[address & 0xff] = (byte) ~data;
      writeBack(address, mem);
    } catch (IOException e) {
      e.printStackTrace();
    }
    if (loadedAddress >= 0
        && ((loadedAddress & 0xfff00) == (address & 0xfff00))) {
      loadedAddress = -1;
    }
  }

  @Override
  public int getSize() {
    return MEMORY_SIZE;
  }
  
  // Should return correct data!
  private int readMemory(int address) {
    if (DEBUG) {
      log("Reading memory address: " + Integer.toHexString(address));
    }
    ensureLoaded(address);
    return readMemory[address & 0xff];
  }

  private void writeBuffer(int address, int data) {
    buffer[address] = (byte) data;
  }

  private void ensureLoaded(int address) {
    if (loadedAddress < 0
	|| ((loadedAddress & 0xfff00) != (address & 0xfff00))) {
      try {
        if (DEBUG) {
          log("Loading memory: " + (address & 0xfff00));
        }
        loadMemory(address, readMemory);
      } catch (IOException e) {
        e.printStackTrace();
      }
      loadedAddress = address & 0xfff00;
    }
  }

  private void loadMemory(int address, byte[] readMemory) throws IOException {
    getStorage().read(address & 0xfff00, readMemory);
    for (int i = 0; i < readMemory.length; i++) {
      readMemory[i] = (byte) (~readMemory[i] & 0xff);
    }
  }
  
  public boolean getChipSelect() {
    return chipSelect;
  }
  
  public void portWrite(IOPort source, int data) {
    // Chip select = active low...
    if (chipSelect && (data & CHIP_SELECT) != 0) {
      // Chip select will go "off"
      switch(state) {
      case PAGE_PROGRAM:
        programPage();
        break;
      }
    }
    chipSelect = (data & CHIP_SELECT) == 0;
//    if (DEBUG) log("write to Port4: " +
//		       Integer.toString(data, 16)
//		       + " CS:" + chipSelect);
    state = 0;
  }

  private void writeStatus(double time) {
      writing = true;
      cpu.scheduleTimeEventMillis(writeEvent, time);
  }

  private void programPage() {
      if (writing) logw(WarningType.EXECUTION, "Can not set program page while already writing... from $" + Utils.hex(cpu.getPC(), 4));
      writeStatus(PROGRAM_PAGE_MILLIS);
      ensureLoaded(blockWriteAddress);
      for (int i = 0; i < readMemory.length; i++) {
          readMemory[i] &= buffer[i];
      }
      writeBack(blockWriteAddress, readMemory);
  }

  private void sectorErase(int address) {
    writeStatus(SECTOR_ERASE_MILLIS);
    int sectorAddress = address & 0xf0000;
    loadedAddress = -1;
    Arrays.fill(buffer, (byte) 0xff);
    // Erase a complete sector
    blockWriteAddress = sectorAddress;
    for (int i = 0; i < 0x100; i++) {
      if (DEBUG) {
        log("erasing at $" + Integer.toHexString(blockWriteAddress));
      }
      writeBack(blockWriteAddress, buffer);
      blockWriteAddress += 0x100;
    }
  }


  private void writeBack(int address, byte[] data) {
    try {
      byte[] tmp = new byte[data.length];
      if (DEBUG) {
        log("Writing data to disk at $" + Integer.toHexString(address));
      }
      for (int i = 0; i < data.length; i++) {
        tmp[i] = (byte) (~data[i] & 0xff);
      }
      getStorage().write(address & 0xfff00, tmp);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  @Override
  public int getModeMax() {
    return 0;
  }

  @Override
  public String info() {
      return "  Status: " + getStatus() + "  Write Enabled: " + writeEnable
      + "  Write in Progress: " + writing + "  Chip Select: " + chipSelect
      + "\n  " + getStorage().info();
  }

} // M25P80

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Storage.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;

import java.io.IOException;

/**
 * @author Niclas Finne
 */
public interface Storage {

    public int read(long pos, byte[] buffer) throws IOException;

    public int read(long pos, byte[] buffer, int offset, int len) throws IOException;

    public void write(long pos, byte[] buffer) throws IOException;

    public void write(long pos, byte[] buffer, int offset, int len) throws IOException;

    public long getMaxSize();

    public void setMaxSize(long size);

    public void close();

    public String info();

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/TR1001.java`:

```java
/**
 * Copyright (c) 2008-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 * TR1001
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 11 mar 2008
 */

package se.sics.mspsim.chip;
import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.USART;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;

/**
 *
 */
public class TR1001 extends Chip implements RFListener, RFSource {

  public static final int MODE_TXRX_OFF = 0x00;
  public static final int MODE_RX_ON = 0x01;
  public static final int MODE_TXRX_ON = 0x02;
  public static final int MODE_MAX = MODE_TXRX_ON;
  private static final String[] MODE_NAMES = new String[] {
    "off", "listen", "transmit"
  };
  private final USART usart;
  private RFListener rfListener;

  public TR1001(MSP430Core cpu, USART usart) {
    super("TR1001", "Radio", cpu);
    this.usart = usart;
    setModeNames(MODE_NAMES);
    setMode(MODE_TXRX_OFF);
    usart.addUSARTListener(new USARTListener() {

      public void dataReceived(USARTSource source, int data) {
        RFListener listener = rfListener;
        if (getMode() != MODE_TXRX_ON) {
          // Radio is turned off during transmission
          if (DEBUG) {
            log(" ----- TR1001 OFF DURING TRANSMISSION -----");
          }
        } else if (listener != null) {
          listener.receivedByte((byte) (data & 0xff));
        }
      }
    });
  }

  public void setMode(int mode) {
    super.setMode(mode);
  }

  @Override
  public int getModeMax() {
    return MODE_MAX;
  }

  public String info() {
      return "Radio State: " + getModeName(getMode());
  }

  @Override
  public synchronized void addRFListener(RFListener rf) {
    rfListener = RFListener.Proxy.INSTANCE.add(rfListener, rf);
  }

  @Override
  public synchronized void removeRFListener(RFListener rf) {
    rfListener = RFListener.Proxy.INSTANCE.remove(rfListener, rf);
  }

  /* Receive a byte from the radio medium
   * @see se.sics.mspsim.chip.RFListener#receivedByte(byte)
   */
  public void receivedByte(byte data) {
    if (getMode() == MODE_TXRX_OFF) {
      // Radio turned off
      if (DEBUG) {
        log(" ----- TR1001 OFF DURING RECEPTION -----");
      }

    } else if (usart.isReceiveFlagCleared()) {
      /* logger.info("----- TR1001 RECEIVED BYTE -----"); */
      usart.byteReceived(data);

    } else {
      if (DEBUG) {
        log(" ----- TR1001 RECEIVED BYTE TOO EARLY -----");
      }
    }
  }

  public int getConfiguration(int parameter) {
      return 0;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/AT45DB.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * AT45DB SPI Flash Simulator
 *
 * Author  : Matt Thompson <matt.thompson@lochisle.com>
 * Created : Fri May 30 2008
 * Updated : $Date:  $
 *           $Revision: $
 */

package se.sics.mspsim.chip;
import java.io.IOException;
import se.sics.mspsim.core.*;
import se.sics.mspsim.core.EmulationLogger.WarningType;

public class AT45DB extends ExternalFlash implements USARTListener {

  public static final int PAGE_SIZE = 264;
  public static final int NUM_PAGES = 2048;
  public static final int SIZE_BYTES = PAGE_SIZE * NUM_PAGES;

  /** Read Commands - Datasheet Table 15-1 */
  public static final int PAGE_READ = 0xD2;
  public static final int CONTINUOUS_ARRAY_READ_LEGACY = 0xE8;
  public static final int CONTINUOUS_ARRAY_READ_HF = 0x0B;			// 66MHz
  public static final int CONTINUOUS_ARRAY_READ_LF = 0x03;			// 33MHz
  public static final int BUFFER1_READ_LF = 0xD1;
  public static final int BUFFER2_READ_LF = 0xD3;
  public static final int BUFFER1_READ = 0xD4;
  public static final int BUFFER2_READ = 0xD6;

  /** Program and Erase Commands - Datasheet Table 15-2 */
  public static final int BUFFER1_WRITE = 0x84;
  public static final int BUFFER2_WRITE = 0x87;
  public static final int BUFFER1_TO_PAGE_ERASE = 0x83;
  public static final int BUFFER2_TO_PAGE_ERASE = 0x86;
  public static final int BUFFER1_TO_PAGE = 0x88;
  public static final int BUFFER2_TO_PAGE = 0x89;
  public static final int PAGE_ERASE = 0x81;
  public static final int BLOCK_ERASE = 0x50;
  public static final int SECTOR_ERASE = 0x7C;
  // These chip erases opcodes are synonymous
  public static final int CHIP_ERASE = 0xC7;
  public static final int CHIP_ERASE1 = 0x94;
  public static final int CHIP_ERASE2 = 0x80;
  public static final int CHIP_ERASE3 = 0x9A;
  public static final int PAGE_PROGRAM_THROUGH_BUFFER1 = 0x82;
  public static final int PAGE_PROGRAM_THROUGH_BUFFER2 = 0x85;
  /** End of Program and Erase Command opcodes */

  /** Protection and Security Commands - Datasheet Table 15-3 */
  /** Additional Commands - Datasheet Table 15-4 */
  public static final int PAGE_TO_BUFFER1 = 0x53;
  public static final int PAGE_TO_BUFFER2 = 0x55;
  public static final int PAGE_TO_BUFFER1_COMPARE = 0x60;
  public static final int PAGE_TO_BUFFER2_COMPARE = 0x61;
  public static final int AUTO_PAGE_REWRITE_BUFFER1 = 0x58;
  public static final int AUTO_PAGE_REWRITE_BUFFER2 = 0x59;
  public static final int DEEP_POWER_DOWN = 0xB9;
  public static final int RESUME_DEEP_POWER_DOWN = 0xAB;
  public static final int STATUS_REGISTER_READ = 0xD7;
  public static final int READ_DEVICE_ID = 0x9F;
  /** Legacy Commands - Datasheet Table 15-5 */

  // Status register bitmasks
  public static final int STATUS_RDY = (1<<7);
  public static final int STATUS_COMP = (1<<6);
  public static final int STATUS_DENSITY = 0x3C;
  public static final int STATUS_PROTECT = (1<<1);
  public static final int STATUS_PAGE_SIZE = 1;


  private static final int STATE_RESET = 0;
  private static final int STATE_IDLE = 1;
  private static final int READ_ADDRESS = 2;
  private int state = STATE_RESET;
  private int next_state = STATE_RESET;


  private boolean Reset; // Reset Pin
  private boolean chipSelect; // CS Pin

  private int pos;

  // AT45 Status Register byte
  private int status = 0x1C | STATUS_RDY;	// AT45DB041 has bits 5-2 set to 0111 - density bits

  private int pageAddress;
  private int bufferAddress;
  private int dummy=0;	// Number of dummy bytes following command



  // AT45 has two page sized RAM buffers
  private byte[] buffer1 = new byte[PAGE_SIZE];
  private byte[] buffer2 = new byte[PAGE_SIZE];

  private TimeEvent writeEvent = new TimeEvent(0) {
    public void execute(long t) {
      setReady(true);
    }};

    public AT45DB(MSP430Core cpu) {
      super("AT45DB", "External Flash", cpu);
    }

    private void setReady(boolean ready) {
      if(ready == true)
        status |= STATUS_RDY;
      else
        status &= ~STATUS_RDY;
    }

    public void dataReceived(USARTSource source, int data) {
      int buf_num = 1;

      if (chipSelect) {
        //if (DEBUG) {
        //  log("byte received: " + data);
        //}

        switch(state) {

        case READ_ADDRESS:
          pos++;
          if(pos == 1) {
            pageAddress = ((data & 0xF) << 7);
          }else if (pos == 2) {
            pageAddress |= ((data & 0xFE) >> 1);
            bufferAddress = ((data & 1) << 9); 
          }else if (pos == 3) {
            bufferAddress |= data;

            if(DEBUG)
              log("Address - PA[10-0]: " + pageAddress + " BA[8-0]: " + bufferAddress);

            if(dummy == 0) {
              if(DEBUG) log("State " + state + " -> " + next_state);
              setState(next_state);
            }
          }else{
            if(--dummy == 0) {
              if(DEBUG) log("State " + state + " -> " + next_state);
              setState(next_state);
            }
          }
          source.byteReceived(0);
          break;

        case BUFFER1_READ:
        case BUFFER2_READ:
          // Return bytes from the RAM buffer
          buf_num = (state == BUFFER1_READ ? 1 : 2);
          source.byteReceived(readBuffer(buf_num, bufferAddress++));
          if(bufferAddress >= PAGE_SIZE)
            logw(WarningType.EXECUTION, "ERROR: Buffer Read past buffer size: " + bufferAddress);
          break;

        case BUFFER1_WRITE:
        case BUFFER2_WRITE:
          buf_num = (state == BUFFER1_WRITE ? 1 : 2);
          writeBuffer(buf_num, bufferAddress++, data);
          if(bufferAddress >= PAGE_SIZE)
            logw(WarningType.EXECUTION, "ERROR: Buffer Write past buffer size: " + bufferAddress);
          source.byteReceived(0);
          break;

        case STATUS_REGISTER_READ:
          // Chip select false will transition state, as the status register can be
          // polled by clocking data on SI until CS is false
          source.byteReceived(status);
          break;

        case STATE_RESET:
        case STATE_IDLE:
          // data is a command byte
          switch(data) {

          case BUFFER1_TO_PAGE_ERASE:
          case BUFFER2_TO_PAGE_ERASE:
            if(DEBUG)
              log("Buffer" + (data == BUFFER1_TO_PAGE_ERASE ? "1" : "2") + " to Page with Erase Command");
            pos = 0;
            setState(READ_ADDRESS);
            next_state = data;
            dummy = 0;
            setReady(false);
            source.byteReceived(0);
            break;

          case BUFFER1_READ:
          case BUFFER2_READ:
            if(DEBUG)
              log("Read Buffer Command " + (data == BUFFER1_READ ? "Buffer1" : "Buffer2"));
            pos = 0;
            setState(READ_ADDRESS);
            next_state = data;
            dummy = 1;
            setReady(false);
            source.byteReceived(0);
            break;

          case BUFFER1_WRITE:
          case BUFFER2_WRITE:
            if(DEBUG)
              log("Write Buffer Command " + (data == BUFFER1_WRITE ? "Buffer1" : "Buffer2"));
            pos = 0;
            setState(READ_ADDRESS);
            next_state = data;
            dummy = 0;
            setReady(false);
            source.byteReceived(0);
            break;

          case PAGE_TO_BUFFER1:
          case PAGE_TO_BUFFER2:
            if(DEBUG)
              log("Page To Buffer " + (data == PAGE_TO_BUFFER1 ? "1" : "2") + " Command");
            pos = 0;
            setState(READ_ADDRESS);
            next_state = data;
            dummy = 0;
            setReady(false);
            source.byteReceived(0);
            break;

          case STATUS_REGISTER_READ:
            if(DEBUG) log("Read status register command.  status: " + status);
            setState(STATUS_REGISTER_READ);
            source.byteReceived(0);
            break;
          default:
              logw(WarningType.EMULATION_ERROR, "WARNING: Command not implemented: " + data);
              source.byteReceived(0);
          break;
          }
          break;
        default:
          source.byteReceived(0);
        break;
        }
      }
    }

    private void setState(int nextState) {
        state = nextState;
        stateChanged(nextState);
    }

    private int readBuffer(int num, int address) {
      //if(DEBUG) {
      //  log("Reading RAM Buffer" + num + " Address: " + Integer.toHexString(address));
      //}
      if(num == 1)
        return buffer1[address & 0x1ff];
      else
        return buffer2[address & 0x1ff];
    }

    private void writeBuffer(int num, int address, int data) {
      //if(DEBUG) {
      //	  log("Writing RAM Buffer" + num + " Address: " + Integer.toHexString(address) + " Data: " + data);
      //}
      if(num == 1)
        buffer1[address & 0x1ff] = (byte)data;
      else
        buffer2[address & 0x1ff] = (byte)data;
    }

    public void setReset(boolean reset) {
      Reset = reset;
      if(Reset == true)
        setState(STATE_RESET);
      if(DEBUG) {
        log("Reset: " + Reset);
      }
    }
    public void setChipSelect(boolean select) {
      chipSelect = select;
      if(chipSelect == false) {
        switch(state) {

        case BUFFER1_TO_PAGE_ERASE:
        case BUFFER2_TO_PAGE_ERASE:
          bufferToPage((state == BUFFER1_TO_PAGE_ERASE ? 1 : 2));
          setReady(true);
          break;

        case PAGE_TO_BUFFER1:
        case PAGE_TO_BUFFER2:
          pageToBuffer((state == PAGE_TO_BUFFER1 ? 1 : 2));
          setReady(true);
          break;

        default:
          setReady(true);
        break;
        }

        setState(STATE_IDLE);
      }

      if(DEBUG) {
        log("Chip Select: " + chipSelect);
      }
    }

    private void bufferToPage(int buf) {
      try {
        if(buf == 1)
          getStorage().write(pageAddress * PAGE_SIZE, buffer1);
        else
          getStorage().write(pageAddress * PAGE_SIZE, buffer2);
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    private void pageToBuffer(int buf) {
      try {
        if(buf == 1)
          getStorage().read(pageAddress * PAGE_SIZE, buffer1);
        else
          getStorage().read(pageAddress * PAGE_SIZE, buffer2);
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    public int getModeMax() {
      return 0;
    }

    @Override
    public int getSize() {
        return 0;
    }

} // AT45DB

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/RFSource.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * RFSource
 *
 * Author  : Joakim Eriksson
 * Created : Feb 2009
 *
 */
package se.sics.mspsim.chip;

public interface RFSource {

    void addRFListener(RFListener listener);
    void removeRFListener(RFListener listener);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Button.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;
import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430Core;

/**
 * @author Niclas Finne
 *
 */
public class Button extends Chip {

    private final IOPort port;
    private final int pin;
    private final boolean polarity;
    private boolean isPressed;

    public Button(String id, MSP430Core cpu, IOPort port, int pin, boolean polarity) {
        super(id, cpu);
        this.port = port;
        this.pin = pin;
        this.polarity = polarity;
    }

    public boolean isPressed() {
        return isPressed;
    }

    public void setPressed(boolean isPressed) {
        if (this.isPressed != isPressed) {
            this.isPressed = isPressed;
            stateChanged(isPressed ? 1 : 0);
            if (DEBUG) log(isPressed ? "pressed" : "released");
            port.setPinState(pin, isPressed == polarity ? IOPort.PinState.HI : IOPort.PinState.LOW);
        }
    }

    @Override
    public int getConfiguration(int parameter) {
        return 0;
    }

    @Override
    public int getModeMax() {
        return 0;
    }

    @Override
    public String info() {
        return " Button is " + (isPressed ? "pressed" : "not pressed");
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Enc28J60.java`:

```java
/*
 * Copyright (c) 2013, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/* This is a stub implementation for the Enc28j60 Ethernet chip. This ignores
 * the majority of configuration and setup, and only provides the very minimum
 * functionality to support a simple bit-banged Thingsquare Mist driver. */

package se.sics.mspsim.chip;

import java.util.ArrayList;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOPort.PinState;
import se.sics.mspsim.core.MSP430Core;

public class Enc28J60 extends Chip {
	protected boolean DEBUG = false;

	public static final int EIE = 0x1b;
	public static final int EIR = 0x1c;
	public static final int ESTAT = 0x1d;
	public static final int ECON2 = 0x1e;
	public static final int ECON1 = 0x1f;

	public static final int ESTAT_CLKRDY = 0x01;
	public static final int ESTAT_TXABRT = 0x02;

	public static final int ECON1_RXEN = 0x04;
	public static final int ECON1_TXRTS = 0x08;

	public static final int ECON2_AUTOINC = 0x80;
	public static final int ECON2_PKTDEC = 0x40;

	public static final int EPKTCNT = 0x19;

	private static final int WBM_COMMAND = 0x3a; /* Note: 0x7a with write bit set */
	private static final int RBM_COMMAND = 0x3a; /* Note: 0x7a with write bit set */

	private IOPort myPort;

	private int myClk;
	private int myMosi;
	private int myChipSelect;
	private int myMisoBit;

	public Enc28J60(MSP430Core cpu, IOPort port, int clk, int mosi,
			int miso, int chipSelect) {
		super("Enc28J60", "Ethernet", cpu);

		myPort = port;
		myClk = (1 << clk);
		myMosi = (1 << mosi);
		myChipSelect = (1 << chipSelect);

		myMisoBit = miso;
	}

	public void log(String msg) {
		if (DEBUG) {
			System.out.println(msg);
		}
	}

	private boolean writingToWBM = false;
	private boolean readingFromRBM = false;
	private boolean nextEcon1 = false;
	private boolean nextEcon2 = false;

	private ArrayList<Byte> wbmData = new ArrayList<>();

	private ArrayList<RbmPacket> rbmPackets = new ArrayList<>();
	private static class RbmPacket {
		ArrayList<Byte> data = new ArrayList<>();
		boolean wasRead = false;
	}
	
	public void writePacket(byte[] data) {
		RbmPacket p = new RbmPacket();
		int len = data.length;

		p.data.add((byte) 0x00); /* ignored: next packet pointer */
		p.data.add((byte) 0x00); /* ignored: next packet pointer */

		p.data.add((byte) (len & 0xff)); /* length */
		p.data.add((byte) ((len >> 8) & 0xff)); /* length */

		p.data.add((byte) 0x00); /* ignored: status */
		p.data.add((byte) 0x00); /* ignored: status */

		for (byte b : data) {
			p.data.add(b); /* data */
		}
		
		rbmPackets.add(p);
		log("Enc28j60: nr pending packets increased to: " + rbmPackets.size());
	}

	private PacketListener listener = null;
	public interface PacketListener {
		public void packetSent(Byte[] packetData);
	}
	public void setPacketListener(PacketListener l) {
		listener = l;
	}
	
	private int inputByte(int data) {
		int val = 0x00;

		if (writingToWBM) {
			wbmData.add((byte) data);
			val = 0x00;
			return val;
		} else if (readingFromRBM) {
			if (rbmPackets.size() > 0) {
				if (rbmPackets.get(0).data.isEmpty()) {
					log("Enc28j60: warning, packet data is already consumed, returning 0");
				} else {
					val = rbmPackets.get(0).data.remove(0);
					rbmPackets.get(0).wasRead = true;
				}
			} else {
				log("Enc28j60: warning, no packet in rbm, returning 0");
				val = 0x00;
			}
			return val;
		}
		

		/* Strip optional write flag */
		boolean writing = (data & 0x40) != 0;
		data = (data & ~0x40);

		if (nextEcon1) {
			if ((data & ECON1_TXRTS) != 0) {
				log("Transmitting enc28j60 packet, size: " + wbmData.size());
				if (listener != null) {
					wbmData.remove(0);
					listener.packetSent(wbmData.toArray(new Byte[0]));
				}
				wbmData.clear();
			}
			nextEcon1 = false;
		} else if (nextEcon2) {
			if (!rbmPackets.isEmpty() && rbmPackets.get(0).wasRead) {
				rbmPackets.remove(0);
				log("Enc28j60: nr pending packets decreased to: " + rbmPackets.size());
			}
			nextEcon2 = false;
		} else if (data == ECON1) {
			/* we are awaiting a ECON1 command */
			nextEcon1 = true;
		} else if (data == ECON2) {
			/* we are awaiting a ECON2 command */
			nextEcon2 = true;
		} else if (data == EPKTCNT) {
			return rbmPackets.size();
		} else if (data == ESTAT) {
			/* chip is always ready */
			val = ESTAT_CLKRDY;
		} else if (writing && data == WBM_COMMAND) {
			writingToWBM = true;
		} else if (data == RBM_COMMAND) {
			if (rbmPackets.size() > 0) {
				if (rbmPackets.get(0).data.isEmpty()) {
					log("Enc28j60: warning, packet data is already consumed, returning 0");
				} else {
					val = rbmPackets.get(0).data.remove(0);
					rbmPackets.get(0).wasRead = true;
				}
			} else {
				log("Enc28j60: warning, no packet in rbm, returning 0");
				val = 0x00;
			}
			readingFromRBM = true;
		}
		return val;
	}


	private int spiOut = 0; /* byte being sent over SPI */
	private int spiOutCount = 0;
	private int spiIn = 0; /* byte being received over SPI */
	private int spiInCount = 0;
	public void write(IOPort port, int data) {
		if (port != myPort) {
			/* ignore  */
			return;
		}

		boolean chipSelect = (data & myChipSelect) == 0;
		boolean clk = (data & myClk) != 0;
		boolean mosi = (data & myMosi) != 0;

		if (!chipSelect) {
			if (readingFromRBM && spiOutCount == 0 && !rbmPackets.isEmpty()) {
				/* XXX Hack: pushing back last byte to rbm */
				rbmPackets.get(0).data.add(0, (byte)spiOut);
			}
			writingToWBM = false;
			readingFromRBM = false;
		}

		if (!chipSelect || !clk) {
			/* ignore */
			//log("write ignored: chipSelect " + chipSelect + ", clk " + clk);
			return;
		}

		/* Prepare next outgoing bit on miso */
		if (spiOutCount < 8) {
			spiOutCount++;

			if ((spiOut & 0x80) != 0) {
				port.setPinState(myMisoBit, PinState.HI);
			} else {
				port.setPinState(myMisoBit, PinState.LOW);
			}

			spiOut = (spiOut << 1);
		}

		/* Read next incoming bit on mosi */
		spiIn = (spiIn << 1);
		if (mosi) {
			spiIn |= 0x01;
		}
		spiInCount++;

		if (spiInCount >= 8) {
			/* We've now read all 8 bits on mosi */
			spiOut = inputByte(spiIn);
			spiOutCount = 0;
			spiIn = 0;
			spiInCount = 0;
		}
	}

	public int getConfiguration(int parameter) {
		return -1;
	}

	public int getModeMax() {
		return -1;
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/PacketListener.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * PacketListener
 *
 * Author  : Joakim Eriksson
 * 
 */
package se.sics.mspsim.chip;
import se.sics.mspsim.util.ProxySupport;

public interface PacketListener {

    public void transmissionStarted();
    public void transmissionEnded(byte[] receivedData);

    public static class Proxy extends ProxySupport<PacketListener> implements PacketListener {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void transmissionStarted() {
            PacketListener[] listeners = this.listeners;
            for(PacketListener listener : listeners) {
                listener.transmissionStarted();
            }
        }

        @Override
        public void transmissionEnded(byte[] receivedData) {
            PacketListener[] listeners = this.listeners;
            for(PacketListener listener : listeners) {
                listener.transmissionEnded(receivedData);
            }
        }

    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/CC1120.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.chip;

import java.util.ArrayList;
import java.util.List;

import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;

public class CC1120 extends Radio802154 implements USARTListener {

	/* cc1120-const.h: Configuration registers */
	public final static int CC1120_IOCFG3 = 0x00;
	public final static int CC1120_IOCFG2 = 0x01;
	public final static int CC1120_IOCFG1 = 0x02;
	public final static int CC1120_IOCFG0 = 0x03;
	public final static int CC1120_SYNC3 = 0x04;
	public final static int CC1120_SYNC2 = 0x05;
	public final static int CC1120_SYNC1 = 0x06;
	public final static int CC1120_SYNC0 = 0x07;
	public final static int CC1120_SYNC_CFG1 = 0x08;
	public final static int CC1120_SYNC_CFG0 = 0x09;
	public final static int CC1120_DEVIATION_M = 0x0A;
	public final static int CC1120_MODCFG_DEV_E = 0x0B;
	public final static int CC1120_DCFILT_CFG = 0x0C;
	public final static int CC1120_PREAMBLE_CFG1 = 0x0D;
	public final static int CC1120_PREAMBLE_CFG0 = 0x0E;
	public final static int CC1120_FREQ_IF_CFG = 0x0F;
	public final static int CC1120_IQIC = 0x10;
	public final static int CC1120_CHAN_BW = 0x11;
	public final static int CC1120_MDMCFG1 = 0x12;
	public final static int CC1120_MDMCFG0 = 0x13;
	public final static int CC1120_DRATE2 = 0x14;
	public final static int CC1120_DRATE1 = 0x15;
	public final static int CC1120_DRATE0 = 0x16;
	public final static int CC1120_AGC_REF = 0x17;
	public final static int CC1120_AGC_CS_THR = 0x18;
	public final static int CC1120_AGC_GAIN_ADJUST = 0x19;
	public final static int CC1120_AGC_CFG3 = 0x1A;
	public final static int CC1120_AGC_CFG2 = 0x1B;
	public final static int CC1120_AGC_CFG1 = 0x1C;
	public final static int CC1120_AGC_CFG0 = 0x1D;
	public final static int CC1120_FIFO_CFG = 0x1E;
	public final static int CC1120_DEV_ADDR = 0x1F;
	public final static int CC1120_SETTLING_CFG = 0x20;
	public final static int CC1120_FS_CFG = 0x21;
	public final static int CC1120_WOR_CFG1 = 0x22;
	public final static int CC1120_WOR_CFG0 = 0x23;
	public final static int CC1120_WOR_EVENT0_MSB = 0x24;
	public final static int CC1120_WOR_EVENT0_LSB = 0x25;
	public final static int CC1120_PKT_CFG2 = 0x26;
	public final static int CC1120_PKT_CFG1 = 0x27;
	public final static int CC1120_PKT_CFG0 = 0x28;
	public final static int CC1120_RFEND_CFG1 = 0x29;
	public final static int CC1120_RFEND_CFG0 = 0x2A;
	public final static int CC1120_PA_CFG2 = 0x2B;
	public final static int CC1120_PA_CFG1 = 0x2C;
	public final static int CC1120_PA_CFG0 = 0x2D;
	public final static int CC1120_PKT_LEN = 0x2E;
	public final static int CC1120_EXTENDED_MEMORY_ACCESS = 0x2F;

	/* cc1120-const.h: Extended register space */
	public final static int CC1120_IF_MIX_CFG = 0x00;
	public final static int CC1120_FREQOFF_CFG = 0x01;
	public final static int CC1120_TOC_CFG = 0x02;
	public final static int CC1120_MARC_SPARE = 0x03;
	public final static int CC1120_ECG_CFG = 0x04;
	public final static int CC1120_SOFT_TX_DATA_CFG = 0x05;
	public final static int CC1120_EXT_CTRL = 0x06;
	public final static int CC1120_RCCAL_FINE = 0x07;
	public final static int CC1120_RCCAL_COARSE = 0x08;
	public final static int CC1120_RCCAL_OFFSET = 0x09;
	public final static int CC1120_FREQOFF1 = 0x0A;
	public final static int CC1120_FREQOFF0 = 0x0B;
	public final static int CC1120_FREQ2 = 0x0C;
	public final static int CC1120_FREQ1 = 0x0D;
	public final static int CC1120_FREQ0 = 0x0E;
	public final static int CC1120_IF_ADC2 = 0x0F;
	public final static int CC1120_IF_ADC1 = 0x10;
	public final static int CC1120_IF_ADC0 = 0x11;
	public final static int CC1120_FS_DIG1 = 0x12;
	public final static int CC1120_FS_DIG0 = 0x13;
	public final static int CC1120_FS_CAL3 = 0x14;
	public final static int CC1120_FS_CAL2 = 0x15;
	public final static int CC1120_FS_CAL1 = 0x16;
	public final static int CC1120_FS_CAL0 = 0x17;
	public final static int CC1120_FS_CHP = 0x18;
	public final static int CC1120_FS_DIVTWO = 0x19;
	public final static int CC1120_FS_DSM1 = 0x1A;
	public final static int CC1120_FS_DSM0 = 0x1B;
	public final static int CC1120_FS_DVC1 = 0x1C;
	public final static int CC1120_FS_DVC0 = 0x1D;
	public final static int CC1120_FS_LBI = 0x1E;
	public final static int CC1120_FS_PFD = 0x1F;
	public final static int CC1120_FS_PRE = 0x20;
	public final static int CC1120_FS_REG_DIV_CML = 0x21;
	public final static int CC1120_FS_SPARE = 0x22;
	public final static int CC1120_FS_VCO4 = 0x23;
	public final static int CC1120_FS_VCO3 = 0x24;
	public final static int CC1120_FS_VCO2 = 0x25;
	public final static int CC1120_FS_VCO1 = 0x26;
	public final static int CC1120_FS_VCO0 = 0x27;
	public final static int CC1120_GBIAS6 = 0x28;
	public final static int CC1120_GBIAS5 = 0x29;
	public final static int CC1120_GBIAS4 = 0x2A;
	public final static int CC1120_GBIAS3 = 0x2B;
	public final static int CC1120_GBIAS2 = 0x2C;
	public final static int CC1120_GBIAS1 = 0x2D;
	public final static int CC1120_GBIAS0 = 0x2E;
	public final static int CC1120_IFAMP = 0x2F;
	public final static int CC1120_LNA = 0x30;
	public final static int CC1120_RXMIX = 0x31;
	public final static int CC1120_XOSC5 = 0x32;
	public final static int CC1120_XOSC4 = 0x33;
	public final static int CC1120_XOSC3 = 0x34;
	public final static int CC1120_XOSC2 = 0x35;
	public final static int CC1120_XOSC1 = 0x36;
	public final static int CC1120_XOSC0 = 0x37;
	public final static int CC1120_ANALOG_SPARE = 0x38;
	public final static int CC1120_PA_CFG3 = 0x39;
	public final static int CC1120_WOR_TIME1 = 0x64;
	public final static int CC1120_WOR_TIME0 = 0x65;
	public final static int CC1120_WOR_CAPTURE1 = 0x66;
	public final static int CC1120_WOR_CAPTURE0 = 0x67;
	public final static int CC1120_BIST = 0x68;
	public final static int CC1120_DCFILTOFFSET_I1 = 0x69;
	public final static int CC1120_DCFILTOFFSET_I0 = 0x6A;
	public final static int CC1120_DCFILTOFFSET_Q1 = 0x6B;
	public final static int CC1120_DCFILTOFFSET_Q0 = 0x6C;
	public final static int CC1120_IQIE_I1 = 0x6D;
	public final static int CC1120_IQIE_I0 = 0x6E;
	public final static int CC1120_IQIE_Q1 = 0x6F;
	public final static int CC1120_IQIE_Q0 = 0x70;
	public final static int CC1120_RSSI1 = 0x71;
	public final static int CC1120_RSSI0 = 0x72;
	public final static int CC1120_MARCSTATE = 0x73;
	public final static int CC1120_LQI_VAL = 0x74;
	public final static int CC1120_PQT_SYNC_ERR = 0x75;
	public final static int CC1120_DEM_STATUS = 0x76;
	public final static int CC1120_FREQOFF_EST1 = 0x77;
	public final static int CC1120_FREQOFF_EST0 = 0x78;
	public final static int CC1120_AGC_GAIN3 = 0x79;
	public final static int CC1120_AGC_GAIN2 = 0x7A;
	public final static int CC1120_AGC_GAIN1 = 0x7B;
	public final static int CC1120_AGC_GAIN0 = 0x7C;
	public final static int CC1120_SOFT_RX_DATA_OUT = 0x7D;
	public final static int CC1120_SOFT_TX_DATA_IN = 0x7E;
	public final static int CC1120_ASK_SOFT_RX_DATA = 0x7F;
	public final static int CC1120_RNDGEN = 0x80;
	public final static int CC1120_MAGN2 = 0x81;
	public final static int CC1120_MAGN1 = 0x82;
	public final static int CC1120_MAGN0 = 0x83;
	public final static int CC1120_ANG1 = 0x84;
	public final static int CC1120_ANG0 = 0x85;
	public final static int CC1120_CHFILT_I2 = 0x86;
	public final static int CC1120_CHFILT_I1 = 0x87;
	public final static int CC1120_CHFILT_I0 = 0x88;
	public final static int CC1120_CHFILT_Q2 = 0x89;
	public final static int CC1120_CHFILT_Q1 = 0x8A;
	public final static int CC1120_CHFILT_Q0 = 0x8B;
	public final static int CC1120_GPIO_STATUS = 0x8C;
	public final static int CC1120_FSCAL_CTRL = 0x8D;
	public final static int CC1120_PHASE_ADJUST = 0x8E;
	public final static int CC1120_PARTNUMBER = 0x8F;
	public final static int CC1120_PARTVERSION = 0x90;
	public final static int CC1120_SERIAL_STATUS = 0x91;
	public final static int CC1120_RX_STATUS = 0x92;
	public final static int CC1120_TX_STATUS = 0x93;
	public final static int CC1120_MARC_STATUS1 = 0x94;
	public final static int CC1120_MARC_STATUS0 = 0x95;
	public final static int CC1120_PA_IFAMP_TEST = 0x96;
	public final static int CC1120_FSRF_TEST = 0x97;
	public final static int CC1120_PRE_TEST = 0x98;
	public final static int CC1120_PRE_OVR = 0x99;
	public final static int CC1120_ADC_TEST = 0x9A;
	public final static int CC1120_DVC_TEST = 0x9B;
	public final static int CC1120_ATEST = 0x9C;
	public final static int CC1120_ATEST_LVDS = 0x9D;
	public final static int CC1120_ATEST_MODE = 0x9E;
	public final static int CC1120_XOSC_TEST1 = 0x9F;
	public final static int CC1120_XOSC_TEST0 = 0xA0;
	public final static int CC1120_RXFIRST = 0xD2;
	public final static int CC1120_TXFIRST = 0xD3;
	public final static int CC1120_RXLAST = 0xD4;
	public final static int CC1120_TXLAST = 0xD5;
	public final static int CC1120_NUM_TXBYTES = 0xD6;
	public final static int CC1120_NUM_RXBYTES = 0xD7;
	public final static int CC1120_FIFO_NUM_TXBYTES = 0xD8;
	public final static int CC1120_FIFO_NUM_RXBYTES = 0xD9;

	public static final int CC1120_SRES = 0x30; // Reset chip.;
	public static final int CC1120_SFSTXON = 0x31; // Enable and calibrate
	// frequency synthesizer (if
	// MCSM0.FS_AUTOCAL=1).;
	public static final int CC1120_SXOFF = 0x32; // Turn off crystal
	// oscillator.;
	public static final int CC1120_SCAL = 0x33; // Calibrate frequency
	// synthesizer and turn it off;
	public static final int CC1120_SRX = 0x34; // Enable RX. Perform calibration
	// first if coming from IDLE
	// and;
	public static final int CC1120_STX = 0x35; // In IDLE state: Enable TX.
	// Perform calibration first if;
	public static final int CC1120_SIDLE = 0x36; // Exit RX / TX, turn off
	// frequency synthesizer and
	// exit;
	public static final int CC1120_SAFC = 0x37; // Perform AFC adjustment of the
	// frequency synthesizer;
	public static final int CC1120_SWOR = 0x38; // Start automatic RX polling
	// sequence (Wake-on-Radio);
	public static final int CC1120_SPWD = 0x39; // Enter power down mode when
	// CSn goes high.;
	public static final int CC1120_SFRX = 0x3A; // Flush the RX FIFO buffer.;
	public static final int CC1120_SFTX = 0x3B; // Flush the TX FIFO buffer.;
	public static final int CC1120_SWORRST = 0x3C; // Reset real time clock.;
	public static final int CC1120_SNOP = 0x3D; // No operation. May be used to
	// pad strobe commands to two;

	public final static int CC1120_TXFIFO = 0x3F;
	public final static int CC1120_RXFIFO = 0x3F;

  public final static int CCA_THRESHOLD = -95;

	private boolean triggerGDO0onSynch = false;
	private boolean triggerGDO0onFifoThreshold = false;

	public static enum CC1120RadioState {
		CC1120_STATE_SLEEP(0b00000)/* 0 */,
		CC1120_STATE_IDLE(0b00001),
		CC1120_STATE_XOFF(0b00010),
		CC1120_STATE_BIAS_SETTLE_MC(0b00011),
		CC1120_STATE_REG_SETTLE_MC(0b00100),
		CC1120_STATE_MANCAL(0b00101),
		CC1120_STATE_BIAS_SETTLE(0b00110),
		CC1120_STATE_REG_SETTLE(0b00111),
		CC1120_STATE_STARTCAL(0b01000),
		CC1120_STATE_BWBOOST(0b01001),
		CC1120_STATE_FS_LOCK(0b01010),
		CC1120_STATE_IFADCON(0b01011),
		CC1120_STATE_ENDCAL(0b01100),
		CC1120_STATE_RX(0b01101) /* 13 */,
		CC1120_STATE_RX_END(0b01110),
		CC1120_STATE_Reserved(0b01111),
		CC1120_STATE_TXRX_SWITCH(0b10000),
		CC1120_STATE_RX_FIFO_ERR(0b10001),
		CC1120_STATE_FSTXON(0b10010),
		CC1120_STATE_TX(0b10011),
		CC1120_STATE_TX_END(0b10100),
		CC1120_STATE_RXTX_SWITCH(0b10101),
		CC1120_STATE_TX_FIFO_ERR(0b10110),
		CC1120_STATE_IFADCON_TXRX(0b10111);

		private final int state;

		CC1120RadioState(int stateNo) {
			state = stateNo;
		}

		public int getStateAsInt() {
			return state | (0b10 << 5); /* TODO 2 pin state not implemented */
		}
	};

	private TimeEvent sendEvent = new TimeEvent(0, "CC1120 Send") {
		public void execute(long t) {
			txNext();
		}
	};

	protected boolean DEBUG = false;

	public final static double BITRATE_BYTE_DURATION = 0.16; /* ms. Duration per byte transmitted, corresponds to 50kbit/s */
	public final static double FREQUENCY_CHANNEL_0 = 902; /* MHz */
	public final static double FREQUENCY_CHANNEL_WIDTH = 0.125; /* MHz */

  private StateListener stateListener = null;
  private ReceiverListener receiverListener = null;

  /* RSSI1: RSSI_11_4 */
	private int currentRssiReg1 = 0;
  /* RSSI0: RSSI_3_0 TODO XXX Ignored */
	private int currentRssiReg0 = 0;

	private double frequency = -1;
	private int nextFreq0 = -1, nextFreq1 = -1, nextFreq2 = -1; /* regs */
	private boolean changeFrequencyNextState;

	private CC1120RadioState state = null;

	protected List<Byte> txfifo = new ArrayList<Byte>();
	protected List<Byte> rxfifo = new ArrayList<Byte>();

	protected int[] registers = new int[64];
	protected int[] extendedRegisters = new int[256];
	protected int[] memory = new int[512];

	private boolean chipSelect;

	private IOPort gdo0Port = null;
	private int gdo0Pin = -1;
	private IOPort gdo2Port = null;
	private int gdo2Pin = -1;

	public CC1120(MSP430Core cpu) {
		super("CC1120", "Radio", cpu);
		reset();
	}

	void strobe(int cmd) {
		switch (cmd) {
		case CC1120_SRES:
			System.out.println("CC1120_SRES not implemented");
			reset();
			break;

		case CC1120_SFSTXON:
			System.out.println("CC1120_SFSTXON not implemented");
			break;

		case CC1120_SXOFF:
			System.out.println("CC1120_SXOFF not implemented");
			break;

		case CC1120_SCAL:
			changeFrequencyNextState = true;
			setState(CC1120RadioState.CC1120_STATE_IDLE);
			break;

		case CC1120_SRX:

			if(getState() == CC1120RadioState.CC1120_STATE_IDLE ||
			getState() == CC1120RadioState.CC1120_STATE_SLEEP) {
				TimeEvent goToRX = new TimeEvent(0, "CC1120 go to RX") {
					public void execute(long t) {
						if(getState() == CC1120RadioState.CC1120_STATE_RX) {
							/* Radio already in RX, ignore */
							return;
						}
						rxfifo.clear();
						rxExpectedLen = -1;
						rxGotSynchByte = false;
						setGDO0(false);
						setState(CC1120RadioState.CC1120_STATE_RX);
					}
				};

				/* The time to activate RX depends on SETTLING_CFG's FS_AUTOCAL settings.
				 * Calibrated from trxeb1120 platform. */
				double stateDelay;
				int settling = getRegister(CC1120_SETTLING_CFG);
				settling = (settling >> 3) & 0b11; /* bit 4:3 */
				if (settling == 0) {
					stateDelay = 0.20;
				} else if (settling == 1) {
					stateDelay = 0.50;
				} else {
					/* not implemented: assuming calibration */
					stateDelay = 0.50;
				}
				cpu.scheduleTimeEventMillis(goToRX, stateDelay);

			} else {
				setStateRX();
			}

			break;

		case CC1120_STX:
      int len = (int) (0xff&txfifo.get(0));
      txFooterCountdown = 1 + len + 1/*len*/;
      if (DEBUG) {
          System.out.println("TX started: len = " + len + ", txFooterCountdown = " + txFooterCountdown);
      }
      txNext();
			setState(CC1120RadioState.CC1120_STATE_TX);
			break;

		case CC1120_SIDLE:
			setState(CC1120RadioState.CC1120_STATE_IDLE);
			break;

		case CC1120_SAFC:
			System.out.println("CC1120_SAFC not implemented");
			break;

		case CC1120_SWOR:
			System.out.println("CC1120_SWOR not implemented");
			break;

		case CC1120_SPWD:
			/*System.out.println("CC1120_SPWD almost implemented");*/
			/* TODO XXX
			 * Wait until CS is de-asserted. (We should at least wait until radio is done
			 * receiving or transmitting.)*/
            setState(CC1120RadioState.CC1120_STATE_SLEEP);
			break;

		case CC1120_SFRX:
			rxfifo.clear();
			rxExpectedLen = -1;
			rxGotSynchByte = false;
			setGDO0(false);
			/* printRXFIFO(); */
			break;

		case CC1120_SFTX:
			txfifo.clear();
			txFooterCountdown = -1;
			/* printTXFIFO(); */
			break;

		case CC1120_SWORRST:
			System.out.println("CC1120_SWORRST not implemented");
			break;

		case CC1120_SNOP:
			System.out.println("CC1120_SNOP not implemented");
			break;

		default:
			System.out.printf("strobe(0x%02x)\n", cmd);
			break;
		}
	}

	public int getLQI() {
		return 0; /* TODO */
	};

	public void setLQI(int lqi) {
	}

	/* SPI */
	private final static int SPI_READ_BIT = 0x80;
	private final static int SPI_BURST_BIT = 0x40;
	private final static int SPI_EXTENDED_ADDRESS = 0x2F;

	private boolean spiAwaitingAddressExtended = false;
	private boolean spiExtendedMode = false;
	private boolean spiBurstMode = false;
	private boolean spiReadMode = false;
	private boolean spiGotAddress = false;
	private int spiAddress;

	private static boolean spiIsBurst(int data) {
		return (data & SPI_BURST_BIT) == SPI_BURST_BIT;
	}

	private static boolean spiIsRead(int data) {
		return (data & SPI_READ_BIT) == SPI_READ_BIT;
	}

	private static boolean spiIsExtended(int data) {
		data &= ~SPI_BURST_BIT;
		data &= ~SPI_READ_BIT;
		return data == SPI_EXTENDED_ADDRESS;
	}

	private static boolean spiIsStrobe(int data) {
		data = data & 0x3f;
		return data >= 0x30 && data <= 0x3e;
	}

	private void spiResetState() {
		spiAwaitingAddressExtended = false;
		spiBurstMode = false;
		spiReadMode = false;
		spiGotAddress = false;
		spiExtendedMode = false;
		spiAddress = 0xFF;
	}

	public void dataReceived(USARTSource source, int data) {
		if (spiGotAddress) {
			if (!spiBurstMode) {
				/* Single access mode */
				if (spiReadMode) {
					source.byteReceived(getReg(spiAddress, spiExtendedMode));
				} else {
					source.byteReceived(setReg(spiAddress, data,
							spiExtendedMode));
				}
				spiResetState();
			} else {
				/* Burst mode */
				if (spiReadMode) {
					source.byteReceived(getReg(spiAddress, spiExtendedMode));
				} else {
					source.byteReceived(setReg(spiAddress, data,
							spiExtendedMode));
				}

				if (spiAddress < CC1120_TXFIFO) {
					spiAddress++;
				}
			}
			return;
		}

		if (spiAwaitingAddressExtended) {
			spiAddress = data;
			spiGotAddress = true;
			spiAwaitingAddressExtended = false;
			spiExtendedMode = true;

			/* Return MARCSTATE */
			source.byteReceived(getMarcstate());
			return;
		}

		/* Read/write. Burst/single. Extended/normal. */
		spiBurstMode = spiIsBurst(data);
		spiReadMode = spiIsRead(data);
		spiExtendedMode = spiIsExtended(data);
		spiAwaitingAddressExtended = spiIsExtended(data);

		/* Is this a strobe command */
		if (!spiBurstMode && !spiAwaitingAddressExtended && spiIsStrobe(data)) {
			/* Strobe command */
			strobe(data);
			source.byteReceived(0);
			spiResetState();
			return;
		}

		if (!spiAwaitingAddressExtended) {
			spiAddress = data & 0x3f;
			spiGotAddress = true;
		}

		/* Return MARCSTATE */
		source.byteReceived(getMarcstate());
		return;
	}
	int setReg(int address, int data, boolean extended) {
		/*System.err.println(String.format("setReg(0x%02x, %s) 0x%02x", address,
				extended ? "extended" : "normal", data));*/

		switch (address) {
		case CC1120_TXFIFO:
			txfifo.add((byte) data);
			/* printTXFIFO(); */
			return txfifo.size();
		case CC1120_FREQ2: /* XXX This is probably wrong, extended right? */
			nextFreq2 = data;
			return 0;
		case CC1120_FREQ1:
			nextFreq1 = data;
			return 0;
		case CC1120_FREQ0:
			nextFreq0 = data;
			return 0;
		case CC1120_IOCFG0:
			if (data == 65 || data == 1) {
				/* CC1120_SETTING_IOCFG0 (IOCFG_GPIO_CFG_RXFIFO_THR_PKT)
				 * or
				 * CC1120_SETTING_IOCFG0 (IOCFG_GPIO_CFG_RXFIFO_THR_PKT | IOCFG_GPIO_CFG_INVERT) */
				triggerGDO0onFifoThreshold = true;
			} else {
				/* Assuming:
				 * CC1120_SETTING_IOCFG0 (IOCFG_GPIO_CFG_PKT_SYNC_RXTX | IOCFG_GPIO_CFG_INVERT) */
				triggerGDO0onSynch = true;
			}
			return 0;
		}

		if (extended) {
			int oldValue = extendedRegisters[address];
			extendedRegisters[address] = data;
			configurationChanged(address, oldValue, data);
			return oldValue;
		}
		
		switch (address) {
		case CC1120_DRATE0:
			if (data != 0x99) {
				System.err.println("Warning: incompatible CC1120 data rate. Only 50kbit/s (0x99) is currently supported. CC1120_DRATE0: " + Integer.toHexString(data));
			}
			return 0;
		case CC1120_DRATE1:
			if (data != 0x99) {
				System.err.println("Warning: incompatible CC1120 data rate. Only 50kbit/s (0x99) is currently supported. CC1120_DRATE1: " + Integer.toHexString(data));
			}
			return 0;
		case CC1120_DRATE2:
			if (data != 0x99) {
				System.err.println("Warning: incompatible CC1120 data rate. Only 50kbit/s (0x99) is currently supported. CC1120_DRATE2: " + Integer.toHexString(data));
			}
			return 0;
		}

		int oldValue = registers[address];
		registers[address] = data;
		configurationChanged(address, oldValue, data);
		return oldValue;
	}
	int getReg(int address, boolean extended) {
		/* MSP430Core.profiler.printStackTrace(System.out); */
		if (extended) {
			switch (address) {
			case CC1120_MARCSTATE:
				return getMarcstate();
			case CC1120_NUM_RXBYTES:
				return rxfifo.size();
			case CC1120_NUM_TXBYTES:
				return txfifo.size();
			case CC1120_RSSI1:
				return currentRssiReg1;
			case CC1120_RSSI0:
			  int ret = 0;
        ret += (0b1111 & currentRssiReg0); /* RSSI_3_0 */

        ret = ret << 1;
        if(currentRssi > CCA_THRESHOLD) {
          ret += 1; /* Carrier detected */
        } else {
          ret += 0; /* No carrier detected */
        }

        ret = ret << 1;
        ret += 1; /* TODO XXX Carrier sense is always valid */

        ret = ret << 1;
        ret += 1; /* TODO XXX RSSI is always valid */
        
        return ret;
			}
		}

		switch (address) {
		case CC1120_RXFIFO:
			if (rxfifo.size() > 0) {
				int ret = (int) rxfifo.remove(0);
				/* printRXFIFO(); */
				
				if (triggerGDO0onFifoThreshold && rxfifo.size() == 0) {
					setGDO0(false);
				}
				return ret;
			}

        	/* RXFIFO underflow */
            setState(CC1120RadioState.CC1120_STATE_RX_FIFO_ERR);
			return -1;
		}

		if (address != CC1120.CC1120_MARCSTATE) {
			/*System.out.println(String.format("getReg(0x%02x, %s) 0x%02x",
					address, extended ? "extended" : "normal",
							extended ? extendedRegisters[address]
									: registers[address]));*/
		}

		if (extended) {
			return extendedRegisters[address];
		}
		return registers[address];
	}

	public boolean isReadyToReceive() {
	  /* TODO Implement me */
    if (getState() == CC1120RadioState.CC1120_STATE_IDLE) {
      return false;
    }
    if (getState() == CC1120RadioState.CC1120_STATE_SLEEP) {
      return false;
    }
	  return true;
	}


	/* txFooterCountdown: send CRC footer in these many bytes */
	protected int txFooterCountdown = -1;

	/* TX/RX states */
	public static final int NUM_PREAMBLE = 4;
	public static final int NUM_SYNCH = 4;
	public static final byte SYNCH_BYTE_LAST = (byte) 0xDE;
	private boolean txPreambleDelay = false;
	private boolean txSentSynchByte = false;
	private int txSendSynchByteCnt = 0;
	private boolean txSentFirstCRC = false;
	void txNext() {
		if (txFooterCountdown < 0) {
			System.out.println("Warning: Aborting transmit since txFooterCountdown=" + txFooterCountdown);
			return;
		}
		
		/* Delay */
		if (!txPreambleDelay) {
			cpu.scheduleTimeEventMillis(sendEvent, 0.75);
			txPreambleDelay = true;
			return;
		}
		
		/* Send preamble and synch bytes */
		if (!txSentSynchByte) {
			/* Send NUM_PREAMBLE preamble bytes */
			if (txSendSynchByteCnt < NUM_PREAMBLE) {
				txSendSynchByteCnt++;
				if (rfListener != null) {
					rfListener.receivedByte((byte) (0xaa));
				}
				cpu.scheduleTimeEventMillis(sendEvent, BITRATE_BYTE_DURATION);
				return;
			}
			/* Send NUM_SYNCH-1 synch bytes */
			if (txSendSynchByteCnt < NUM_PREAMBLE + NUM_SYNCH - 1) {
				txSendSynchByteCnt++;
				if (rfListener != null) {
					rfListener.receivedByte((byte) (SYNCH_BYTE_LAST + 1));
				}
				cpu.scheduleTimeEventMillis(sendEvent, BITRATE_BYTE_DURATION);
				return;
			}
			/* Send last synch byte */
			if (txSendSynchByteCnt < NUM_PREAMBLE + NUM_SYNCH) {
				txSendSynchByteCnt++;
				if (rfListener != null) {
					rfListener.receivedByte((byte) (SYNCH_BYTE_LAST));
				}
				cpu.scheduleTimeEventMillis(sendEvent, BITRATE_BYTE_DURATION);

				txSentSynchByte = true;
				return;
			}
			
			txSentFirstCRC = false;
		}

		if (txSentFirstCRC) {
			/* send second CRC byte */
			if (rfListener != null) {
				rfListener.receivedByte((byte) (0xef));
			}
			if (!txfifo.isEmpty()) {
				System.out.println("Warning: TXFIFO not empty after sending CRC bytes");
			}
			setStateRX();
			txPreambleDelay = false;
			txSentSynchByte = false;
			txSendSynchByteCnt = 0;
			txSentFirstCRC = false;
			return;
		}

		txFooterCountdown--;

		if (txFooterCountdown == 0) {
			/* countdown is zero, send first CRC byte */
			if (rfListener != null) {
				rfListener.receivedByte((byte) (0xee));
			}
			txSentFirstCRC = true;
			cpu.scheduleTimeEventMillis(sendEvent, BITRATE_BYTE_DURATION);
			return;
		}

		/* Send payload byte (including first FIFO length byte) */
		if (txfifo.isEmpty()) {
			System.out.println("Warning: TXFIFO is empty, sending zero-byte, txFooterCountdown=" + txFooterCountdown);
			if (rfListener != null) {
				rfListener.receivedByte((byte) 0);
			}
			cpu.scheduleTimeEventMillis(sendEvent, BITRATE_BYTE_DURATION);
			return;
		}

		if (rfListener != null) {
			rfListener.receivedByte((byte) (txfifo.get(0).intValue()));
		}
		txfifo.remove(0);
		cpu.scheduleTimeEventMillis(sendEvent, BITRATE_BYTE_DURATION);

		/* printTXFIFO(); */
	}

	public void setGDO0(IOPort port, int pin) {
		gdo0Port = port;
		gdo0Pin = pin;
	}
	public void setGDO0(boolean active) {
		/* TODO Read active low/high configuration */

		if (active) {
			gdo0Port.setPinState(gdo0Pin, IOPort.PinState.HI);
		} else {
			gdo0Port.setPinState(gdo0Pin, IOPort.PinState.LOW);
		}
	}

	public void setGDO2(IOPort port, int pin) {
		gdo2Port = port;
		gdo2Pin = pin;
	}
	public void setGDO2(boolean active) {
		gdo2Port.setPinState(gdo2Pin, active ? IOPort.PinState.LOW
				: IOPort.PinState.HI);
	}

	private void printRXFIFO() {
		System.out.printf("RXFIFO[%03d]: ", rxfifo.size());
		for (int i = 0; i < rxfifo.size(); i++) {
			System.out.printf("%02x", rxfifo.get(i));
		}
		System.out.println();
	}
	private void printTXFIFO() {
		System.out.printf("TXFIFO[%03d]: ", txfifo.size());
		for (int i = 0; i < txfifo.size(); i++) {
			System.out.printf("%02x", txfifo.get(i));
		}
		System.out.println();
	}

	public CC1120RadioState getState() {
		return state;
	}
	public interface StateListener {
		public void newState(CC1120RadioState state);
	}
	public void setStateListener(StateListener listener) {
		stateListener = listener;
	}
	public interface ReceiverListener {
	  public void newState(boolean on);
	}
	public void setReceiverListener(ReceiverListener listener) {
	  receiverListener = listener;
	}

	boolean receiverOn = false;
	boolean setState(final CC1120RadioState newState) {
		if (newState != CC1120RadioState.CC1120_STATE_IDLE
				&& newState != CC1120RadioState.CC1120_STATE_RX
				&& newState != CC1120RadioState.CC1120_STATE_TX) {
			/*System.out.println("setState(" + newState + ")");*/
		}

		if (changeFrequencyNextState
				&& newState == CC1120RadioState.CC1120_STATE_RX
				|| newState == CC1120RadioState.CC1120_STATE_TX) {
			changeFrequencyNextState = false;
			frequency = ((0xff & nextFreq0) << 0) + ((0xff & nextFreq1) << 8)
					+ ((0xff & nextFreq2) << 16);

			frequency *= 32; /* frequency oscillator */
			frequency /= 65536;
			frequency /= 4; /* LO divider */

			/* System.out.println("Activating new frequency: " + frequency + " MHz"); */
			if (channelListener != null) {
				channelListener.channelChanged((int) Math
						.round((frequency - FREQUENCY_CHANNEL_0)
								/ FREQUENCY_CHANNEL_WIDTH));
			}
		}

		state = newState;

		/* Notify state listener */
		if (stateListener != null) {
			stateListener.newState(state);
		}
		if (receiverListener != null && isReadyToReceive() != receiverOn) {
			receiverOn = isReadyToReceive();
			receiverListener.newState(receiverOn);
		}

		return true;
	}

	boolean rxGotSynchByte = false;
	private int rxExpectedLen = -1;
	public void receivedByte(byte data) {
		if (!rxGotSynchByte) {
			/* Await synch byte */
			if (data == SYNCH_BYTE_LAST) {
				rxGotSynchByte = true;
				
				if(triggerGDO0onSynch) {
					setGDO0(true);
				}
			}
			return;
		}

		if (rxExpectedLen < 0) {
			rxExpectedLen = 1/*len*/ + (int) data/*payload*/ + 2/*CRC*/;
		}

		rxExpectedLen--;
		if (rxExpectedLen == 0) {
			setGDO0(false); /* triggerGDO0onFifoThreshold, triggerGDO0onSynch */
			rxExpectedLen = -1;
			rxGotSynchByte = false;
		}

        if (rxfifo.size() < 128) {
			/* printRXFIFO(); */
            rxfifo.add(data);

            if (triggerGDO0onFifoThreshold && rxfifo.size() >= 3 && rxExpectedLen > 0) {
            	setGDO0(true);
            }
        } else {
        	/* RXFIFO overflow */
            setState(CC1120RadioState.CC1120_STATE_RX_FIFO_ERR);
        }
		/* printRXFIFO(); */
	}

	public String info() {
		return "CC1120 info: [not implemented]";
	}

	public int getRegister(int register) {
		return registers[register];
	}

	public void setRegister(int register, int data) {
		registers[register] = data;
	}

	private int currentRssi = -100;
	public void setRSSI(int power) {
		currentRssi = power;
		currentRssiReg1 = 0xff&power;
	}
	public int getRSSI() {
		return currentRssiReg1;
	}

	public int getActiveFrequency() {
		return (int) (1000 * Math.round(frequency)); /* kHz */
	}

	public int getActiveChannel() {
		return (int) Math.round((frequency - FREQUENCY_CHANNEL_0)
				/ FREQUENCY_CHANNEL_WIDTH);
	}

	public int getOutputPowerIndicator() {
		return 1;
	}

	public double getFrequency() {
		return frequency;
	}

	public void notifyReset() {
		super.notifyReset();
		setChipSelect(false);
	}

	public int getOutputPower() {
		return 1;
	}

	public int getOutputPowerMax() {
		return 1;
	}

	public int getOutputPowerIndicatorMax() {
		return 1;
	}

	/*****************************************************************************
	 * Chip APIs
	 *****************************************************************************/

	public int getModeMax() {
		return 0;
	}

	/* return data in register at the correct position */
	public int getConfiguration(int parameter) {
		return registers[parameter];
	}

	public boolean getChipSelect() {
		return chipSelect;
	}

	public void setChipSelect(boolean select) {
		chipSelect = select;
		if (!chipSelect) {
			spiResetState();
		}

		if (DEBUG) {
			log("setting chipSelect: " + chipSelect);
		}
	}

	void setStateRX() {
		setState(CC1120RadioState.CC1120_STATE_RX);
	}

	void reset() {
		setState(CC1120RadioState.CC1120_STATE_IDLE);
	}

	int getMarcstate() {
		return getState().getStateAsInt();
	}

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/CC2520SPI.java`:

```java
/**
 * Copyright (c) 2012 Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 */
package se.sics.mspsim.chip;

public class CC2520SPI {

    private final static boolean DEBUG = false;

    private final CC2520 cc2520;
    private final SPIData spiData;
    private final SPICommand[] commands = new SPICommand[256];

    public CC2520SPI(CC2520 cc) {
        /* the SPI commands for CC2520 */
        cc2520 = cc;
        spiData = cc;
        SPICommand[] spiCommands = {
            new SPICommand("SNOP 0 0 0 0 0 0 0 0") {
                public void executeSPICommand() {}
            },
            new SPICommand("IBUFLD 0 0 0 0 0 0 1 0 i i i i i i i i") {
                public void executeSPICommand() {
                    cc2520.instructionBuffer = spiData.getSPIData(1);
                }
            },
            new SPICommand("SIBUFEX 0 0 0 0 0 0 1 1"),
            new SPICommand("SSAMPLECCA 0 0 0 0 0 1 0 0"),
            new SPICommand("SRES 0 0 0 0 1 1 1 1 - - - - - - - -"),
            new SPICommand("MEMRD 0 0 0 1 a a a a a a a a a a a a - - - - - - - - ...") {
                final BitField adr = getBitField("a");
                int cAdr = 0;
                public boolean dataReceived(int data) {
                    /* check if this is first two bytes*/
                    if (spiData.getSPIDataLen() == 2) {
                        cAdr = adr.getValue(spiData);
                    } else if (spiData.getSPIDataLen() > 2){
                        spiData.outputSPI(cc2520.readMemory(cAdr));
                        cAdr = (cAdr + 1) & 0x3ff;
                    }
                    return true;
                }
                public void executeSPICommand() {}
            },
            new SPICommand("MEMWR 0 0 1 0 a a a a a a a a a a a a d d d d d d d d ...") {
                final BitField adr = getBitField("a");
                int cAdr = -1;
                public boolean dataReceived(int data) {
                    /* check if this is first two bytes*/
                    int len = spiData.getSPIDataLen();
//                    int sdata[] = spiData.getSPIData();
                    if (len == 2) {
                        cAdr = adr.getValue(spiData);
//                        System.out.println("SPI BitValue: [" + adr.startBit + " - " +
//                                adr.endBit + "] mask:" + adr.firstMask);
//                        System.out.printf("SPI Data: %02x %02x  => adr:%x\n", sdata[0], sdata[1], cAdr);
                    } else if (len > 2){
                        cc2520.writeMemory(cAdr, data);
                        cAdr = (cAdr + 1) & 0x3ff;
                    }
                    return true;
                }
                public void executeSPICommand() {}
            },
            new SPICommand("RXBUF 0 0 1 1 0 0 0 0 - - - - - - - - ...") {
                public boolean dataReceived(int data) {
                    /* second byte is fifo data instead of status... */
                    if (spiData.getSPIDataLen() > 1) {
                        cc2520.readRXFifo();
                    }
                    return true;
                }
                public void executeSPICommand() {}
            },
            new SPICommand("RXBUFCP 0 0 1 1 1 0 0 0 0 0 0 0 a a a a a a a a a a a a - - - - - - - - ..."),
            new SPICommand("RXBUFMOV 0 0 1 1 0 0 1 p c c c c c c c c 0 0 0 0 a a a a a a a a a a a a"),
            new SPICommand("TXBUF 0 0 1 1 1 0 1 0 d d d d d d d d d d d d d d d d ...") {
                public boolean dataReceived(int data) {
                    if (spiData.getSPIDataLen() > 1) {
                        cc2520.writeTXFIFO(data);
                    }
                    return true;
                }
                public void executeSPICommand() {}
            },
            new SPICommand("TXBUFCP 0 0 1 1 1 1 1 p c c c c c c c c 0 0 0 0 a a a a a a a a a a a a"),
            new SPICommand("RANDOM 0 0 1 1 1 1 0 0 - - - - - - - - - - - - - - - - ..."),
            new SPICommand("SXOSCON 0 1 0 0 0 0 0 0") {
                public void executeSPICommand() {
                    cc2520.startOscillator();
                }
            },
            new SPICommand("STXCAL 0 1 0 0 0 0 0 1"),
            new SPICommand("SRXON 0 1 0 0 0 0 1 0") {
                public void executeSPICommand() {
                    cc2520.rxon();
                }
            },
            new SPICommand("STXON 0 1 0 0 0 0 1 1") {
                public void executeSPICommand() {
                    cc2520.stxon();
                }
            },
            new SPICommand("STXONCCA 0 1 0 0 0 1 0 0") {
                public void executeSPICommand() {
                    cc2520.stxoncca();
                }
            },
            new SPICommand("SRFOFF 0 1 0 0 0 1 0 1") {
                public void executeSPICommand() {
                    cc2520.rxtxoff();
                }
            },
            new SPICommand("SXOSCOFF 0 1 0 0 0 1 1 0") {
                public void executeSPICommand() {
                    cc2520.stopOscillator();
                }
            },
            new SPICommand("SFLUSHRX 0 1 0 0 0 1 1 1") {
                public void executeSPICommand() {
                    cc2520.flushRX();
                }
            },
            new SPICommand("SFLUSHTX 0 1 0 0 1 0 0 0") {
                public void executeSPICommand() {
                    cc2520.flushTX();
                }
            },
            new SPICommand("SACK 0 1 0 0 1 0 0 1") {
                public void executeSPICommand() {
                    cc2520.sack(false);
                }
            },
            new SPICommand("SACKPEND 0 1 0 0 1 0 1 0") {
                public void executeSPICommand() {
                    cc2520.sack(true);
                }
            },
            new SPICommand("SNACK 0 1 0 0 1 0 1 1"),
            new SPICommand("SRXMASKBITSET 0 1 0 0 1 1 0 0"),
            new SPICommand("SRXMASKBITCLR 0 1 0 0 1 1 0 1"),
            new SPICommand("RXMASKAND 0 1 0 0 1 1 1 0 d d d d d d d d d d d d d d d d"),
            new SPICommand("RXMASKOR 0 1 0 0 1 1 1 1 d d d d d d d d d d d d d d d d"),
            new SPICommand("MEMCP 0 1 0 1 0 0 0 p c c c c c c c c a a a a e e e e a a a a a a a a e e e e e e e e"),
            new SPICommand("MEMCPR 0 1 0 1 0 0 1 p c c c c c c c c a a a a e e e e a a a a a a a a e e e e e e e e"),
            new SPICommand("MEMXCP 0 1 0 1 0 1 0 p c c c c c c c c a a a a e e e e a a a a a a a a e e e e e e e e"),
            new SPICommand("MEMXWR 0 1 0 1 0 1 1 0 0 0 0 0 a a a a a a a a a a a a d d d d d d d d ..."),
            new SPICommand("BCLR 0 1 0 1 1 0 0 0 a a a a a b b b"),
            new SPICommand("BSET 0 1 0 1 1 0 0 1 a a a a a b b b"),
            new SPICommand("CTR/UCTR 0 1 1 0 0 0 0 p k k k k k k k k 0 c c c c c c c n n n n n n n n a a a a e e e e a a a a a a a a e e e e e e e e"),
            new SPICommand("CBCMAC 0 1 1 0 0 1 0 p k k k k k k k k 0 c c c c c c c a a a a e e e e a a a a a a a a e e e e e e e e 0 0 0 0 0 mmm"),
            new SPICommand("UCBCMAC 0 1 1 0 0 1 1 p k k k k k k k k 0 c c c c c c c 0 0 0 0 a a a a a a a a a a a a 0 0 0 0 0 mmm"),
            new SPICommand("CCM 0 1 1 0 1 0 0 p k k k k k k k k 0 c c c c c c c n n n n n n n n a a a a e e e e a a a a a a a a e e e e e e e e 0 f f f f f f f 0 0 0 0 0 0 mm"),
            new SPICommand("UCCM 0 1 1 0 1 0 1 p k k k k k k k k 0 c c c c c c c n n n n n n n n a a a a e e e e a a a a a a a a e e e e e e e e 0 f f f f f f f 0 0 0 0 0 0 mm"),
            new SPICommand("ECB 0 1 1 1 0 0 0 p k k k k k k k k c c c c a a a a a a a a a a a a 0 0 0 0 e e e e e e e e e e e e"),
            new SPICommand("ECBO 0 1 1 1 0 0 1 p k k k k k k k k c c c c a a a a a a a a a a a a"),
            new SPICommand("ECBX 0 1 1 1 0 1 0 p k k k k k k k k c c c c a a a a a a a a a a a a 0 0 0 0 e e e e e e e e e e e e"),
            new SPICommand("INC 0 1 1 1 1 0 0 p 0 0 c c a a a a a a a a a a a a"),
            new SPICommand("ABORT 0 1 1 1 1 1 1 1 0 0 0 0 0 0 c c"),
            new SPICommand("REGRD 1 0 a a a a a a - - - - - - - - ...") {
                final BitField adr = getBitField("a");
                int cAdr = 0;
                public boolean dataReceived(int data) {
                    /* check if this is first byte*/
                    if (spiData.getSPIDataLen() == 1) {
                        cAdr = adr.getValue(spiData);
                    } else {
                        spiData.outputSPI(cc2520.readMemory(cAdr));
                        cAdr = (cAdr + 1) & 0x7f;
                    }
                    return true;
                }
                public void executeSPICommand() {}
            },
            new SPICommand("REGWR 1 1 a a a a a a d d d d d d d d ...") {
                final BitField adr = getBitField("a");
                int cAdr = 0;
                public boolean dataReceived(int data) {
                    /* check if this is first byte*/
                    if (spiData.getSPIDataLen() == 1) {
                        cAdr = adr.getValue(spiData);
                    } else {
                        cc2520.writeMemory(cAdr, data);
                        cAdr = (cAdr + 1) & 0x7f;
                    }
                    return true;
                }
                public void executeSPICommand() {}
            }
        };

        /* set up the commands */
        for (SPICommand c : spiCommands) {
            int maxv = 1 << (8 - c.bitCount);
            int v = c.value;
            /* populate an array with the values for quick decoding */
            for (int j = 0; j < maxv; j++) {
                if (DEBUG) System.out.printf(c.name + " =>  Value: %x\n", (v + j));
                if (commands[v + j] != null) {
                    throw new IllegalStateException("ERROR: command already registered: " + commands[v + j].name);
                }
                commands[v + j] = c;
            }
        }
    }

    SPICommand getCommand(int cmd) {
        if (cmd < 256) {
            return commands[cmd];
        }
        return null;
    }

//   public static void main(String[] args) {
//       CC2520SPI spi = new CC2520SPI(null);
//       SPICommand cmd = spi.getCommand(0xff);
//       /* commands that take infinite number of bytes have the bitfield ... */
//       System.out.println("Has ... => " + cmd.getBitField("..."));
//
//       if (args.length > 0 && "all".equals(args[0])) {
//           for (int i = 0, n = spi.commands.length; i < n; i++) {
//               SPICommand c = spi.commands[i];
//               System.out.print(se.sics.mspsim.util.Utils.binary8(i));
//               if (c != null) {
//                   System.out.printf(": %14s %s/%s (%d)\n", c.name,
//                           se.sics.mspsim.util.Utils.binary8(c.value),
//                           se.sics.mspsim.util.Utils.binary8(c.mask),
//                           c.bitCount);
//               } else {
//                   System.out.println(":");
//               }
//           }
//       }
//   }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/RFListener.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * RFListener
 *
 * Author  : Joakim Eriksson
 * Created : Sep 06 22:00:00 2008
 *
 */
package se.sics.mspsim.chip;
import se.sics.mspsim.util.ProxySupport;

public interface RFListener {

    // A byte has been received via the "air"
    public void receivedByte(byte data);

    public static class Proxy extends ProxySupport<RFListener> implements RFListener {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void receivedByte(byte data) {
            RFListener[] listeners = this.listeners;
            for(RFListener listener : listeners) {
                listener.receivedByte(data);
            }
        }

    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/TMP112.java`:

```java
/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */

package se.sics.mspsim.chip;

import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.USARTSource;

/**
 * Temperature chipset TI tmp112 emulation
 * 
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public class TMP112 extends I2CUnit implements TemperatureChip {

	private int temperature = 0; // in degrees
	private int config = 0x60a0; // default config

	private boolean extendedMode = false;
	private boolean polarity = false;
	private boolean alarm = false;
	private boolean shutdown = false;
	private boolean thermostat = false;
	private int resolution = 0x03;
	private boolean oneShot = false;

	private float[] resFactors = { 50f, 25f, 12.5f, 6.25f };

	public static final int TEMP_REG = 0;
	public static final int CONFIG_REG = 1;
	public static final int TEMP_L_REG = 2;
	public static final int TEMP_H_REG = 3;

	public TMP112(USARTSource src, MSP430Core cpu) {
		super("tmp112", 0x48, src, cpu);
	}

	@Override
	protected int registerRead(int address) {
		switch (address) {
		case TEMP_REG:
			return getRawTemperature() & 0xffff;
		case CONFIG_REG:
			return config;
		case TEMP_L_REG:
		case TEMP_H_REG:
			logw("not implemented");
			break;
		}
		return 0;
	}

	@Override
	protected void registerWrite(int address, int value) {
		switch (address) {
		case CONFIG_REG:
			config = value;
			/* Parse some of the configurations */
			polarity = ((value & 0x400) > 0);
			extendedMode = ((value & 0x10) > 0);
			alarm = ((value & 0x020) > 0);
			shutdown = ((value & 0x100) > 0);
			thermostat = ((value & 0x200) > 0);
			resolution = ((value & 0x6000) >> 13);
			oneShot = ((value & 0x8000) > 0);
			break;
		default:
			logw("not implemented");
			break;
		}
	}

	/**
	 * Get the raw temperature
	 * 
	 * The temperature in the class is stored in a user-friendly way, however the
	 * chipset must transmit it in a specific way without resolution conversions.
	 * This is done by this function: convert a temperature into the format that
	 * the tmp112 would send it to via i2c.
	 * 
	 * @return
	 */
	private synchronized int getRawTemperature() {
		int tmp = (int) (Math.abs(temperature) / resFactors[resolution]);
		if (temperature < 0) {
			/* Do the two-complements value and mask it */
			int nbits = 9 + resolution + (extendedMode ? 1 : 0);
			int mask = (int) ((1L << nbits) - 1);
			tmp = ~tmp + 1;
			tmp &= mask;
		}
		return tmp << 4;
	}

	@Override
	public synchronized int getTemperature() {
		return temperature;
	}

	@Override
	public synchronized void setTemperature(int temp) {
		if (temp <= getMaxTemperature() && temp >= getMinTemperature()) {
			temperature = temp;
		}
	}

	@Override
	public int getMaxTemperature() {
		int nbits = 9 + resolution + (extendedMode ? 1 : 0);
		nbits -= 1;
		return (int) (((1L << nbits) - 1) * resFactors[resolution]);
	}

	@Override
	public int getMinTemperature() {
		return -4000;
	}

	public int getConfig() {
		return config;
	}

	public boolean isExtendedMode() {
		return extendedMode;
	}

	public boolean isPolarity() {
		return polarity;
	}

	public boolean isAlarm() {
		return alarm;
	}

	public boolean isShutdown() {
		return shutdown;
	}

	public boolean isThermostat() {
		return thermostat;
	}

	public int getResolution() {
		return resolution;
	}

	public boolean isOneShot() {
		return oneShot;
	}

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/MemoryStorage.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;

import java.io.IOException;
import java.util.Arrays;

/**
 * @author Niclas Finne
 */
public class MemoryStorage implements Storage {

    private byte[] data;
    private int maxSize;

    private void ensureCapacity(int size) throws IOException {
        if (data == null) {
            data = new byte[size];
        } else if (data.length < size) {
            data = Arrays.copyOf(data, size);
        }
    }

    @Override
    public int read(long pos, byte[] b) throws IOException {
        return read(pos, b, 0, b.length);
    }

    @Override
    public int read(long storagePos, byte[] buffer, int offset, int len) throws IOException {
        if (maxSize > 0 && storagePos + len > maxSize) {
            throw new IOException("outside storage");
        }
        if (data == null) {
            Arrays.fill(buffer, offset, offset + len, (byte)0);
        } else {
            int pos = (int) storagePos;
            if (pos + len > data.length) {
                System.arraycopy(data, pos, buffer, offset, data.length - pos);
                Arrays.fill(buffer, offset + data.length - pos, offset + len, (byte) 0);
            } else {
                System.arraycopy(data, pos, buffer, offset, len);
            }
        }
        return len;
    }

    @Override
    public void write(long storagePos, byte[] buffer) throws IOException {
        write(storagePos, buffer, 0, buffer.length);
    }

    @Override
    public void write(long storagePos, byte[] buffer, int offset, int len) throws IOException {
        int pos = (int) storagePos;
        if (maxSize > 0 && pos + len > maxSize) {
            throw new IOException("outside storage");
        }
        ensureCapacity(pos + len);
        System.arraycopy(buffer, offset, data, pos, len);
    }

    @Override
    public long getMaxSize() {
        return maxSize;
    }

    @Override
    public void setMaxSize(long size) {
        this.maxSize = (int) size;
        if (maxSize > 0 && data != null && data.length > maxSize) {
            data = Arrays.copyOf(data, maxSize);
        }
    }

    @Override
    public void close() {
        // Nothing to close
    }

    @Override
    public String info() {
        if (maxSize > 0) {
            return "MemoryStorage(" + data.length + "/" + maxSize + " bytes)";
        }
        return "MemoryStorage(" + data.length + " bytes allocated)";
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/SHT11.java`:

```java
/**
 * Copyright (c) 2007, 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * SHT11 
 *
 * Author  : Joakim Eriksson, joakime@sics.se
 * Created : Sept 16 2008
 * Updated : $Date:  $
 *           $Revision: $
 */

package se.sics.mspsim.chip;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.util.Utils;

public class SHT11 extends Chip {

  private static final int IDLE = 0;
  private static final int COMMAND = 1;
  private static final int ACK_CMD = 2;
  private static final int MEASURE = 3;
  private static final int WRITE_BYTE = 4;
  private static final int ACK_WRITE = 5;

  private final int CMD_MEASURE_TEMP = 0x03;
  private final int CMD_MEASURE_HUM = 0x05;

  private final static char[] INIT_COMMAND = "CdcCDc".toCharArray();
  private int initPos = 0;
  
  
  /* Serial data pins */
  IOPort sclkPort;
  int sclkPin;
  IOPort sdataPort;
  int sdataPin;
  
  int state = IDLE;
  
  boolean clockHi = false;
  boolean dataHi = false;
  private int readData = 0;
  private int bitCnt = 0;
  private int temp = 3960 + 2400;
  private int humid = 0x1040;
  private int output[] = new int[3];
  private int writePos = 0;
  private int writeLen = 0;
  private int writeData = 0;
  
  private static int rev8bits(int v) {
    int r = 0;
    int s = 8;

    while(v > 0) {
      r = (r << 1) | v & 1;
      v = (v >> 1) & 0xff;
      s--;
    }
    r <<= s;                  /* Shift when v's highest bits are zero */
    return r & 0xff;
  }
  
  private int crc8Add(int acc, int data) {
    int i;
    acc ^= (data & 0xff);
    for(i = 0; i < 8; i++) {
      if((acc & 0x80) != 0) {
        acc = ((acc << 1) ^ 0x31) & 0xff;
      } else {
        acc <<= 1;
      }
    }
    return acc & 0xff;
  }
  
  
  private TimeEvent measureEvent = new TimeEvent(0) {
    public void execute(long t) {
      if (readData == CMD_MEASURE_TEMP) {
        output[0] = (temp >> 8) & 0xff;
        output[1] = temp & 0xff;
      } else if (readData == CMD_MEASURE_HUM) {
        output[0] = (humid >> 8) & 0xff;
        output[1] = humid & 0xff;
      } else {
        /* Something bad has happened */
        return;
      }
      
      int crc = 0;
      crc = crc8Add(crc, readData);
      crc = crc8Add(crc, output[0]);
      crc = crc8Add(crc, output[1]);
      if (DEBUG) log("CRC: " + Utils.hex8(crc) +
          " rcrc: " + Utils.hex8(rev8bits(crc)));
      output[2] = rev8bits(crc);
      
      /* finished measuring - signal with LOW! */
      sdataPort.setPinState(sdataPin, IOPort.PinState.LOW);
      state = WRITE_BYTE;
      writeData = output[0];
      writePos = 0;
      writeLen = 3;
    }};

    
  public void setTemperature(int temp) {
     this.temp = temp;
  }

  public int getTemperature() {
     return this.temp;
  }
  
  public void setHumidity(int humidity) {
      this.humid = humidity;
  }
  
  public int getHumidity() {
     return this.humid;
  }

  public SHT11(MSP430Core cpu) {
      super("SHT11", "Digital Humidity Sensor", cpu);
  }
    
  public void setDataPort(IOPort port, int bit) {
    sdataPort = port;
    sdataPin = bit;
  }
  
  public void reset(int type) {    
    clockHi = true;
    dataHi = true;
    initPos = 0;
    bitCnt = 0;
    readData = 0;
    writePos = 0;
    writeData = 0;
    state = IDLE;
    // Always set pin to high when not doing anything...
    sdataPort.setPinState(sdataPin, IOPort.PinState.HI);
  }
  
  public void clockPin(boolean high) {
    if (clockHi == high) return;

    char c = high ? 'C' : 'c';
    if (DEBUG) log("clock pin " + c);
    switch (state) {
    case IDLE:
      if (checkInit(c)) {
        state = COMMAND;
      }
      break;
    case COMMAND:
      if (c == 'c') {
        readData = (readData << 1) | (dataHi ? 1 : 0);
        bitCnt++;
        if (bitCnt == 8) {
          if (DEBUG) log("read: " + Utils.hex8(readData));
          bitCnt = 0;
          state = ACK_CMD;
          sdataPort.setPinState(sdataPin, IOPort.PinState.LOW);
        }
      }
      break;
    case ACK_CMD:
      if (c == 'c') {
        sdataPort.setPinState(sdataPin, IOPort.PinState.HI);
        if (readData == CMD_MEASURE_HUM || readData == CMD_MEASURE_TEMP) {
          state = MEASURE;
          /* schedule measurement for 20 millis */
          cpu.scheduleTimeEventMillis(measureEvent, 20);
        }
      }
      break;
    case MEASURE:
      break;
    case WRITE_BYTE:
      if (c == 'C') {
        boolean hi = (writeData & 0x80) != 0;
        sdataPort.setPinState(sdataPin, hi ? IOPort.PinState.HI : IOPort.PinState.LOW);
        bitCnt++;
        writeData = writeData << 1;
        if (bitCnt == 8) {
          // All bits are written!
          state = ACK_WRITE;
          if (DEBUG) log("Wrote byte: " + output[writePos]);
          writePos++;
        }
      }
      break;
    case ACK_WRITE:
      if (c == 'C' && dataHi) {
        if (DEBUG) log("*** NO ACK???");
        reset(0);
      }
      break;
    }
    clockHi = high;
  }
  
  public void dataPin(boolean high) {
    if (dataHi == high) return;
    char c = high ? 'D' : 'd';
    if (DEBUG) log("data pin  " + c);
    switch (state) {
    case IDLE:
      if (checkInit(c)) {
        state = COMMAND;
      }
      break;
    case ACK_WRITE:
      if (c == 'D') { // if D goes back high - then we are done here!!!
        if (DEBUG) log("ACK for byte complete...");
        if (writePos < writeLen) {
          state = WRITE_BYTE;
          writeData = output[writePos];
          bitCnt = 0;
        } else {
          reset(0);
        }
      }
      break;
    }
    dataHi = high;
  }

  private boolean checkInit(char c) {
    if (INIT_COMMAND[initPos] == c) {
      initPos++;
      if (initPos == INIT_COMMAND.length) {
        initPos = 0;
        if (DEBUG) {
          log("COMMAND signature detected!!!");
        }
        return true;
      }
    } else {
      initPos = 0;
      // If this is a correct first char => ok!
      if (c == INIT_COMMAND[0]) {
        initPos = 1;
      }
    }
    return false;
  }
  
  
  public int getModeMax() {
    return 0;
  }

  /* no configuration for the SHT11 ? */
  public int getConfiguration(int parameter) {
      return 0;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Beeper.java`:

```java
/**
 * Copyright (c) 2007-2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Beeper
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.chip;
import javax.sound.sampled.AudioFormat;
import javax.sound.sampled.AudioSystem;
import javax.sound.sampled.DataLine;
import javax.sound.sampled.FloatControl;
import javax.sound.sampled.SourceDataLine;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;

/**
 * Beeper for the ESB...
 */
public class Beeper extends Chip {

    public static final int MODE_OFF = 0;
    public static final int MODE_ON = 1;
    public static final int MODE_MAX = MODE_ON;

    public static final int SAMPLE_RATE = 44000;
    public static final int FRQ_1 = 2200;
    public static final int WAVE_LEN = (SAMPLE_RATE / FRQ_1);

    // One second of the sound in buffer
    private static byte[] buffer;
    private static byte[] quiet;

    private boolean beepOn = false;
    private int beepCtrl;
    private boolean isSoundEnabled = false;

    private SourceDataLine dataLine;
    private FloatControl volume;

    private TimeEvent soundEvent;

    public Beeper(MSP430Core cpu) {
        super("Beeper", cpu);
        setMode(MODE_OFF);
    }

    private void initSound() {
        if (quiet == null) {
            quiet = new byte[WAVE_LEN];
        }
        if (buffer == null) {
            byte[] buf = new byte[WAVE_LEN];
            double f1 = 0;
            for (int i = 0, n = WAVE_LEN; i < n; i++) {
                f1 = Math.sin(i * 3.141592 * 2 / WAVE_LEN) * 40;
                f1 += Math.sin(i * 3.141592 * 4 / WAVE_LEN) * 30;
                buf[i] = (byte) (f1);
            }
            buffer = buf;
        }
        if (soundEvent == null) {
            soundEvent = new TimeEvent(0, "Beeper") {
                public void execute(long t) {
                    if (isSoundEnabled) {
                        ioTick(t);
                        cpu.scheduleCycleEvent(this, cpu.cycles + 1000);
                    }
                }
            };
        }
        AudioFormat af = new AudioFormat(SAMPLE_RATE, 8, 1, true, false);
        DataLine.Info dli = new DataLine.Info(SourceDataLine.class, af, 16384);
        try {
            dataLine = (SourceDataLine) AudioSystem.getLine(dli);
            if (dataLine == null) {
                logw(WarningType.EMULATION_ERROR, "No audio data line available");
            } else {
                dataLine.open(dataLine.getFormat(), 16384);
                volume = (FloatControl) dataLine.getControl(FloatControl.Type.MASTER_GAIN);
            }
        } catch (Exception e) {
            logw(WarningType.EMULATION_ERROR, "Could not get audio data line: " + e);
        }
        if (dataLine != null) {
            isSoundEnabled = true;
            dataLine.start();
        }
    }

    private void shutdownSound() {
        isSoundEnabled = false;
        if (dataLine != null) {
            dataLine.close();
            dataLine = null;
            volume = null;
        }
    }

    public boolean isSoundEnabled() {
        return isSoundEnabled;
    }

    public void setSoundEnabled(boolean sound) {
        if (this.isSoundEnabled != sound) {
            if (sound) {
                initSound();
            } else {
                shutdownSound();
            }
        }
    }

    public int getVolume() {
        return volume == null ? 0 : (int) volume.getValue();
    }

    public void setVolume(int vol) {
        if (volume != null) {
            volume.setValue(vol);
        }
    }

    public void beepOn(boolean beep) {
        if (beepOn != beep) {
            beepOn = beep;
            setMode(beepOn ? MODE_ON : MODE_OFF);
            if (DEBUG) log(beepOn ? "BEEPING" : "SILENT");
            if (beepOn && isSoundEnabled) {
                beepCtrl = 7;
                if (!soundEvent.isScheduled()) {
                    cpu.scheduleTimeEvent(soundEvent, cpu.getTime() + 2);
                }
            }
        }
    }

    private void ioTick(long time) {
        // Avoid blocking using timer...
        if (isSoundEnabled && dataLine != null) {
            if (dataLine.available() > WAVE_LEN * 2) {
                if (beepCtrl > 0) {
                    dataLine.write(buffer, 0, WAVE_LEN);
                    if (!beepOn) {
                        beepCtrl--;
                    }
                } else {
                    dataLine.write(quiet, 0, WAVE_LEN);
                }
            }
        }
    }

    public int getModeMax() {
        return MODE_MAX;
    }

    public String info() {
        return "Volume: " + getVolume() + " Beep: " + (beepOn ? "on" : "off")
        + " Sound Enabled: " + isSoundEnabled;
    }

    /* just return some value */
    public int getConfiguration(int parameter) {
        return beepOn ? 1 : 0;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/I2CUnit.java`:

```java
/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */

package se.sics.mspsim.chip;

import se.sics.mspsim.core.GenericUSCI;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;

/**
 * Simple I2C unit
 * 
 * Any class extending this unit can use the i2c protocol by just implementing
 * two methods for reading and writing registers.
 * 
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public abstract class I2CUnit implements USARTListener {

	/**
	 * Auxiliar class for emulating the i2c signaling. This is necessary as
	 * there's no line messages in the emulator.
	 * 
	 * @author Víctor Ariño <victor.arino@tado.com>
	 */
	public static class I2CData {

		/**
		 * Several mask for messages. This may not implement a real i2c but is
		 * useful for message passing
		 */
		public final static int START = 0x100;
		public final static int STOP = 0x200;
		public final static int ACK = 0x400;
		public final static int NACK = 0x800;

		private int data;

		public I2CData(int data) {
			this.data = data;
		}

		protected int getData() {
			return data & 0xff;
		}

		protected boolean isStart() {
			return (data & START) == START;
		}

		protected boolean isStop() {
			return (data & STOP) == STOP;
		}

		protected boolean isAck() {
			return data == ACK;
		}

		protected int getAddress() {
			if (isStart()) {
				return (data & 0xfe) >> 1;
			}
			return 0;
		}

		protected boolean isRead() {
			if (isStart()) {
				return (data & 0x01) != 0x01;
			}
			return false;
		}
	}

	/**
	 * Address of the I2C peripheral
	 */
	protected int busAddress = 0x00;

	/**
	 * String name for logging
	 */
	protected String name = "Unknown";

	/**
	 * Enable debug
	 */
	protected boolean DEBUG = false;

	/**
	 * Is a read message or a write
	 */
	private boolean isRead = false;

	/**
	 * Memory address of the peripheral to read/write
	 */
	private int registerAddress = 0x00;

	/**
	 * Length in bytes of the bus address
	 */
	protected int regAddressLen = 1;

	/**
	 * Length in bytes of the buffer value
	 */
	protected int numBytesTotal = 2;

	/**
	 * Number of received value bytes
	 */
	private int numBytesRxTx = 0;

	/**
	 * Received bytes of the address
	 */
	private int regAddressBytesRx = 0;

	/**
	 * Value to read/write
	 */
	private int value;

	/**
	 * Is the peripheral ready to receive / send data?
	 */
	private boolean ready = false;

	private MSP430Core cpu;
	private USARTSource source;
	private boolean txScheduled = false;

	/**
	 * Tx Event Handler
	 */
	private TimeEvent txTrigger = new TimeEvent(0) {
		public void execute(long t) {
			/* Transmit the next pending byte to the uC */
			if (numBytesTotal > numBytesRxTx) {
				int tmp = (value >> ((numBytesTotal - numBytesRxTx - 1) * 8)) & 0xff;
				log("<sent> " + tmp);
				source.byteReceived(tmp);
				numBytesRxTx++;
			}
			txScheduled = false;
		}
	};

	/**
	 * Class constructor
	 * 
	 * @param name
	 * @param address
	 * @param src
	 * @param cpu
	 */
	public I2CUnit(String name, int address, USARTSource src, MSP430Core cpu) {
		this.name = name;
		busAddress = address;
		if (src != null) {
			src.addUSARTListener((USARTListener) this);
		}
		this.cpu = cpu;
		source = src;
	}

	/**
	 * The microcontroller requested to write a register of the i2c peripheral
	 * 
	 * @param address
	 *           address of the register
	 * @param value
	 *           value to write
	 */
	protected abstract void registerWrite(int address, int value);

	/**
	 * Read a register of the peripheral
	 * 
	 * @param address
	 *           address of the register to read
	 * @return write this value
	 */
	protected abstract int registerRead(int address);

	@Override
	public void dataReceived(USARTSource source, int data) {

		I2CData d = new I2CData(data);

		if (d.isStart()) {
			if (d.getAddress() != busAddress) {
				// Message not for us!
				return;
			}

			isRead = d.isRead();
			numBytesRxTx = 0;
			ready = true;

			log("<start> read?" + isRead);

			source.byteReceived(I2CData.ACK);

			/*
			 * Read the register if necessary. When a write reset the memory
			 * address to avoid strange situations
			 */
			if (isRead) {
				value = registerRead(registerAddress);
				scheduleTransmission();
			} else {
				registerAddress = 0x00;
				value = 0;
				regAddressBytesRx = 0;
			}
			return;
		}

		if (ready) {
			/*
			 * In case of stop condition write the register if necessary and set
			 * the end of the message acceptance
			 */
			if (d.isStop()) {
				log("<stop>");
				if (!isRead && numBytesRxTx > 1) {
					registerWrite(registerAddress, value);
				}

				ready = false;
				return;
			}

			/* If the master transmits and ACK we can transmit the next byte */
			if (d.isAck() && isRead) {
				log("<ack>");
				if (numBytesRxTx < numBytesTotal) {
					scheduleTransmission();
				}
			}

			/*
			 * Write messages are for the address and for the value. First the
			 * address of the register is received. Afterwards the value itself
			 */
			if (!isRead) {
				if (regAddressBytesRx < regAddressLen) {
					log("<addr>");
					registerAddress = d.getData();
					regAddressBytesRx++;
				} else if (numBytesRxTx < numBytesTotal) {
					value <<= 8;
					value |= d.getData();
					numBytesRxTx++;
					log("<data>" + value);
				} else {
					logw("Received more bytes than expected!");
				}
				source.byteReceived(I2CData.ACK);
			}
		}
	}

	/**
	 * Schedule a transmission with the correct baud rate
	 */
	private void scheduleTransmission() {
		int baudRate = defaultBaudRate;

		if (source instanceof GenericUSCI) {
			baudRate = ((GenericUSCI) source).getBaudRate();
		}

		if (!txScheduled && numBytesRxTx < numBytesTotal) {
			cpu.scheduleCycleEvent(txTrigger, cpu.cpuCycles + 1);
			txScheduled = true;
		}
	}

	/**
	 * Log a message when the DEBUG flag is set
	 * 
	 * @param msg
	 */
	protected void log(String msg) {
		if (DEBUG) {
			System.out.println("(i2c) " + name + ": " + msg);
		}
	}

	/**
	 * Log a warning message
	 * 
	 * @param msg
	 */
	protected void logw(String msg) {
		System.err.println("(i2c) " + name + ": WARNING " + msg);
	}

	/**
	 * Default baud rate for the communications
	 */
	private int defaultBaudRate = 100;

	protected void setDefaultBaudRate(int br) {
		defaultBaudRate = br;
	}

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/TemperatureChip.java`:

```java
/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */

package se.sics.mspsim.chip;

/**
 * Interface for a temperature chip. 
 * 
 * Implementing this interface makes it compatible with the cooja-interfaces 
 * and hence makes the peripheral implementation way easier
 * 
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public interface TemperatureChip {
	/**
	 * Get the current temperature on the chip
	 * 
	 * @return
	 */
	public int getTemperature();
	
	/**
	 * Set a new temperature on the chip
	 * 
	 * @param temp
	 * 		temperature to set in XXYY format where XX.YY°C
	 */
	public void setTemperature(int temp);
	
	/**
	 * Get the maximum temperature allowed by the chipset
	 * 
	 * @return
	 */
	public int getMaxTemperature();
	
	/**
	 * Get the minimum temperature allowed by the chipset
	 * 
	 * @return
	 */
	public int getMinTemperature();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/ChannelListener.java`:

```java
/*
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */

package se.sics.mspsim.chip;
import se.sics.mspsim.util.ProxySupport;

public interface ChannelListener {

    public void channelChanged(int channel);

    public static class Proxy extends ProxySupport<ChannelListener> implements ChannelListener {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void channelChanged(int channel) {
            ChannelListener[] listeners = this.listeners;
            for(ChannelListener listener : listeners) {
                listener.channelChanged(channel);
            }
        }

    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/CC1101.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.chip;
import java.util.ArrayList;
import java.util.List;

import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOPort.PinState;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.core.USARTListener;
import se.sics.mspsim.core.USARTSource;

public class CC1101 extends Radio802154 implements USARTListener {
    protected boolean DEBUG = false;

	/* cc1101-const.h: Configuration registers */
	public static final int CC1101_IOCFG1 = 0x01;
	public static final int CC1101_IOCFG0 = 0x02;
	public static final int CC1101_FIFOTHR = 0x03;
	public static final int CC1101_SYNC1 = 0x04;
	public static final int CC1101_SYNC0 = 0x05;
	public static final int CC1101_PKTLEN = 0x06;
	public static final int CC1101_PKTCTRL1 = 0x07;
	public static final int CC1101_PKTCTRL0 = 0x08;
	public static final int CC1101_ADDR = 0x09;
	public static final int CC1101_CHANNR = 0x0A;
	public static final int CC1101_FSCTRL1 = 0x0B;
	public static final int CC1101_FSCTRL0 = 0x0C;
	public static final int CC1101_FREQ2 = 0x0D;
	public static final int CC1101_FREQ1 = 0x0E;
	public static final int CC1101_FREQ0 = 0x0F;
	public static final int CC1101_MDMCFG4 = 0x10;
	public static final int CC1101_MDMCFG3 = 0x11;
	public static final int CC1101_MDMCFG2 = 0x12;
	public static final int CC1101_MDMCFG1 = 0x13;
	public static final int CC1101_MDMCFG0 = 0x14;
	public static final int CC1101_DEVIATN = 0x15;
	public static final int CC1101_MCSM2 = 0x16;
	public static final int CC1101_MCSM1 = 0x17;
	public static final int CC1101_MCSM0 = 0x18;
	public static final int CC1101_FOCCFG = 0x19;
	public static final int CC1101_BSCFG = 0x1A;
	public static final int CC1101_AGCCTRL2 = 0x1B;
	public static final int CC1101_AGCCTRL1 = 0x1C;
	public static final int CC1101_AGCCTRL0 = 0x1D;
	public static final int CC1101_WOREVT1 = 0x1E;
	public static final int CC1101_WOREVT0 = 0x1F;
	public static final int CC1101_WORCTRL = 0x20;
	public static final int CC1101_FREND1 = 0x21;
	public static final int CC1101_FREND0 = 0x22;
	public static final int CC1101_FSCAL3 = 0x23;
	public static final int CC1101_FSCAL2 = 0x24;
	public static final int CC1101_FSCAL1 = 0x25;
	public static final int CC1101_FSCAL0 = 0x26;
	public static final int CC1101_RCCTRL1 = 0x27;
	public static final int CC1101_RCCTRL0 = 0x28;
	public static final int CC1101_FSTEST = 0x29;
	public static final int CC1101_PTEST = 0x2A;
	public static final int CC1101_AGCTEST = 0x2B;
	public static final int CC1101_TEST2 = 0x2C;
	public static final int CC1101_TEST1 = 0x2D;
	public static final int CC1101_TEST0 = 0x2E;
	public static final int CC1101_PARTNUM = 0x30;
	public static final int CC1101_VERSION = 0x31;
	public static final int CC1101_FREQEST = 0x32;
	public static final int CC1101_LQI = 0x33;
	public static final int CC1101_RSSI = 0x34;
	public static final int CC1101_MARCSTATE = 0x35;
	public static final int CC1101_WORTIME1 = 0x36;
	public static final int CC1101_WORTIME0 = 0x37;
	public static final int CC1101_PKTSTATUS = 0x38;
	public static final int CC1101_VCO_VC_DAC = 0x39;
	public static final int CC1101_TXBYTES = 0x3A;
	public static final int CC1101_RXBYTES = 0x3B;
	public static final int CC1101_RCCTRL1_STATUS = 0x3C;
	public static final int CC1101_RCCTRL0_STATUS = 0x3D;
	public static final int CC1101_PATABLE = 0x3E;
	public static final int CC1101_PA_M30 = 0x03;
	public static final int CC1101_PA_M20 = 0x0E;
	public static final int CC1101_PA_M15 = 0x1E;
	public static final int CC1101_PA_M10 = 0x27;
	public static final int CC1101_PA_M6 = 0x38;
	public static final int CC1101_PA_0 = 0x8E;
	public static final int CC1101_PA_5 = 0x84;
	public static final int CC1101_PA_7 = 0xCC;
	public static final int CC1101_PA_10 = 0xC3;
	public static final int CC1101_PA_11 = 0xC0;

	public final static int CC1101_TXFIFO = 0x3F;
	public final static int CC1101_RXFIFO = 0x3F;

	/* Strobe commands */
	public static final int CC1101_SRES = 0x30;
	public static final int CC1101_SFSTXON = 0x31;
	public static final int CC1101_SXOFF = 0x32;
	public static final int CC1101_SCAL = 0x33;
	public static final int CC1101_SRX = 0x34;
	public static final int CC1101_STX = 0x35;
	public static final int CC1101_SIDLE = 0x36;
	public static final int CC1101_SAFC = 0x37;
	public static final int CC1101_SWOR = 0x38;
	public static final int CC1101_SPWD = 0x39;
	public static final int CC1101_SFRX = 0x3A;
	public static final int CC1101_SFTX = 0x3B;
	public static final int CC1101_SWORRST = 0x3C;
	public static final int CC1101_SNOP = 0x3D;

        public static final int CC1101_PKTSTATUS_CS_BIT = (1 << 6);
	public static final int CC1101_PKTSTATUS_CCA_BIT = (1 << 4);

	public static enum CC1101RadioState {
		CC1101_STATE_SLEEP(0x00)/* 0 */,
		CC1101_STATE_IDLE(0x01),
		CC1101_STATE_XOFF(0x02),
		CC1101_STATE_VCOON_MC(0x03),
		CC1101_STATE_REGON_MC(0x04),
		CC1101_STATE_MANCAL(0x05),
		CC1101_STATE_VCOON(0x06),
		CC1101_STATE_REGON(0x07),
		CC1101_STATE_STARTCAL(0x08),
		CC1101_STATE_BWBOOST(0x09),
		CC1101_STATE_FS_LOCK(0x0A),
		CC1101_STATE_IFADCON(0x0B),
		CC1101_STATE_ENDCAL(0x0C),
		CC1101_STATE_RX(0x0D) /* 13 */,
		CC1101_STATE_RX_END(0x0E),
		CC1101_STATE_RX_RST(0x0F),
		CC1101_STATE_TXRX_SWITCH(0x10),
		CC1101_STATE_RXFIFO_OVERFLOW(0x11),
		CC1101_STATE_FSTXON(0x12),
		CC1101_STATE_TX(0x13),
		CC1101_STATE_TX_END(0x14),
		CC1101_STATE_RXTX_SWITCH(0x15),
		CC1101_STATE_TXFIFO_UNDERFLOW(0x16);

		private final int state;

		CC1101RadioState(int stateNo) {
			state = stateNo;
		}

		public int getStateAsInt() {
			return state | (0b10 << 5); /* TODO 2 pin state not implemented */
		}
	};
	private TimeEvent sendEvent = new TimeEvent(0, "CC1101 Send") {
		public void execute(long t) {
			txNext();
		}
	};

	public final static double FREQUENCY_CHANNEL_0 = 902; /* MHz */
	public final static double FREQUENCY_CHANNEL_WIDTH = 0.125; /* MHz */

  public final static int CCA_THRESHOLD = -95;

  private boolean triggerGDO0onSynch = false;
  private boolean triggerGDO0onFifoThreshold = true;

	private StateListener stateListener = null;
	private ReceiverListener receiverListener = null;

        private boolean currentRssiValid;
	private int currentRssiReg = 0;

	private CC1101RadioState state = null;

	protected List<Byte> txfifo = new ArrayList<Byte>();
	protected List<Byte> rxfifo = new ArrayList<Byte>();

	protected int[] registers = new int[64];
	protected int[] memory = new int[512];

	private boolean chipSelect;

	private IOPort gdo0Port = null;
	private int gdo0Pin = -1;
	private IOPort gdo2Port = null;
	private int gdo2Pin = -1;

	private int channel = 0;

	public CC1101(MSP430Core cpu) {
		super("CC1101", "Radio", cpu);
		reset();
	}

    public long getBitRate() {
        /* This function returns the current bit rate of the radio. It
           should use the CC1101 configuration registers to figure out
           the actual bit rate, but this code simply checks for two
           specific configurations that correspond to known bit
           rates. */
        if(registers[CC1101_MDMCFG3] == 0xf8) {
            return 50000;
        } else if(registers[CC1101_MDMCFG3] == 0x3b) {
            return 250000;
        }
        return 250000;
    }

    public double getInterByteDelayMs() {
        return 1000.0 / (getBitRate() / 8.0);
    }

	public void log(String str) {
	    if (DEBUG) {
	        System.out.println(str);
	    }
	}
	
	public void strobe(int cmd) {
		switch (cmd) {
		case CC1101_SRES:
			log("CC1101_SRES not implemented");
			reset();
			break;

		case CC1101_SFSTXON:
			log("CC1101_SFSTXON not implemented");
			break;

		case CC1101_SXOFF:
			log("CC1101_SXOFF not implemented");
			break;

		case CC1101_SCAL:
			setState(CC1101RadioState.CC1101_STATE_IDLE);
			break;

		case CC1101_SRX:
                    if(getState() == CC1101RadioState.CC1101_STATE_IDLE ||
                       getState() == CC1101RadioState.CC1101_STATE_SLEEP) {
                        log("CC1101 from idle to rx, should wait");
                        TimeEvent goToRX = new TimeEvent(0, "CC1101 go to RX") {
                                public void execute(long t) {
                                    if(getState() == CC1101RadioState.CC1101_STATE_RX) {
                                        /* Radio already in RX, ignore */
                                        return;
                                    }
                                    rxfifo.clear();
                                    rxExpectedLen = -1;
                                    rxGotSynchByte = false;
                                    setGDO0(false);
                                    setState(CC1101RadioState.CC1101_STATE_RX);
                                }
                            };
                        int RXTIME = 190;
                        cpu.scheduleTimeEventMillis(goToRX, RXTIME / 1000.0);

                        TimeEvent rssiValid = new TimeEvent(0, "CC1101 set RSSI valid") {
                                public void execute(long t) {
                                    log("RSSI is now valid");
                                    currentRssiValid = true;
                                }
                            };
                        log("RSSI is not valid");
                        int RSSITIME = 380;
                        cpu.scheduleTimeEventMillis(rssiValid, RSSITIME / 1000.0);
                        //                        setState(CC1101RadioState.CC1101_STATE_RX);
                    } else {
                        setStateRX();
                    }
			break;

		case CC1101_STX:
            int len = (int) (0xff&txfifo.get(0));
            txFooterCountdown = 1 + len + 1/*len*/;
            if (DEBUG) {
                System.out.println("TX started: len = " + len + ", txFooterCountdown = " + txFooterCountdown);
            }
            txNext();
            setState(CC1101RadioState.CC1101_STATE_TX);
			break;

		case CC1101_SIDLE:
			setState(CC1101RadioState.CC1101_STATE_IDLE);
                        currentRssiValid = false;
			break;

		case CC1101_SAFC:
			log("CC1101_SAFC not implemented");
			break;

		case CC1101_SWOR:
			log("CC1101_SWOR not implemented");
			break;

		case CC1101_SPWD:
                    //			log("CC1101_SPWD almost implemented");
			/* TODO XXX
			* Wait until CS is de-asserted. (We should at least wait
			* receiving or transmitting.)*/
			setState(CC1101RadioState.CC1101_STATE_SLEEP);
			break;

		case CC1101_SFRX:
			rxfifo.clear();
			rxExpectedLen = -1;
			rxGotSynchByte = false;
			setGDO0(false);
			/*printRXFIFO();*/
			break;

		case CC1101_SFTX:
			txfifo.clear();
			txFooterCountdown = -1;
			/*printTXFIFO();*/
			break;

		case CC1101_SWORRST:
			log("CC1101_SWORRST not implemented");
			break;

		case CC1101_SNOP:
                    //			log("CC1101_SNOP not implemented");
			break;

		default:
			System.out.printf("strobe(0x%02x)\n", cmd);
			break;
		}
	}

	public int getLQI() {
		return 0; /* TODO */
	};

	public void setLQI(int lqi) {
	}

	/* SPI */
	public final static int SPI_READ_BIT = 0x80;
	public final static int SPI_BURST_BIT = 0x40;

	private boolean spiBurstMode = false;
	private boolean spiReadMode = false;
	private boolean spiGotAddress = false;
	private int spiAddress;

	public static boolean spiIsBurst(int data) {
		return (data & SPI_BURST_BIT) == SPI_BURST_BIT;
	}

	public static boolean spiIsRead(int data) {
		return (data & SPI_READ_BIT) == SPI_READ_BIT;
	}

	public static boolean spiIsStrobe(int data) {
		data = data & 0x3f;
		return data >= 0x30 && data <= 0x3d;
	}

	private void spiResetState() {
		spiBurstMode = false;
		spiReadMode = false;
		spiGotAddress = false;
		spiAddress = 0xFF;
	}

	public void dataReceived(USARTSource source, int data) {
		if (spiGotAddress) {
			if (!spiBurstMode) {
				/* Single access mode */
				if (spiReadMode) {
					source.byteReceived(getReg(spiAddress));
				} else {
					source.byteReceived(setReg(spiAddress, data));
				}
				spiResetState();
			} else {
				/* Burst mode */
				if (spiReadMode) {
					source.byteReceived(getReg(spiAddress));
				} else {
					source.byteReceived(setReg(spiAddress, data));
				}

				if (spiAddress != CC1101_TXFIFO && spiAddress != CC1101_PATABLE) {
					spiAddress++;
				}
			}
			return;
		}

		/* Read/write. Burst/single. */
		spiBurstMode = spiIsBurst(data);
		spiReadMode = spiIsRead(data);

		/* Is this a strobe command? */
		if (!spiBurstMode && spiIsStrobe(data)) {
			/* Strobe command */
			strobe(data);
			source.byteReceived(0);
			spiResetState();
			return;
		}

		spiAddress = data & 0x3f;
		spiGotAddress = true;

		/* Return MARCSTATE */
		source.byteReceived(getMarcstate());
		return;
	}
	public int setReg(int address, int data) {
		switch (address) {
		case CC1101_TXFIFO:
			txfifo.add((byte) data);
			/*printTXFIFO();*/
			return txfifo.size();
		case CC1101_CHANNR:
			channel = data;
			if (channelListener != null) {
				channelListener.channelChanged(channel);
			}
			return 0;
		}

		log(String.format("setReg(0x%02x) 0x%02x", address, data));
		int oldValue = registers[address];
		registers[address] = data;
		configurationChanged(address, oldValue, data);
		return oldValue;
	}
	public int getReg(int address) {
		/* MSP430Core.profiler.printStackTrace(System.out); */
		switch (address) {
		case CC1101_CHANNR:
			return channel;
		case CC1101_MARCSTATE:
			return getMarcstate();
		case CC1101_RXBYTES:
		  /*log("getReg(CC1101_RXBYTES) " + rxfifo.size());*/
			return rxfifo.size();
		case CC1101_TXBYTES:
		  /*log("getReg(CC1101_TXBYTES) " + txfifo.size());*/
			return txfifo.size();
		case CC1101_PKTSTATUS:
		  int status = 0;
                  if(currentRssiValid) {
                      if(currentRssiReg < CCA_THRESHOLD) {
                          status |= CC1101_PKTSTATUS_CCA_BIT;
                      } else {
                          status |= CC1101_PKTSTATUS_CS_BIT;
                      }
                  }
		  return status;
		case CC1101_RSSI:
			return currentRssiReg;
		case CC1101_RXFIFO:
			if (rxfifo.size() > 0) {
				int ret = (int) rxfifo.remove(0);
				/*printRXFIFO();*/
                if (triggerGDO0onFifoThreshold && rxfifo.size() == 0) {
                    setGDO0(false);
                }
				return ret;
			}
			System.err.println("Warning: reading from empty RXFIFO");
			return -1;
		}

        log(String.format("getReg(0x%02x) 0x%02x", address, registers[address]));
		return registers[address];
	}
	
	

	public boolean isReadyToReceive() {
	  /* TODO Implement me */
	  if (getState() == CC1101RadioState.CC1101_STATE_IDLE) {
	    return false;
	  }
	  if (getState() == CC1101RadioState.CC1101_STATE_SLEEP) {
	    return false;
	  }
	  return true;
	}

	/* txFooterCountdown: send CRC footer in these many bytes */
	protected int txFooterCountdown = -1;

	/* TX/RX states */
	public static final int NUM_PREAMBLE = 4;
    public static final int NUM_SYNCH = 4;
    public static final byte SYNCH_BYTE_LAST = (byte) 0x91;
    private boolean txSentSynchByte = false;
    private int txSendSynchByteCnt = 0;
    private boolean txSentFirstCRC = false;
    void txNext() {
        if (txFooterCountdown < 0) {
            System.out.println("Warning: Aborting transmit since txFooterCountdown=" + txFooterCountdown);
            return;
        }
        
        /* Send preamble and synch bytes */
        if (!txSentSynchByte) {
            /* Send NUM_PREAMBLE preamble bytes */
            if (txSendSynchByteCnt < NUM_PREAMBLE) {
                txSendSynchByteCnt++;
                if (rfListener != null) {
                    rfListener.receivedByte((byte) (0xaa));
                }
                cpu.scheduleTimeEventMillis(sendEvent, getInterByteDelayMs());
                return;
            }
            /* Send NUM_SYNCH-1 synch bytes */
            if (txSendSynchByteCnt < NUM_PREAMBLE + NUM_SYNCH - 1) {
                txSendSynchByteCnt++;
                if (rfListener != null) {
                    rfListener.receivedByte((byte) (SYNCH_BYTE_LAST + 1));
                }
                cpu.scheduleTimeEventMillis(sendEvent, getInterByteDelayMs());
                return;
            }
            /* Send last synch byte */
            if (txSendSynchByteCnt < NUM_PREAMBLE + NUM_SYNCH) {
                txSendSynchByteCnt++;
                if (rfListener != null) {
                    rfListener.receivedByte((byte) (SYNCH_BYTE_LAST));
                }
                cpu.scheduleTimeEventMillis(sendEvent, getInterByteDelayMs());

                txSentSynchByte = true;
                return;
            }
            
            txSentFirstCRC = false;
        }

        if (txSentFirstCRC) {
            /* send second CRC byte */
            if (rfListener != null) {
                rfListener.receivedByte((byte) (0xef));
            }
            if (!txfifo.isEmpty()) {
                System.out.println("Warning: TXFIFO not empty after sending CRC bytes");
            }
            setStateRX();
            txSentSynchByte = false;
            txSendSynchByteCnt = 0;
            txSentFirstCRC = false;
            return;
        }

        txFooterCountdown--;

        if (txFooterCountdown == 0) {
            /* countdown is zero, send first CRC byte */
            if (rfListener != null) {
                rfListener.receivedByte((byte) (0xee));
            }
            txSentFirstCRC = true;
            cpu.scheduleTimeEventMillis(sendEvent, getInterByteDelayMs());
            return;
        }

        /* Send payload byte (including first FIFO length byte) */
        if (txfifo.isEmpty()) {
            System.out.println("Warning: TXFIFO is empty, sending zero-byte, txFooterCountdown=" + txFooterCountdown);
            if (rfListener != null) {
                rfListener.receivedByte((byte) 0);
            }

            cpu.scheduleTimeEventMillis(sendEvent, getInterByteDelayMs());
            setState(CC1101RadioState.CC1101_STATE_TXFIFO_UNDERFLOW);
            return;
        }

        if (rfListener != null) {
            rfListener.receivedByte((byte) (txfifo.get(0).intValue()));
        }
        txfifo.remove(0);
        cpu.scheduleTimeEventMillis(sendEvent, getInterByteDelayMs());

        /*printTXFIFO();*/
    }

	public void setGDO0(IOPort port, int pin) {
		gdo0Port = port;
		gdo0Pin = pin;
	}
	public void setGDO0(boolean active) {
		/* TODO Read active low/high configuration */

		if (active) {
		  if (gdo0Port != null) {
	      gdo0Port.setPinState(gdo0Pin, IOPort.PinState.HI);
		  }
			if (gdo0Listener != null) {
			  gdo0Listener.event(IOPort.PinState.HI);
			}
		} else {
      if (gdo0Port != null) {
        gdo0Port.setPinState(gdo0Pin, IOPort.PinState.LOW);
      }
      if (gdo0Listener != null) {
        gdo0Listener.event(IOPort.PinState.LOW);
      }
		}
	}

	public interface GDOListener {
	  public void event(PinState state);
	}
	private GDOListener gdo0Listener = null;
	public void setGDO0Listener(GDOListener l) {
    gdo0Listener = l;
  }
	
	public void setGDO2(IOPort port, int pin) {
		gdo2Port = port;
		gdo2Pin = pin;
	}
	public void setGDO2(boolean active) {
        if (gdo2Port == null) {
            return;
        }
		gdo2Port.setPinState(gdo2Pin, active ? IOPort.PinState.LOW
				: IOPort.PinState.HI);
	}

	private void printRXFIFO() {
	    StringBuilder sb = new StringBuilder();
	    sb.append(String.format("RXFIFO[%03d]: ", rxfifo.size()));
		for (int i = 0; i < rxfifo.size(); i++) {
		    sb.append(String.format("%02x", rxfifo.get(i)));
		}
		log(sb.toString() + "\n");
	}
	private void printTXFIFO() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("TXFIFO[%03d]: ", txfifo.size()));
		for (int i = 0; i < txfifo.size(); i++) {
		    sb.append(String.format("%02x", txfifo.get(i)));
		}
        log(sb.toString() + "\n");
	}

	public CC1101RadioState getState() {
		return state;
	}
	public interface StateListener {
		public void newState(CC1101RadioState state);
	}
	public void setStateListener(StateListener listener) {
		stateListener = listener;
	}
  public interface ReceiverListener {
    public void newState(boolean on);
  }
  public void setReceiverListener(ReceiverListener listener) {
    receiverListener = listener;
  }

  boolean receiverOn = false;
	boolean setState(CC1101RadioState newState) {
		if (newState != CC1101RadioState.CC1101_STATE_IDLE
				&& newState != CC1101RadioState.CC1101_STATE_RX
				&& newState != CC1101RadioState.CC1101_STATE_TX) {
			log("setState(" + newState + ")");
		}

		state = newState;

		/* Notify state listener */
		if (stateListener != null) {
			stateListener.newState(state);
		}
    if (receiverListener != null && isReadyToReceive() != receiverOn) {
      receiverOn = isReadyToReceive();
      receiverListener.newState(receiverOn);
    }
    return true;
	}

	boolean rxGotSynchByte = false;
	private int rxExpectedLen = -1;
	public void receivedByte(byte data) {
            if(state != CC1101RadioState.CC1101_STATE_RX) {
                return;
            }
		if (!rxGotSynchByte) {
			/* Await synch byte */
			if (data == SYNCH_BYTE_LAST) {
				rxGotSynchByte = true;
                if(triggerGDO0onSynch) {
                    setGDO0(true);
                }
			}
			return;
		}

		if (rxExpectedLen < 0) {
			rxExpectedLen = 1/*len*/ + (int) data/*payload*/ + 2/*CRC*/;
		}

		rxExpectedLen--;
		if (rxExpectedLen == 0) {
			setGDO0(false);
			rxExpectedLen = -1;
			rxGotSynchByte = false;
		}

                if (rxfifo.size() < 64) {
                        rxfifo.add(data);
                        
                        if (triggerGDO0onFifoThreshold && rxfifo.size() >= 3 && rxExpectedLen > 0) {
                            setGDO0(true);
                        }
                } else {
                        log("rxfifo overflow " + rxfifo.size());
                        setState(CC1101RadioState.CC1101_STATE_RXFIFO_OVERFLOW);
                }
		/*printRXFIFO();*/
	}

	public String info() {
		return "CC1101 info: [not implemented]";
	}

	public int getRegister(int register) {
		return registers[register];
	}

	public void setRegister(int register, int data) {
		registers[register] = data;
	}

	public void setRSSI(int power) {
	  currentRssiReg = power;
	}
	public int getRSSI() {
		return currentRssiReg;
	}

	public int getActiveFrequency() {
		return (int) 0; /* Not implemented */
	}

	public int getActiveChannel() {
		return channel;
	}

	public int getOutputPowerIndicator() {
		return 1;
	}

	public double getFrequency() {
		return 0; /* Not implemented */
	}

	public void notifyReset() {
		super.notifyReset();
		setChipSelect(false);
	}

	public int getOutputPower() {
		return 1;
	}

	public int getOutputPowerMax() {
		return 1;
	}

	public int getOutputPowerIndicatorMax() {
		return 1;
	}

	/*****************************************************************************
	 * Chip APIs
	 *****************************************************************************/

	public int getModeMax() {
		return 0;
	}

	/* return data in register at the correct position */
	public int getConfiguration(int parameter) {
		return registers[parameter];
	}

	public boolean getChipSelect() {
		return chipSelect;
	}

	public void setChipSelect(boolean select) {
		chipSelect = select;
		if (!chipSelect) {
			spiResetState();
		}

		if (DEBUG) {
			/*log("Chip select: " + chipSelect);*/
		}
	}

	void setStateRX() {
		setState(CC1101RadioState.CC1101_STATE_RX);
                currentRssiValid = true;
	}

	void reset() {
	  setState(CC1101RadioState.CC1101_STATE_SLEEP);

	  registers[CC1101_PARTNUM] = 0;
	  registers[CC1101_VERSION] = 6;
	}

	public int getMarcstate() {
		return getState().getStateAsInt();
	}

	private boolean lastWasRead = false;
  public void setLastInstructionWasRead(boolean wasRead) {
    lastWasRead = wasRead;
  }

  public int getStatusByte() {
    int status = 0;

    /* Bit 7: RF ready */
    if (true) {
      status += 0; /* XXX Always ready! */
    }

    /* Bit 4-6: simplified state */     
    status = status << 3;
    if (state == CC1101RadioState.CC1101_STATE_IDLE) {
      status += 0;
    } else if (state == CC1101RadioState.CC1101_STATE_RX ||
        state == CC1101RadioState.CC1101_STATE_RX_END ||
        state == CC1101RadioState.CC1101_STATE_RX_RST) {
      status += 1;
    } else if (state == CC1101RadioState.CC1101_STATE_TX ||
        state == CC1101RadioState.CC1101_STATE_TX_END) {
      status += 2;
    } else if (state == CC1101RadioState.CC1101_STATE_FSTXON) {
      status += 3;
    } else if (state == CC1101RadioState.CC1101_STATE_ENDCAL ||
        state == CC1101RadioState.CC1101_STATE_MANCAL ||
        state == CC1101RadioState.CC1101_STATE_STARTCAL) {
      status += 4;
    } else if (state == CC1101RadioState.CC1101_STATE_RXTX_SWITCH ||
        state == CC1101RadioState.CC1101_STATE_TXRX_SWITCH) {
      status += 5;
    } else if (state == CC1101RadioState.CC1101_STATE_RXFIFO_OVERFLOW) {
      status += 6;
    } else if (state == CC1101RadioState.CC1101_STATE_TXFIFO_UNDERFLOW) {
      status += 7;
    }

    /* Bit 0-3 */
    status = status << 4;
    if (lastWasRead) {
      /* Return available bytes in RXFIFO */
      int available = rxfifo.size();
      if (available > 15) {
        status += 15;
      } else {
        status += available;
      }
    } else {
      /* Return available bytes in TXFIFO */
      int available = 64 - txfifo.size();
      if (available > 15) {
        status += 15;
      } else {
        status += available;
      }
    }

    return status;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/FileStorage.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.Arrays;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author Niclas Finne
 */
public class FileStorage implements Storage {

    private String filename;
    private String currentFilename;
    private RandomAccessFile file;
    private FileChannel fileChannel;
    private FileLock fileLock;
    private long maxSize = 0;

    public FileStorage() {
        this("flash.bin");
    }

    public FileStorage(String filename) {
        this.filename = filename;
    }

    private boolean ensureOpen(boolean write) throws IOException {
        if (fileChannel != null) {
            return true;
        }
        if (!write) {
            File fp = new File(filename);
            if (!fp.exists()) {
                // File does not exist and only trying to read. Delay file creation until first write
                return false;
            }
        }

        // Open flash file for R/W
        if (!openFile(filename)) {
            // Failed to open/lock the specified file. Add a counter and try with next filename.
            Matcher m = Pattern.compile("(.+?)(\\d*)(\\.[^.]+)").matcher(filename);
            if (m.matches()) {
                String baseName = m.group(1);
                String c = m.group(2);
                String extName = m.group(3);
                int count = 1;
                if (c != null && c.length() > 0) {
                    count = Integer.parseInt(c) + 1;
                }
                for (int i = 0; !openFile(baseName + count + extName) && i < 100; i++, count++);
            }
        }
        if (fileLock == null) {
            // Failed to open flash file
            if (write) {
                throw new IOException("failed to open storage file '" + filename + '\'');
            }
            return false;
        }
        return true;
    }

    private boolean openFile(String filename) {
        // Open flash file for R/W
        try {
            currentFilename = filename;
            file = new RandomAccessFile(filename, "rw");
            fileChannel = file.getChannel();
            fileLock = fileChannel.tryLock();
            if (fileLock != null) {
                // The file is now locked for use
//                if (DEBUG) log("using flash file '" + filename + '\'');
                return true;
            }
            fileChannel.close();
            return false;
        } catch (IOException e) {
            e.printStackTrace();
            close();
            return false;
        }
    }

    public String getFilename() {
        return filename;
    }

    public void setFilename(String filename) {
        this.filename = filename;
        close();
    }

    public File getCurrentFile() {
        if (file != null) {
            return new File(currentFilename);
        }
        return null;
    }

    @Override
    public int read(long pos, byte[] b) throws IOException {
        return read(pos, b, 0, b.length);
    }

    @Override
    public int read(long pos, byte[] b, int offset, int len) throws IOException {
        if (maxSize > 0 && pos + len > maxSize) {
            throw new IOException("outside storage");
        }
        if (file != null || ensureOpen(false)) {
            file.seek(pos);
            return file.read(b, offset, len);
        }
        Arrays.fill(b, (byte) 0);
        return len;
    }

    @Override
    public void write(long pos, byte[] b) throws IOException {
        write(pos, b, 0, b.length);
    }

    public void write(long pos, byte[] b, int offset, int len) throws IOException {
        if (maxSize > 0 && pos + len > maxSize) {
            throw new IOException("outside storage");
        }
        if (file != null || ensureOpen(true)) {
            file.seek(pos);
            file.write(b, offset, len);
        }
    }

    @Override
    public long getMaxSize() {
        return maxSize;
    }

    @Override
    public void setMaxSize(long size) {
        this.maxSize = size;
        if (size > 0 && file != null) {
            try {
                if (file.length() > size) {
                    file.setLength(size);
                }
            } catch (IOException e) {
                // Ignore
            }
        }
    }

    @Override
    public void close() {
        try {
            file = null;
            if (fileLock != null) {
                fileLock.release();
                fileLock = null;
            }
            if (fileChannel != null) {
                fileChannel.close();
                fileChannel = null;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String info() {
        File fp = getCurrentFile();
        StringBuilder sb = new StringBuilder();
        sb.append("FileStorage(");
        if (file != null) {
            try {
                long len = file.length();
                sb.append(len);
            } catch (Exception e) {
                // Ignore
                sb.append('0');
            }
        }
        if (maxSize > 0) {
            sb.append('/').append(maxSize);
        }
        sb.append(" bytes): ");
        if (fp != null) {
            sb.append(fp.getAbsolutePath());
        } else {
            sb.append(filename);
        }
        return sb.toString();
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/DS2411.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * DS2411 - MAC Address chip
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */
package se.sics.mspsim.chip;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;
import se.sics.mspsim.util.Utils;

public class DS2411 extends Chip {
  
  private enum STATE {
    IDLE, WAIT_FOR_RESET, RESETTING, SIGNAL_READY, READY, WAIT_SENDING, SENDING
  }
  
  private static final int CMD_READ_ROM = 0x33;
  //private static final int CMD_SEARCH_ROM = 0xf0;  
  
  private IOPort sdataPort;
  private int sdataPin;
  private STATE state = STATE.IDLE;
  private boolean lastPin;
  
  private int pos = 0;
  private int readByte = 0;
  private int writeByte = 0;
  private int writeLen = 0;
  private int writePos = 0;
  /* max 10 bytes to write back */
  private int[] writeBuf = new int[10];
  private int[] macID = new int[]{1, 2, 3, 4, 5, 6};
  
  private TimeEvent stateEvent = new TimeEvent(0) {
    public void execute(long t) {
      switch (state) {
      case WAIT_FOR_RESET:
        if (!lastPin) {
          state = STATE.RESETTING;
          stateChanged(state.ordinal());
          if (DEBUG) log("Resetting...");
        }
        break;
      case SIGNAL_READY:
        /* ready! release bus */
        sdataPort.setPinState(sdataPin, IOPort.PinState.HI);
        state = STATE.READY;
        stateChanged(state.ordinal());
        if (DEBUG) log("Ready!");
        readByte = 0;
        pos = 0;
        break;
      case READY:
        if (DEBUG) log("Reading: " + (lastPin ? 1 : 0));
        readByte = readByte + (lastPin ? (1 << pos) : 0);
        pos++;
        if (pos == 8) {
          if (DEBUG) log("Command: " + Utils.hex8(readByte));
          handleCommand(readByte);
          state = STATE.WAIT_SENDING;        
          stateChanged(state.ordinal());
          pos = 0;
          writePos = 0;
          writeByte = writeBuf[writePos];              
        }
        break;
    case IDLE:
        break;
    case RESETTING:
        break;
    case WAIT_SENDING:
        break;
    case SENDING:
        break;
      }
    }
  };
  
  public DS2411(MSP430Core cpu) {
    super("DS2411", "Silicon Serial Number", cpu);
  }

  private int crcAdd(int acc, int data) {
    int i;
    acc ^= data;
    for (i = 0; i < 8; i++) {
      if ((acc & 1) == 1)
        acc = (acc >> 1) ^ 0x8c;
      else
        acc >>= 1;
    }
    return acc;
  }

  private int crc8(int[] buf, int len) {
    int acc = 0;
    for (int i = 0; i < len; i++) {
      acc = crcAdd(acc, buf[i]);
    }
    return acc;
  }
  
  protected void handleCommand(int cmd) {
    if (cmd == CMD_READ_ROM) {
      /* 48 bits = 6 bytes */
      writeBuf[0] = 0x01; /* family */
      writeBuf[1] = macID[0];
      writeBuf[2] = macID[1];
      writeBuf[3] = macID[2];
      writeBuf[4] = macID[3];
      writeBuf[5] = macID[4];
      writeBuf[6] = macID[5];
      writeBuf[7] = crc8(writeBuf, 7); /* the crc */
      writeLen = 1 + 6 + 1;
    }
  }

  public int getModeMax() {
    return 0;
  }

  public void setDataPort(IOPort port, int bit) {
    sdataPort = port;
    sdataPin = bit;
  }

  /* Communication pin to the DS2411 */
  /* TODO: we should have a separate reset event so that a low for a long time will
   * cause a reset in any state...
   */
  public void dataPin(boolean high) {
    if (DEBUG) log("Data pin high: " + high + " " + cpu.cycles);
    if (lastPin == high) return;
    lastPin = high;
    switch(state) {
    case IDLE:
      sdataPort.setPinState(sdataPin, IOPort.PinState.HI);
      if (!high) {
        state = STATE.WAIT_FOR_RESET;
        stateChanged(state.ordinal());
        /* reset if low for at least 480uS - we check after 400uS and resets
         * then */
        if (DEBUG) log("Wait for reset...");
        cpu.scheduleTimeEventMillis(stateEvent, 0.400);
      }
      break;
    case WAIT_FOR_RESET:
        break;
    case RESETTING:
      if (high) {
        state = STATE.SIGNAL_READY;
        stateChanged(state.ordinal());
        if (DEBUG) log("Signal ready");
        /* reset done - signal with LOW for a while! */
        sdataPort.setPinState(sdataPin, IOPort.PinState.LOW);
        cpu.scheduleTimeEventMillis(stateEvent, 0.480);
        pos = 0;
      }
      break;
    case SIGNAL_READY:
        break;
    case READY:
      /* we should read a byte during the READY - 60us - 120us time slot*/
      if (!high) {
        /* schedule a read after 40us */
        cpu.scheduleTimeEventMillis(stateEvent, 0.040);
      }
      break;
    case WAIT_SENDING:
      if (!high) {
        state = STATE.SENDING;
        stateChanged(state.ordinal());
      }
      break;
    case SENDING:
      if (high) {
        if (pos == 0 && DEBUG) log("should write next byte: " + writeByte);

        /* went high => we should send another bit */
        sdataPort.setPinState(sdataPin,
            ((writeByte & (1 << pos)) > 0) ? IOPort.PinState.HI : IOPort.PinState.LOW);
        if (DEBUG) log("wrote bit: " + (((writeByte & (1 << pos)) > 0) ? 1 : 0));
        pos++;
        if (pos == 8) {
          writePos++;
          if (writePos == writeLen) {
            if (DEBUG) log("write is over => IDLE!!!!");
            state = STATE.IDLE;
            stateChanged(state.ordinal());
          } else {
            pos = 0;
            writeByte = writeBuf[writePos];
          }
        }
      }
    }
  }

  public void setMACID(int i, int j, int k, int l, int m, int n) {
    macID[0] = i;
    macID[1] = j;
    macID[2] = k;
    macID[3] = l;
    macID[4] = m;
    macID[5] = n;    
  }

  public int getConfiguration(int parameter) {
      return 0;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/ExternalFlash.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430Core;

public abstract class ExternalFlash extends Chip {

    private Storage storage;

    protected ExternalFlash(String id, MSP430Core cpu) {
        super(id, cpu);
    }

    protected ExternalFlash(String id, String name, MSP430Core cpu) {
        super(id, name, cpu);
    }

    public Storage getStorage() {
        if (storage ==null) {
            // No storage set. Create a memory storage
            storage = new MemoryStorage();
            storage.setMaxSize(getSize());
        }
        return storage;
    }

    public void setStorage(Storage storage) {
        this.storage = storage;
    }

    @Override
    public int getConfiguration(int param) {
        return 0;
    }

    public abstract int getSize();

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Accelerometer.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.chip;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430Core;

/**
 * @author Niclas Finne
 *
 */
public abstract class Accelerometer extends Chip {

    protected double x, y, z;

    protected Accelerometer(String id, MSP430Core cpu) {
        super(id, "Accelerometer", cpu);
    }

    protected Accelerometer(String id, String name, MSP430Core cpu) {
        super(id, name, cpu);
    }

    public void setX(double x) {
        this.x = x;
    }

    public double getX() {
        return x;
    }

    public void setY(double y) {
        this.y = y;
    }

    public double getY() {
        return y;
    }

    public void setZ(double z) {
        this.z = z;
    }

    public double getZ() {
        return z;
    }

    public void setPosition(double x, double y, double z) {
        setX(x);
        setY(y);
        setZ(z);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Leds.java`:

```java
 /*
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Leds
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 17 jul 2010
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.chip;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.util.Utils;

public class Leds extends Chip {

    private final int[] ledColors;

    private int leds;

    public Leds(MSP430Core cpu, int[] ledColors) {
        super("Leds", cpu);
        if (ledColors == null) {
            throw new NullPointerException("ledColors");
        }
        this.ledColors = ledColors;
    }

    public int getLeds() {
        return leds;
    }

    public void setLeds(int leds) {
        if (this.leds != leds) {
            this.leds = leds;
            stateChanged(leds);
            if (DEBUG) log(ledColors.length <= 8 ? Utils.binary8(leds) : Utils.binary16(leds));
        }
    }

    public void setLeds(int leds, boolean on) {
        if (on) {
            setLeds(this.leds | leds);
        } else {
            setLeds(this.leds & ~leds);
        }
    }

    public boolean isLedOn(int led) {
        return (leds & (1 << led)) != 0;
    }


    public int getLedsColor(int led) {
        return ledColors[led];
    }

    public int getLedsCount() {
        return ledColors.length;
    }

    @Override public int getModeMax() {
        return 0;
    }

    @Override public String info() {
        return "Leds: " + (ledColors.length <= 8 ? Utils.binary8(leds) : Utils.binary16(leds));
    }

    @Override public int getConfiguration(int parameter) {
        return 0;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/chip/Radio802154.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 */
package se.sics.mspsim.chip;
import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430Core;

/**
 * @author Niclas Finne
 */
public abstract class Radio802154 extends Chip implements RFListener, RFSource {

    protected RFListener rfListener;
    protected ChannelListener channelListener;

    public Radio802154(String id, String name, MSP430Core cpu) {
        super(id, name, cpu);
    }

    public abstract boolean isReadyToReceive();

    @Override
    public abstract void receivedByte(byte c);

    public abstract int getActiveChannel();
    public abstract int getActiveFrequency();
    public abstract int getOutputPower();
    public abstract int getOutputPowerMax();
    public abstract int getOutputPowerIndicator();
    public abstract int getOutputPowerIndicatorMax();

    public abstract int getRSSI();
    public abstract void setRSSI(int rssi);

    public abstract int getLQI();
    public abstract void setLQI(int lqi);

    @Override
    public synchronized void addRFListener(RFListener rf) {
        rfListener = RFListener.Proxy.INSTANCE.add(rfListener, rf);
    }

    @Override
    public synchronized void removeRFListener(RFListener rf) {
        rfListener = RFListener.Proxy.INSTANCE.remove(rfListener, rf);
    }

    public synchronized void addChannelListener(ChannelListener listener) {
        channelListener = ChannelListener.Proxy.INSTANCE.add(channelListener, listener);
    }

    public synchronized void removeChannelListener(ChannelListener listener) {
        channelListener = ChannelListener.Proxy.INSTANCE.remove(channelListener, listener);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/HighlightSourceViewer.java`:

```java
/*
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * HighlightSourceViewer
 *
 * Authors : Adam Dunkels, Joakim Eriksson, Niclas Finne
 * Created : 6 dec 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.extutil.highlight;
import java.awt.Color;
import java.awt.Container;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;

import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JScrollPane;
import javax.swing.SwingUtilities;

import se.sics.mspsim.ui.SourceViewer;
import se.sics.mspsim.ui.WindowUtils;

/**
 *
 */
public class HighlightSourceViewer implements SourceViewer {

  private JFrame window;
  private SyntaxHighlighter highlighter;
  private String currentFile;
  private ArrayList<File> path = null;
  private JFileChooser fileChooser;

  public HighlightSourceViewer() {
    //
  }

  private void setup() {
    if (window == null) {
      window = new JFrame("Source Viewer");
      window.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

      LineNumberedBorder border = new LineNumberedBorder(LineNumberedBorder.LEFT_SIDE, LineNumberedBorder.RIGHT_JUSTIFY);
      border.setSeparatorColor(Color.lightGray);

      Scanner scanner = new CScanner();
      highlighter = new SyntaxHighlighter(24, 120, scanner);
      highlighter.setEditable(false);
      highlighter.setBorder(border);
      JScrollPane scroller = new JScrollPane(highlighter);
      scroller.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
      Container pane = window.getContentPane();
      pane.add(scroller);
      WindowUtils.restoreWindowBounds("SourceViewer", window);
      WindowUtils.addSaveOnShutdown("SourceViewer", window);

      String searchPath = System.getProperty("CONTIKI_PATH");
      if (searchPath != null) {
        addEnvPath(searchPath);
      }
      searchPath = System.getenv("CONTIKI_PATH");
      if (searchPath != null) {
        addEnvPath(searchPath);
      }
    }
  }
  
  private void addEnvPath(String searchPath) {
    String[] p = searchPath.split(File.pathSeparator);
    if (p != null) {
      for (int i = 0, n = p.length; i < n; i++) {
        addSearchPath(new File(p[i]));
      }
    }
  }

  public boolean isVisible() {
    return window != null && window.isVisible();
  }

  public void setVisible(boolean isVisible) {
    setup();
    window.setVisible(isVisible);
  }

  public void viewFile(final String path, final String filename) {
    if (filename.equals(currentFile)) {
      // Already showing this file
      return;
    }
    currentFile = filename;

    SwingUtilities.invokeLater(new Runnable() {
      public void run() {
        try {
	  setup();

          File file = findSourceFile(path, filename);
          if (file != null) {
            FileReader reader = new FileReader(file);
            try {
              highlighter.read(reader, null);
              // Workaround for bug 4782232 in Java 1.4
              highlighter.setCaretPosition(1);
              highlighter.setCaretPosition(0);
	      window.setTitle("Source Viewer (" + file.getAbsolutePath()
			      + ')');
              if (!window.isVisible()) {
                window.setVisible(true);
              }
            } finally {
              reader.close();
            }
          }
        } catch (IOException err) {
          err.printStackTrace();
          JOptionPane.showMessageDialog(window, "Failed to read the file '" + filename + '\'', "Could not read file", JOptionPane.ERROR_MESSAGE);
        }
      }
    });
  }

  public void viewLine(final int line) {
    if (highlighter != null) {
      SwingUtilities.invokeLater(new Runnable() {
        public void run() {
          highlighter.viewLine(line - 1);
          if (!window.isVisible()) {
            window.setVisible(true);
          }
        }
      });
    }
  }

  public void addSearchPath(File directory) {
    if (path == null) {
      path = new ArrayList<File>();
    }
    path.add(directory);
  }

  public void removeSearchPath(File directory) {
    if (path != null) {
      path.remove(directory);
    }
  }

  private File findSourceFile(String fPath, String filename) {
    File fp = new File(fPath, filename);
    if (fp.exists()) {
      return fp;
    }
    fp = new File(filename);
    if (fp.exists()) {
      return fp;
    }

    if (path != null) {
      for(File p : path) {
        File nfp = new File(p, filename);
        if (nfp.exists()) {
          return nfp;
        }
      }
    } else {
      path = new ArrayList<File>();
    }
    // Find new path to search from
    if (fileChooser == null) {
      fileChooser = new JFileChooser("./");
      fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      fileChooser.setDialogTitle("Select compilation directory");
    }
    if (!window.isVisible()) {
      window.setVisible(true);
    }
    if (fileChooser.showOpenDialog(window) == JFileChooser.APPROVE_OPTION) {
      File d = fileChooser.getSelectedFile();
      if (d != null) {
	path.add(d);
	return findSourceFile(fPath, filename);
      }
    }
    return null;
  }

  public static void main(String[] args) {
    HighlightSourceViewer sv = new HighlightSourceViewer();
    sv.setVisible(true);
    sv.viewFile(".", args[0]);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/JavaScanner.java`:

```java
package se.sics.mspsim.extutil.highlight;
// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * <p>
 * Provide a hand-written scanner for the Java language.
 */

public class JavaScanner extends Scanner {

  // The version of Java supported.
  private int version = 15;

  private boolean debug = false;

  /** Create a Java scanner, for Java version 1.5 by default. */
  public JavaScanner() {
    super();
    initKind();
    initUniKind();
  }

  /** Create a Java scanner, for a given version between "1.1" and "1.5". */
  public JavaScanner(String version) {
    super();
    initKind();
    initUniKind();
    if (version.equals("1.1"))
      this.version = 11;
    else if (version.equals("1.2"))
      this.version = 12;
    else if (version.equals("1.3"))
      this.version = 13;
    else if (version.equals("1.4"))
      this.version = 14;
    else if (version.equals("1.5"))
      this.version = 15;
    else
      throw new Error("Unknown version of Java: " + version);
  }

  /** Override the read method from the Scanner class. */
  protected int read() {
    int type, saveStart = 0;
    if (debug)
      saveStart = start;

    if (start >= end)
      return WHITESPACE;

    switch (state) {
    case MID_COMMENT:
    case END_COMMENT:
      type = readComment(MID_COMMENT);
      if (type == END_COMMENT)
        state = WHITESPACE;
      else
        state = MID_COMMENT;
      return type;
    default:
      char c = buffer[start];
      if (c == '\\')
        c = next();
      if (c < 128)
        type = kind[c];
      else
        type = unikind[Character.getType(c)];
      switch (type) {
      case WHITESPACE:
        start = start + charlength;
        charlength = 1;
        while (start < end) {
          c = buffer[start];
          if (c == '\\')
            c = next();
          int k;
          if (c < 128)
            k = kind[c];
          else
            k = unikind[Character.getType(c)];
          if (k != WHITESPACE)
            break;
          start = start + charlength;
          charlength = 1;
        }
        break;
      case UNRECOGNIZED:
      case BRACKET:
      case SEPARATOR:
        start = start + charlength;
        charlength = 1;
        break;
      case OPERATOR:
        start = start + charlength;
        charlength = 1;
        type = readOperator(c);
        break;
      case CHARACTER:
        start = start + charlength;
        charlength = 1;
        type = readCharLiteral();
        break;
      case STRING:
        start = start + charlength;
        charlength = 1;
        type = readStringLiteral();
        break;
      case IDENTIFIER:
        start = start + charlength;
        charlength = 1;
        while (start < end) {
          c = buffer[start];
          if (c == '\\')
            c = next();
          int k;
          if (c < 128)
            k = kind[c];
          else
            k = unikind[Character.getType(c)];
          if (k != IDENTIFIER && k != NUMBER)
            break;
          start = start + charlength;
          charlength = 1;
        }
        break;
      case NUMBER:
        start = start + charlength;
        charlength = 1;
        type = readNumber(c);
        break;
      case PUNCTUATION:
        start = start + charlength;
        charlength = 1;
        type = readDot();
        break;
      case COMMENT:
        start = start + charlength;
        charlength = 1;
        type = readSlash();
        if (type == START_COMMENT)
          state = MID_COMMENT;
        break;
      }
    }
    if (debug) {
      System.out.print(TokenTypes.typeNames[type]);
      System.out.println(" " + saveStart + "," + end + "("
          + (start - saveStart) + ")");
    }
    return type;
  }

  private int readOperator(char c) {
    if (start >= end)
      return OPERATOR;
    char c2;

    switch (c) {
    case '~':
    case '?':
    case ':':
      break;
    case '+':
    case '-':
    case '&':
    case '|':
      c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      if (c2 != c && c2 != '=')
        break;
      start = start + charlength;
      charlength = 1;
      break;
    case '=':
    case '*':
    case '!':
    case '^':
    case '%':
    case '/':
      c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      if (c2 != '=')
        break;
      start = start + charlength;
      charlength = 1;
      break;
    case '<':
    case '>':
      c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      if (c2 == '=') {
        start = start + charlength;
        charlength = 1;
      } else if (c2 == c) {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          break;
        char c3 = buffer[start];
        if (c3 == '\\')
          c3 = next();
        if (c3 == '=') {
          start = start + charlength;
          charlength = 1;
        } else if (c == '>' && c3 == '>') // >>>
        {
          start = start + charlength;
          charlength = 1;
          if (start >= end)
            break;
          char c4 = buffer[start];
          if (c4 == '\\')
            c4 = next();
          if (c4 != '=')
            break;
          start = start + charlength;
          charlength = 1;
        }
      }
      break;
    }
    return OPERATOR;
  }

  private int readCharLiteral() {
    if (start >= end)
      return bad(CHARACTER);
    char c2 = buffer[start];
    if (c2 == '\\')
      c2 = next();

    switch (c2) {
    case '\\':
      start = start + charlength;
      charlength = 1;
      boolean ok = readEscapeSequence();
      if (!ok)
        return bad(CHARACTER);
      break;
    case '\'':
    case '\n':
      return bad(CHARACTER);
    default:
      start = start + charlength;
      charlength = 1;
      break;
    }
    if (start >= end)
      return bad(CHARACTER);
    char c3 = buffer[start];
    if (c3 == '\\')
      c3 = next();
    if (c3 != '\'')
      return bad(CHARACTER);
    start = start + charlength;
    charlength = 1;
    return CHARACTER;
  }

  private int readStringLiteral() {
    if (start >= end)
      return bad(STRING);
    char c = buffer[start];
    if (c == '\\')
      c = next();

    while (c != '"') {
      switch (c) {
      case '\\':
        start = start + charlength;
        charlength = 1;
        boolean ok = readEscapeSequence();
        if (!ok)
          return bad(STRING);
        break;
      case '\n':
        return bad(STRING);
      default:
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return bad(STRING);
        break;
      }
      c = buffer[start];
      if (c == '\\')
        c = next();
    }
    if (c != '"')
      return bad(STRING);
    start = start + charlength;
    charlength = 1;
    return STRING;
  }

  private int readSlash() {
    if (start >= end)
      return OPERATOR;
    char c = buffer[start];
    if (c == '\\')
      c = next();
    if (c == '/') {
      while (c != '\n') {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return COMMENT;
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
      start = start + charlength;
      charlength = 1;
      return COMMENT;
    } else if (c == '*') {
      start = start + charlength;
      charlength = 1;
      return readComment(START_COMMENT);
    }
    return readOperator('/');
  }

  // Read one line of a /*...*/ comment, given the expected type
  int readComment(int type) {
    if (start >= end)
      return type;
    char c = buffer[start];
    if (c == '\\')
      c = next();

    while (true) {
      while (c != '*' && c != '\n') {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return type;
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
      start = start + charlength;
      charlength = 1;
      if (c == '\n')
        return type;
      if (start >= end)
        return type;
      c = buffer[start];
      if (c == '\\')
        c = next();
      if (c == '/') {
        start = start + charlength;
        charlength = 1;
        if (type == START_COMMENT) {
          return COMMENT;
        }
        return END_COMMENT;
      }
    }
  }

  // Read a number, without checking whether it is out of range
  // Doesn't deal with e.g. 0777.9 or 07779f
  private int readNumber(char c) {
    if (c == '0') {
      int saveStart = start, saveLength = charlength;
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return NUMBER;
      char c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      switch (c2) {
      case 'x':
      case 'X':
        start = start + charlength;
        charlength = 1;
        boolean ok = readDigits(16);
        if (!ok)
          return bad(NUMBER);
        readSuffix();
        return NUMBER;
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        readDigits(8);
        readSuffix();
        return NUMBER;
      case '.':
      case 'e':
      case 'E':
        start = saveStart;
        charlength = saveLength;
        break;
      case 'f':
      case 'F':
      case 'd':
      case 'D':
        start = start + charlength;
        charlength = 1;
        return NUMBER;
      case 'l':
      case 'L':
        start = start + charlength;
        charlength = 1;
        return NUMBER;
      }
    }
    boolean hasDigits = false;
    if ('0' <= c && c <= '9') {
      hasDigits = true;
      readDigits(10);
      if (start >= end)
        return NUMBER;
      c = buffer[start];
      if (c == '\\')
        c = next();
      if (c == 'l' || c == 'L') {
        start = start + charlength;
        charlength = 1;
        return NUMBER;
      }
    }
    if (c == '.') {
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return NUMBER;
      c = buffer[start];
      if (c == '\\')
        c = next();
      if ('0' <= c && c <= '9') {
        hasDigits = true;
        readDigits(10);
        if (start >= end)
          return NUMBER;
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
    }
    if (!hasDigits)
      return bad(NUMBER);
    switch (c) {
    case 'e':
    case 'E':
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return bad(NUMBER);
      c = buffer[start];
      if (c == '\\')
        c = next();
      if (c == '+' || c == '-') {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return bad(NUMBER);
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
      readDigits(10);
      break;
    case 'f':
    case 'F':
    case 'd':
    case 'D':
      start = start + charlength;
      charlength = 1;
      return NUMBER;
    }
    return NUMBER;
  }

  boolean readDigits(int radix) {
    if (start >= end)
      return false;
    char c = buffer[start];
    if (c == '\\')
      c = next();
    if (Character.digit(c, radix) == -1)
      return false;
    while (Character.digit(c, radix) != -1) {
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return true;
      c = buffer[start];
      if (c == '\\')
        c = next();
    }
    return true;
  }

  void readSuffix() {
    if (start >= end)
      return;
    char c = buffer[start];
    if (c == '\\')
      c = next();
    switch (c) {
    case 'f':
    case 'F':
    case 'd':
    case 'D':
    case 'l':
    case 'L':
      start = start + charlength;
      charlength = 1;
    }
  }

  private int readDot() {
    if (start >= end)
      return SEPARATOR;
    char c2 = buffer[start];
    if (c2 == '\\')
      c2 = next();
    if (Character.isDigit(c2)) {
      return readNumber('.');
    }
    if (start + 1 >= end || version < 15)
      return SEPARATOR;
    if (c2 != '.' || buffer[start + 1] != '.')
      return SEPARATOR;
    start = start + 2;
    return SEPARATOR;
  }

  private boolean readEscapeSequence() {
    if (start >= end)
      return false;
    char c2 = buffer[start];
    if (c2 == '\\')
      c2 = next();

    switch (c2) {
    case 'b':
    case 't':
    case 'n':
    case 'f':
    case 'r':
    case '\"':
    case '\'':
    case '\\':
      start = start + charlength;
      charlength = 1;
      return true;
    case '0':
    case '1':
    case '2':
    case '3':
      return readOctal(3);
    case '4':
    case '5':
    case '6':
    case '7':
      return readOctal(2);
    default:
      return false;
    }
  }

  boolean readOctal(int maxlength) {
    if (start >= end)
      return false;
    char c = buffer[start];
    if (c == '\\')
      c = next();

    int i, val = 0;
    for (i = 0; i < maxlength; i++) {
      if (Character.digit(c, 8) != -1) {
        val = 8 * val + Character.digit(c, 8);
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          break;
        c = buffer[start];
        if (c == '\\')
          c = next();
      } else
        break;
    }
    if ((i == 0) || (val > 0xFF))
      return false;
    return true;
  }

  // A malformed or incomplete token has a negative type
  private int bad(int type) {
    return -type;
  }

  // Look ahead at the next character or unicode escape.
  // For efficiency, replace c = next(); with
  // c = buffer[start]; if (c == '\\') c = next();
  // To accept the character after looking at it, use:
  // start = start + charlength; charlength = 1;

  // Record the number of source code characters used up. To deal with an odd
  // or even number of backslashes preceding a unicode escape, whenever a
  // second backslash is coming up, mark its position as a pair.

  private int charlength = 1;

  private int pair = 0;

  private char next() {
    if (start >= end)
      return 26; // EOF
    char c = buffer[start];
    if (c != '\\')
      return c;
    if (start == pair) {
      pair = 0;
      return '\\';
    }
    if (start + 1 >= end)
      return '\\';

    c = buffer[start + 1];
    if (c == '\\')
      pair = start + 1;
    if (c != 'u')
      return '\\';

    int pos = start + 2;
    while (pos < end && buffer[pos] == 'u')
      pos++;
    if (pos + 4 > end) {
      charlength = end - start;
      return '\0';
    }

    c = 0;
    for (int j = 0; j < 4; j++) {
      int d = Character.digit(buffer[pos + j], 16);
      if (d < 0) {
        charlength = pos + j - start;
        return '\0';
      }
      c = (char) (c * 16 + d);
    }
    charlength = pos + 4 - start;
    return c;
  }

  // Override initSymbolTable

  protected void initSymbolTable() {
    lookup(KEYWORD, "abstract");
    if (version >= 14)
      lookup(KEYWORD, "assert");
    lookup(KEYWORD, "boolean");
    lookup(KEYWORD, "break");
    lookup(KEYWORD, "byte");
    lookup(KEYWORD, "case");
    lookup(KEYWORD, "catch");
    lookup(KEYWORD, "char");
    lookup(KEYWORD, "class");
    lookup(KEYWORD, "const");
    lookup(KEYWORD, "continue");
    lookup(KEYWORD, "default");
    lookup(KEYWORD, "do");
    lookup(KEYWORD, "double");
    lookup(KEYWORD, "else");
    if (version >= 15)
      lookup(KEYWORD, "enum");
    lookup(KEYWORD, "extends");
    lookup(KEYWORD, "final");
    lookup(KEYWORD, "finally");
    lookup(KEYWORD, "float");
    lookup(KEYWORD, "for");
    lookup(KEYWORD, "goto");
    lookup(KEYWORD, "if");
    lookup(KEYWORD, "implements");
    lookup(KEYWORD, "import");
    lookup(KEYWORD, "instanceof");
    lookup(KEYWORD, "int");
    lookup(KEYWORD, "interface");
    lookup(KEYWORD, "long");
    lookup(KEYWORD, "native");
    lookup(KEYWORD, "new");
    lookup(KEYWORD, "package");
    lookup(KEYWORD, "private");
    lookup(KEYWORD, "protected");
    lookup(KEYWORD, "public");
    lookup(KEYWORD, "return");
    lookup(KEYWORD, "short");
    lookup(KEYWORD, "static");
    if (version >= 12)
      lookup(KEYWORD, "strictfp");
    lookup(KEYWORD, "super");
    lookup(KEYWORD, "switch");
    lookup(KEYWORD, "synchronized");
    lookup(KEYWORD, "this");
    lookup(KEYWORD, "throw");
    lookup(KEYWORD, "throws");
    lookup(KEYWORD, "transient");
    lookup(KEYWORD, "try");
    lookup(KEYWORD, "void");
    lookup(KEYWORD, "volatile");
    lookup(KEYWORD, "while");

    lookup(LITERAL, "true");
    lookup(LITERAL, "false");
    lookup(LITERAL, "null");
  }

  // *** Override lookup, but what about unicode escape translation?

  private Symbol temp = new Symbol(0, null);

  protected Symbol lookup(int type, String name) {
    if (type != IDENTIFIER)
      return super.lookup(type, name);
    temp.type = KEYWORD;
    temp.name = name;
    Symbol sym = symbolTable.get(temp);
    if (sym != null)
      return sym;
    temp.type = LITERAL;
    sym = symbolTable.get(temp);
    if (sym != null)
      return sym;
    return super.lookup(type, name);
  }

  // Classify the ascii characters using an array of kinds, and classify all
  // other unicode characters using an array indexed by unicode category.
  // See the source file java/lang/Character.java for the categories.
  // To find the classification of a character, use:
  // if (c < 128) k = kind[c]; else k = unikind[Character.getType(c)];

  private static final byte[] kind = new byte[128];

  private static final byte[] unikind = new byte[31];

  // Initialise the two classification arrays using static initializer code.
  // Token types from the TokenTypes class are used to classify characters.

  private void initKind() {
    for (char c = 0; c < 128; c++)
      kind[c] = -1;
    for (char c = 0; c < 128; c++)
      switch (c) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 127:
      case '#':
      case '@':
      case '`':
      case '\\':
        kind[c] = UNRECOGNIZED;
        break;
      case '\t':
      case '\n':
      case ' ':
      case '\f':
      case 26:
        kind[c] = WHITESPACE;
        break;
      case '!':
      case '%':
      case '&':
      case '*':
      case '+':
      case '-':
      case ':':
      case '<':
      case '=':
      case '>':
      case '?':
      case '^':
      case '|':
      case '~':
        kind[c] = OPERATOR;
        break;
      case '"':
        kind[c] = STRING;
        break;
      case '\'':
        kind[c] = CHARACTER;
        break;
      case '.':
        kind[c] = PUNCTUATION;
        break;
      case '/':
        kind[c] = COMMENT;
        break;
      case '$':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
        kind[c] = IDENTIFIER;
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        kind[c] = NUMBER;
        break;
      case '(':
      case ')':
      case '[':
      case ']':
      case '{':
      case '}':
        kind[c] = BRACKET;
        break;
      case ',':
      case ';':
        kind[c] = SEPARATOR;
        break;
      }
    for (char c = 0; c < 128; c++)
      if (kind[c] == -1)
        System.out.println("Char " + ((int) c) + " hasn't been classified");
  }

  private void initUniKind() {
    for (byte b = 0; b < 31; b++)
      unikind[b] = -1;
    for (byte b = 0; b < 31; b++)
      switch (b) {
      case Character.UNASSIGNED:
      case Character.ENCLOSING_MARK:
      case Character.OTHER_NUMBER:
      case Character.SPACE_SEPARATOR:
      case Character.LINE_SEPARATOR:
      case Character.PARAGRAPH_SEPARATOR:
      case Character.CONTROL:
      case 17: // category 17 is unused
      case Character.PRIVATE_USE:
      case Character.SURROGATE:
      case Character.DASH_PUNCTUATION:
      case Character.START_PUNCTUATION:
      case Character.END_PUNCTUATION:
      case Character.OTHER_PUNCTUATION:
      case Character.MATH_SYMBOL:
      case Character.MODIFIER_SYMBOL:
      case Character.OTHER_SYMBOL:
      case Character.INITIAL_QUOTE_PUNCTUATION:
      case Character.FINAL_QUOTE_PUNCTUATION:
        unikind[b] = UNRECOGNIZED;
        break;
      case Character.UPPERCASE_LETTER:
      case Character.LOWERCASE_LETTER:
      case Character.TITLECASE_LETTER:
      case Character.MODIFIER_LETTER:
      case Character.OTHER_LETTER:
      case Character.LETTER_NUMBER:
      case Character.CONNECTOR_PUNCTUATION: // maybe NUMBER
      case Character.CURRENCY_SYMBOL:
        // Characters where Other_ID_Start is true
        unikind[b] = IDENTIFIER;
        break;
      case Character.NON_SPACING_MARK:
      case Character.COMBINING_SPACING_MARK:
      case Character.DECIMAL_DIGIT_NUMBER:
      case Character.FORMAT:
        unikind[b] = NUMBER;
        break;
      }
    for (byte b = 0; b < 31; b++)
      if (unikind[b] == -1)
        System.out.println("Unicode cat " + b + " hasn't been classified");
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/Symbol.java`:

```java
package se.sics.mspsim.extutil.highlight;
// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * A Symbol represents the information shared between similar tokens, i.e. their
 * type and spelling.
 */
public class Symbol {
  /**
   * The type is a small integer used to classify symbols. It also distinguishes
   * different symbols with the same spelling, where necessary.
   */
  public int type;

  /**
   * The spelling.
   */
  public String name;

  /**
   * Construct a symbol from its type and name.
   */
  public Symbol(int type, String name) {
    this.type = type;
    this.name = name;
  }

  /**
   * Return the name of the symbol.
   */
  public String toString() {
    return name;
  }

  /**
   * Form a hash value from the type and name.
   */
  public int hashCode() {
    return name.hashCode() + type;
  }

  /**
   * Compare the type and name with some other symbol.
   */
  public boolean equals(Object obj) {
    if (!(obj instanceof Symbol))
      return false;
    Symbol that = (Symbol) obj;
    return name.equals(that.name) && type == that.type;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/TokenTypes.java`:

```java
package se.sics.mspsim.extutil.highlight;
// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * The TokenTypes interface defines the integer constants representing different
 * types of tokens, for use with any languages. The constants are used in
 * symbols to represent the types of similar tokens, and in scanners as scanner
 * states, and in highlighters to determine the colour or style of tokens. There
 * is also an array typeNames of textual names, indexed by type, for descriptive
 * purposes.
 *
 * <p>
 * The UNRECOGNIZED constant (zero) is for tokens which are completely
 * unrecognized, usually consisting of a single illegal character. Other error
 * tokens are represented by negative types, where -t represents an incomplete
 * or malformed token of type t. An error token usually consists of the maximal
 * legal substring of the source text.
 *
 * <p>
 * The WHITESPACE constant is used to classify tokens which are to be discarded,
 * it acts as a suitable scanner state at the beginning of a document, and it is
 * used for the usual end-of-text sentinel token which marks the end of the
 * document. Comments can optionally be classified as WHITESPACE and discarded,
 * if they are not needed for highlighting. No other types besides UNRECOGNIZED
 * and WHITESPACE are treated specially.
 *
 * <p>
 * The constants are presented as an interface so that any class can implement
 * the interface and use the names of the constants directly, without prefixing
 * them with a class name.
 *
 */
public interface TokenTypes {
  public static final int UNRECOGNIZED = 0, WHITESPACE = 1, WORD = 2,
      NUMBER = 3, PUNCTUATION = 4, COMMENT = 5, START_COMMENT = 6,
      MID_COMMENT = 7, END_COMMENT = 8, TAG = 9, END_TAG = 10, KEYWORD = 11,
      KEYWORD2 = 12, IDENTIFIER = 13, LITERAL = 14, STRING = 15,
      CHARACTER = 16, OPERATOR = 17, BRACKET = 18, SEPARATOR = 19, URL = 20, DEFINE = 21;


  /**
   * The names of the token types, indexed by type, are provided for descriptive
   * purposes.
   */
  public static final String[] typeNames = {
    "bad token", "whitespace", "word", "number", "punctuation", "comment",
    "start of comment", "middle of comment", "end of comment", "tag",
    "end tag", "keyword", "keyword 2", "identifier", "literal", "string",
    "character", "operator", "bracket", "separator", "url", "define"
  };
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/CScanner.java`:

```java
package se.sics.mspsim.extutil.highlight;
// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * <p>
 * Provide a hand-written scanner for the Java language.
 */

public class CScanner extends Scanner {

  private boolean debug = false;

  /** Create a Java scanner, for Java version 1.5 by default. */
  public CScanner() {
    super();
    initKind();
    initUniKind();
  }

  /** Create a Java scanner, for a given version between "1.1" and "1.5". */
  public CScanner(String version) {
    super();
    initKind();
    initUniKind();
  }

  /** Override the read method from the Scanner class. */
  protected int read() {
    int type, saveStart = 0;
    if (debug)
      saveStart = start;

    if (start >= end)
      return WHITESPACE;

    switch (state) {
    case MID_COMMENT:
    case END_COMMENT:
      type = readComment(MID_COMMENT);
      if (type == END_COMMENT)
        state = WHITESPACE;
      else
        state = MID_COMMENT;
      return type;
    default:
      char c = buffer[start];
      if (c == '\\')
        c = next();
      if (c < 128)
        type = kind[c];
      else
        type = unikind[Character.getType(c)];
      switch (type) {
      case WHITESPACE:
        start = start + charlength;
        charlength = 1;
        while (start < end) {
          c = buffer[start];
          if (c == '\\')
            c = next();
          int k;
          if (c < 128)
            k = kind[c];
          else
            k = unikind[Character.getType(c)];
          if (k != WHITESPACE)
            break;
          start = start + charlength;
          charlength = 1;
        }
        break;
      case UNRECOGNIZED:
      case BRACKET:
      case SEPARATOR:
        start = start + charlength;
        charlength = 1;
        break;
      case OPERATOR:
        start = start + charlength;
        charlength = 1;
        type = readOperator(c);
        break;
      case CHARACTER:
        start = start + charlength;
        charlength = 1;
        type = readCharLiteral();
        break;
      case STRING:
        start = start + charlength;
        charlength = 1;
        type = readStringLiteral();
        break;
      case IDENTIFIER:
        start = start + charlength;
        charlength = 1;
        while (start < end) {
          c = buffer[start];
          if (c == '\\')
            c = next();
          int k;
          if (c < 128)
            k = kind[c];
          else
            k = unikind[Character.getType(c)];
          if (k != IDENTIFIER && k != NUMBER)
            break;
          start = start + charlength;
          charlength = 1;
        }
        break;
      case NUMBER:
        start = start + charlength;
        charlength = 1;
        type = readNumber(c);
        break;
      case PUNCTUATION:
        start = start + charlength;
        charlength = 1;
        type = readDot();
        break;
      case COMMENT:
        start = start + charlength;
        charlength = 1;
        type = readSlash();
        if (type == START_COMMENT)
          state = MID_COMMENT;
        break;
      }
    }
    if (debug) {
      System.out.print(TokenTypes.typeNames[type]);
      System.out.println(" " + saveStart + "," + end + "("
          + (start - saveStart) + ")");
    }
    return type;
  }

  private int readOperator(char c) {
    if (start >= end)
      return OPERATOR;
    char c2;

    switch (c) {
    case '~':
    case '?':
    case ':':
      break;
    case '+':
    case '-':
    case '&':
    case '|':
      c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      if (c2 != c && c2 != '=')
        break;
      start = start + charlength;
      charlength = 1;
      break;
    case '=':
    case '*':
    case '!':
    case '^':
    case '%':
    case '/':
      c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      if (c2 != '=')
        break;
      start = start + charlength;
      charlength = 1;
      break;
    case '<':
    case '>':
      c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      if (c2 == '=') {
        start = start + charlength;
        charlength = 1;
      } else if (c2 == c) {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          break;
        char c3 = buffer[start];
        if (c3 == '\\')
          c3 = next();
        if (c3 == '=') {
          start = start + charlength;
          charlength = 1;
        } else if (c == '>' && c3 == '>') // >>>
        {
          start = start + charlength;
          charlength = 1;
          if (start >= end)
            break;
          char c4 = buffer[start];
          if (c4 == '\\')
            c4 = next();
          if (c4 != '=')
            break;
          start = start + charlength;
          charlength = 1;
        }
      }
      break;
    }
    return OPERATOR;
  }

  private int readCharLiteral() {
    if (start >= end)
      return bad(CHARACTER);
    char c2 = buffer[start];
    if (c2 == '\\')
      c2 = next();

    switch (c2) {
    case '\\':
      start = start + charlength;
      charlength = 1;
      boolean ok = readEscapeSequence();
      if (!ok)
        return bad(CHARACTER);
      break;
    case '\'':
    case '\n':
      return bad(CHARACTER);
    default:
      start = start + charlength;
      charlength = 1;
      break;
    }
    if (start >= end)
      return bad(CHARACTER);
    char c3 = buffer[start];
    if (c3 == '\\')
      c3 = next();
    if (c3 != '\'')
      return bad(CHARACTER);
    start = start + charlength;
    charlength = 1;
    return CHARACTER;
  }

  private int readStringLiteral() {
    if (start >= end)
      return bad(STRING);
    char c = buffer[start];
    if (c == '\\')
      c = next();

    while (c != '"') {
      switch (c) {
      case '\\':
        start = start + charlength;
        charlength = 1;
        boolean ok = readEscapeSequence();
        if (!ok)
          return bad(STRING);
        break;
      case '\n':
        return bad(STRING);
      default:
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return bad(STRING);
        break;
      }
      c = buffer[start];
      if (c == '\\')
        c = next();
    }
    if (c != '"')
      return bad(STRING);
    start = start + charlength;
    charlength = 1;
    return STRING;
  }

  private int readSlash() {
    if (start >= end)
      return OPERATOR;
    char c = buffer[start];
    if (c == '\\')
      c = next();
    if (c == '/') {
      while (c != '\n') {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return COMMENT;
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
      start = start + charlength;
      charlength = 1;
      return COMMENT;
    } else if (c == '*') {
      start = start + charlength;
      charlength = 1;
      return readComment(START_COMMENT);
    }
    return readOperator('/');
  }

  // Read one line of a /*...*/ comment, given the expected type
  int readComment(int type) {
    if (start >= end)
      return type;
    char c = buffer[start];
    if (c == '\\')
      c = next();

    while (true) {
      while (c != '*' && c != '\n') {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return type;
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
      start = start + charlength;
      charlength = 1;
      if (c == '\n')
        return type;
      if (start >= end)
        return type;
      c = buffer[start];
      if (c == '\\')
        c = next();
      if (c == '/') {
        start = start + charlength;
        charlength = 1;
        if (type == START_COMMENT) {
          return COMMENT;
        }
        return END_COMMENT;
      }
    }
  }

  // Read a number, without checking whether it is out of range
  // Doesn't deal with e.g. 0777.9 or 07779f
  private int readNumber(char c) {
    if (c == '0') {
      int saveStart = start, saveLength = charlength;
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return NUMBER;
      char c2 = buffer[start];
      if (c2 == '\\')
        c2 = next();
      switch (c2) {
      case 'x':
      case 'X':
        start = start + charlength;
        charlength = 1;
        boolean ok = readDigits(16);
        if (!ok)
          return bad(NUMBER);
        readSuffix();
        return NUMBER;
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        readDigits(8);
        readSuffix();
        return NUMBER;
      case '.':
      case 'e':
      case 'E':
        start = saveStart;
        charlength = saveLength;
        break;
      case 'f':
      case 'F':
      case 'd':
      case 'D':
        start = start + charlength;
        charlength = 1;
        return NUMBER;
      case 'l':
      case 'L':
        start = start + charlength;
        charlength = 1;
        return NUMBER;
      }
    }
    boolean hasDigits = false;
    if ('0' <= c && c <= '9') {
      hasDigits = true;
      readDigits(10);
      if (start >= end)
        return NUMBER;
      c = buffer[start];
      if (c == '\\')
        c = next();
      if (c == 'l' || c == 'L') {
        start = start + charlength;
        charlength = 1;
        return NUMBER;
      }
    }
    if (c == '.') {
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return NUMBER;
      c = buffer[start];
      if (c == '\\')
        c = next();
      if ('0' <= c && c <= '9') {
        hasDigits = true;
        readDigits(10);
        if (start >= end)
          return NUMBER;
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
    }
    if (!hasDigits)
      return bad(NUMBER);
    switch (c) {
    case 'e':
    case 'E':
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return bad(NUMBER);
      c = buffer[start];
      if (c == '\\')
        c = next();
      if (c == '+' || c == '-') {
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          return bad(NUMBER);
        c = buffer[start];
        if (c == '\\')
          c = next();
      }
      readDigits(10);
      break;
    case 'f':
    case 'F':
    case 'd':
    case 'D':
      start = start + charlength;
      charlength = 1;
      return NUMBER;
    }
    return NUMBER;
  }

  boolean readDigits(int radix) {
    if (start >= end)
      return false;
    char c = buffer[start];
    if (c == '\\')
      c = next();
    if (Character.digit(c, radix) == -1)
      return false;
    while (Character.digit(c, radix) != -1) {
      start = start + charlength;
      charlength = 1;
      if (start >= end)
        return true;
      c = buffer[start];
      if (c == '\\')
        c = next();
    }
    return true;
  }

  void readSuffix() {
    if (start >= end)
      return;
    char c = buffer[start];
    if (c == '\\')
      c = next();
    switch (c) {
    case 'f':
    case 'F':
    case 'd':
    case 'D':
    case 'l':
    case 'L':
      start = start + charlength;
      charlength = 1;
    }
  }

  private int readDot() {
    if (start >= end)
      return SEPARATOR;
    char c2 = buffer[start];
    if (c2 == '\\')
      c2 = next();
    if (Character.isDigit(c2)) {
      return readNumber('.');
    }
    if (start + 1 >= end) //  || version < 15)
      return SEPARATOR;
    if (c2 != '.' || buffer[start + 1] != '.')
      return SEPARATOR;
    start = start + 2;
    return SEPARATOR;
  }

  private boolean readEscapeSequence() {
    if (start >= end)
      return false;
    char c2 = buffer[start];
    if (c2 == '\\')
      c2 = next();

    switch (c2) {
    case 'b':
    case 't':
    case 'n':
    case 'f':
    case 'r':
    case '\"':
    case '\'':
    case '\\':
      start = start + charlength;
      charlength = 1;
      return true;
    case '0':
    case '1':
    case '2':
    case '3':
      return readOctal(3);
    case '4':
    case '5':
    case '6':
    case '7':
      return readOctal(2);
    default:
      return false;
    }
  }

  boolean readOctal(int maxlength) {
    if (start >= end)
      return false;
    char c = buffer[start];
    if (c == '\\')
      c = next();

    int i, val = 0;
    for (i = 0; i < maxlength; i++) {
      if (Character.digit(c, 8) != -1) {
        val = 8 * val + Character.digit(c, 8);
        start = start + charlength;
        charlength = 1;
        if (start >= end)
          break;
        c = buffer[start];
        if (c == '\\')
          c = next();
      } else
        break;
    }
    if ((i == 0) || (val > 0xFF))
      return false;
    return true;
  }

  // A malformed or incomplete token has a negative type
  private int bad(int type) {
    return -type;
  }

  // Look ahead at the next character or unicode escape.
  // For efficiency, replace c = next(); with
  // c = buffer[start]; if (c == '\\') c = next();
  // To accept the character after looking at it, use:
  // start = start + charlength; charlength = 1;

  // Record the number of source code characters used up. To deal with an odd
  // or even number of backslashes preceding a unicode escape, whenever a
  // second backslash is coming up, mark its position as a pair.

  private int charlength = 1;

  private int pair = 0;

  private char next() {
    if (start >= end)
      return 26; // EOF
    char c = buffer[start];
    if (c != '\\')
      return c;
    if (start == pair) {
      pair = 0;
      return '\\';
    }
    if (start + 1 >= end)
      return '\\';

    c = buffer[start + 1];
    if (c == '\\')
      pair = start + 1;
    if (c != 'u')
      return '\\';

    int pos = start + 2;
    while (pos < end && buffer[pos] == 'u')
      pos++;
    if (pos + 4 > end) {
      charlength = end - start;
      return '\0';
    }

    c = 0;
    for (int j = 0; j < 4; j++) {
      int d = Character.digit(buffer[pos + j], 16);
      if (d < 0) {
        charlength = pos + j - start;
        return '\0';
      }
      c = (char) (c * 16 + d);
    }
    charlength = pos + 4 - start;
    return c;
  }

  // Override initSymbolTable

  protected void initSymbolTable() {
    lookup(KEYWORD, "auto");
    lookup(KEYWORD, "asm");
    lookup(KEYWORD, "break");
    lookup(KEYWORD, "case");
    lookup(KEYWORD, "const");
    lookup(KEYWORD, "continue");
    lookup(KEYWORD, "default");
    lookup(KEYWORD, "define");
    lookup(KEYWORD, "do");
    lookup(KEYWORD, "double");
    lookup(KEYWORD, "else");
    lookup(KEYWORD, "endif");
    lookup(KEYWORD, "enum");
    lookup(KEYWORD, "extern");
    lookup(KEYWORD, "for");
    lookup(KEYWORD, "goto");
    lookup(KEYWORD, "if");
    lookup(KEYWORD, "ifdef");
    lookup(KEYWORD, "ifndef");
    lookup(KEYWORD, "inline");
    lookup(KEYWORD, "include");
    lookup(KEYWORD, "private");
    lookup(KEYWORD, "protected");
    lookup(KEYWORD, "public");
    lookup(KEYWORD, "register");
    lookup(KEYWORD, "return");
    lookup(KEYWORD, "sizeof");
    lookup(KEYWORD, "static");
    lookup(KEYWORD, "struct");
    lookup(KEYWORD, "super");
    lookup(KEYWORD, "switch");
    lookup(KEYWORD, "typedef");
    lookup(KEYWORD, "union");
    lookup(KEYWORD, "volatile");
    lookup(KEYWORD, "while");

    lookup(LITERAL, "TRUE");
    lookup(LITERAL, "FALSE");
    lookup(LITERAL, "NULL");
    lookup(LITERAL, "int8_t");
    lookup(LITERAL, "int16_t");
    lookup(LITERAL, "int32_t");
    lookup(LITERAL, "uint8_t");
    lookup(LITERAL, "uint16_t");
    lookup(LITERAL, "uint32_t");
    lookup(LITERAL, "u8_t");
    lookup(LITERAL, "u16_t");
    lookup(LITERAL, "u32_t");
    lookup(LITERAL, "int");
    lookup(LITERAL, "long");
    lookup(LITERAL, "float");
    lookup(LITERAL, "double");
    lookup(LITERAL, "void");
    lookup(LITERAL, "unsigned");
    lookup(LITERAL, "signed");
    lookup(LITERAL, "char");
    lookup(LITERAL, "short");
  }

  // *** Override lookup, but what about unicode escape translation?

  private Symbol temp = new Symbol(0, null);

  protected Symbol lookup(int type, String name) {
    if (type != IDENTIFIER)
      return super.lookup(type, name);
    temp.type = KEYWORD;
    temp.name = name;
    Symbol sym = symbolTable.get(temp);
    if (sym != null)
      return sym;
    temp.type = LITERAL;
    sym = symbolTable.get(temp);
    if (sym != null)
      return sym;
    return super.lookup(type, name);
  }

  // Classify the ascii characters using an array of kinds, and classify all
  // other unicode characters using an array indexed by unicode category.
  // See the source file java/lang/Character.java for the categories.
  // To find the classification of a character, use:
  // if (c < 128) k = kind[c]; else k = unikind[Character.getType(c)];

  private static final byte[] kind = new byte[128];

  private static final byte[] unikind = new byte[31];

  // Initialise the two classification arrays using static initializer code.
  // Token types from the TokenTypes class are used to classify characters.

  private void initKind() {
    for (char c = 0; c < 128; c++)
      kind[c] = -1;
    for (char c = 0; c < 128; c++)
      switch (c) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
      case 24:
      case 25:
      case 27:
      case 28:
      case 29:
      case 30:
      case 31:
      case 127:
      case '#':
      case '@':
      case '`':
      case '\\':
        kind[c] = UNRECOGNIZED;
        break;
      case '\t':
      case '\n':
      case ' ':
      case '\f':
      case 26:
        kind[c] = WHITESPACE;
        break;
      case '!':
      case '%':
      case '&':
      case '*':
      case '+':
      case '-':
      case ':':
      case '<':
      case '=':
      case '>':
      case '?':
      case '^':
      case '|':
      case '~':
        kind[c] = OPERATOR;
        break;
      case '"':
        kind[c] = STRING;
        break;
      case '\'':
        kind[c] = CHARACTER;
        break;
      case '.':
        kind[c] = PUNCTUATION;
        break;
      case '/':
        kind[c] = COMMENT;
        break;
      case '$':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Y':
      case 'Z':
      case '_':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
      case 'g':
      case 'h':
      case 'i':
      case 'j':
      case 'k':
      case 'l':
      case 'm':
      case 'n':
      case 'o':
      case 'p':
      case 'q':
      case 'r':
      case 's':
      case 't':
      case 'u':
      case 'v':
      case 'w':
      case 'x':
      case 'y':
      case 'z':
        kind[c] = IDENTIFIER;
        break;
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        kind[c] = NUMBER;
        break;
      case '(':
      case ')':
      case '[':
      case ']':
      case '{':
      case '}':
        kind[c] = BRACKET;
        break;
      case ',':
      case ';':
        kind[c] = SEPARATOR;
        break;
      }
    for (char c = 0; c < 128; c++)
      if (kind[c] == -1)
        System.out.println("Char " + ((int) c) + " hasn't been classified");
  }

  private void initUniKind() {
    for (byte b = 0; b < 31; b++)
      unikind[b] = -1;
    for (byte b = 0; b < 31; b++)
      switch (b) {
      case Character.UNASSIGNED:
      case Character.ENCLOSING_MARK:
      case Character.OTHER_NUMBER:
      case Character.SPACE_SEPARATOR:
      case Character.LINE_SEPARATOR:
      case Character.PARAGRAPH_SEPARATOR:
      case Character.CONTROL:
      case 17: // category 17 is unused
      case Character.PRIVATE_USE:
      case Character.SURROGATE:
      case Character.DASH_PUNCTUATION:
      case Character.START_PUNCTUATION:
      case Character.END_PUNCTUATION:
      case Character.OTHER_PUNCTUATION:
      case Character.MATH_SYMBOL:
      case Character.MODIFIER_SYMBOL:
      case Character.OTHER_SYMBOL:
      case Character.INITIAL_QUOTE_PUNCTUATION:
      case Character.FINAL_QUOTE_PUNCTUATION:
        unikind[b] = UNRECOGNIZED;
        break;
      case Character.UPPERCASE_LETTER:
      case Character.LOWERCASE_LETTER:
      case Character.TITLECASE_LETTER:
      case Character.MODIFIER_LETTER:
      case Character.OTHER_LETTER:
      case Character.LETTER_NUMBER:
      case Character.CONNECTOR_PUNCTUATION: // maybe NUMBER
      case Character.CURRENCY_SYMBOL:
        // Characters where Other_ID_Start is true
        unikind[b] = IDENTIFIER;
        break;
      case Character.NON_SPACING_MARK:
      case Character.COMBINING_SPACING_MARK:
      case Character.DECIMAL_DIGIT_NUMBER:
      case Character.FORMAT:
        unikind[b] = NUMBER;
        break;
      }
    for (byte b = 0; b < 31; b++)
      if (unikind[b] == -1)
        System.out.println("Unicode cat " + b + " hasn't been classified");
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/Scanner.java`:

```java
package se.sics.mspsim.extutil.highlight;
import java.util.HashMap;

// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * <p>
 * A Scanner object provides a lexical analyser and a resulting token array.
 * Incremental rescanning is supported, e.g. for use in a token colouring
 * editor. This is a base class dealing with plain text, which can be extended
 * to support other languages.
 * 
 * <p>
 * The actual text is assumed to be held elsewhere, e.g. in a document. The
 * <code>change()</code> method is called to report the position and length of
 * a change in the text, and the <code>scan()</code> method is called to
 * perform scanning or rescanning. For example, to scan an entire document held
 * in a character array <code>text</code> in one go:
 * 
 * <blockquote>
 * 
 * <pre>
 * scanner.change(0, 0, text.length);
 * scanner.scan(text, 0, text.length);
 * </pre>
 * 
 * </blockquote>
 * 
 * <p>
 * For incremental scanning, the <code>position()</code> method is used to
 * find the text position at which rescanning should start. For example, a
 * syntax highlighter might contain this code:
 * 
 * <blockquote>
 * 
 * <pre>
 * // Where to start rehighlighting, and a segment object
 * int firstRehighlightToken;
 * Segment segment;
 * ...
 * // Whenever the text changes, e.g. on an insert or remove or read.
 * firstRehighlightToken = scanner.change(offset, oldLength, newLength);
 * repaint();
 * ...
 * // in repaintComponent
 * int offset = scanner.position();
 * if (offset &lt; 0) return;
 * int tokensToRedo = 0;
 * int amount = 100;
 * while (tokensToRedo == 0 &amp;&amp; offset &gt;= 0)
 * {
 *    int length = doc.getLength() - offset;
 *    if (length &gt; amount) length = amount;
 *    try { doc.getText(offset, length, text); }
 *    catch (BadLocationException e) { return; }
 *    tokensToRedo = scanner.scan(text.array, text.offset, text.count);
 *    offset = scanner.position();
 *    amount = 2*amount;
 * }
 * for (int i = 0; i &lt; tokensToRedo; i++)
 * {
 *    Token t = scanner.getToken(firstRehighlightToken + i);
 *    int length = t.symbol.name.length();
 *    int type = t.symbol.type;
 *    doc.setCharacterAttributes (t.position, length, styles[type], false);
 * }
 * firstRehighlightToken += tokensToRedo;
 * if (offset &gt;= 0) repaint(2);
 * </pre>
 * 
 * </blockquote>
 * 
 * <p>
 * Note that <code>change</code> can be called at any time, even between calls
 * to <code>scan</code>. Only small number of characters are passed to
 * <code>scan</code> so that only a small burst of scanning is done, to
 * prevent the program's user interface from freezing.
 */
public class Scanner implements TokenTypes {
  /**
   * <p>
   * Read one token from the start of the current text buffer, given the start
   * offset, end offset, and current scanner state. The method moves the start
   * offset past the token, updates the scanner state, and returns the type of
   * the token just scanned.
   * 
   * <p>
   * The scanner state is a representative token type. It is either the state
   * left after the last call to read, or the type of the old token at the same
   * position if rescanning, or WHITESPACE if at the start of a document. The
   * method succeeds in all cases, returning whitespace or comment or error
   * tokens where necessary. Each line of a multi-line comment is treated as a
   * separate token, to improve incremental rescanning. If the buffer does not
   * extend to the end of the document, the last token returned for the buffer
   * may be incomplete and the caller must rescan it. The read method can be
   * overridden to implement different languages. The default version splits
   * plain text into words, numbers and punctuation.
   */
  protected int read() {
    char c = buffer[start];
    int type;
    // Ignore the state, since there is only one.
    if (Character.isWhitespace(c)) {
      type = WHITESPACE;
      while (++start < end) {
        if (!Character.isWhitespace(buffer[start]))
          break;
      }
    } else if (Character.isLetter(c)) {
      type = WORD;
      while (++start < end) {
        c = buffer[start];
        if (Character.isLetter(c) || Character.isDigit(c))
          continue;
        if (c == '-' || c == '\'' || c == '_')
          continue;
        break;
      }
    } else if (Character.isDigit(c)) {
      type = NUMBER;
      while (++start < end) {
        c = buffer[start];
        if (!Character.isDigit(c) && c != '.')
          break;
      }
    } else if (c >= '!' || c <= '~') {
      type = PUNCTUATION;
      start++;
    } else {
      type = UNRECOGNIZED;
      start++;
    }

    // state = WHITESPACE;
    return type;
  }

  /**
   * The current buffer of text being scanned.
   */
  protected char[] buffer;

  /**
   * The current offset within the buffer, at which to scan the next token.
   */
  protected int start;

  /**
   * The end offset in the buffer.
   */
  protected int end;

  /**
   * The current scanner state, as a representative token type.
   */
  protected int state = WHITESPACE;

  // The array of tokens forms a gap buffer. The total length of the text is
  // tracked, and tokens after the gap have (negative) positions relative to
  // the end of the text. While scanning, the gap represents the area to be
  // scanned, no tokens after the gap can be taken as valid, and in particular
  // the end-of-text sentinel token is after the gap.

  private Token[] tokens;

  private int gap, endgap, textLength;

  private boolean scanning;

  private int position;

  /**
   * The symbol table can be accessed by <code>initSymbolTable</code> or
   * <code>lookup</code>, if they are overridden. Symbols are inserted with
   * <code>symbolTable.put(sym,sym)</code> and extracted with
   * <code>symbolTable.get(sym)</code>.
   */
  protected HashMap<Symbol,Symbol> symbolTable;

  /**
   * Create a new Scanner representing an empty text document. For
   * non-incremental scanning, use change() to report the document size, then
   * pass the entire text to the scan() method in one go, or if coming from an
   * input stream, a bufferful at a time.
   */
  public Scanner() {
    tokens = new Token[1];
    gap = 0;
    endgap = 0;
    textLength = 0;
    symbolTable = new HashMap<Symbol,Symbol>();
    initSymbolTable();
    Symbol endOfText = new Symbol(WHITESPACE, "");
    tokens[0] = new Token(endOfText, 0);
    scanning = false;
    position = 0;
  }

  // Move the gap to a new index within the tokens array. When preparing to
  // pass a token back to a caller, this is used to ensure that the token's
  // position is relative to the start of the text and not the end.

  private void moveGap(int newgap) {
    if (scanning)
      throw new Error("moveGap called while scanning");
    if (newgap < 0 || newgap > gap + tokens.length - endgap) {
      throw new Error("bad argument to moveGap");
    }
    if (gap < newgap) {
      while (gap < newgap) {
        tokens[endgap].position += textLength;
        tokens[gap++] = tokens[endgap++];
      }
    } else if (gap > newgap) {
      while (gap > newgap) {
        tokens[--endgap] = tokens[--gap];
        tokens[endgap].position -= textLength;
      }
    }
  }

  /**
   * Find the number of available valid tokens, not counting tokens in or after
   * any area yet to be rescanned.
   */
  public int size() {
    if (scanning) {
      return gap;
    }
    return gap + tokens.length - endgap;
  }

  /**
   * Find the n'th token, or null if it is not currently valid.
   */
  public Token getToken(int n) {
    if (n < 0 || n >= gap && scanning)
      return null;
    if (n >= gap)
      moveGap(n + 1);
    return tokens[n];
  }

  /**
   * Find the index of the valid token starting before, but nearest to, text
   * position p. This uses an O(log(n)) binary chop search.
   */
  public int find(int p) {
    int start = 0, end, mid, midpos;
    if (!scanning)
      moveGap(gap + tokens.length - endgap);
    end = gap - 1;
    if (p > tokens[end].position)
      return end;
    while (end > start + 1) {
      mid = (start + end) / 2;
      midpos = tokens[mid].position;
      if (p > midpos) {
        start = mid;
      } else {
        end = mid;
      }
    }
    return start;
  }

  /**
   * Report the position of an edit, the length of the text being replaced, and
   * the length of the replacement text, to prepare for rescanning. The call
   * returns the index of the token at which rescanning will start.
   */
  public int change(int start, int len, int newLen) {
    if (start < 0 || len < 0 || newLen < 0 || start + len > textLength) {
      throw new Error("change(" + start + "," + len + "," + newLen + ")");
    }
    textLength += newLen - len;
    int end = start + newLen;
    if (scanning) {
      while (gap > 0 && tokens[gap - 1].position > start)
        gap--;
      if (gap > 0)
        gap--;
      if (gap > 0) {
        gap--;
        position = tokens[gap].position;
        state = tokens[gap].symbol.type;
      } else {
        position = 0;
        state = WHITESPACE;
      }
      while (tokens[endgap].position + textLength < end)
        endgap++;
      return gap;
    }
    if (endgap == tokens.length)
      moveGap(gap - 1);
    scanning = true;
    while (tokens[endgap].position + textLength < start) {
      tokens[endgap].position += textLength;
      tokens[gap++] = tokens[endgap++];
    }
    while (gap > 0 && tokens[gap - 1].position > start) {
      tokens[--endgap] = tokens[--gap];
      tokens[endgap].position -= textLength;
    }
    if (gap > 0)
      gap--;
    if (gap > 0) {
      gap--;
      position = tokens[gap].position;
      state = tokens[gap].symbol.type;
    } else {
      position = 0;
      state = WHITESPACE;
    }
    while (tokens[endgap].position + textLength < end)
      endgap++;
    return gap;
  }

  /**
   * Find out at what text position any remaining scanning work should start, or
   * -1 if scanning is complete.
   */
  public int position() {
    if (!scanning) {
      return -1;
    }
    return position;
  }

  /**
   * Create the initial symbol table. This can be overridden to enter keywords,
   * for example. The default implementation does nothing.
   */
  protected void initSymbolTable() {
    // Nothing as default
  }

  // Reuse this symbol object to create each new symbol, then look it up in
  // the symbol table, to replace it by a shared version to minimize space.

  private Symbol symbol = new Symbol(0, null);

  /**
   * Lookup a symbol in the symbol table. This can be overridden to implement
   * keyword detection, for example. The default implementation just uses the
   * table to ensure that there is only one shared occurrence of each symbol.
   */
  protected Symbol lookup(int type, String name) {
    symbol.type = type;
    symbol.name = name;
    Symbol sym = symbolTable.get(symbol);
    if (sym != null) {
      return sym;
    }
    sym = new Symbol(type, name);
    symbolTable.put(sym, sym);
    return sym;
  }

  /**
   * Scan or rescan a given read-only segment of text. The segment is assumed to
   * represent a portion of the document starting at <code>position()</code>.
   * Return the number of tokens successfully scanned, excluding any partial
   * token at the end of the text segment but not at the end of the document. If
   * the result is 0, the call should be retried with a longer segment.
   */
  public int scan(char[] array, int offset, int length) {
    if (!scanning)
      throw new Error("scan called when not scanning");
    if (position + length > textLength)
      throw new Error("scan too much");
    boolean all = position + length == textLength;
    end = start + length;
    int startGap = gap;

    buffer = array;
    start = offset;
    end = start + length;
    while (start < end) {
      int tokenStart = start;
      int type = read();
      if (start == end && !all)
        break;

      if (type != WHITESPACE) {
        String name = new String(buffer, tokenStart, start - tokenStart);
        Symbol sym = lookup(type, name);
        Token t = new Token(sym, position);
        if (gap >= endgap)
          checkCapacity(gap + tokens.length - endgap + 1);
        tokens[gap++] = t;
      }

      // Try to synchronise

      while (tokens[endgap].position + textLength < position)
        endgap++;
      if (position + start - tokenStart == textLength)
        scanning = false;
      else if (gap > 0 && tokens[endgap].position + textLength == position
          && tokens[endgap].symbol.type == type) {
        endgap++;
        scanning = false;
        break;
      }
      position += start - tokenStart;
    }
    checkCapacity(gap + tokens.length - endgap);
    return gap - startGap;
  }

  // Change the size of the gap buffer, doubling it if it fills up, and
  // halving if it becomes less than a quarter full.

  private void checkCapacity(int capacity) {
    int oldCapacity = tokens.length;
    if (capacity <= oldCapacity && 4 * capacity >= oldCapacity)
      return;
    Token[] oldTokens = tokens;
    int newCapacity;
    if (capacity > oldCapacity) {
      newCapacity = oldCapacity * 2;
      if (newCapacity < capacity)
        newCapacity = capacity;
    } else
      newCapacity = capacity * 2;

    tokens = new Token[newCapacity];
    System.arraycopy(oldTokens, 0, tokens, 0, gap);
    int n = oldCapacity - endgap;
    System.arraycopy(oldTokens, endgap, tokens, newCapacity - n, n);
    endgap = newCapacity - n;
  }

  void print() {
    for (int i = 0; i < tokens.length; i++) {
      if (i >= gap && i < endgap)
        continue;
      if (i == endgap)
        System.out.print("... ");
      System.out.print("" + i + ":" + tokens[i].position);
      System.out.print("-"
          + (tokens[i].position + tokens[i].symbol.name.length()));
      System.out.print(" ");
    }
    System.out.println();
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/LineNumberedBorder.java`:

```java
package se.sics.mspsim.extutil.highlight;
import java.awt.Color;
import java.awt.Component;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Insets;

import javax.swing.border.AbstractBorder;

/**
 * Draws line numbers next to each line, in the same font as the text.
 * Currently, this can only be used with a <tt>SyntaxHighlighter</tt> , since it
 * relies on the <tt>getRows()</tt> and <tt>getLineCount()</tt> methods. A
 * possible extension, create an interface to return this rows/linecount.
 * 
 * @author Paul Durbin (McDurby@yahoo.com)
 * @created January 29, 2002
 */
public class LineNumberedBorder extends AbstractBorder {

  private static final long serialVersionUID = -3812536735962506061L;

  /**
   * The line numbers should be drawn on the left side of the component.
   */
  public static int LEFT_SIDE = -2;

  /**
   * The line numbers should be drawn on the right side of the component.
   */
  public static int RIGHT_SIDE = -1;

  /**
   * The line number should be right justified.
   */
  public static int RIGHT_JUSTIFY = 0;

  /**
   * The line number should be left justified.
   */
  public static int LEFT_JUSTIFY = 1;

  /**
   * Indicates the justification of the text of the line number.
   */
  private int lineNumberJustification = RIGHT_JUSTIFY;

  /**
   * Indicates the location of the line numbers, w.r.t. the component.
   */
  private int location = LEFT_SIDE;

  private Color separatorColor = null;

  public LineNumberedBorder(int location, int justify) {
    setLocation(location);
    setLineNumberJustification(justify);
  }

  public Insets getBorderInsets(Component c) {
    return getBorderInsets(c, new Insets(0, 0, 0, 0));
  }

  /**
   * This modifies the insets, by adding space for the line number on the left.
   * Should be modified to add space on the right, depending upon Locale.
   * 
   * @param c
   *                Description of the Parameter
   * @param insets
   *                Description of the Parameter
   * @return The borderInsets value
   */
  public Insets getBorderInsets(Component c, Insets insets) {
    // if c is not a SyntaxHighlighter...nothing is done...
    if (c instanceof SyntaxHighlighter) {
      int width = lineNumberWidth((SyntaxHighlighter) c);
      if (location == LEFT_SIDE) {
        insets.left = width;
      } else {
        insets.right = width;
      }
    }
    return insets;
  }

  public int getLineNumberJustification() {
    return lineNumberJustification;
  }

  public void setLineNumberJustification(int justify) {
    if (justify == RIGHT_JUSTIFY || justify == LEFT_JUSTIFY) {
      lineNumberJustification = justify;
    }
  }

  public int getLocation() {
    return location;
  }

  public void setLocation(int loc) {
    if (loc == RIGHT_SIDE || loc == LEFT_SIDE) {
      location = loc;
    }
  }

  public Color getSeparatorColor() {
    return separatorColor;
  }

  public void setSeparatorColor(Color c) {
    this.separatorColor = c;
  }

  /**
   * Returns the width, in pixels, of the maximum line number, plus a trailing
   * space.
   * 
   * @param textArea
   *                Description of the Parameter
   * @return Description of the Return Value
   */
  private int lineNumberWidth(SyntaxHighlighter textArea) {
    //
    // note: should this be changed to use all nines for the lineCount?
    // for example, if the number of rows is 111...999 could be wider
    // (in pixels) in a proportionally spaced font...
    //
    int lineCount = Math.max(textArea.getRows(), textArea.getLineCount() + 1);
    return textArea.getFontMetrics(textArea.getFont()).stringWidth(
        lineCount + " ");
  }

  //
  // NOTE: This method is called every time the cursor blinks...
  // so...optimize (later and if possible) for speed...
  //
  public void paintBorder(Component c, Graphics g, int x, int y, int width,
      int height) {

    java.awt.Rectangle clip = g.getClipBounds();

    FontMetrics fm = g.getFontMetrics();
    int fontHeight = fm.getHeight();

    // starting location at the "top" of the page...
    // y is the starting baseline for the font...
    // should "font leading" be applied?
    int ybaseline = y + fm.getAscent();

    //
    // now determine if it is the "top" of the page...or somewhere else
    //
    int startingLineNumber = (clip.y / fontHeight) + 1;

    //
    // use any one of the following if's:
    //
    // if (startingLineNumber != 1)
    if (ybaseline < clip.y) {
      //
      // not within the clip rectangle...move it...
      // determine how many fontHeight's there are between
      // y and clip.y...then add that many fontHeights
      //
      ybaseline =
          y + startingLineNumber * fontHeight - (fontHeight - fm.getAscent());
    }

    //
    // options:
    // . write the number rows in the document (current)
    // . write the number of existing lines in the document (to do)
    // see getLineCount()
    //

    // determine which the "drawing" should end...
    // add fontHeight: make sure...part of the line number is drawn
    //
    // could also do this by determining what the last line
    // number to draw.
    // then the "while" loop whould change accordingly.
    //
    // int yend = y + clip.height + fontHeight;
    // int yend = ybaseline + height + fontHeight; // original
    int yend = ybaseline + height;
    if (yend > (y + height)) {
      yend = y + height;
    }

    SyntaxHighlighter jta = (SyntaxHighlighter) c;
    int lineWidth = lineNumberWidth(jta);

    // base x position of the line number
    int lnxstart = x;
    if (location == LEFT_SIDE) {
      // x (LEFT) or (x + lineWidth) (RIGHT)
      // (depends upon justification)
      if (lineNumberJustification == LEFT_JUSTIFY) {
        lnxstart = x;
      } else {
        // RIGHT JUSTIFY
        lnxstart = x + lineWidth;
      }
    } else {
      // RIGHT SIDE
      // (y + width) - lineWidth (LEFT) or (y + width) (RIGHT)
      // (depends upon justification)
      if (lineNumberJustification == LEFT_JUSTIFY) {
        lnxstart = (y + width) - lineWidth;
      } else {
        // RIGHT JUSTIFY
        lnxstart = (y + width);
      }
    }

    g.setColor(c.getForeground());
    //
    // loop until out of the "visible" region...
    //
    int length =
        ("" + Math.max(jta.getRows(), jta.getLineCount() + 1)).length();
    while (ybaseline < yend) {
      //
      // options:
      // . left justify the line numbers
      // . right justify the line numbers
      //

      if (lineNumberJustification == LEFT_JUSTIFY) {
        g.drawString(startingLineNumber + " ", lnxstart, ybaseline);
      } else {
        // right justify
        String label = padLabel(startingLineNumber, length, true);
        g.drawString(label, lnxstart - fm.stringWidth(label), ybaseline);
      }

      ybaseline += fontHeight;
      startingLineNumber++;
    }
    if (separatorColor != null) {
      g.setColor(separatorColor);
      if (location == LEFT_SIDE) {
        lnxstart = x + lineWidth - 1;
      } else {
        lnxstart = width - lineWidth;
      }
      g.drawLine(lnxstart, 0, lnxstart, height);
    }
  }

  // paintComponent

  /**
   * Create the string for the line number. NOTE: The <tt>length</tt> param
   * does not include the <em>optional</em> space added after the line number.
   * 
   * @param lineNumber
   *                to stringize
   * @param length
   *                the length desired of the string
   * @param addSpace
   *                Description of the Parameter
   * @return the line number for drawing
   */
  private static String padLabel(int lineNumber, int length, boolean addSpace) {
    StringBuilder buffer = new StringBuilder();
    buffer.append(lineNumber);
    for (int count = (length - buffer.length()); count > 0; count--) {
      buffer.insert(0, ' ');
    }
    if (addSpace) {
      buffer.append(' ');
    }
    return buffer.toString();
  }
}
// LineNumberedBorder

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/Scan.java`:

```java
package se.sics.mspsim.extutil.highlight;
// Illustrate the use of the scanner by reading in a file and displaying its
// tokens. Public domain, no restrictions, Ian Holyer, University of Bristol.

import java.io.*;

public class Scan {
  // Get the filename from the command line
  public static void main(String[] args) throws IOException {
    Scan program = new Scan();
    if (args.length != 1) {
      System.out.println("Usage: java Scan filename");
    } else {
      program.scan(args[0]);
    }
  }

  // Scan each line in turn
  public void scan(String filename) throws IOException {
    File file = new File(filename);
    int len = (int) file.length();
    char[] buffer = new char[len];
    Reader in = new FileReader(file);
    in.read(buffer);
    in.close();

    Scanner scanner = new Scanner();
    scanner.change(0, 0, len);
    scanner.scan(buffer, 0, len);

    for (int i = 0; i < scanner.size(); i++) {
      Token t = scanner.getToken(i);
      System.out.print("" + t.position);
      System.out.print(": " + t.symbol.name);
      System.out.println(" " + TokenTypes.typeNames[t.symbol.type]);
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/Token.java`:

```java
package se.sics.mspsim.extutil.highlight;
// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * A token represents a smallest meaningful fragment of text, such as a word,
 * recognised by a scanner.
 */
public class Token {
  /**
   * The symbol contains all the properties shared with similar tokens.
   */
  public Symbol symbol;

  /**
   * The token's position is given by an index into the document text.
   */
  public int position;

  /**
   * Create a token with a given symbol and position.
   */
  public Token(Symbol symbol, int position) {
    this.symbol = symbol;
    this.position = position;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/SyntaxHighlighter.java`:

```java
package se.sics.mspsim.extutil.highlight;
import java.awt.*;
import javax.swing.*;
import javax.swing.text.*;
import javax.swing.event.*;
import java.awt.geom.Rectangle2D;
import java.io.*;

// Public domain, no restrictions, Ian Holyer, University of Bristol.

/**
 * Display text with syntax highlighting. Highlighting is done with full
 * accuracy, using a given language scanner. Large amounts of re-highlighting
 * are done in small bursts to make sure the user interface doesn't freeze.
 */
public class SyntaxHighlighter extends JTextPane implements DocumentListener, TokenTypes {


  private static final long serialVersionUID = -1801145479677890566L;

  private StyledDocument doc;
  private Scanner scanner;
  private int rows, columns;

  private int currentY, currentHeight = -1;

  /**
   * Create a graphics component which displays text with syntax highlighting.
   * Provide a rows and columns, in characters, and a language scanner.
   */
  public SyntaxHighlighter(int rows, int columns, Scanner scanner) {
    super(new DefaultStyledDocument());
    doc = (StyledDocument) getDocument();
    this.rows = rows;
    this.columns = columns;
    this.scanner = scanner;
    doc.addDocumentListener(this);
    Font font = new Font("Monospaced", Font.PLAIN, getFont().getSize());
    changeFont(font);
    initStyles();

    // Quick fix to highlight selected line
    addCaretListener(new CaretListener() {

      public void caretUpdate(CaretEvent e) {
        int caret = getCaretPosition();
        if (caret >= 0) {
          try {
            Rectangle2D r = getUI().modelToView2D(SyntaxHighlighter.this, caret, Position.Bias.Forward);
            if (currentHeight > 0) {
              repaint(0, currentY, getWidth(), currentHeight);
            }
            if (r != null && r.getHeight() > 0) {
              currentY = (int) r.getY();
              currentHeight = (int) r.getHeight();
              repaint(0, currentY, getWidth(), currentHeight);
            } else {
              currentHeight = -1;
            }

          } catch (BadLocationException e1) {
            // Ignore
          }
        }
      }

    });

    setOpaque(false);

  }

  public int getColumns() {
    return columns;
  }

  public int getRows() {
    return rows;
  }

  /**
   * Change the component's font, and change the size of the component to match.
   */
  public void changeFont(Font font) {
    int borderOfJTextPane = 3;
    setFont(font);
    FontMetrics metrics = getFontMetrics(font);
    int paneWidth = columns * metrics.charWidth('m') + 2 * borderOfJTextPane;
    int paneHeight = rows * metrics.getHeight() + 2 * borderOfJTextPane;
    Dimension size = new Dimension(paneWidth, paneHeight);
    setMinimumSize(size);
    setPreferredSize(size);
    invalidate();
  }

  /**
   * Read new text into the component from a <code>Reader</code>. Overrides
   * <code>read</code> in <code>JTextComponent</code> in order to highlight
   * the new text.
   */
  public void read(Reader in, Object desc) throws IOException {
    int oldLength = getDocument().getLength();
    doc.removeDocumentListener(this);
    super.read(in, desc);
    doc = (StyledDocument) getDocument();
    doc.addDocumentListener(this);
    int newLength = getDocument().getLength();
    firstRehighlightToken = scanner.change(0, oldLength, newLength);
    repaint();
  }

  // An array of styles, indexed by token type. Default styles are set up,
  // which can be used for any languages.

  private Style[] styles;

  private void initStyles() {
    styles = new Style[typeNames.length];
    changeStyle(UNRECOGNIZED, Color.black);
    changeStyle(WHITESPACE, Color.black);
    changeStyle(WORD, Color.black);
    changeStyle(NUMBER, Color.black);
    changeStyle(PUNCTUATION, Color.blue);
    changeStyle(COMMENT, new Color(178,34,34), Font.ITALIC);
    changeStyle(START_COMMENT, new Color(178,34,34), Font.ITALIC);
    changeStyle(MID_COMMENT, new Color(178,34,34), Font.ITALIC);
    changeStyle(END_COMMENT, new Color(178,34,34), Font.ITALIC);
    changeStyle(TAG, Color.blue, Font.BOLD);
    changeStyle(END_TAG, Color.blue, Font.BOLD);
    changeStyle(KEYWORD, new Color(160,32,240));
    changeStyle(KEYWORD2, new Color(160,32,240));
    changeStyle(IDENTIFIER, Color.black);
    changeStyle(LITERAL, Color.green.darker());
    changeStyle(STRING, new Color(188,143,143));
    changeStyle(CHARACTER, new Color(188,143,143));
    changeStyle(OPERATOR, Color.black, Font.BOLD);
    changeStyle(BRACKET, Color.black);
    changeStyle(SEPARATOR, Color.black);
    changeStyle(URL, Color.blue.darker());

    for (int i = 0; i < styles.length; i++) {
      if (styles[i] == null) {
        styles[i] = styles[WHITESPACE];
      }
    }
  }

  /**
   * Change the style of a particular type of token.
   */
  public void changeStyle(int type, Color color) {
    Style style = addStyle(typeNames[type], null);
    StyleConstants.setForeground(style, color);
    styles[type] = style;
  }

  /**
   * Change the style of a particular type of token, including adding bold or
   * italic using a third argument of <code>Font.BOLD</code> or
   * <code>Font.ITALIC</code> or the bitwise union
   * <code>Font.BOLD|Font.ITALIC</code>.
   */
  public void changeStyle(int type, Color color, int fontStyle) {
    Style style = addStyle(typeNames[type], null);
    StyleConstants.setForeground(style, color);
    if ((fontStyle & Font.BOLD) != 0)
      StyleConstants.setBold(style, true);
    if ((fontStyle & Font.ITALIC) != 0)
      StyleConstants.setItalic(style, true);
    styles[type] = style;
  }

  public int getLineCount() {
    return getDocument().getDefaultRootElement().getElementCount();
  }

  public int getLineStartOffset(int line) {
    Element root = getDocument().getDefaultRootElement();
    if (line < 0 || line >= root.getElementCount()) {
      throw new IndexOutOfBoundsException("illegal line");
    }
    return root.getElement(line).getStartOffset();
  }

  public int getLineEndOffset(int line) {
    Element root = getDocument().getDefaultRootElement();
    if (line < 0 || line >= root.getElementCount()) {
      throw new IndexOutOfBoundsException("illegal line");
    }
    return root.getElement(line).getEndOffset();
  }


  /**
   * <font style='color:gray;'>Ignore this method. Responds to the underlying
   * document changes by re-highlighting.</font>
   */
  public void insertUpdate(DocumentEvent e) {
    int offset = e.getOffset();
    int length = e.getLength();
    firstRehighlightToken = scanner.change(offset, 0, length);
    repaint();
  }

  /**
   * <font style='color:gray;'>Ignore this method. Responds to the underlying
   * document changes by re-highlighting.</font>
   */
  public void removeUpdate(DocumentEvent e) {
    int offset = e.getOffset();
    int length = e.getLength();
    firstRehighlightToken = scanner.change(offset, length, 0);
    repaint();
  }

  /**
   * <font style='color:gray;'>Ignore this method. Responds to the underlying
   * document changes by re-highlighting.</font>
   */
  public void changedUpdate(DocumentEvent e) {
    // Do nothing.
  }

  // Scan a small portion of the document. If more is needed, call repaint()
  // so the GUI gets a go and doesn't freeze, but calls this again later.

  private Segment text = new Segment();

  private int firstRehighlightToken;

  private int smallAmount = 100;

  private Color highlightColor = new Color(0, 240, 0, 255);

  /**
   * <font style='color:gray;'>Ignore this method. Carries out a small amount of
   * re-highlighting for each call to <code>repaint</code>.</font>
   */
  protected void paintComponent(Graphics g) {
    if (currentHeight > 0) {
      g.setColor(highlightColor);
      g.fillRect(0, currentY, getWidth(), currentHeight);
    }

    super.paintComponent(g);


    int offset = scanner.position();
    if (offset < 0)
      return;

    int tokensToRedo = 0;
    int amount = smallAmount;
    while (tokensToRedo == 0 && offset >= 0) {
      int length = doc.getLength() - offset;
      if (length > amount) {
        length = amount;
      }
      try {
        doc.getText(offset, length, text);
      } catch (BadLocationException e) {
        return;
      }
      tokensToRedo = scanner.scan(text.array, text.offset, text.count);
      offset = scanner.position();
      amount = 2 * amount;
    }
    for (int i = 0; i < tokensToRedo; i++) {
      Token t = scanner.getToken(firstRehighlightToken + i);
      int length = t.symbol.name.length();
      int type = t.symbol.type;
      if (type < 0) {
        type = UNRECOGNIZED;
      }
      doc.setCharacterAttributes(t.position, length, styles[type], false);
    }
    firstRehighlightToken += tokensToRedo;
    if (offset >= 0) {
      repaint(2);
    }
  }

  public void viewLine(int line) {
    if (line >= 0 && line < getLineCount()) {
      try {
        int pos = getLineStartOffset(line);

        // Quick fix to position the line somewhere in the center
        Rectangle2D r = getUI().modelToView2D(this, pos, Position.Bias.Forward);
        if (r != null && r.getHeight() > 0) {
          Rectangle vr = getVisibleRect();
          vr.y = (int) (r.getY() - vr.height / 2);
          if (vr.y < 0) {
            vr.y = 0;
          }
          scrollRectToVisible(vr);
        }

        setCaretPosition(pos);
      } catch (BadLocationException e1) {
        // Ignore
      }
    }
  }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/highlight/TextScanner.java`:

```java
package se.sics.mspsim.extutil.highlight;
// This does exactly the same job as the Scanner class, but uses a table driven
// scanner.  This illustrates how to extend the Scanner class, and how a
// generator might produce a table-driven scanner (though this one was written
// by hand).  Public domain, no restrictions, Ian Holyer, University of Bristol.

public class TextScanner extends Scanner {
  // Classify the 128 ASCII characters. Define a compact 'readable' form,
  // then expand into an array, using static initializer code. The 128 are:
  // .........tn..................... !"#$%&'()*+,-./0123456789:;<=>?
  // @ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~.

  static final String cs =
      "1111111112211111111111111111111127777774777774675555555555777777"
          + "7333333333333333333333333337777473333333333333333333333333377771";

  static final byte[] kinds = new byte[cs.length()];
  static {
    for (int i = 0; i < cs.length(); i++) {
      kinds[i] = (byte) (cs.charAt(i) - '0');
    }
  }

  // This state table has a row per scanner state, and a column per class of
  // character. Each entry is '-s' to mean accept the current character and
  // goto state s, or '+t' to mean end the token giving it type t. There is
  // no stack of states, or extra table to determine the next state after a
  // token is recognized, as there could be with more sophisticated scanners.
  // The raw numbers +t must use or match the constants in TokenTypes.

  int[][] table = {
  // $ \0 \n z '-_ 9 . ( // $ = end of text, must be column 0
      { +1, -1, -2, -3, -4, -5, -4, -4 }, // s=0: start token
      { +1, +1, +1, +1, +1, +1, +1, +1 }, // s=1: illegal character (t=1)
      { +0, +0, -2, +0, +0, +0, +0, +0 }, // s=2: whitespace (t=0)
      { +2, +2, +2, -3, -3, -3, +2, +2 }, // s=3: word (t=2)
      { +4, +4, +4, +4, +4, +4, +4, +4 }, // s=4: punctuation (t=4)
      { +3, +3, +3, +3, +3, -5, -5, +3 } // s=5: number (t=3)
      };

  // Now all we have to do is to override read(), using the parent variables
  // buffer, start, end, state.

  protected int read() {
    state = 0;
    int kind = kinds[buffer[start]];
    int type;
    while (true) {
      type = table[state][kind];
      if (type >= 0)
        break;
      state = -type;
      start++;
      if (start >= end)
        kind = 0;
      else
        kind = kinds[buffer[start]];
    }
    state = WHITESPACE;
    return type;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/jfreechart/DataSourceSampler.java`:

```java
package se.sics.mspsim.extutil.jfreechart;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Date;

import javax.swing.Timer;

import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;

import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.util.DataSource;

public class DataSourceSampler implements ActionListener {

  private MSP430Core cpu;
  private int interval = 100;
  private Timer timer;
  private ArrayList<TimeSource> sources = new ArrayList<TimeSource>();

  public DataSourceSampler(MSP430Core cpu) {
    this.cpu = cpu;
    timer = new Timer(interval, this);
    timer.start();
  }

  public void stop() {
      timer.stop();
  }
  
  public void start() {
      timer.start();
  }
  
  public TimeSource addDataSource(DataSource source, TimeSeries ts) {
    TimeSource times = new TimeSource(cpu, source, ts);
    sources.add(times);
    return times;
  }
  
  public void removeDataSource(TimeSource source) {
    sources.remove(source);
  }
  
  public void setInterval(int intMsek) {
    interval = intMsek;
    timer.setDelay(interval);
  }

  private void sampleAll() {
    if (sources.size() > 0) {
      TimeSource[] srcs = (TimeSource[]) sources.toArray(new TimeSource[0]);
      for (int i = 0; i < srcs.length; i++) {
        if (srcs[i] != null)
          srcs[i].update();
      }
    }
    
//    test.add(new Millisecond(), Math.random() * 100);
//    test2.add(new Millisecond(), Math.random() * 100);
  }

  public void actionPerformed(ActionEvent arg0) {
    sampleAll();
  }
    
  private static class TimeSource {

    private MSP430Core cpu;
    private DataSource dataSource;
    private TimeSeries timeSeries;
    private long lastUpdate;

    TimeSource(MSP430Core cpu, DataSource ds, TimeSeries ts) {
      this.cpu = cpu;
      dataSource = ds;
      timeSeries = ts;
    }
    
    public void update() {
      long time = cpu.cycles / 2;
      if (time > lastUpdate) {
        lastUpdate = time;
        timeSeries.add(new Millisecond(new Date(time)), dataSource.getValue());
      } else {
//        System.out.println("IGNORING TIME " + time);
      }
    }
    
  }
  
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/jfreechart/DataChart.java`:

```java
package se.sics.mspsim.extutil.jfreechart;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JPanel;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.DateAxis;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.DefaultXYItemRenderer;
import org.jfree.data.time.Millisecond;
import org.jfree.data.time.TimeSeries;
import org.jfree.data.time.TimeSeriesCollection;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.ui.ManagedWindow;
import se.sics.mspsim.ui.WindowManager;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.DataSource;
import se.sics.mspsim.util.ServiceComponent;
import se.sics.mspsim.util.StackMonitor;
import se.sics.mspsim.util.ServiceComponent.Status;

@SuppressWarnings("serial")
public class DataChart extends JPanel implements ServiceComponent {

  private enum Mode {NONE, STACK, DUTY};
  private Mode mode = Mode.NONE;
  
  private TimeSeriesCollection dataset;
  private ComponentRegistry registry;
  private ManagedWindow jw;
  private MSP430 cpu;
  private DataSourceSampler dss;
  private Status status = Status.STOPPED;
  private String name = null;
  
  public DataChart(ComponentRegistry registry, String title, String yaxis) {
    DateAxis domain = new DateAxis("Time");
    NumberAxis range = new NumberAxis(yaxis);
    XYPlot xyplot = new XYPlot();
    xyplot.setDomainAxis(domain);
    xyplot.setRangeAxis(range);
 // xyplot.setBackgroundPaint(Color.black);
    xyplot.setDataset(dataset = new TimeSeriesCollection());

    DefaultXYItemRenderer renderer = new DefaultXYItemRenderer();
    renderer.setSeriesPaint(0, Color.red);
    renderer.setSeriesPaint(1, Color.green);
    renderer.setSeriesPaint(2, Color.blue);
    renderer.setSeriesPaint(3, Color.black);
//    renderer.setBaseStroke(
//        new BasicStroke(2f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL)
//    );
    renderer.setSeriesShapesVisible(0, false);
    renderer.setSeriesShapesVisible(1, false);
    renderer.setSeriesShapesVisible(2, false);
    renderer.setSeriesShapesVisible(3, false);
    xyplot.setRenderer(renderer);

    domain.setAutoRange(true);
    domain.setLowerMargin(0.0);
    domain.setUpperMargin(0.0);

    domain.setTickLabelsVisible(true);
    range.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
    JFreeChart chart = new JFreeChart(title,
        JFreeChart.DEFAULT_TITLE_FONT, xyplot, true);
    ChartPanel chartPanel = new ChartPanel(chart);
    setLayout(new BorderLayout());
    setPreferredSize(new Dimension(400, 200));
    add(chartPanel, BorderLayout.CENTER);
  }

  public void addTimeSeries(TimeSeries ts) {
    dataset.addSeries(ts);
  }

  private ManagedWindow openFrame(String name) {
    WindowManager wm = (WindowManager) registry.getComponent("windowManager");
      ManagedWindow jw = wm.createWindow(name);
    jw.add(this);
    return jw;
  }

  
  
  public void setupStackFrame(MSP430 cpu) {
    mode = Mode.STACK;
    this.cpu = cpu;
  }
  
  private void openStackFrame() {
      if (jw == null) {
          jw = openFrame("Stack Monitor");
          StackMonitor sm = new StackMonitor(cpu);
          DataSourceSampler dss = new DataSourceSampler(cpu);
          TimeSeries ts = new TimeSeries("Max Stack", Millisecond.class);
          ts.setMaximumItemCount(200);
          addTimeSeries(ts);
          dss.addDataSource(sm.getMaxSource(), ts);
          ts = new TimeSeries("Stack", Millisecond.class);
          ts.setMaximumItemCount(200);
          addTimeSeries(ts);
          dss.addDataSource(sm.getSource(), ts);
      }
  }

  public DataSourceSampler setupChipFrame(MSP430 cpu) {
      mode = Mode.DUTY;
      this.cpu = cpu;
      jw = openFrame("Duty-Cycle Monitor");
      dss = new DataSourceSampler(cpu);
      dss.setInterval(50);
      return dss;
  }

  public void addDataSource(DataSourceSampler dss, String name, DataSource src) {
    TimeSeries ts = new TimeSeries(name, Millisecond.class);
    ts.setMaximumItemCount(200);
    addTimeSeries(ts);
    dss.addDataSource(src, ts);
  }

  public Status getStatus() {
      return status;
  }

  public void init(String name, ComponentRegistry registry) {
      this.registry = registry;
      this.name = name;
  }

  public void start() {
      if (mode == Mode.STACK) {
          openStackFrame();
      } else {
          dss.start();
      }
      jw.setVisible(true);
      status = Status.STARTED;
  }

  public void stop() {
      jw.setVisible(false);
      if (mode == Mode.STACK) {
          // ?
      } else {
          dss.stop();
      }
      status = Status.STOPPED;
  }
  
  public String getName() {
      return name;
  }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/jfreechart/LineSampleChart.java`:

```java
package se.sics.mspsim.extutil.jfreechart;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JComponent;
import javax.swing.JPanel;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.DefaultXYItemRenderer;
import org.jfree.data.general.Series;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

public class LineSampleChart extends JFreeWindowDataHandler {

  private JPanel panel;
  private XYSeriesCollection dataset;
  private XYSeries dataSeries;
  private JFreeChart chart;
  private DefaultXYItemRenderer renderer;

  public LineSampleChart() {
    NumberAxis domain = new NumberAxis("Index");
    NumberAxis range = new NumberAxis("Value");
    XYPlot xyplot = new XYPlot();
    xyplot.setDomainAxis(domain);
    xyplot.setRangeAxis(range);
    // xyplot.setBackgroundPaint(Color.black);
    xyplot.setDataset(dataset = new XYSeriesCollection());

    renderer = new DefaultXYItemRenderer();
    renderer.setSeriesPaint(0, Color.black);
    renderer.setSeriesShapesVisible(0, false);
    xyplot.setRenderer(renderer);

    domain.setAutoRange(true);
    domain.setLowerMargin(0.0);
    domain.setUpperMargin(0.0);

    domain.setTickLabelsVisible(true);
    range.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
    chart = new JFreeChart("Test",
        JFreeChart.DEFAULT_TITLE_FONT, xyplot, true);
    ChartPanel chartPanel = new ChartPanel(chart);
    panel = new JPanel();
    panel.setLayout(new BorderLayout());
    panel.setPreferredSize(new Dimension(400, 200));
    panel.add(chartPanel, BorderLayout.CENTER);
    
    dataSeries = new XYSeries("-");
    dataSeries.setMaximumItemCount(200);
    dataset.addSeries(dataSeries);
  }
  
  public JComponent getComponent() {
    return panel;
  }

  public void lineRead(String line) {
    String parts[] = line.trim().split(" ");
    dataSeries.clear();
    for (int i = 0; i < parts.length; i++) {
      dataSeries.add(i, atod(parts[i], 0));
    }
    panel.repaint();
  }

  public void setProperty(String param, String[] args) {
    if ("title".equals(param)) {
      chart.setTitle(args[0]);
    }
  }

  public int getDataSeriesCount() {
    return 1;
  }

  public Series getDataSeries(int index) {
    return dataSeries;
  }

  @Override
  public void setProperty(int index, String param, String[] args) {
    super.setProperty(index, param, args);
    if ("color".equals(param)) {
      renderer.setSeriesPaint(index, Color.decode(args[0]));
      panel.repaint();
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/jfreechart/LineChart.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * LineChart
 *
 * Author  : Joakim Eriksson
 * Created : 17 apr 2008
 * Updated : $Date:$
 *           $Revision:$
 */
package se.sics.mspsim.extutil.jfreechart;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import javax.swing.JComponent;
import javax.swing.JPanel;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.DefaultXYItemRenderer;
import org.jfree.data.general.Series;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

/**
 * @author joakim
 *
 */
public class LineChart extends JFreeWindowDataHandler {

  private JPanel panel;
  private JFreeChart chart;
  private XYSeriesCollection dataset;
  private DefaultXYItemRenderer renderer = new DefaultXYItemRenderer();

  public LineChart() {
    NumberAxis domain = new NumberAxis("Time");
    NumberAxis range = new NumberAxis("Value");
    XYPlot xyplot = new XYPlot();
    xyplot.setDomainAxis(domain);
    xyplot.setRangeAxis(range);
    xyplot.setDataset(dataset = new XYSeriesCollection());
    xyplot.setRenderer(renderer);

    domain.setAutoRange(true);
    domain.setAutoRangeIncludesZero(false);
    domain.setLowerMargin(0.0);
    domain.setUpperMargin(0.0);
    domain.setTickLabelsVisible(true);
    range.setStandardTickUnits(NumberAxis.createIntegerTickUnits());
    chart = new JFreeChart("Data",  JFreeChart.DEFAULT_TITLE_FONT, xyplot, true);
    ChartPanel chartPanel = new ChartPanel(chart);
    panel = new JPanel();
    panel.setLayout(new BorderLayout());
    panel.setPreferredSize(new Dimension(400, 200));
    panel.add(chartPanel, BorderLayout.CENTER);
  }
 
  public JComponent getComponent() {
    return panel;
  }

  public int getDataSeriesCount() {
    return dataset.getSeriesCount();
  }

  public Series getDataSeries(int index) {
    while (index >= dataset.getSeriesCount()) {
      addSeries();
    }
    return dataset.getSeries(index);
  }

  public void setProperty(String param, String[] args) {
    if ("title".equals(param)) {
      chart.setTitle(args[0]);
    }
  }

  private void addSeries() {
    XYSeries dataSeries = new XYSeries("series " + (getDataSeriesCount() + 1));
    dataSeries.setMaximumItemCount(200);
//    renderer.setSeriesPaint(0, Color.black);
    renderer.setSeriesShapesVisible(getDataSeriesCount(), false);
    dataset.addSeries(dataSeries);
  }
  
  int point = 0;
  public void lineRead(String line) {
    String parts[] = line.trim().split(" ");
    while (parts.length > getDataSeriesCount()) {
      addSeries();
    }
    for (int i = 0; i < parts.length; i++) {
      dataset.getSeries(i).add(point, atod(parts[i], 0));
    }
    point++;
    panel.repaint();
  }
  
  @Override
  public void setProperty(int index, String param, String[] args) {
    super.setProperty(index, param, args);
    if ("color".equals(param)) {
      renderer.setSeriesPaint(index, Color.decode(args[0]));
      panel.repaint();
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/extutil/jfreechart/JFreeWindowDataHandler.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * JFreeWindowDataHandler
 *
 * Author  : Joakim Eriksson
 * Created : 18 apr 2008
 * Updated : $Date:$
 *           $Revision:$
 */
package se.sics.mspsim.extutil.jfreechart;

import org.jfree.data.general.Series;
import se.sics.mspsim.cli.AbstractWindowDataHandler;

/**
 * @author joakim
 *
 */
public abstract class JFreeWindowDataHandler extends AbstractWindowDataHandler {


  public abstract int getDataSeriesCount();
  public abstract Series getDataSeries(int index);
  
  /* (non-Javadoc)
   * @see se.sics.mspsim.cli.AbstractWindowDataHandler#setProperty(int, java.lang.String, java.lang.String[])
   */
  @Override
  public void setProperty(int index, String param, String[] args) {
    if (index > getDataSeriesCount()) {
      throw new IndexOutOfBoundsException("Illegal index: " + index);
    }
    if ("label".equals(param)) {
      getDataSeries(index).setKey(args[0]);
      getComponent().revalidate();
      getComponent().repaint();
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/profiler/SimpleProfiler.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SimpleProfiler
 *
 * Author  : Joakim Eriksson
 * Created : March 5, 2013
 */

package se.sics.mspsim.profiler;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.regex.Pattern;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.EventListener;
import se.sics.mspsim.core.EventSource;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.Profiler;
import se.sics.mspsim.profiler.CallEntry;
import se.sics.mspsim.profiler.CallEntry.CallCounter;
import se.sics.mspsim.util.ArrayUtils;
import se.sics.mspsim.util.MapEntry;
import se.sics.mspsim.util.StackMonitor;
import se.sics.mspsim.util.Utils;

public class SimpleProfiler implements Profiler, EventListener {
 
  private HashMap<MapEntry,CallEntry> profileData;
  private HashMap<String, TagEntry> tagProfiles;
  private HashMap<String, TagEntry> startTags;
  private HashMap<String, TagEntry> endTags;
  private HashMap<String, String> ignoreFunctions;
  private CallEntry[] callStack;
  private int cSP = 0;
  private MSP430Core cpu;
  private PrintStream logger;
  private boolean hideIRQ = false;

  private CallListener[] callListeners;

  /* statistics for interrupts */
  private long[] lastInterruptTime = new long[64];
  private long[] interruptTime = new long[64];
  private long[] interruptCount = new long[64];
  private int servicedInterrupt;
  private int interruptLevel;
  private int interruptFrom;
  private boolean newIRQ;

  private StackMonitor stackMonitor;
  
  public SimpleProfiler() {
    profileData = new HashMap<MapEntry, CallEntry>();
    tagProfiles = new HashMap<String, TagEntry>();
    startTags = new HashMap<String, TagEntry>();
    endTags = new HashMap<String, TagEntry>();
    ignoreFunctions = new HashMap<String, String>();
    callStack = new CallEntry[64];
    servicedInterrupt = -1;
  }

  public void setCPU(MSP430Core cpu) {
    this.cpu = cpu;
  }

  public void setStackMonitor(StackMonitor stackMonitor) {
      this.stackMonitor = stackMonitor;
  }

  public void setHideIRQ(boolean hide) {
    hideIRQ = hide;
  }
  
  public void addIgnoreFunction(String function) {
    ignoreFunctions.put(function, function);
  }
  
  public void profileCall(MapEntry entry, long cycles, int from) {
    if (cSP == callStack.length) {
      CallEntry[] tmp = new CallEntry[cSP + 64];
      System.arraycopy(callStack, 0, tmp, 0, cSP);
      callStack = tmp;
    }
    if (callStack[cSP] == null) {
      callStack[cSP] = new CallEntry();
    }

    int hide = 0;
    PrintStream logger = this.logger;
    if (logger != null) {
      /* hide this if last call was to be hidden */
      hide = (cSP == 0 || newIRQ) ? 0 : callStack[cSP - 1].hide;
      /* increase level of "hide" if last was hidden */
      if (hide > 0) hide++;
      if ((!hideIRQ || servicedInterrupt == -1) && hide == 0) {
        if (servicedInterrupt >= 0) logger.printf("[%2d] ", servicedInterrupt);
        printSpace(logger, (cSP - interruptLevel) * 2);
        logger.println("Call to $" + Utils.hex(entry.getAddress(), 4) +
                       ": " + entry.getInfo());
        if (ignoreFunctions.get(entry.getName()) != null) {
          hide = 1;
        }
      }
    }

    CallEntry ce = callStack[cSP++];
    ce.function = entry;
    ce.calls = 0;
    ce.cycles = cycles;
    ce.exclusiveCycles = cycles;
    ce.hide = hide;
    ce.fromPC = from;
    newIRQ = false;

    
    if (stackMonitor != null) {
        /* get the current stack MAX for previous function */
        if (cSP > 1) {
            callStack[cSP - 2].currentStackMax = stackMonitor.getProfStackMax();
        }
        /* start stack here! */
        ce.stackStart = stackMonitor.getStack();
        stackMonitor.setProfStackMax(stackMonitor.getStack());
    }

    CallListener[] listeners = callListeners;
    if (listeners != null) {
      for (int i = 0, n = listeners.length; i < n; i++) {
        listeners[i].functionCall(this, ce);
      }
    }
  }

  public void profileReturn(long cycles) {
    if (cSP <= 0) {
      /* the stack pointer might have been messed with? */
      PrintStream logger = this.logger;
      if (logger != null) {
          // logger.println("SimpleProfiler: Too many returns?");
      } else {
        // System.err.println("SimpleProfiler: Too many returns?");
      }
      return;
    }
    CallEntry cspEntry = callStack[--cSP];
    MapEntry fkn = cspEntry.function;
//     System.out.println("Profiler: return / call stack: " + cSP + ", " + fkn);
    
    long elapsed = cycles - cspEntry.cycles;
    long exElapsed = cycles - cspEntry.exclusiveCycles;
    if (cSP != 0) {
      callStack[cSP-1].exclusiveCycles += elapsed;
    }
    int maxUsage = 0;
    
    if (cspEntry.calls >= 0) {
      CallEntry ce = profileData.get(fkn);
      if (ce == null) {
        profileData.put(fkn, ce = new CallEntry());
        ce.function = fkn;
      }
      ce.cycles += elapsed;
      ce.exclusiveCycles += exElapsed;
      ce.calls++;
      
      if (stackMonitor != null) {
          maxUsage = stackMonitor.getProfStackMax() - cspEntry.stackStart;
          ce.stackStart = cspEntry.stackStart;
          if (maxUsage > ce.currentStackMax) {
              ce.currentStackMax = maxUsage;
          }
          if (cSP != 0) {
              /* put the max for previous function back into the max profiler */ 
              stackMonitor.setProfStackMax(callStack[cSP-1].currentStackMax);
          }
      }

      
      
      if (cSP != 0) {
        MapEntry caller = callStack[cSP-1].function;
        HashMap<MapEntry,CallCounter> callers = ce.callers;
        CallCounter numCalls = callers.get(caller);
        if (numCalls == null) {
          numCalls = new CallCounter();
          callers.put(caller, numCalls);
        }
        numCalls.count++;
      }

      PrintStream logger = this.logger;
      if (logger != null) {
        if ((cspEntry.hide <= 1) && (!hideIRQ || servicedInterrupt == -1)) {
          if (servicedInterrupt >= 0) logger.printf("[%2d] ",servicedInterrupt);
          printSpace(logger, (cSP - interruptLevel) * 2);
          logger.println("return from " + ce.function.getInfo() + " elapsed: " + elapsed + " maxStackUsage: " + maxUsage);
        }
      }

      CallListener[] listeners = callListeners;
      if (listeners != null) {
        for (int i = 0, n = listeners.length; i < n; i++) {
          listeners[i].functionReturn(this, cspEntry);
        }
      }
    }
    newIRQ = false;
  }

  public void profileInterrupt(int vector, long cycles) {
    servicedInterrupt = vector;
    interruptFrom = cpu.getPC(); 
    lastInterruptTime[servicedInterrupt] = cycles;
    interruptLevel = cSP;
    newIRQ = true;

    PrintStream logger = this.logger;
    if (logger != null && !hideIRQ) {
      logger.println("----- Interrupt vector " + vector + " start execution -----");
    }
  }
  
  public void profileRETI(long cycles) {
    if (servicedInterrupt > -1) {
      interruptTime[servicedInterrupt] += cycles - lastInterruptTime[servicedInterrupt];
      interruptCount[servicedInterrupt]++;
    }
    newIRQ = false;

    PrintStream logger = this.logger;
    if (logger != null && !hideIRQ) {
      logger.println("----- Interrupt vector " + servicedInterrupt + " returned - elapsed: " +
          (cycles - lastInterruptTime[servicedInterrupt]));
    }
    interruptLevel = 0;
    
    /* what if interrupt from interrupt ? */
    servicedInterrupt = -1;
  }

  public void resetProfile() {
    clearProfile();
    cSP = 0;
    servicedInterrupt = -1;
  }

  public void clearProfile() {
    if (profileData != null) {
      CallEntry[] entries =
        profileData.values().toArray(new CallEntry[profileData.size()]);
      for (int i = 0, n = entries.length; i < n; i++) {
        entries[i].cycles = 0;
        entries[i].calls = 0;
      }
      for (int i = 0, n = callStack.length; i < n; i++) {
        CallEntry e = callStack[i];
        if (e != null) {
          e.calls = -1;
        }
      }
    }
  }  

  public void printProfile(PrintStream out) {
    printProfile(out, new Properties());
  }

  public void printProfile(PrintStream out, Properties parameters) {
    String functionNameRegexp = parameters.getProperty(PARAM_FUNCTION_NAME_REGEXP);
    String profSort = parameters.getProperty(PARAM_SORT_MODE);
    boolean profCallers = parameters.getProperty(PARAM_PROFILE_CALLERS) != null;
    Pattern pattern = null;
    CallEntry[] entries = profileData.values().toArray(new CallEntry[profileData.size()]);

    Arrays.sort(entries, new CallEntryComparator(profSort));
    
    out.println("************************* Profile Data **************************************");
    out.println("Function                              Calls    Average       Total  Exclusive");

    if (functionNameRegexp != null && functionNameRegexp.length() > 0) {
      pattern = Pattern.compile(functionNameRegexp);
    }
    for (int i = 0, n = entries.length; i < n; i++) {
      int c = entries[i].calls;
      if (c > 0) {
        String functionName = entries[i].function.getName();
        if (pattern == null || pattern.matcher(functionName).find()) {
          String cyclesS = "" + entries[i].cycles;
          String exCyclesS = "" + entries[i].exclusiveCycles;
          String callS = "" + c;
          String avgS = "" + (c > 0 ? (entries[i].cycles / c) : 0);
          out.print(functionName);
          printSpace(out, 43 - functionName.length() - callS.length());
          out.print(callS);
          out.print(' ');
          printSpace(out, 10 - avgS.length());
          out.print(avgS);
          out.print(' ');
          printSpace(out, 11 - cyclesS.length());
          out.print(cyclesS);
          printSpace(out, 11 - exCyclesS.length());
          out.println(exCyclesS);
          if (profCallers) {
            printCallers(entries[i], out);
          }
        }
      }
    }
    if (pattern == null) {
      out.println("********** Profile IRQ **************************");
      out.println("Vector          Average    Calls  Tot.Cycles");
      for (int i = 0; i <= cpu.config.maxInterruptVector; i++) {
        out.print((i < 10 ? "0" : "") + i + "               ");
        out.printf("%4d ",(interruptCount[i] > 0 ? (interruptTime[i] / interruptCount[i]):0));
        out.printf("%8d   %8d",interruptCount[i],interruptTime[i]);
        out.println();
      }
    }
  }

  private void printCallers(CallEntry callEntry, PrintStream out) {
    HashMap<MapEntry,CallCounter> callers = callEntry.callers;
    List<Entry<MapEntry,CallCounter>> list = new ArrayList<Entry<MapEntry,CallCounter>>(callers.entrySet());
    Collections.sort(list, new Comparator<Entry<MapEntry,CallCounter>>() {
        public int compare(Entry<MapEntry,CallCounter> o1, Entry<MapEntry,CallCounter> o2) {
          return o2.getValue().compareTo(o1.getValue());
        }
    });
    for (Entry<MapEntry,CallCounter> entry : list) {
      String functionName = entry.getKey().getName();
      String callS = "" + entry.getValue().count;
      printSpace(out, 12 - callS.length());
      out.print(callS);
      printSpace(out, 2);
      out.print(functionName);
      out.println();
    }
  }

  private void printSpace(PrintStream out, int len) {
    for (int i = 0; i < len; i++) {
      out.print(' ');
    }
  }

  public void printStackTrace(PrintStream out) {
    int stackCount = cSP;
    out.println("Stack Trace: number of calls: " + stackCount
        + " PC: $" + Utils.hex(cpu.getPC(), 5));
    for (int i = 0; i < stackCount; i++) {
      CallEntry call = callStack[stackCount - i - 1];
      out.println("  " + call.function.getInfo()
          + " called from PC: $" + Utils.hex(call.fromPC, 5)
          + " (elapsed: " + (cpu.cpuCycles - call.cycles) + ')');
      if (stackCount - i - 1 == interruptLevel && servicedInterrupt != -1) {
        out.println(" *** Interrupt " + servicedInterrupt + " from PC: $" + Utils.hex(interruptFrom, 5));
      }
    }
  }

  private static class CallEntryComparator implements Comparator<CallEntry> {
    private int mode;
    
    public CallEntryComparator(String modeS) {
      if ("exclusive".equalsIgnoreCase(modeS)) {
        mode = 1;
      } else if ("calls".equalsIgnoreCase(modeS)) {
        mode = 2;
      } else if ("average".equalsIgnoreCase(modeS)) {
        mode = 3;
      } else if ("function".equalsIgnoreCase(modeS)) {
        mode = 4;
      } else {
        mode = 0;
      }
    }
    
    public int compare(CallEntry o1, CallEntry o2) {
      long diff;
      switch (mode) {
      case 1:
        diff = o2.exclusiveCycles - o1.exclusiveCycles;
        break;
      case 2:
        diff = o2.calls - o1.calls;
        break;
      case 3:
        diff = (o2.calls > 0 ? (o2.cycles / o2.calls) : 0) -
        (o1.calls > 0 ? (o1.cycles / o1.calls) : 0);
        break;
      case 4:
        return o1.function.getName().compareTo(o2.function.getName());
      default:
        diff = o2.cycles - o1.cycles;
      }
      if (diff > 0) return 1;
      if (diff < 0) return -1;
      return 0;
    }
  }
  

  private static class TagEntry implements Comparable<TagEntry> {
    public final String tag;
    long cycles;
    long lastCycles;
    int calls;

    public TagEntry(String tag) {
        this.tag = tag;
    }

    public int compareTo(TagEntry o) {
      long diff = o.cycles - cycles;
      if (diff > 0) return 1;
      if (diff < 0) return -1;
      return 0;
    }
  }

  
  
  public void setLogger(PrintStream out) {
    logger = out;
  }
  
  /* 
   * Tag profiling.
   */
  public void measureStart(String tag) {
    TagEntry tagEntry = tagProfiles.get(tag);
    if (tagEntry == null) {
      tagEntry = new TagEntry(tag);
      tagProfiles.put(tag, tagEntry);
    }
    /* only the first occurrence of event will set the lastCycles */
    if (tagEntry.lastCycles == 0) {
      tagEntry.lastCycles = cpu.cycles;
    }
  }
  
  public void measureEnd(String tag) {
    TagEntry tagEntry = tagProfiles.get(tag);
    if (tagEntry != null) {
      if (tagEntry.lastCycles != 0) {
        tagEntry.calls++;
        tagEntry.cycles += cpu.cycles - tagEntry.lastCycles;
        tagEntry.lastCycles = 0;
      }
    }
  }
  
  public void printTagProfile(PrintStream out) {
    TagEntry[] entries = tagProfiles.values().toArray(new TagEntry[tagProfiles.size()]);
    Arrays.sort(entries);
    for (TagEntry entry : entries) {
      out.println(entry.tag + "\t" + entry.calls + "\t" + entry.cycles);
    }
  }

  public void addProfileTag(String tag, Chip chip, String start,
      Chip chip2, String end) {
    System.out.println("Add profile: " + tag +
        " start: " + start + " end: " + end);
    TagEntry tagEntry = new TagEntry(tag);
    startTags.put(start, tagEntry);
    endTags.put(end, tagEntry);
    tagProfiles.put(tag, tagEntry);
    chip.addEventListener(this);
    chip2.addEventListener(this);
  }

  public void event(EventSource source, String event, Object data) {
    TagEntry tagEntry = null;
    if ((tagEntry = startTags.get(event)) != null) {
      /* only the first occurrence of event will set the lastCycles */
      if (tagEntry.lastCycles == 0) {
        tagEntry.lastCycles = cpu.cycles;
      }
    } else if ((tagEntry = endTags.get(event)) != null) {
      if (tagEntry.lastCycles != 0) {
        tagEntry.calls++;
        tagEntry.cycles += cpu.cycles - tagEntry.lastCycles;
        tagEntry.lastCycles = 0;
      }
    }
  }

  public synchronized void addCallListener(CallListener listener) {
    callListeners = ArrayUtils.add(CallListener.class, callListeners, listener);
  }

  public synchronized void removeCallListener(CallListener listener) {
    callListeners = ArrayUtils.remove(callListeners, listener);
  }

  public String getCall(int i) {
    return callStack[cSP - i - 1].function.getInfo();
  }

  public MapEntry getCallMapEntry(int i) {
    return callStack[cSP - i - 1].function;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/profiler/CallEntry.java`:

```java
package se.sics.mspsim.profiler;
import java.util.HashMap;
import se.sics.mspsim.util.MapEntry;

public class CallEntry {
    
    static class CallCounter implements Comparable<CallCounter> {
        public int count = 0;

        public int compareTo(CallCounter o) {
            return (count < o.count ? -1 : (count == o.count ? 0 : 1));
        }
    }

    
    int fromPC;
    MapEntry function;
    long cycles;
    long exclusiveCycles;
    int calls;
    int hide;
    int stackStart;
    int currentStackMax;
    
    HashMap<MapEntry,CallCounter> callers;
    
    public CallEntry() {
      callers = new HashMap<MapEntry,CallCounter>();
    }
    
    public MapEntry getFunction() {
        return function;
    }
  }

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/profiler/CallListener.java`:

```java
package se.sics.mspsim.profiler;
import se.sics.mspsim.core.Profiler;

public interface CallListener {

  public void functionCall(Profiler source,  CallEntry entry);

  public void functionReturn(Profiler source, CallEntry entry);

}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/RTC.java`:

```java
/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */
package se.sics.mspsim.core;

import java.util.Calendar;
import java.util.GregorianCalendar;

import se.sics.mspsim.core.EmulationLogger.WarningType;


/**
 * RTC module for the MSP430
 * 
 * TODO: alarm mode not implemented
 * 
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public class RTC extends IOUnit {

	/**
	 * Address and size for IO configuration
	 */
	public static final int OFFSET = 0x04A0;
	public static final int SIZE = 0x0001A;

	/**
	 * Interrupt vector
	 */
	public static final int RTC_VECTOR = 0x005C;

	/* Peripheral registers */
	private static final int RTCCTL01 = 0x0000;
	private static final int RTCCTL23 = 0x0002;
	private static final int RTCPS0CTL = 0x0008;
	private static final int RTCPS1CTL = 0x000A;
	private static final int RTCPS = 0x000C;
	private static final int RTCIV = 0x000E;
	private static final int RTCTIM0 = 0x0010;
	private static final int RTCTIM1 = 0x0012;
	private static final int RTCDATE = 0x0014;
	private static final int RTCYEAR = 0x0016;
	private static final int RTCAMINHR = 0x0018;
	private static final int RTCADOWDAY = 0x001A;

	/* RTCCTL01 Control Bits */
	private static final int RTCBCD = 0x8000;
	private static final int RTCHOLD = 0x4000;
	private static final int RTCMODE = 0x2000;
	private static final int RTCRDY = 0x1000;
	private static final int RTCTEVIE = 0x0040;
	private static final int RTCAIE = 0x0020;
	private static final int RTCRDYIE = 0x0010;
	private static final int RTCTEVIFG = 0x0004;
	private static final int RTCAIFG = 0x0002;
	private static final int RTCRDYIFG = 0x0001;

	private static final int RTCSSEL__ACLK = 0x0000;
	private static final int RTCSSEL__SMCLK = 0x0400;
	private static final int RTCSSEL__RT1PS = 0x0800;

	private static final int RTCOFIE = (1 << 7);
	private static final int RTCOFIFG = (1 << 3);
	private static final int RTCEVIFG = (1 << 2);

	/* Possible types of RTC */
	public static enum RtcType {
		TYPE_A, TYPE_D,
	}

	private RtcType type = RtcType.TYPE_A;
	private int rtcIntVector = RTC_VECTOR;

	/**
	 * RTC peripheral for the MSP430
	 * 
	 * @param cpu
	 *           CPU core
	 */
	public RTC(MSP430Core cpu, int offset, RtcType r, int intVector) {
		super("RTC", cpu, cpu.memory, offset);
		type = r;
		rtcIntVector = intVector;
		DEBUG = true;
		cal.setLenient(true);
	}

	/**
	 * Clear everything when reset
	 */
	public void reset(int type) {
		oscFaultInterruptEnable = false;
		eventInterruptEnable = false;
		alarmInterruptEnable = false;
		readyInterruptEnable = false;
		oscFaultInterruptFlag = false;
		eventInterruptFlag = false;
		alarmInterruptFlag = false;
		readyInterruptFlag = false;
	}

	/* RTCCTL0 */
	private boolean oscFaultInterruptEnable = false;
	private boolean eventInterruptEnable = false;
	private boolean alarmInterruptEnable = false;
	private boolean readyInterruptEnable = false;
	private boolean oscFaultInterruptFlag = false;
	private boolean eventInterruptFlag = false;
	private boolean alarmInterruptFlag = false;
	private boolean readyInterruptFlag = false;

	/**
	 * Get the CTLO (byte) register
	 * 
	 * @return
	 */
	private short getCTL0Reg() {
		short ctl0 = 0;
		ctl0 |= (oscFaultInterruptEnable ? 1 : 0) << 7;
		ctl0 |= (eventInterruptEnable ? 1 : 0) << 6;
		ctl0 |= (alarmInterruptEnable ? 1 : 0) << 5;
		ctl0 |= (readyInterruptEnable ? 1 : 0) << 4;
		ctl0 |= (oscFaultInterruptFlag ? 1 : 0) << 3;
		ctl0 |= (eventInterruptFlag ? 1 : 0) << 2;
		ctl0 |= (alarmInterruptFlag ? 1 : 0) << 1;
		ctl0 |= (readyInterruptFlag ? 1 : 0) << 0;
		return ctl0;
	}

	/**
	 * Get the CTL1 (byte) register
	 * 
	 * @return
	 */
	private short getCTL1Reg() {
		short ctl1 = 0;
		ctl1 |= (formatBCD ? 1 : 0) << 7;
		ctl1 |= (rtcHold ? 1 : 0) << 6;
		ctl1 |= (modeCalendar ? 1 : 0) << 5;
		ctl1 |= (rtcReady ? 1 : 0) << 4;
		ctl1 |= (clockSource & 0x3) << 2;
		ctl1 |= (rtcEvent & 0x3);
		return ctl1;
	}

	/**
	 * Get the CTL01 (word) register
	 * 
	 * @return
	 */
	private int getCTL01Reg() {
		return getCTL1Reg() << 8 | getCTL0Reg();
	}

	/* RTCCTL1 */
	private boolean formatBCD = false;
	private boolean rtcHold = true;
	private boolean modeCalendar = true;
	private boolean rtcReady = true;
	private int clockSource = 0;
	private int rtcEvent = 0;

	/**
	 * Handler of the 4 (byte) counter registers, for simplicity they can be
	 * collected in a single 32-bit variable.
	 */
	private long rtcCount = 0;

	/**
	 * Period to increment the counters
	 */
	private double period = osc32KHzMs;
	private static final float osc32KHzMs = 0.031f;

	private int preScaler0Src = 0;
	private int preScaler0Div = 0;
	private boolean preScaler0Hold = false;

	private int preScaler1Src = 0;
	private int preScaler1Div = 0;
	private boolean preScaler1Hold = false;

	private static final int RT0SSEL = 0x4000;
	private static final int RT0PSHOLD = 0x0100;
	private static final int RT0PSIE = 0x0002;
	private static final int RT0PSIFG = 0x0001;
	private static final int RT0IP = 0x001C;

	private static final int RT1SSEL = 0xC000;
	private static final int RT1PSHOLD = 0x0100;
	private static final int RT1PSIE = 0x0002;
	private static final int RT1PSIFG = 0x0001;
	private static final int RT1IP = 0x001C;

	private int getPS0CTL() {
		int ctl0 = 0;
		ctl0 |= (preScaler0Src & 0x01) << 14;
		ctl0 |= (preScaler0Div & 0x03) << 11;
		ctl0 |= (preScaler0Hold ? 1 : 0) << 8;
		return ctl0;
	}

	private int getPS1CTL() {
		int ctl1 = 0;
		ctl1 |= (preScaler1Src & 0x03) << 14;
		ctl1 |= (preScaler1Div & 0x03) << 11;
		ctl1 |= (preScaler1Hold ? 1 : 0) << 8;
		return ctl1;
	}

	/**
	 * In calendar mode, use a gregorian calendar
	 */
	private GregorianCalendar cal = new GregorianCalendar(0, 1, 1, 0, 0, 0);

	/**
	 * Timer to generate the interrupts and handle the calendar
	 */
	private TimeEvent rtcTimer = new TimeEvent(0) {

		public void execute(long t) {
			if (!rtcHold) {
				updateCounters();
				reSchedule();
			}
			if (getIV() > 0) {

				cpu.flagInterrupt(rtcIntVector, RTC.this, true);
			}
		}

		/**
		 * Re-Schedule the timer event
		 */
		private void reSchedule() {
			// cpu.scheduleTimeEventMillis(this, period);
			rtcInit();
		}

		/**
		 * Update the counters or the calendar, depending on the mode
		 */
		private void updateCounters() {
			if (modeCalendar) {
				/* In calendar mode it is updated every second */
				cal.add(Calendar.SECOND, 1);

				/* Track the changes */
				int sec = cal.get(Calendar.SECOND);
				int min = cal.get(Calendar.MINUTE);
				int hour = cal.get(Calendar.HOUR_OF_DAY);

				if (sec == 0) {
					if (rtcEvent == 0) { // minute
						generateInterrupt();
					} else if (rtcEvent == 1 && min == 0) { // hour
						generateInterrupt();
					} else if (rtcEvent == 2 && hour == 0 && min == 0) { // day
						generateInterrupt();
					} else if (rtcEvent == 3 && hour == 12 && min == 0) { // day
						generateInterrupt();
					}
				}

				/*
				 * Generate interrupts when time successfully increased and there's
				 * no other interrupt
				 */
				if (readyInterruptEnable && modeCalendar) {
					readyInterruptFlag = true;
				}

			} else {
				rtcCount += 1;
				long overflow = ((1L << ((rtcEvent + 1) * 8)));
				overflow -= 1;
				if ((rtcCount & overflow) == 0) {
					generateInterrupt();
				}
				if (rtcCount >= (1L << 32)) {
					rtcCount = 0;
				}
			}
		}

		/**
		 * Trigger a microprocessor interrupt
		 */
		private void generateInterrupt() {
			eventInterruptFlag = true;
		}

	};

	private double getPreScalerFreq() {
		double freqSrc = 0;
		if (preScaler1Src > 1) {
			/* From preScaler 0 */
			if (preScaler0Src == 0) {
				freqSrc = cpu.getAclkFrq();
			} else {
				freqSrc = cpu.getSmclkFrq();
			}
			int div = (0x2 << preScaler0Div);
			freqSrc /= div;
		} else if (preScaler1Src == 0) {
			freqSrc = cpu.getAclkFrq();
		} else {
			freqSrc = cpu.getSmclkFrq();
		}
		int div = (0x2 << preScaler1Div);
		freqSrc /= div;
		return freqSrc;
	}

	/**
	 * Initialize the RTC clock. This is called when the hold bit is released
	 */
	private void rtcInit() {
		double freqSrc = 1f;
		if (modeCalendar) {
			/* In this mode we can set the counter to 1 second */
			freqSrc = 1f; // 1Hz = ~1s
		} else {
			if (type == RtcType.TYPE_A) {
				/* For the RTC_A the sources are aclk, smclk, rt1ps */
				if (clockSource == 0) {
					freqSrc = cpu.getAclkFrq();
				} else if (clockSource == 1) {
					freqSrc = cpu.getSmclkFrq();
				} else {
					freqSrc = getPreScalerFreq();
				}
			} else {
				/* For the RTC_D the sources are 32-khz, rt1ps */
				if (clockSource <= 1) {
					freqSrc = 32000;
				} else {
					freqSrc = getPreScalerFreq();
				}
			}
		}
		period = 1000f / freqSrc;
		cpu.scheduleTimeEventMillis(rtcTimer, period);
	}

	/**
	 * Reset the calendar to 01.01.0000
	 */
	private void resetCalendar() {
		cal = new GregorianCalendar(0, 1, 1, 0, 0, 0);
	}

	/**
	 * Get the interrupt vector
	 * 
	 * @return
	 */
	private int getIV() {
		int iv = 0;
		iv |= (readyInterruptFlag ? 1 : 0) << 1;
		iv |= (eventInterruptFlag ? 1 : 0) << 2;
		iv |= (alarmInterruptFlag ? 1 : 0) << 3;
		return iv;
	}

	/**
	 * Given a calendar field, get the BCD or hex representation
	 * 
	 * @param calField
	 *           Calendar.XXXX field
	 * @return the formated field
	 */
	private int formatField(int calField) {
		int f = cal.get(calField);
		/* Day of week is 0-6 in uC and 1-7 in Java */
		if (calField == Calendar.DAY_OF_WEEK) {
			f -= 1;
		}
		int res = 0;
		int base = 0;
		if (formatBCD) {
			base = 10;
		} else {
			base = 16;
		}
		for (int i = 0; f > 0; i++) {
			int v = f % base;
			f = f / base;
			res |= (v << i * 4);
		}
		return res;
	}

	/**
	 * Parses a calendar input
	 * 
	 * This processes the registers written in BCD or hex format
	 * 
	 * @param calField
	 *           the calendar field to parse
	 * @param value
	 *           the input value
	 */
	private void parseCalReg(int calField, int value) {
		int res = 0;
		int factor = 1;
		int base = 0;
		if (formatBCD) {
			base = 10;
		} else {
			base = 16;
		}

		/* Day of week is 0-6 in uC and 1-7 in Java */
		if (calField == Calendar.DAY_OF_WEEK) {
			value += 1;
		}

		while (value > 0) {
			int v = value & 0x0f;
			res += (v * factor);
			value >>= 4;
			factor *= base;
		}
		cal.set(calField, res);
		cal.get(calField); // Until get is not done the fields are not set
	}

	/**
	 * Clear the highest priority interrupt flag
	 */
	private void clearHighestInterrupt() {
		if (readyInterruptFlag) {
			readyInterruptFlag = false;
		} else if (eventInterruptFlag) {
			eventInterruptFlag = false;
		} else if (alarmInterruptFlag) {
			alarmInterruptFlag = false;
		}

		if (getIV() > 0) {
			cpu.flagInterrupt(rtcIntVector, this, true);
		}
	}

	/**
	 * The registers are written
	 */
	public void write(int address, int value, boolean word, long cycles) {
		/*
		 * XXX: this assumes always word access
		 */
		if (!word) {
			logw(WarningType.MISALIGNED_WRITE, "byte access not implemented");
		}

		int lo = (value) & 0xff; // low byte
		int hi = (value >> 8) & 0xff; // high byte

		switch (address - offset) {
		case RTCCTL01:
			oscFaultInterruptEnable = ((value & RTCOFIE) == RTCOFIE);
			eventInterruptEnable = ((value & RTCTEVIE) == RTCTEVIE);
			alarmInterruptEnable = ((value & RTCAIE) == RTCAIE);
			readyInterruptEnable = ((value & RTCRDYIE) == RTCRDYIE);
			oscFaultInterruptFlag = ((value & RTCOFIFG) == RTCOFIFG);
			eventInterruptFlag = ((value & RTCEVIFG) == RTCEVIFG);
			alarmInterruptFlag = ((value & RTCAIFG) == RTCAIFG);
			readyInterruptFlag = ((value & RTCRDYIFG) == RTCRDYIFG);

			rtcHold = ((value & RTCHOLD) == RTCHOLD);
			rtcReady = ((value & RTCRDY) == RTCRDY);
			clockSource = (value & 0x0C00) >> 10;
			rtcEvent = (value & 0x0300) >> 8;

			/*
			 * Either the BCD has changed and is in mode calendar or the mode
			 * calendar has been enabled
			 */
			if ((modeCalendar && formatBCD != ((value & RTCBCD) == RTCBCD))
					|| (modeCalendar == false && (value & RTCMODE) == RTCMODE)) {
				/*
				 * Changing this bit clears seconds, minutes, hours, day of week,
				 * and year to 0 and sets day of month and month to 1. The real-time
				 * clock registers must be set by software afterwards.
				 */
				resetCalendar();
			}
			modeCalendar = ((value & RTCMODE) == RTCMODE);
			formatBCD = ((value & RTCBCD) == RTCBCD);

			/* Initialize the RTC or stop it */
			if (!rtcHold) {
				rtcInit();
			}

			break;

		case RTCPS0CTL:
			preScaler0Src = ((value & 0x4000) >> 14);
			preScaler0Div = ((value & 0x3800) >> 11);
			preScaler0Hold = ((value & RT0PSHOLD) == RT0PSHOLD);

			if (((value & (RT0PSIE | RT0PSIFG | RT0IP)) > 0)) {
				logNotImplemented("prescaling interrupts");
			}
			break;

		case RTCPS1CTL:
			preScaler1Src = ((value & 0xC000) >> 14);
			preScaler1Div = ((value & 0x3800) >> 11);
			preScaler1Hold = ((value & RT1PSHOLD) == RT1PSHOLD);

			if (((value & (RT1PSIE | RT1PSIFG | RT1IP)) > 0)) {
				logNotImplemented("prescaling interrupts");
			}
			break;

		case RTCCTL23:
			logNotImplemented("Calibration");
			break;

		case RTCPS:
			logNotImplemented("prescaling counter");
			break;

		case RTCTIM0: // RTCNT12
			if (modeCalendar) {
				parseCalReg(Calendar.SECOND, lo);
				parseCalReg(Calendar.MINUTE, hi);
			} else {
				rtcCount &= 0xffff0000;
				rtcCount |= value;
			}
			break;

		case RTCTIM1: // RTCNT34
			if (modeCalendar) {
				parseCalReg(Calendar.HOUR_OF_DAY, lo);
				parseCalReg(Calendar.DAY_OF_WEEK, hi);
			} else {
				rtcCount &= 0x0000ffff;
				rtcCount |= (long) (value << 16);
			}
			break;

		case RTCDATE:
			if (modeCalendar) {
				parseCalReg(Calendar.DAY_OF_MONTH, lo);
				parseCalReg(Calendar.MONTH, hi);
			}
			break;

		case RTCYEAR:
			if (modeCalendar) {
				parseCalReg(Calendar.YEAR, value);
			}
			break;

		case RTCIV:
			/*
			 * Any access, read or write, of the RTCIV register automatically
			 * resets the highest-pending interrupt flag. If another interrupt flag
			 * is set, another interrupt is immediately generated after servicing
			 * the initial interrupt. In addition, all flags can be cleared via
			 * software.
			 */
			clearHighestInterrupt();

		default:
			logNotImplemented("register: " + address);
		}
	}

	/**
	 * Registers are read
	 */
	public int read(int address, boolean word, long cycles) {

		if (!word) {
			logw(WarningType.MISALIGNED_READ, "byte access not implemented");
		}

		switch (address - offset) {
		case RTCCTL01:
			if (word) {
				return getCTL01Reg();
			} else {
				return getCTL0Reg();
			}

		case RTCCTL23:
			logNotImplemented("calibration");
			break;

		case RTCPS:
			logNotImplemented("prescaling coutner");
			break;

		case RTCPS0CTL:
			return getPS0CTL();

		case RTCPS1CTL:
			return getPS1CTL();

		case RTCIV:
			/*
			 * Any access, read or write, of the RTCIV register automatically
			 * resets the highest-pending interrupt flag. If another interrupt flag
			 * is set, another interrupt is immediately generated after servicing
			 * the initial interrupt. In addition, all flags can be cleared via
			 * software.
			 */
			int tmp = getIV();
			clearHighestInterrupt();
			return tmp;

		case RTCTIM0: // RTCNT12
			if (modeCalendar) {
				return formatField(Calendar.MINUTE) << 8
						| formatField(Calendar.SECOND);
			} else {
				return (int) (rtcCount & 0xffff);
			}

		case RTCTIM1: // RTCNT34
			if (modeCalendar) {
				return formatField(Calendar.DAY_OF_WEEK) << 8
						| formatField(Calendar.HOUR_OF_DAY);
			} else {
				return (int) ((rtcCount >> 16) & 0xffff);
			}

		case RTCDATE:
			if (modeCalendar) {
				return formatField(Calendar.MONTH) << 8
						| formatField(Calendar.DAY_OF_MONTH);
			}
			break;

		case RTCYEAR:
			if (modeCalendar) {
				return formatField(Calendar.YEAR);
			}
			break;

		default:
			logNotImplemented("register: " + address);
		}
		return 0;
	}

	public void interruptServiced(int vector) {
		/*
		 * NOTE this function is called BEFORE the interrupt is actually
		 * serviced!!!
		 */
		if (vector == rtcIntVector) {
			cpu.flagInterrupt(rtcIntVector, this, false);
		}
	}

	/*
	 * The inherited log function is not working for whatever reason. A quick
	 * redefinition helps a lot while developing the module
	 */
	@Override
	protected void log(String msg) {
		if (DEBUG) {
			System.out.println(msg);
		}
	}

	/**
	 * Log using printf format
	 * 
	 * @param format
	 * @param arguments
	 */
	protected void log(final String format, final Object... arguments) {
		if (DEBUG) {
			System.out.printf(format, arguments);
		}
	}

	private void logNotImplemented(String feature) {
		logw(WarningType.EMULATION_ERROR, feature + " is not implemented");
	}

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Memory.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Memory
 *
 * Author  : Joakim Eriksson
 * Created : Sept 15 22:00:00 2008
 */
package se.sics.mspsim.core;

public interface Memory {

    public static final int SEGMENT_SIZE = 256;

    public enum AccessType {
        READ,    /* normal read */
        EXECUTE, /* instruction execution read */
        ARG,     /* arguments for execution */
        WRITE    /* write */
    };

    public enum AccessMode {
        BYTE(1, 8, 0xff),
        WORD(2, 16, 0xffff),
        WORD20(4, 20, 0xfffff);

        public final int bytes;
        public final int bitSize;
        public final int mask;
        public final int msb;

        AccessMode(int bytes, int bitSize, int mask) {
            this.bytes = bytes;
            this.bitSize = bitSize;
            this.mask = mask;
            this.msb = 1 << (bitSize - 1);
        }
    };

    public int read(int address, AccessMode mode, AccessType type) throws EmulationException;
    public void write(int dstAddress, int data, AccessMode mode) throws EmulationException;

    public int get(int address, AccessMode mode);
    public void set(int address, int data, AccessMode mode);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/RegisterMonitor.java`:

```java
package se.sics.mspsim.core;

import se.sics.mspsim.util.ProxySupport;

public interface RegisterMonitor {

    public void notifyReadBefore(int reg, Memory.AccessMode mode);
    public void notifyReadAfter(int reg, Memory.AccessMode mode);

    public void notifyWriteBefore(int reg, int data, Memory.AccessMode mode);
    public void notifyWriteAfter(int reg, int data, Memory.AccessMode mode);

    public static class Adapter implements RegisterMonitor {

        @Override
        public void notifyReadBefore(int reg, Memory.AccessMode mode) {
        }

        @Override
        public void notifyReadAfter(int reg, Memory.AccessMode mode) {
        }

        @Override
        public void notifyWriteBefore(int reg, int data, Memory.AccessMode mode) {
        }

        @Override
        public void notifyWriteAfter(int reg, int data, Memory.AccessMode mode) {
        }

    }

    public static class Proxy extends ProxySupport<RegisterMonitor> implements RegisterMonitor {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void notifyReadBefore(int reg, Memory.AccessMode mode) {
            RegisterMonitor[] listeners = this.listeners;
            for(RegisterMonitor listener : listeners) {
                listener.notifyReadBefore(reg, mode);
            }
        }

        @Override
        public void notifyReadAfter(int reg, Memory.AccessMode mode) {
            RegisterMonitor[] listeners = this.listeners;
            for(RegisterMonitor listener : listeners) {
                listener.notifyReadAfter(reg, mode);
            }
        }

        @Override
        public void notifyWriteBefore(int reg, int data, Memory.AccessMode mode) {
            RegisterMonitor[] listeners = this.listeners;
            for(RegisterMonitor listener : listeners) {
                listener.notifyWriteBefore(reg, data, mode);
            }
        }

        @Override
        public void notifyWriteAfter(int reg, int data, Memory.AccessMode mode) {
            RegisterMonitor[] listeners = this.listeners;
            for(RegisterMonitor listener : listeners) {
                listener.notifyWriteAfter(reg, data, mode);
            }
        }

    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/BreakpointException.java`:

```java
/*
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.core;

public class BreakpointException extends EmulationException {

    private static final long serialVersionUID = 49958825510873400L;

    BreakpointException() {
        super("breakpoint");
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/MemoryMonitor.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * MemoryMonitor
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import se.sics.mspsim.util.ProxySupport;

public interface MemoryMonitor {

  public void notifyReadBefore(int addr, Memory.AccessMode mode, Memory.AccessType type);
  public void notifyReadAfter(int addr, Memory.AccessMode mode, Memory.AccessType type);

  public void notifyWriteBefore(int dstAddress, int data, Memory.AccessMode mode);
  public void notifyWriteAfter(int dstAddress, int data, Memory.AccessMode mode);

  public static class Adapter implements MemoryMonitor {

    @Override
    public void notifyReadBefore(int addr, Memory.AccessMode mode, Memory.AccessType type) {
    }

    @Override
    public void notifyReadAfter(int addr, Memory.AccessMode mode, Memory.AccessType type) {
    }

    @Override
    public void notifyWriteBefore(int dstAddress, int data, Memory.AccessMode mode) {
    }

    @Override
    public void notifyWriteAfter(int dstAddress, int data, Memory.AccessMode mode) {
    }

  }

  public static class Proxy extends ProxySupport<MemoryMonitor> implements MemoryMonitor {
      public static final Proxy INSTANCE = new Proxy();

      @Override
      public void notifyReadBefore(int address, Memory.AccessMode mode, Memory.AccessType type) {
          MemoryMonitor[] listeners = this.listeners;
          for(MemoryMonitor listener : listeners) {
              listener.notifyReadBefore(address, mode, type);
          }
      }

      @Override
      public void notifyReadAfter(int address, Memory.AccessMode mode, Memory.AccessType type) {
          MemoryMonitor[] listeners = this.listeners;
          for(MemoryMonitor listener : listeners) {
              listener.notifyReadAfter(address, mode, type);
          }
      }

      @Override
      public void notifyWriteBefore(int dstAddress, int data, Memory.AccessMode mode) {
          MemoryMonitor[] listeners = this.listeners;
          for(MemoryMonitor listener : listeners) {
              listener.notifyWriteBefore(dstAddress, data, mode);
          }
      }

      @Override
      public void notifyWriteAfter(int dstAddress, int data, Memory.AccessMode mode) {
          MemoryMonitor[] listeners = this.listeners;
          for(MemoryMonitor listener : listeners) {
              listener.notifyWriteAfter(dstAddress, data, mode);
          }
      }

  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/DisAsm.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * DisAsm
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;
import java.io.BufferedReader;
import java.io.InputStreamReader;

import se.sics.mspsim.util.MapEntry;
import se.sics.mspsim.util.MapTable;
import se.sics.mspsim.util.Utils;

public class DisAsm implements MSP430Constants {

  private boolean step = true; //false;

  private MapTable map;

  // Idiots solution to single stepping...
  private BufferedReader input =
    new BufferedReader(new InputStreamReader(System.in));

  
  public void setMap(MapTable m) {
    map = m;
  }

  public MapTable getMap() {
    return map;
  }

  public DbgInstruction disassemble(int pc, int[] memory, int[] reg) {
    return disassemble(pc, memory, reg, 0);
  }

  public DbgInstruction disassemble(int pc, int[] memory, int[] reg,
				 int interrupt) {
    DbgInstruction dbg = disassemble(pc, memory, reg, new DbgInstruction(),
				     interrupt);
    String fkn;
    if ((fkn = dbg.getFunction()) != null) {
      System.out.println("//// " + fkn);
    }
    System.out.println(dbg.getASMLine());

    /* Hack for printing the instruction after the ext word... */
    if (dbg.isExtensionWord()) {
        pc = pc + 2;
        dbg = disassemble(pc, memory, reg, new DbgInstruction(),
                interrupt);
        System.out.println(dbg.getASMLine());
    }
    
    return dbg;
  }

  public DbgInstruction getDbgInstruction(int pc, MSP430 cpu) {
    return disassemble(pc, cpu.memory, cpu.reg, new DbgInstruction(),
		       cpu.servicedInterrupt);
  }

  public DbgInstruction disassemble(int pc, int[] memory, int[] reg,
					   DbgInstruction dbg, int interrupt) {
    int startPC = pc;
    int size = 0;
    int instruction = memory[pc] + (memory[pc + 1] << 8);
    int op = instruction >> 12;
    boolean word = (instruction & 0x40) == 0;

    String output = "    ";
    if (interrupt > 0) {
      output = "I:" + Integer.toString(interrupt) + ' ';
    }

    String regs = "";


    if (pc < 0x0010) {
      output += "000" + Integer.toString(pc, 16);
    } else if (pc < 0x0100) {
      output += "00" + Integer.toString(pc, 16);
    } else if (pc < 0x1000) {
      output += "0" + Integer.toString(pc, 16);
    } else {
      output += Integer.toString(pc, 16);
    }


    output += ":\t";

    pc += 2;
    size += 2;

    switch (op) {
    case 0: // MSP430X instructions
    {
        // MSP430X - additional instructions
        String opstr = "";
        op = instruction & 0xf0f0;
        int srcdata = (instruction & 0x0f00) >> 8;
        int dst = instruction & 0x000f;
        int nextData = memory[pc] + (memory[pc + 1] << 8);
        boolean rrword = true;

        switch(op) {
        case MOVA_IND:
            opstr = "MOVA @R" + srcdata +  ",R" + dst;
            break;
        case MOVA_IND_AUTOINC:
            opstr = "MOVA @R" + srcdata +  "+,R" + dst;
            break;
        case MOVA_ABS2REG:
            opstr = "MOVA &$" + Utils.hex20(((srcdata << 16) | nextData)) +  ",R" + dst;
            size += 2;
            break;
        case MOVA_INDX2REG:
            opstr = "MOVA $" + Utils.hex16(nextData) +  "(R" + srcdata + "),R" + dst;
            size += 2;
            break;
        case MOVA_REG2ABS:
            opstr = "MOVA R" + srcdata + ",&$" + Utils.hex20(((dst << 16) | nextData));
            size += 2;
            break;
        case MOVA_REG2INDX:
            opstr = "MOVA R" + srcdata + ",$" + Utils.hex16(nextData) + "(R" + dst + ")";
            size += 2;
            break;
        case MOVA_IMM2REG:
            opstr = "MOVA #$" + Utils.hex20(((srcdata << 16) | nextData)) +  ",R" + dst;
            size += 2;
            break;
        case CMPA_IMM:
            opstr = "CMPA #$" + Utils.hex20(((srcdata << 16) | nextData)) +  ",R" + dst;
            size += 2;
            break;
        case ADDA_IMM:
            opstr = "ADDA #$" + Utils.hex20(((srcdata << 16) | nextData)) +  ",R" + dst;
            size += 2;
            break;
        case SUBA_IMM:
            opstr = "SUBA #$" + Utils.hex20(((srcdata << 16) | nextData)) +  ",R" + dst;
            size += 2;
            break;
        case MOVA_REG:
            opstr = "MOVA R" + srcdata +  ",R" + dst;
            break;
        case CMPA_REG:
            opstr = "CMPA R" + srcdata +  ",R" + dst;
            break;
        case ADDA_REG:
            opstr = "ADDA R" + srcdata +  ",R" + dst;
            break;
        case SUBA_REG:
            opstr = "SUBA R" + srcdata +  ",R" + dst;
            break;
        case RRXX_ADDR:
            rrword = false;
        case RRXX_WORD:
            String rrwordStr = rrword ? ".W" : ".A";
            int count = ((instruction >> 10) & 0x03) + 1; // shift amount
            switch (instruction & RRMASK) {
                case RRCM:
                    opstr = "RRCM" + rrwordStr + " #" + count + ",R" + dst;
                    break;
                case RRAM:
                    opstr = "RRAM" + rrwordStr + " #" + count + ",R" + dst;
                    break;
                case RLAM:
                    opstr = "RLAM" + rrwordStr + " #" + count + ",R" + dst;
                    break;
                case RRUM:
                    opstr = "RRUM" + rrwordStr + " #" + count + ",R" + dst;
                    break;
            }
            break;
        }
        
        output += dumpMem(startPC, size, memory);
        output += opstr + " ";
        regs = "R" + srcdata + "=" + Utils.hex16(reg[srcdata]);
        regs += " SP=" + Utils.hex16(reg[SP]);
    }
    break;
    case 1: // Single operand instructions
    {
        /* check CALLA first */
        int dst = instruction & 0x000f;
        int nextData = memory[pc] + (memory[pc + 1] << 8);
        String opstr = null;
        switch(instruction & 0xfff0) {
        case CALLA_REG:
            opstr = "CALLA R" + dst;
            break;
        case CALLA_IND:
            opstr = "CALLA @R" + dst;
            break;
        case CALLA_IND_AUTOINC:
            opstr = "CALLA @R" + dst + "+";
            break;
        case CALLA_ABS:
            opstr = "CALLA &" + Utils.hex20(((dst << 16) | nextData));
            size += 2;
            break;
        case CALLA_EDE:
            opstr = "CALLA " + Utils.hex20(((dst << 16) | nextData)) + "(PC)";
            size += 2;
            break;
        case CALLA_IMM:
            opstr = "CALLA #" + Utils.hex20(((dst << 16) | nextData));
            size += 2;
            break;
        default:
            switch (instruction & 0xff00) {
            case PUSHM_A:
                opstr = "PUSHM.A #" + (1 + ((instruction >> 4) & 0x0f)) + ", R" + (instruction & 0x0f);
                break;
            case PUSHM_W:
                opstr = "PUSHM.W #" + (1 + ((instruction >> 4) & 0x0f)) + ", R" + (instruction & 0x0f);
                break;
            case POPM_A:
                opstr = "POPM.A #" + (1 + ((instruction >> 4) & 0x0f)) + ", R" + (instruction & 0x0f);
                break;
            case POPM_W:
                opstr = "POPM.W #" + (1 + ((instruction >> 4) & 0x0f)) + ", R" + (instruction & 0x0f);
                break;                
            }
        }
        if (opstr != null) {        
            output += dumpMem(startPC, size, memory);
            output += opstr + " ";
            regs = "R" + dst + "=" + Utils.hex16(reg[dst]);
            regs += " SP=" + Utils.hex16(reg[SP]);
        } else {
            // Register
            int register = instruction & 0xf;
            // Adress mode of destination...
            int ad = (instruction >> 4) & 3;
            // Pick up the destination address based on ad more and regs...
            int dstAddress = 0;
            String adr = "";
            switch(ad) {
            // Operand in register!
            case AM_REG:
                adr = "R" + register;
                break;
            case AM_INDEX:
                dstAddress = memory[pc] + (memory[pc + 1] << 8);
                adr = "R" + register + "(" + dstAddress + ")";
                dstAddress = (register == CG1 ? 0 : reg[register]) + dstAddress;
                pc += 2;
                size += 2;
                break;
                // Indirect register
            case AM_IND_REG:
                adr = "@(R" + register + ")";
                dstAddress = reg[register];
                break;
            case AM_IND_AUTOINC:
                if (register == 0) {
                    // Can this be PC and be incremented only one byte?
                    int tmp = memory[pc] + (memory[pc + 1] << 8);
                    MapEntry me;
                    if (map != null && (me = map.getEntry(tmp)) != null) {
                        adr = me.getName(); // + " = $" + Utils.hex16(tmp);
                    } else {
                        adr = "#$" + Utils.hex16(tmp);
                    }
                    size += 2;
                } else {
                    adr = "@(R" + register + "+)";
                    dstAddress = reg[register];
                }
                break;
            }

            switch(instruction & 0xff80) {
            case RRC:
                opstr = "RRC" + (word ? ".W" : ".B");
                break;
            case SWPB:
                opstr = "SWPB" + (word ? ".W" : ".B");
                break;
            case RRA:
                opstr = "RRA" + (word ? ".W" : ".B");
                break;
            case SXT:
                opstr = "RRA" + (word ? ".W" : ".B");
                break;
            case PUSH:
                opstr = "PUSH" + (word ? ".W" : ".B");
                break;
            case CALL:
                opstr = "CALL";
                break;
            case RETI:
                opstr = "RETI";
                break;
            default:
                if ((instruction & 0xf800) == 0x1800) {
                    int zc = (instruction & EXTWORD_ZC) > 0 ? 1 : 0;
                    int al = (instruction & EXTWORD_AL) > 0 ? 1 : 0;
                    int rp = (instruction & EXTWORD_REPEAT) > 0 ? 1 : 0;
                    int shi = (instruction & EXTWORD_SRC) >> 7;
                    int dhi = (instruction & EXTWORD_DST);
                    opstr = "ExtWord " + Utils.hex16(instruction) + ":ZC:" + zc + " #:" + rp +
                    " A/L:" + al + " src:" + shi + " dst:" + dhi;
                    dbg.setExtWord(true);
                } else {
                    System.out.println("Not implemented instruction: $" + Utils.hex16(instruction) +
                            " at " + Utils.hex16(startPC));
                    opstr = "<Unkown>";
                }
            }
            output += dumpMem(startPC, size, memory);
            output += opstr + " " + adr;
            regs = "R" + register + "=" + Utils.hex16(reg[register]);
            regs += " SP=" + Utils.hex16(reg[SP]);
        }
    }
    break;
    // Jump instructions
    case 2:
    case 3:
      // 10 bits for address for these => 0x00fc => remove 2 bits
      int jmpOffset = instruction & 0x3ff;
      jmpOffset = (jmpOffset & 0x200) == 0 ?
	2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
      boolean jump = false;
      String opstr = "";
      switch(instruction & 0xfc00) {
      case JNE:
	opstr = "JNE";
	break;
      case JEQ:
	opstr = "JEQ";
	break;
      case JNC:
	opstr = "JNC";
	break;
      case JC:
	opstr = "JC";
	break;
      case JN:
	opstr = "JN";
	break;
      case JGE:
	opstr = "JGE";
	break;
      case JL:
	opstr = "JL";
	break;
      case JMP:
	opstr = "JMP";
	break;
      default:
	System.out.println("Not implemented instruction: " +
			   Utils.binary16(instruction));
      }
      output += dumpMem(startPC, size, memory);
      output += opstr + " $" + Utils.hex16(jmpOffset);
      regs = "\tSR=" + dumpSR(reg[SR]);
      break;
    default:
      // ---------------------------------------------------------------
      // Double operand instructions!
      // ---------------------------------------------------------------
      int dstRegister = (instruction & 0xf);
      int srcRegister = (instruction >> 8) & 0xf;
      int as = (instruction >> 4) & 3;

      // AD: 0 => register direct, 1 => register index, e.g. X(Rn)
      boolean dstRegMode = ((instruction >> 7) & 1) == 0;
      int dstAddress = 0;
      int srcAddress = 0;
      int src = 0;
      int dst = 0;
      boolean write = false;
      boolean updateStatus = true;
      String srcadr = "";
      String dstadr = "";
      switch(as) {
	// Operand in register!
      case AM_REG:
	if (srcRegister == CG2) {
	  srcadr = "#0";
	} else if (srcRegister == CG1) {
	  srcadr = "#0";
	} else {
	  srcadr = getRegName(srcRegister);
	}
	break;
      case AM_INDEX:
	// Indexed if reg != PC & CG1/CG2 - will PC be incremented?
	if (srcRegister == CG1) {
	  srcAddress = memory[pc] + (memory[pc + 1] << 8);

	  MapEntry me;
	  if (map != null && (me = map.getEntry(srcAddress)) != null) {
	    srcadr = "&" + me.getName(); // + " = $" + Utils.hex16(srcAddress);
	  } else {
	    srcadr = "&$" + Utils.hex16(srcAddress);
	  }
	  size += 2;
	} else if (srcRegister == CG2) {
	  srcadr = "#1";
	} else {
	  srcAddress = reg[srcRegister] + memory[pc] + (memory[pc + 1] << 8);
	  srcadr = "$" + Utils.hex16(memory[pc] + (memory[pc + 1] << 8)) + "(R" + srcRegister + ")";
	  size += 2;
	}
	pc += 2;
	break;
	// Indirect register
      case AM_IND_REG:
	if (srcRegister == CG2) {
	  srcadr = "#2";
	} else if (srcRegister == CG1) {
	  srcadr = "#4";
	} else {
	  srcadr = "@" + getRegName(srcRegister);
	}
	break;
      case AM_IND_AUTOINC:
	if (srcRegister == CG2) {
	  srcadr = "#$ffff";
	} else if (srcRegister == CG1) {
	  srcadr = "#8";
	} else if (srcRegister == PC) {
	  srcadr = "#$" + Utils.hex16(memory[pc] + (memory[pc + 1] << 8));
	  pc += 2;
	  size += 2;
	} else if (srcRegister == CG2) {
	  srcadr = "#$ffff";
	} else {
	  srcadr = "@" + getRegName(srcRegister) + "+";
	  srcAddress = reg[srcRegister];
	}
	break;
      }

      if (dstRegMode) {
	dstadr = getRegName(dstRegister);
      } else {
	dstAddress = memory[pc] + (memory[pc + 1] << 8);
        MapEntry me = map != null ? map.getEntry(dstAddress) : null;
	if (dstRegister == 2) {
	  if (me != null) {
            dstadr = "&" + me.getName(); // + " = $" + Utils.hex16(srcAddress);
	  } else {
	    dstadr = "&$" + Utils.hex16(dstAddress);
	  }
	} else {
          if (me != null) {
            dstadr = me.getName() + "(R" + dstRegister + ")";
          } else {
            dstadr = "$" + Utils.hex16(dstAddress) + "(R" + dstRegister + ")";
          }
	}
	pc += 2;
	size += 2;
      }

      // If byte mode the source will not contain the full word...
      if (!word) {
	src = src & 0xff;
	dst = dst & 0xff;
      }
      opstr = "";
      switch (op) {
      case MOV: // MOV
	if (instruction == 0x3041) {
	  opstr = "RET /emulated: MOV.W ";
	} else {
	  opstr = "MOV" + (word ? ".W" : ".B");
	}
	break;
      case ADD: // ADD
	opstr = "ADD" + (word ? ".W" : ".B");
	break;
      case ADDC: // ADDC
	opstr = "ADDC" + (word ? ".W" : ".B");
	break;
      case SUBC: // SUBC
	opstr = "SUBC" + (word ? ".W" : ".B");
	break;
      case SUB: // SUB
	opstr = "SUB" + (word ? ".W" : ".B");
	break;
      case CMP: // CMP
	opstr = "CMP" + (word ? ".W" : ".B");
	break;
      case DADD: // DADD
	opstr = "DADD" + (word ? ".W" : ".B");
	break;
      case BIT: // BIT
	opstr = "BIT" + (word ? ".W" : ".B");
	break;
      case BIC: // BIC
	opstr = "BIC" + (word ? ".W" : ".B");
	break;
      case BIS: // BIS
	opstr = "BIS" + (word ? ".W" : ".B");
	break;
      case XOR: // XOR
	opstr = "XOR" + (word ? ".W" : ".B");
	break;
      case AND: // AND
	opstr = "AND" + (word ? ".W" : ".B");
	break;
      default:
        if (startPC > 0x200)
          System.out.println(output + " DoubleOperand not implemented: " +
              op + " instruction: " +
              Utils.binary16(instruction) + " = " +
              Utils.hex16(instruction));
      }


      output += dumpMem(startPC, size, memory);
      output += opstr + " " + srcadr + ", " + dstadr;

      regs = "R" + dstRegister + "=" + Utils.hex16(reg[dstRegister]) +
	" R" + srcRegister + "=" + Utils.hex16(reg[srcRegister]);
      regs += " SR=" + dumpSR(reg[SR]);
      regs += " SP=" + Utils.hex16(reg[SP]);
      regs += "; as = " + as;
      srcAddress &= 0xffff;
      if (srcAddress != -1) {
	srcAddress &= 0xffff;
	regs += " sMem:" + Utils.hex16(memory[srcAddress] +
				       (memory[(srcAddress + 1) % 0xffff]
					<< 8));
      }
    }

    dbg.setASMLine(output);
    dbg.setRegs(regs);
    dbg.setInstruction(instruction, size);
    if (map != null) {
      dbg.setFunction(map.getFunctionName(startPC));
    }

    if (!step) {
      String line = "";
      try {line = input.readLine();}catch(Exception e){}
      if (line != null && line.length() > 0 && line.charAt(0) == 'r') {
	System.out.println("Registers:");
	for (int i = 0, n = 16; i < n; i++) {
	  System.out.print("R" + i + "=" + Utils.hex16(reg[i]) + "  ");
	  if (i % 7 == 0 && i != 0) System.out.println();
	}
	System.out.println();
      }
    }
    return dbg;
  }

  private String getRegName(int index) {
    if (index == 0) return "PC";
    if (index == 1) return "SP";
    if (index == 2) return "SR";
    return "R" + index;
  }

  public static String getSingleOPStr(int instruction) {
    boolean word = (instruction & 0x40) == 0;
    switch(instruction & 0xff80) {
    case RRC:
      return "RRC" + (word ? ".W" : ".B");
    case SWPB:
      return "SWPB" + (word ? ".W" : ".B");
    case RRA:
      return "RRA" + (word ? ".W" : ".B");
    case SXT:
      return "RRA" + (word ? ".W" : ".B");
    case PUSH:
      return "PUSH" + (word ? ".W" : ".B");
    case CALL:
      return "CALL";
    case RETI:
      return "RETI";
    default:
      return "-";
    }
  }

  private static String dumpSR(int sr) {
    return "" +
      (((sr & OVERFLOW) != 0) ? 'V' : '-') +
      (((sr & NEGATIVE) != 0) ? 'N' : '-') +
      (((sr & ZERO) != 0) ? 'Z' : '-') +
      (((sr & CARRY) != 0) ? 'C' : '-');
  }

  private static String dumpMem(int pc, int size, int[] memory) {
    StringBuilder output = new StringBuilder();
    for (int i = 0, n = size; i < n; i++) {
      if (size > i) {
	output.append(Utils.hex8(memory[pc + i])).append(" ");
      } else {
	output.append("   ");
      }
    }
    return output.toString();
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/DMA.java`:

```java
package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

public class DMA extends IOUnit {

    /* global DMA configuration */
    public static final int DMACTL0 = 0x122;
    public static final int DMACTL1 = 0x124;

    /* per channel configuration */
    public static final int DMAxCTL = 0x1e0;
    public static final int DMAxSA = 0x1e2;
    public static final int DMAxDA = 0x1e4;
    public static final int DMAxSZ = 0x1e6;
 
    /* DMA TSELx - from msp430x1xxx devices */
    /* new devices has more channels and more triggers */
    public static final int DMAREQ = 0;
    public static final int TACCR2 = 1;
    public static final int TBCCR2 = 2;
    public static final int URXIFG0 = 3; /* UART 0 */
    public static final int UTXIFG0 = 4; /* UART 0 */
    public static final int DAC12_0 = 5;
    public static final int ADC12_0 = 6;
    public static final int TACCR0 = 7;
    public static final int TBCCR0 = 8;
    public static final int URXIFG1 = 9; /* UART 1 */
    public static final int UTXIFG1 = 10; /* UART 1 */
    public static final int MULTIPLIER = 11;

    public static final int IFG_MASK = 0x08;
    
    private static final int[] INCR = {0,0,-1,1};
    
    private InterruptMultiplexer interruptMultiplexer;
    
    class Channel implements InterruptHandler {
        int channelNo;
        /* public registers */
        
        int ctl;
        int sourceAddress;
        int destinationAddress;
        int size;
        
        /* internal registers */
        int currentSourceAddress;
        int currentDestinationAddress;
        int storedSize;

        int srcIncr = 0;
        int dstIncr = 0;
        boolean dstByteMode = false;
        boolean srcByteMode = false;

        DMATrigger trigger;
        int triggerIndex;
        int transferMode = 0;
        
        boolean enable = false;
        boolean dmaLevel = false; /* edge or level sensitive trigger */
        boolean dmaIE = false;
        boolean dmaIFG = false;
        
        public Channel(int i) {
            channelNo = i;
        }

        public void setTrigger(DMATrigger t, int index) {
            if (DEBUG) log("Setting trigger to " + t);
            trigger = t;
            triggerIndex = index;
        }
        
        public void write(int address, int data) {
            switch(address) {
            case 0:
                ctl = data;
                transferMode = (data >> 12) & 7;
                dstIncr = INCR[(data >> 10) & 3];
                srcIncr = INCR[(data >> 8) & 3];
                dstByteMode = (data & 0x80) > 0; /* bit 7 */
                srcByteMode = (data & 0x40) > 0; /* bit 6 */
                dmaLevel = (data & 0x20) > 0; /* bit 5 */
                boolean enabling = !enable && (data & 0x10) > 0;  
                enable = (data & 0x10) > 0; /* bit 4 */
                dmaIFG = (data & IFG_MASK) > 0; /* bit 3 */
                dmaIE = (data & 0x04) > 0; /* bit 2 */
                if (DEBUG) log("DMA Ch." + channelNo + ": config srcIncr: " + srcIncr + " dstIncr:" + dstIncr
                        + " en: " + enable + " srcB:" + srcByteMode + " dstB:" + dstByteMode + " level: " + dmaLevel +
                        " transferMode: " + transferMode + " ie:" + dmaIE);
                /* this might be wrong ? */
                /*if (enabling) trigger(trigger, triggerIndex);*/
                interruptMultiplexer.updateInterrupt(dmaIFG & dmaIE, channelNo);
                break;
            case 2:
                sourceAddress = data;
                currentSourceAddress = data;
                break;
            case 4:
                destinationAddress = data;
                currentDestinationAddress = data;
                break;
            case 6:
                size = data;
                storedSize = data;
                break;
            }
        }
        
        public int read(int address) {
            switch(address) {
            case 0:
                /* set the IFG */
                ctl = (ctl & ~IFG_MASK) | (dmaIFG ? IFG_MASK : 0);
                return ctl;
            case 2:
                return sourceAddress;
            case 4:
                return destinationAddress;
            case 6:
                return size;
            }
            logw(WarningType.EXECUTION, "Illegal read of DMA Channel register");
            return 0;
        }
        
        public void trigger(DMATrigger trigger, int index) {
            /* perform memory move and possibly clear triggering flag!!! */
            /* NOTE: show config byte/word also !!! */
            if (enable) {
                int data = cpu.currentSegment.read(currentSourceAddress, Memory.AccessMode.BYTE, Memory.AccessType.READ);
                if (DEBUG) log("DMA Triggered reading from: " +
                        currentSourceAddress + " => " + data + " " + (char) data +
                        " size:" + size + " index:" + index);
                // flag already cleared by the memory read above
//                trigger.clearDMATrigger(index);
                DMA.this.cpu.currentSegment.write(currentDestinationAddress, data, Memory.AccessMode.BYTE);
                
                currentSourceAddress += srcIncr;
                currentDestinationAddress += dstIncr;
                size--;
                if (size == 0) {
                    currentSourceAddress = sourceAddress;
                    currentDestinationAddress = destinationAddress;
                    size = storedSize;
                    if ((transferMode & 0x04) == 0) {
                        enable = false;
                    }
                    /* flag interrupt and update interrupt vector */
                    dmaIFG = true;
                    interruptMultiplexer.updateInterrupt(dmaIFG & dmaIE, channelNo);
                }
            }
        }

        public void interruptServiced(int vector) {
        }

        public String getName() {
            return "DMA Channel " + channelNo;
        }

        public String info() {
            return getName() + (enable ? " Enabled " : " Disabled")
                    + "  Index: " + triggerIndex + "  Trigger: " + trigger
                    + "\n    current source: 0x"
                    + cpu.getAddressAsString(currentSourceAddress)
                    + " destination: 0x"
                    + cpu.getAddressAsString(currentDestinationAddress)
                    + "  size: " + (storedSize - size) + "/" + storedSize;
        }
    }

    private Channel channels[] = new Channel[3];
    private int dmactl0;
    private int dmactl1;

    /* MAX 16 triggers ? */
    private DMATrigger[] dmaTrigger = new DMATrigger[16];
    private int[] dmaTriggerIndex = new int[16];
    
    public DMA(String id, MSP430Core cpu, int[] memory, int offset) {
        super(id, cpu, memory, offset);
        channels[0] = new Channel(0);
        channels[1] = new Channel(1);
        channels[2] = new Channel(2);
    }

    public void setInterruptMultiplexer(InterruptMultiplexer interruptMultiplexer) {
        this.interruptMultiplexer = interruptMultiplexer;
    }
    
    public void setDMATrigger(int totindex, DMATrigger trigger, int tIndex) {
        dmaTrigger[totindex] = trigger;
        dmaTriggerIndex[totindex] = tIndex;
        trigger.setDMA(this);
    }
    
    public void trigger(DMATrigger trigger, int index) {
        /* could make this a bit and have a bit-pattern if more dma channels but
         * with 3 channels it does not make sense. Optimize later - maybe with
         * flag in DMA triggers so that they now if a channel listens at all.
         */
        for (int i = 0; i < channels.length; i++) {
//            System.out.println("DMA Channel:" + i + " " + channels[i].trigger + " = " + trigger);
            if (channels[i].trigger == trigger &&
                channels[i].triggerIndex == index) channels[i].trigger(trigger, index);
        }
    }
    
    public void interruptServiced(int vector) {
    }

    public void write(int address, int value, boolean word, long cycles) {
        if (DEBUG) log("DMA write to: " + Utils.hex(address, 4) + ": " + value);
        switch (address) {
        case DMACTL0:
            /* DMA Control 0 */
            dmactl0 = value;
            channels[0].setTrigger(dmaTrigger[value & 0xf], dmaTriggerIndex[value & 0xf]);
            channels[1].setTrigger(dmaTrigger[(value >> 4) & 0xf], dmaTriggerIndex[(value >> 4) & 0xf]);
            channels[2].setTrigger(dmaTrigger[(value >> 8) & 0xf], dmaTriggerIndex[(value >> 8) & 0xf]);
            break;
        case DMACTL1:
            /* DMA Control 1 */
            dmactl1 = value;
            break;
        default:
            /* must be word ??? */
            Channel c = channels[(address - DMAxCTL) / 8];
            c.write(address & 0x07, value);
        }
    }

    public int read(int address, boolean word, long cycles) {
        switch (address) {
        case DMACTL0:
            /* DMA Control 0 */
            return dmactl0;
        case DMACTL1:
            /* DMA Control 1 */
            return dmactl1; 
        default:
            /* must be word ??? */
            Channel c = channels[(address - DMAxCTL) / 8];
            return c.read(address & 7);
        }
    }

    public String info() {
        StringBuilder sb = new StringBuilder();
        sb.append("  DMACTL0: 0x" + Utils.hex16(dmactl0) + "  DMACTL1: 0x" + Utils.hex16(dmactl1));
        for (Channel c : channels) {
            sb.append("\n  ").append(c.info());
        }
        return sb.toString();
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/ConfigurationChangeListener.java`:

```java
/*
 * Copyright (c) 2010, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: StateChangeListener.java 729 2010-07-18 07:00:28Z nifi $
 *
 * -----------------------------------------------------------------
 *
 * StateChangeListener
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 17 jul 2010
 * Updated : $Date: 2010-07-18 09:00:28 +0200 (Sun, 18 Jul 2010) $
 *           $Revision: 729 $
 */


package se.sics.mspsim.core;

public interface ConfigurationChangeListener {
    
    public void configurationChanged(Object source, int configurationParam, int oldValue, int newValue);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/PortListenerProxy.java`:

```java
/*
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * PortListenerProxy
 *
 * Author  : Niclas Finne
 * Created : Tue Dec 7 18:25:00 2011
 */

package se.sics.mspsim.core;
import se.sics.mspsim.util.ArrayUtils;

public class PortListenerProxy implements PortListener {

    private PortListener[] portListeners;

    public PortListenerProxy(PortListener listen1, PortListener listen2) {
        portListeners = new PortListener[] { listen1, listen2 };
    }

    public static PortListener addPortListener(PortListener portListener, PortListener listener) {
        if (portListener == null) {
            return listener;
        }
        if (portListener instanceof PortListenerProxy) {
            return ((PortListenerProxy)portListener).add(listener);
        }
        return new PortListenerProxy(portListener, listener);
    }

    public static PortListener removePortListener(PortListener portListener, PortListener listener) {
        if (portListener == listener) {
            return null;
        }
        if (portListener instanceof PortListenerProxy) {
            return ((PortListenerProxy)portListener).remove(listener);
        }
        return portListener;
    }

    public PortListener add(PortListener mon) {
        portListeners = ArrayUtils.add(PortListener.class, portListeners, mon);
        return this;
    }

    public PortListener remove(PortListener listener) {
        PortListener[] listeners = ArrayUtils.remove(portListeners, listener);
        if (listeners == null) {
            return null;
        }
        if (listeners.length == 1) {
            return listeners[0];
        }
        portListeners = listeners;
        return this;
    }

    @Override
    public void portWrite(IOPort source, int data) {
        PortListener[] listeners = this.portListeners;
        for(PortListener l : listeners) {
            l.portWrite(source, data);
        }
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/EmulationLogger.java`:

```java
package se.sics.mspsim.core;

public interface EmulationLogger {

  /* warning mode for CPU errors such as unaligned word access */
  public enum WarningMode {SILENT, PRINT, EXCEPTION};

  /* warning types */
  public enum WarningType {
      EMULATION_ERROR, EXECUTION,
      MISALIGNED_READ, MISALIGNED_WRITE,
      ADDRESS_OUT_OF_BOUNDS_READ, ADDRESS_OUT_OF_BOUNDS_WRITE,
      ILLEGAL_IO_WRITE, VOID_IO_READ, VOID_IO_WRITE
  };
  
  public void log(Loggable source, String message);
  public void logw(Loggable source, WarningType type, String message) throws EmulationException;

  public WarningMode getDefaultWarningMode();
  public void setDefaultWarningMode(WarningMode mode);
  public WarningMode getWarningMode(WarningType type);
  public void setWarningMode(WarningType type, WarningMode mode);
  
  public void addLogListener(LogListener listener);
  public void removeLogListener(LogListener listener);
  
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/GenericUSCI.java`:

```java
package se.sics.mspsim.core;

import java.util.ArrayDeque;

import se.sics.mspsim.chip.I2CUnit.I2CData;


/** 
 * GenericUSCI - for newer MSP430's
 * 
 * @author Unknown
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public class GenericUSCI extends IOUnit implements DMATrigger, USARTSource {

    // USCI A/Bx common register offset
    public static final int CTL0 = 1; /* Is this really correct??? */
    public static final int CTL1 = 0;
    public static final int BR0 = 6;
    public static final int BR1 = 7;
    public static final int MCTL = 8;
    public static final int STAT = 0x0a;
    public static final int RXBUF = 0x0c;
    public static final int TXBUF = 0x0e;
    
    // i2C Registers
    public static final int I2COA = 0x10;
    public static final int I2CSA = 0x12; 

    // Interrupt related
    public static final int IE = 0x1c;
    public static final int IFG = 0x1d;
    public static final int IV = 0x1e;

    // Misc flags
    public static final int RXIFG = 0x01;
    public static final int TXIFG = 0x02;
    
    public static final int USCI_BUSY = 0x01;

    public static final int SWRST = 0x01;
    
    private USARTListener usartListener;

    private int ubr0;
    private int ubr1;

    protected int ie;
    protected int ifg;
    protected int iv = 2; /* TODO Implement me! */

    private int clockSource = 0;
    private int baudRate = 0;

    private int tickPerByte = 1000;
    private long nextTXReady = -1;
    private boolean transmitting = false;

    private int ctl0;
    private int ctl1;
    private int br0;
    private int br1;
    private int mctl;
    private int rxbuf;
    private int txbuf;
    private int stat;

    private boolean syncMode = false;

    /* always on for now - but SWRST controls it */
    private boolean moduleEnabled = true;

    private final int uartIndex;
    private final int vector;

    private TimeEvent txTrigger = new TimeEvent(0) {
        public void execute(long t) {
            // Ready to transmit new byte!
            handleTransmit(t);
        }
    };
	private boolean i2cEnabled;
	private boolean i2cTransmitter;
	private int i2cSlaveAddress;
	private int i2cOwnAddress;
	private boolean readyForNextTransmit;
	private boolean stopConditionPending;
	
	private ArrayDeque<Integer> txBuffer = new ArrayDeque<Integer>(100);

    public GenericUSCI(MSP430Core cpu, int uartIndex, int[] memory, MSP430Config config) {
        super(config.uartConfig[uartIndex].name, cpu, memory, config.uartConfig[uartIndex].offset);
        /* do some stuff ? */
        
        this.uartIndex = uartIndex;
        MSP430Config.UARTConfig uartConfig = config.uartConfig[uartIndex];

        /* both vectors are the same in modern MSP430 USCIs (f5xxx) */
        vector = uartConfig.rxVector;
        reset(0);
    }

    public void reset(int type) {
        nextTXReady = cpu.cycles + tickPerByte + 100;
        transmitting = false;
        clrBitIFG(RXIFG);
        setBitIFG(TXIFG); /* empty at start! */
        stat &= ~USCI_BUSY;
        moduleEnabled = true; //false;
        updateIV();
        txBuffer.clear();
      }

    void updateIV() {
        int bitval = 0x01;
        iv = 0;
        int ie_ifg = ifg & ie;
        for (int i = 0; i < 8; i++) {
            if ((bitval & ie_ifg) > 0) {
                iv = 2 + i * 2;
                break;
            }
            bitval = bitval << 1;
        }
        //System.out.println("*** Setting IV to: " + iv + " ifg: " + ifg);
    }
    
    protected void setBitIFG(int bits) {
        ifg |= bits;

        // TODO: implement DMA... 
        //        if (dma != null) {
        //            /* set bit first, then trigger DMA transfer - this should
        //             * be made via a 1 cycle or so delayed action */
        //            if ((bits & urxifg) > 0) dma.trigger(this, 0);
        //            if ((bits & utxifg) > 0) dma.trigger(this, 1);
        //        }
        updateIV();
        if ((ifg & ie) > 0) cpu.flagInterrupt(vector, this, true);
    }

    protected void clrBitIFG(int bits) {
        ifg &= ~bits;
        /* if no more interrupts here - turn off... */
        updateIV();
        if ((ifg & ie) == 0) cpu.flagInterrupt(vector, this, false);
    }

    protected int getIFG() {
        return ifg;
    }

    private boolean isIEBitsSet(int bits) {
        return (bits & ie) != 0;
    }
    
    private void handleTransmit(long cycles) {
        if (cpu.getMode() >= MSP430Core.MODE_LPM3) {
            System.out.println(getName() + " Warning: USART transmission during LPM!!! ");
        }
        
        if (transmitting) {
            /* in this case we have shifted out the last character */
            USARTListener listener = this.usartListener;
            if (listener != null && !txBuffer.isEmpty()) {
            	int t = txBuffer.remove();
                listener.dataReceived(this, t);
                
                if (i2cEnabled) {  
                	if ((t & I2CData.START) > 0) {
                		ctl1 &= ~0x02;
                	} else if ((t & I2CData.STOP) > 0) { 
                		ctl1 &= ~0x04;
                	}
                }
            }
            /* nothing more to transmit after this - stop transmission */
            if (txBuffer.isEmpty()) {
        		/* ~BUSY - nothing more to send - and last data already in RX */
            	stat &= ~USCI_BUSY;
        		transmitting = false;
        		setBitIFG(TXIFG);
            }
        }

        /* any more chars to transmit? */
        if (!txBuffer.isEmpty()) {
            /* txbuf always empty after this */
            clrBitIFG(TXIFG);
            transmitting = true;
            nextTXReady = cycles + tickPerByte + 1;
            cpu.scheduleCycleEvent(txTrigger, nextTXReady);
        }

        if (DEBUG) {
            if (isIEBitsSet(TXIFG)) {
                log(" flagging on transmit interrupt");
            }
            log(" Ready to transmit next at: " + cycles);
        }
    }


    protected void updateBaudRate() {
        int div = ubr0 + (ubr1 << 8);
        if (div == 0) {
            div = 1;
        }
        if (clockSource == MSP430Constants.CLK_ACLK) {
            if (DEBUG) {
                log(" Baud rate is (bps): " + cpu.aclkFrq / div + " div = " + div);
            }
            baudRate = cpu.aclkFrq / div;
        } else {
            if (DEBUG) {     
                log(" Baud rate is (bps): " + cpu.smclkFrq / div + " div = " + div);
            }
            baudRate = cpu.smclkFrq / div;
        }
        if (baudRate == 0) baudRate = 1;
        // Is this correct??? Is it the DCO or smclkFRQ we should have here???
        tickPerByte = (8 * cpu.smclkFrq) / baudRate;
        if (DEBUG) {
            log(" Ticks per byte: " + tickPerByte);
        }
    }


    public void interruptServiced(int vector) {
    }

    // Only 8 bits / read!
    public void write(int address, int data, boolean word, long cycles) {
      address = address - offset;

      // Indicate ready to write!!! - this should not be done here...
//      System.out.println(">>>> Write to " + getName() + " at " +
//              address + " = " + data);
      switch (address) {
      case CTL0:
        syncMode = (data & 0x01) > 0;
        i2cEnabled = (data & 0x06) == 0x06;
        if (DEBUG) log(" write to UxxCTL0 " + data);
        break;
      case CTL1:
          /* emulate the reset */
          if ((ctl1 & SWRST) == SWRST && (data & SWRST) == 0)
              reset(0);
          moduleEnabled = (data & SWRST) == 0;
          if (DEBUG) log(" write to UxxCTL1 " + data + " => ModEn:" + moduleEnabled);

          if (((data >> 6) & 3) == 1) {
              clockSource = MSP430Constants.CLK_ACLK;
              if (DEBUG) {
                  log(" Selected ACLK as source");
              }
          } else {
              clockSource = MSP430Constants.CLK_SMCLK;
              if (DEBUG) {
                  log(" Selected SMCLK as source");
              }
          }
          updateBaudRate();
          
          /*
           * When in I2C mode and an start or stop condition is reached
           * just transmit the corresponding signals.
           */
          if (i2cEnabled) {
        	  if ((data & 0x04) > 0 && (ctl1 & 0x04) == 0) { // stop condition
        		  txBuffer.add(I2CData.STOP);
        	  } 
        	  if ((data & 0x02) > 0 && (ctl1 & 0x02) == 0) {
        		  i2cTransmitter = (data & 0x10) == 0x10;
        		  /* Transmit a start condition START|ADDR|R/W */
        		  int t = I2CData.START;
        		  t |= i2cSlaveAddress << 1;
        		  t |= i2cTransmitter ? 1 : 0;
        		  txBuffer.add(t);
        		  rxbuf = 0;
        	  } 
        	  clrBitIFG(TXIFG);
        	  stat |= USCI_BUSY;
              if (!transmitting) {
                  nextTXReady = cycles + 1; //tickPerByte + 3;
                  cpu.scheduleCycleEvent(txTrigger, nextTXReady);
              }
          }
          
          ctl1 = data;
          
          break;
      case MCTL:
        mctl = data;
        if (DEBUG) log(" write to UMCTL " + data);
        break;
      case BR0:
        ubr0 = data;
        updateBaudRate();
        break;
      case BR1:
        ubr1 = data;
        updateBaudRate();
        break;
      case STAT:
          //ustat = data;
        break;
      case IE:
          ie = data;
        break;
      case TXBUF:
        if (DEBUG) log(": USART_UTXBUF:" + (char) data + " = " + data + "\n");
        if (moduleEnabled) {
          // Interruptflag not set!
          clrBitIFG(TXIFG);
          /* the TX is no longer empty ! */
          stat |= USCI_BUSY;
          /* should the interrupt be flagged off here ? - or only the flags */
          if (DEBUG) log(" flagging off transmit interrupt");
          //      cpu.flagInterrupt(transmitInterrupt, this, false);

          // Schedule on cycles here
          // TODO: adding 3 extra cycles here seems to give
          // slightly better timing in some test...
          txBuffer.add(data);
          if (!transmitting) {
              /* how long time will the copy from the TX_BUF to the shift reg take? */
              /* assume 3 cycles? */
              nextTXReady = cycles + tickPerByte + 1; //tickPerByte + 3;
              cpu.scheduleCycleEvent(txTrigger, nextTXReady);
          }
        } else {
          log("Ignoring UTXBUF data since TX not active...");
        }
        txbuf = data;
        break;
        
      case I2CSA:
    	i2cSlaveAddress = data & 0x3ff;
    	break;
    	
      case I2COA:
    	i2cOwnAddress = data & 0x3ff;
    	break;
      }
    }

    public int read(int address, boolean word, long cycles) {
        int op = address - offset;
        switch (op) {
        case CTL0:
            return ctl0;
        case CTL1:
            return ctl1;
        case BR0:
            return br0;
        case BR1:
            return br1;
        case TXBUF:
            return txbuf;
        case RXBUF:
            int tmp = rxbuf;
            // When byte is read - the interruptflag is cleared!
            // and error status should also be cleared later...
            // is this cleared also on the MSP430x5xx series???
            if (MSP430Constants.DEBUGGING_LEVEL > 0) {
                log(" clearing rx interrupt flag " + cpu.getPC() + " byte: " + tmp);
            }
            clrBitIFG(RXIFG);
            /* This should be changed to a state rather than an "event" */
            /* Force callback since this is not used as a state */
            stateChanged(USARTListener.RXFLAG_CLEARED, true);
            
            /* For timing issues we have to send the ACK after reading the
             * register */
            if (i2cEnabled && !i2cTransmitter) {
        		txBuffer.add(I2CData.ACK);
        		stat |= USCI_BUSY;
                if (!transmitting) {
                    /* how long time will the copy from the TX_BUF to the shift reg take? */
                    /* assume 3 cycles? */
                    nextTXReady = cpu.cpuCycles + tickPerByte + 1; //tickPerByte + 3;
                    cpu.scheduleCycleEvent(txTrigger, nextTXReady);
                }
            }
            
            return tmp;
        case MCTL:
            return mctl;
        case STAT:
            return stat;
        case IE:
            return ie;
        case IFG:
            return ifg;
        case IV:
            return iv;
        }
        return 0;
    }

    /* reuse USART listener API for USCI */
    @Override
    public synchronized void addUSARTListener(USARTListener listener) {
        usartListener = USARTListener.Proxy.INSTANCE.add(usartListener, listener);
    }

    @Override
    public synchronized void removeUSARTListener(USARTListener listener) {
        usartListener = USARTListener.Proxy.INSTANCE.remove(usartListener, listener);
    }

    /*  default behavior assumes UART/SPI config */
    public boolean isReceiveFlagCleared() {
        return (ifg & RXIFG) == 0;
    }

    // A byte have been received!
    // This needs to be complemented with a method for checking if the USART
    // is ready for next byte (readyForReceive) that respects the current speed
    public void byteReceived(int b) {
        //System.out.println(getName() + " byte received: " + b);

        if (DEBUG) {
            log("byteReceived: " + b + " " + (char) b);
        }
        
        /* Ignore i2c ACK messages */
        if (i2cEnabled && b == I2CData.ACK) {
			return;
        }
        
        rxbuf = b & 0xff;
        
        // Indicate interrupt also!
        setBitIFG(RXIFG);

        // Check if the IE flag is enabled! - same as the IFlag to indicate!
        if (isIEBitsSet(RXIFG)) {
            if (DEBUG) {
                log(" flagging receive interrupt ");
            }
        }
    }

    /* TODO: IMPLEMENT DMA! */
    public void setDMA(DMA dma) {
    }

    public boolean getDMATriggerState(int index) {
        return false;
    }

    public void clearDMATrigger(int index) {
    }

    public String info() {
        return "UTXIE: " + isIEBitsSet(TXIFG) + "  URXIE:" + isIEBitsSet(RXIFG) + "\n" +
        "UTXIFG: " + ((getIFG() & TXIFG) > 0) + "  URXIFG:" + ((getIFG() & RXIFG) > 0);
    }
        
    public int getBaudRate() {
    	return tickPerByte;
    }
    
    protected void vlog(String msg) {
    	if (i2cEnabled) {
    		System.out.println("USCI "+msg);
    	}
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Profiler.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * MSP430
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;
import java.io.PrintStream;
import java.util.Properties;

import se.sics.mspsim.profiler.CallListener;
import se.sics.mspsim.util.MapEntry;

public interface Profiler {

  public static final String PARAM_FUNCTION_NAME_REGEXP = "function.regexp";
  public static final String PARAM_PROFILE_CALLERS = "showcallers";
  public static final String PARAM_SORT_MODE = "sortmode";
  
  public void setCPU(MSP430Core cpu);

  public void profileCall(MapEntry entry, long cycles, int from);
  public void profileReturn(long cycles);
  public void profileInterrupt(int vector, long cycles);
  public void profileRETI(long cycles);

  public void resetProfile();
  public void clearProfile();

  public void addCallListener(CallListener listener);
  public void removeCallListener(CallListener listener);
  
  public void printProfile(PrintStream out);

  public void printProfile(PrintStream out, Properties parameters);

  public void printStackTrace(PrintStream out);
  
  /* function call logging */
  public void setLogger(PrintStream out);

  public String getCall(int i);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/PortListener.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * PortListener
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

public interface PortListener {
  public void portWrite(IOPort source, int data);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/ADCInput.java`:

```java
package se.sics.mspsim.core;

public interface ADCInput {
  public int nextData();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/IOSegment.java`:

```java
package se.sics.mspsim.core;

import java.util.Arrays;
import se.sics.mspsim.util.Utils;

public class IOSegment implements Memory {

    private final MSP430Core core;
    private final IOUnit[] mem;
    private final IOUnit voidIO;

    IOSegment(MSP430Core core, int maxMemIO, IOUnit voidIO) {
        this.core = core;
        this.voidIO = voidIO;
        this.mem = new IOUnit[maxMemIO];
        Arrays.fill(mem, voidIO);
    }

    void setIORange(int address, int range, IOUnit io) {
//        System.out.println("IO: 0x" + Utils.hex(address, 4) + "-"
//                + Utils.hex(address + range - 1, 4) + ": " + io.id);
        for (int i = 0; i < range; i++) {
//            if (mem[address + i] != voidIO) {
//                System.err.println("Warning, IO unit already set: 0x"
//                        + Utils.hex(address + i, 4)
//                        + " (" + io.id + " => " + mem[address + i].id + ')');
//                throw new IllegalStateException("IO unit already set: 0x"
//                        + Utils.hex(address + i, 4)
//                        + " (" + io.id + " => " + mem[address + i].id + ')');
//            }
            mem[address + i] = io;
        }
    }

    @Override
    public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
        boolean word = mode != AccessMode.BYTE;
        // Only word reads at 0x1fe which is highest address...
        int val = mem[address].read(address, word, core.cycles);
        if (mode == AccessMode.WORD20) {
            val |= mem[address + 2].read(address, word, core.cycles) << 16;
        }
        return val;
    }

    @Override
    public void write(int dstAddress, int data, AccessMode mode) throws EmulationException {
        boolean word = mode != AccessMode.BYTE;

        if (!word) data &= 0xff;
        mem[dstAddress].write(dstAddress, data & 0xffff, word, core.cycles);
        if (mode == AccessMode.WORD20) {
            mem[dstAddress].write(dstAddress + 2, data >> 16, word, core.cycles);
        }
    }

    @Override
    public int get(int address, AccessMode mode) {
        return read(address, mode, AccessType.READ);
    }

    @Override
    public void set(int address, int data, AccessMode mode) {
        write(address, data, mode);
    }

    public String info() {
        StringBuilder sb = new StringBuilder();
        sb.append("IOSegment[0x0000-").append(Utils.hex(mem.length, 4)).append("]\n");

        int start = 0;
        for (int i = 1; i < mem.length; i++) {
            if (mem[i] != mem[i - 1]) {
                sb.append(" 0x").append(Utils.hex(start, 4))
                .append("-").append(Utils.hex(i - 1, 4))
                .append(": ").append(mem[i - 1].id).append(" (")
                .append(mem[i - 1].name).append(")\n");
                start = i;
            }
        }
        return sb.toString();
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Chip.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Chip
 *
 * Author  : Joakim Eriksson
 * Created : 17 jan 2008
 */
package se.sics.mspsim.core;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.ArrayUtils;

/**
 * @author Joakim Eriksson, SICS
 * TODO: add a detailed state too (including a listener). State is not necessarily 
 * related to energy consumption, etc. but more detailed state of the Chip.
 * LPM1,2,3 / ON is OperatingModes as well as Transmitting, Listening and Off.
 * State can be things such as search for SFD (which is in mode Listen for CC2420).
 */
public abstract class Chip implements Loggable, EventSource {

  protected final String id;
  protected final String name;
  protected final MSP430Core cpu;

  private OperatingModeListener[] omListeners;
  private StateChangeListener stateListener;
  private ConfigurationChangeListener[] ccListeners;

  private EventListener eventListener;
  protected boolean sendEvents = false;
  private String[] modeNames = null;
  private int mode;
  private int chipState;
  protected EmulationLogger logger;
  protected boolean DEBUG = false;
  protected int logLevel;

  public Chip(String id, MSP430Core cpu) {
    this(id, id, cpu);
  }

  public Chip(String id, String name, MSP430Core cpu) {
    this.id = id;
    this.name = name;
    this.cpu = cpu;
    if (cpu != null) {
      logger = cpu.getLogger();
      cpu.addChip(this);
    }
  }

  public void notifyReset() {
  }

  public synchronized void addOperatingModeListener(OperatingModeListener listener) {
    omListeners = ArrayUtils.add(OperatingModeListener.class, omListeners, listener);
  }
  
  public synchronized void removeOperatingModeListener(OperatingModeListener listener) {
    omListeners = ArrayUtils.remove(omListeners, listener);
  }

  public synchronized void addStateChangeListener(StateChangeListener listener) {
      stateListener = StateChangeListener.Proxy.INSTANCE.add(stateListener, listener);
  }

  public synchronized void removeStateChangeListener(StateChangeListener listener) {
      stateListener = StateChangeListener.Proxy.INSTANCE.remove(stateListener, listener);
  }

  public synchronized void addConfigurationChangeListener(ConfigurationChangeListener listener) {
      ccListeners = ArrayUtils.add(ConfigurationChangeListener.class, ccListeners, listener);
  }

  public synchronized void removeConfigurationChangeListener(ConfigurationChangeListener listener) {
      ccListeners = ArrayUtils.remove(ccListeners, listener);
  }

  public int getMode() {
    return mode;
  }

  protected void setMode(int mode) {
    if (mode != this.mode) {
      this.mode = mode;
      OperatingModeListener[] listeners = omListeners;
      if (listeners != null) {
        for (int i = 0, n = listeners.length; i < n; i++) {
          listeners[i].modeChanged(this, mode);
        }
      }
    }
  }

  protected void setModeNames(String[] names) {
    modeNames = names;
  }

  public synchronized void addEventListener(EventListener listener) {
      eventListener = EventListener.Proxy.INSTANCE.add(eventListener, listener);
      sendEvents = eventListener != null;
  }

  public synchronized void removeEventListener(EventListener listener) {
      eventListener = EventListener.Proxy.INSTANCE.add(eventListener, listener);
      sendEvents = eventListener != null;
  }

  protected void sendEvent(String event, Object data) {
    EventListener listener = this.eventListener;
    if (listener != null) {
        listener.event(this, event, data);
    }
  }
  
  public String getModeName(int index) {
    if (modeNames == null) {
      return null;
    }
    return modeNames[index];
  }

  public int getModeByName(String mode) {
    if (modeNames != null) {
      for (int i = 0; i < modeNames.length; i++) {
        if (mode.equals(modeNames[i])) return i;
      }
    }
    try {
      // If it is just an integer it can be parsed!
      int modei = Integer.parseInt(mode);
      if (modei >= 0 && modei <= getModeMax()) {
        return modei;
      }
    } catch (Exception e) {
    }
    return -1;
  }

  /* Called by subclasses to inform about changes of state */
  protected void stateChanged(int newState) {
      if (chipState != newState) {
          int oldState = chipState;
          chipState = newState;
          /* inform listeners */
          StateChangeListener listener = stateListener;
          if (listener != null) {
              listener.stateChanged(this, oldState, chipState);
          }
      }
  }
  
  /* Called by subclasses to inform about changes of configuration */
  protected void configurationChanged(int parameter, int oldValue, int newValue) {
      ConfigurationChangeListener[] listeners = ccListeners;
      if (oldValue != newValue && listeners != null) {
          for (int i = 0, n = listeners.length; i < n; i++) {
              listeners[i].configurationChanged(this, parameter, oldValue, newValue);
          }
      }
  }

  /* interface for getting hold of configuration values - typically mapped to some kind of address */
  public abstract int getConfiguration(int parameter);
  
  
  public String getID() {
    return id;
  }

  public String getName() {
    return name;
  }

  public abstract int getModeMax();

  /* By default the cs is set high */
  public boolean getChipSelect() {
    return true;
  }
  
  public String info() {
    return "* no info";
  }

  public int getLogLevel() {
      return logLevel;
  }

  public void setLogLevel(int l) {
      logLevel = l;
      DEBUG = logLevel == Loggable.DEBUG;
  }
  
  protected void log(String msg) {
      logger.log(this, msg);
  }

  /* warn about anything above severe - but what types are severe? */
  protected void logw(WarningType type, String msg) {
      logger.logw(this, type, msg);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/PMM.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.core;

public class PMM extends IOUnit {
    public static int SIZE = 32;

    /*
     * This is only a stub to avoid immediate Mspsim exceptions. TODO XXX:
     * Implement me!
     */

    private int baseAddress;

    public PMM(MSP430Core cpu, int[] memory, int address) {
        super("PMM", "PMM", cpu, memory, address);
        baseAddress = address;
        reset(0);
    }

    public void reset(int type) {
        /* Initial values */
        memory[baseAddress + 0x0] = 0x9600; /* PMMCTL0 */
        memory[baseAddress + 0x2] = 0x0000; /* PMMCTL1 */
        memory[baseAddress + 0x4] = 0x4400; /* SVSMHCTL */
        memory[baseAddress + 0x6] = 0x4400; /* SVSMLCTL */
        memory[baseAddress + 0x8] = 0x0020; /* SVSMIO */
        memory[baseAddress + 0xc] = 0x0000; /* PMMIFG */
        memory[baseAddress + 0xe] = 0x1100; /* PMMRIE */
    }

    public void write(int address, int value, boolean word, long cycles) {
        if (DEBUG)
            log(this.getName() + ": Write to: "
                    + String.format("0x%05x = 0x%05x", address, value));

        memory[address] = value;
    }

    public int read(int address, boolean word, long cycles) {
        if (address == baseAddress + 0xc) {
            /* PMMIFG always settled */
            int SVSMLDLYIFG = 0x01;
            int SVSMHDLYIFG = 0x10;
            int SVMHVLRIFG = 0x40;
            memory[address] |= SVSMLDLYIFG | SVSMHDLYIFG | SVMHVLRIFG;
        }

        if (DEBUG) {
            log(this.getName()
                    + ": Read from: "
                    + String.format("0x%05x = 0x%05x", address, memory[address]));
        }

        return memory[address];
    }

    public void interruptServiced(int vector) {
        if (DEBUG) {
            log(this.getName() + ": Interrupt services vector: " + vector);
        }
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/CRC16.java`:

```java
/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */
package se.sics.mspsim.core;


/**
 * CRC16 module for the MSP430
 * 
 * @author Victor Ariño <victor.arino@tado.com>
 */
public class CRC16 extends IOUnit {

	/**
	 * Address and size for IO configuration
	 */
	public static final int OFFSET = 0x0150;
	public static final int SIZE = 8;

	/**
	 * Register offsets definition as in the documentation.
	 */
	public static final int CRCDI = 0;
	public static final int CRCDIRB = 0x2;
	public static final int CRCINIRES = 0x4;
	public static final int CRCRESR = 0x6;

	/**
	 * Initial seed as recommended by CCITT
	 */
	private static final int CCITTSeed = 0xFFFF;

	/**
	 * CRC16 peripheral for the MSP430 using the default memory offset
	 * 
	 * @param cpu
	 */
	public CRC16(MSP430Core cpu) {
		this(cpu, OFFSET);
	}

	/**
	 * CRC16 peripheral for the MSP430
	 * 
	 * @param cpu
	 *           CPU core
	 * @param offset
	 *           Address offset, by default is 0x0150
	 */
	public CRC16(MSP430Core cpu, int offset) {
		super("CRC16", cpu, cpu.memory, offset);
		setLogLevel(Loggable.DEBUG);
	}

	/**
	 * CRC16 CCITT Java implementation
	 * 
	 * @author Víctor Ariño <victor.arino@tado.com>
	 */
	private static class CRC16Java {
		private int crc = CCITTSeed;
		private int polynomial = 0x1021; // 0001 0000 0010 0001 (0, 5, 12)

		/**
		 * Adds one byte to the CRC computation
		 * 
		 * @param b
		 *           byte to add
		 */
		protected void process(byte b) {
			for (int i = 0; i < 8; i++) {
				boolean bit = ((b >> (7 - i) & 1) == 1);
				boolean c15 = ((crc >> 15 & 1) == 1);
				crc <<= 1;
				if (c15 ^ bit)
					crc ^= polynomial;
			}
		}

		/**
		 * Add one byte in reverse way
		 * 
		 * @param b
		 *           byte to add
		 */
		protected void processRb(byte b) {
			process(reflectByte(b));
		}

		/**
		 * Set the seed of the CRC
		 * 
		 * @param seed
		 */
		protected void reset(int seed) {
			crc = seed;
		}

		/**
		 * Get computed CRC
		 * 
		 * @return
		 */
		protected int getCRC() {
			return crc;
		}

		/**
		 * Reflect a byte
		 * 
		 * @author Valentin Sawadski <valentin@tado.com>
		 * @param b
		 *           byte to reflect
		 * @return reversed byte
		 */
		private byte reflectByte(byte b) {
			byte ret = 0;
			for (int i = 0; i < 8; i++) {
				if ((b & (1 << i)) == (1 << i)) {
					ret += (1 << (7 - i));
				}
			}
			return ret;
		}

		/**
		 * Reflect all bytes of the CRC
		 * 
		 * @author Valentin Sawadski <valentin@tado.com>
		 * @param crc
		 * @return crc reversed
		 */
		private int reflectCrcBytewise(int crc) {
			int lowByte = reflectByte((byte) (crc & 0xFF)) & 0xFF;
			int highByte = reflectByte((byte) ((crc & 0xFF00) >> 8)) & 0xFF;
			return ((highByte << 8) + lowByte) & 0xFFFF;
		}

		/**
		 * Swap two bytes
		 * 
		 * @author Valentin Sawadski <valentin@tado.com>
		 * @param crc
		 * @return swapped bytes
		 */
		private int swapBytes(int crc) {
			int lowByte = crc & 0xFF;
			int highByte = crc & 0xFF00;
			return ((lowByte << 8) + (highByte >> 8)) & 0xFFFF;
		}

		/**
		 * Get the CRC reversed
		 * 
		 * @return reversed crc
		 */
		protected int getCrcRb() {
			return swapBytes(reflectCrcBytewise(crc));
		}
	}

	private CRC16Java crc = new CRC16Java();

	/**
	 * Clear everything when reset
	 */
	public void reset(int type) {
		crc.reset(CCITTSeed);
	}

	/**
	 * The registers are written
	 */
	public void write(int address, int value, boolean word, long cycles) {
		/*
		 * The offset variable is used in case the peripheral changes the base
		 * address in some microcontroller model
		 */
		switch (address - offset) {
		case CRC16.CRCDI:
			if (word) {
				int hi = (value >> 8) & 0x00ff;
				int lo = (value) & 0x00ff;
				crc.processRb((byte) lo);
				crc.processRb((byte) hi);
			} else {
				crc.processRb((byte) value);
			}
			break;
		case CRC16.CRCDIRB:
			if (word) {
				int hi = (value >> 8) & 0x00ff;
				int lo = (value) & 0x00ff;
				crc.process((byte) hi);
				crc.process((byte) lo);
			} else {
				crc.process((byte) value);
			}
			break;
		case CRC16.CRCINIRES:
			crc.reset(value & 0xffff);
			break;
		}
	}

	/**
	 * Registers are read
	 */
	public int read(int address, boolean word, long cycles) {
		switch (address - offset) {
		case CRC16.CRCINIRES:
			return crc.getCRC();
		case CRC16.CRCRESR:
			return crc.getCrcRb();
		}
		return 0;
	}

	public void interruptServiced(int vector) {
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/MSP430.java`:

```java
 /**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * MSP430
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import java.io.PrintStream;

import se.sics.mspsim.profiler.SimpleProfiler;
import se.sics.mspsim.util.ArrayUtils;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.MapTable;

public class MSP430 extends MSP430Core {

  private int[] execCounter;
  private int[] trace;
  private int tracePos;
  
  private boolean debug = false;
  private boolean running = false;
  private boolean isBreaking = false;
  private double rate = 2.0;

  // Debug time - measure cycles
  private long lastCycles = 0;
  private long lastCpuCycles = 0;
  private long time;
  private long nextSleep = 0;
  private long nextOut = 0;

  private double lastCPUPercent = 0d;

  private DisAsm disAsm;

  private SimEventListener[] simEventListeners;

  /**
   * Creates a new <code>MSP430</code> instance.
   *
   */
  public MSP430(int type, ComponentRegistry registry, MSP430Config config) {
    super(type, registry, config);
    disAsm = new DisAsm();
  }

  public double getCPUPercent() {
    return lastCPUPercent;
  }

  public DisAsm getDisAsm() {
    return disAsm;
  }

  public void cpuloop() throws EmulationException {
    if (isRunning()) {
      throw new IllegalStateException("already running");
    }
    setRunning(true);
    try {
        // ??? - power-up  should be executed?!
        time = System.currentTimeMillis();
        run();
    } finally {
        setRunning(false);
    }
  }

  private void run() throws EmulationException {
      while (!isStopping) {

      if (cycles > nextOut && !debug) {
	printCPUSpeed(reg[PC]);
	nextOut = cycles + 20000007;
      }

      int pc = emulateOP(-1);
      if (pc >= 0) {
	if (execCounter != null) {
	  execCounter[pc]++;
	}
	if (trace != null) {
	    trace[tracePos++] = pc;
	    if (tracePos >= trace.length)
		tracePos = 0;
	}
	// -------------------------------------------------------------------
	// Debug information
	// -------------------------------------------------------------------
	if (debug) {
	    if (servicedInterrupt >= 0) {
	        disAsm.disassemble(pc, memory, reg, servicedInterrupt);
	    } else {
	        disAsm.disassemble(pc, memory, reg);
	    }
	}
      }

      /* Just a test to see if it gets down to a reasonable speed */
      if (cycles > nextSleep) {
	try {
	  Thread.sleep(100);
	} catch (Exception e) {
	}
	// Frequency = 100 * cycles ratio
	// Ratio = Frq / 100
	nextSleep = cycles + (long)(rate * dcoFrq / 10);
      }

//       if ((instruction & 0xff80) == CALL) {
// 	System.out.println("Call to PC = " + reg[PC]);
//       }
    }
    isStopping = isBreaking = false;
  }

  /* Use stepInstructions or stepMicros instead */
  @Deprecated public long step() throws EmulationException {
    return stepMicros(1, 1);
  }

  public long stepInstructions(int count) throws EmulationException {
    if (isRunning()) {
      throw new IllegalStateException("step not possible when CPU is running");
    }
    setRunning(true);
    try {
    while (count > 0 && !isStopping) {
      int pc = emulateOP(-1);
      if (pc >= 0) {
        count--;
        if (execCounter != null) {
          execCounter[pc]++;
        }
        if (trace != null) {
  	  trace[tracePos++] = pc;
          if (tracePos >= trace.length) {
            tracePos = 0;
          }
        }

        // -------------------------------------------------------------------
        // Debug information
        // -------------------------------------------------------------------
        if (debug) {
            if (servicedInterrupt >= 0) {
                disAsm.disassemble(pc, memory, reg, servicedInterrupt);
            } else {
                disAsm.disassemble(pc, memory, reg);
            }
        }
      }
    }
    } finally { 
        setRunning(false);
    }
    isStopping = isBreaking = false;
    return cycles;
  }
  
  /* this represents the micros time that was "promised" last time */
  /* NOTE: this is a delta compared to "current micros" 
   */
  long lastReturnedMicros;
  long lastMicrosCycles;
  boolean microClockReady = false;

  /* when DCO has changed speed, this method will be called */
  protected void dcoReset() {
      microClockReady = false;
  }
  
  /* 
   * Perform a single step (even if in LPM) but no longer than to maxCycles + 1 instr
   * Note: jumpMicros just jump the clock until that time
   * executeMicros also check eventQ, etc and executes instructions
   */
  long maxCycles = 0;
  public long stepMicros(long jumpMicros, long executeMicros) throws EmulationException {
    if (isRunning()) {
      throw new IllegalStateException("step not possible when CPU is running");
    }

    if (jumpMicros < 0) {
      throw new IllegalArgumentException("Can not jump a negative time: " + jumpMicros);
    }
    /* quick hack - if microdelta == 0 => ensure that we have correct zery cycles
     */
    if (!microClockReady) {
      lastMicrosCycles = maxCycles;
    }
    
    // Note: will be reset during DCO-syncs... => problems ???
    lastMicrosDelta += jumpMicros;

    if (microClockReady) {
    /* check that we did not miss any events (by comparing with last return value) */
    maxCycles = lastMicrosCycles + (lastMicrosDelta * dcoFrq) / 1000000;
    if (cpuOff) {
      if(maxCycles > nextEventCycles) {
        /* back this time again... */
        lastMicrosDelta -= jumpMicros;
        printEventQueues(System.out);
        throw new IllegalArgumentException("Jumping to a time that is further than possible in LPM maxCycles:" + 
            maxCycles + " cycles: " + cycles + " nextEventCycles: " + nextEventCycles);
      }
    } else if (maxCycles > cycles) {
      /* back this time again... */
      lastMicrosDelta -= jumpMicros;
      throw new IllegalArgumentException("Jumping to a time that is further than possible not LPM maxCycles:" + 
          maxCycles + " cycles: " + cycles);
    }

    }
    microClockReady = true;

    /* run until this cycle time */
    maxCycles = lastMicrosCycles + ((lastMicrosDelta + executeMicros) * dcoFrq) / 1000000;
    /*System.out.println("Current cycles: " + cycles + " additional micros: " + (jumpMicros) +
          " exec micros: " + executeMicros + " => Execute until cycles: " + maxCycles);*/


    while (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
        int pc = emulateOP(maxCycles);
        if (pc >= 0) {
            if (execCounter != null) {
                execCounter[pc]++;
            }
            if (trace != null) {
              if (tracePos >= trace.length) {
                tracePos = 0;
              }
              trace[tracePos++] = pc;
            }
            // -------------------------------------------------------------------
            // Debug information
            // -------------------------------------------------------------------
            if (debug) {
              if (servicedInterrupt >= 0) {
                disAsm.disassemble(pc, memory, reg, servicedInterrupt);
              } else {
                disAsm.disassemble(pc, memory, reg);
              }
            }
        }

        if (isStopping) {
            isStopping = false;
            if (cycles < maxCycles || (cpuOff && (nextEventCycles < cycles))) {
                // Did not complete the execution cycle
                lastMicrosDelta -= jumpMicros;
            }
            if (isBreaking) {
                isBreaking = false;
                throw new BreakpointException();
            }
            lastReturnedMicros = 0;
            return 0;
        }
    }

    if (cpuOff && !(interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0)) {
      lastReturnedMicros = (1000000 * (nextEventCycles - cycles)) / dcoFrq;
    } else {
      lastReturnedMicros = 0;
    }
    
    if(cycles < maxCycles) {
      throw new RuntimeException("cycles < maxCycles : " + cycles + " < " + maxCycles);
    }
    if(lastReturnedMicros < 0) {
      throw new RuntimeException("lastReturnedMicros < 0 : " + lastReturnedMicros);
    }

    return lastReturnedMicros;
  }

  public void stop() {
      isStopping = true;
  }

  public void triggBreakpoint() {
      isBreaking = true;
      stop();
  }

  public int getDCOFrequency() {
    return dcoFrq;
  }
  public int getExecCount(int address) {
    if (execCounter != null) {
      return execCounter[address];
    }
    return 0;
  }

  public void setMonitorExec(boolean mon) {
    if (mon) {
      if (execCounter == null) {
	execCounter = new int[MAX_MEM];
      }
    } else {
      execCounter = null;
    }
  }

  public void setTrace(int size) {
      if (size == 0) {
	  trace = null;
      } else {
	  trace = new int[size];
      }
      tracePos = 0;
  }
  
  public int getBackTrace(int pos) {
      int tPos = tracePos - pos - 1;
      if (tPos < 0) {
	  tPos += trace.length;
      }
      return trace[tPos];
  }
  
  public int getTraceSize() {
      return trace == null ? 0 : trace.length;
  }

  
  private void printCPUSpeed(int pc) {
    // Passed time
    int td = (int)(System.currentTimeMillis() - time);
    // Passed total cycles
    long cd = (cycles - lastCycles);
    // Passed "active" CPU cycles
    long cpud = (cpuCycles - lastCpuCycles);

    if (td == 0 || cd == 0) {
      return;
    }

    if (DEBUGGING_LEVEL > 0) {
      System.out.println("Elapsed: " + td
			 +  " cycDiff: " + cd + " => " + 1000 * (cd / td )
			 + " cyc/s  cpuDiff:" + cpud + " => "
			 + 1000 * (cpud / td ) + " cyc/s  "
			 + (10000 * cpud / cd)/100.0 + "%");
    }
    lastCPUPercent = (10000 * cpud / cd) / 100.0;
    time = System.currentTimeMillis();
    lastCycles = cycles;
    lastCpuCycles = cpuCycles;
    if (DEBUGGING_LEVEL > 0) {
      disAsm.disassemble(pc, memory, reg);
    }
  }

  public void generateTrace(PrintStream out) {
    if (profiler != null && out != null) {
      profiler.printStackTrace(out);
    }
  }
  
  public boolean getDebug() {
    return debug;
  }

  public void setDebug(boolean db) {
    debug = db;
  }

  public void setMap(MapTable map) {
    this.map = map;
    /* When we got the map table we can also profile! */
    if (profiler == null) {
      setProfiler(new SimpleProfiler());
      profiler.setCPU(this);
    }
  }

  private void setRunning(boolean running) {
    if (this.running != running) {
      this.running = running;
      if (running) {
          isStopping = false;
          isBreaking = false;
      }
      SimEventListener[] listeners = this.simEventListeners;
      if (listeners != null) {
        SimEvent.Type type = running ? SimEvent.Type.START : SimEvent.Type.STOP;
        SimEvent event = new SimEvent(type);
        for(SimEventListener l : listeners) {
          l.simChanged(event);
        }
      }
    }
  }

  public boolean isRunning() {
    return running;
  }

  public double getExecutionRate() {
    return rate;
  }

  public void setExecutionRate(double rate) {
    this.rate = rate;
  }

  public synchronized void addSimEventListener(SimEventListener l) {
    simEventListeners = ArrayUtils.add(SimEventListener.class, simEventListeners, l);
  }

  public synchronized void removeSimEventListener(SimEventListener l) {
    simEventListeners = ArrayUtils.remove(simEventListeners, l);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/FlashSegment.java`:

```java
package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;

public class FlashSegment implements Memory {

    private final MSP430Core core;
    private final int memory[];
    private final Flash flash;

    public FlashSegment(MSP430Core core, Flash flash) {
        this.core = core;
        this.memory = core.memory;
        this.flash = flash;
    }

    @Override
    public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
        if (core.isFlashBusy) {
            flash.notifyRead(address);
        }

        int val = memory[address] & 0xff;
        if (mode != AccessMode.BYTE) {
            val |= (memory[address + 1] & 0xff) << 8;
            if ((address & 1) != 0) {
                core.printWarning(WarningType.MISALIGNED_READ, address);
            }
            if (mode == AccessMode.WORD20) {
                /* will the read really get data from the full word? CHECK THIS */
                val |= (memory[address + 2] & 0xf) << 16;
            }
        }
        return val;
    }

    @Override
    public void write(int dstAddress, int data, AccessMode mode) throws EmulationException {
        flash.flashWrite(dstAddress, data, mode);
    }

    @Override
    public int get(int address, AccessMode mode) {
        int val = memory[address] & 0xff;
        if (mode != AccessMode.BYTE) {
            val |= (memory[address + 1] << 8);
            if ((address & 1) != 0) {
                core.printWarning(WarningType.MISALIGNED_READ, address);
            }
            if (mode == AccessMode.WORD20) {
                /* will the read really get data from the full word? CHECK THIS */
                val |= (memory[address + 2] << 16) | (memory[address + 3] << 24);
                val &= 0xfffff;
            } else {
                val &= 0xffff;
            }
        }
        return val;
    }

    @Override
    public void set(int address, int data, AccessMode mode) {
        write(address, data, mode);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/DbgInstruction.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * DbgInstruction
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

public class DbgInstruction {

  private String asmLine;
  private String regs;
  private String function;
  private int instruction;
  private int size;
  private int pos;

  private boolean extWord = false;
  
  public DbgInstruction() {
  }
  

  public boolean isExtensionWord() {
      return extWord;
  }
  
  public void setPos(int p) {
    pos = p;
  }

  public int getPos() {
    return pos;
  }

  public void setASMLine(String line) {
    asmLine = line;
  }

  public void setRegs(String regs) {
    this.regs = regs;
  }

  public void setInstruction(int instruction, int size) {
    this.instruction = instruction;
    this.size = size;
  }

  public int getSize() {
    return size;
  }

  public int getInstruction() {
    return instruction;
  }

  public String getASMLine(boolean showregs) {
    if (showregs) return getASMLine();
    return asmLine;
  }

  public String getASMLine() {
    return asmLine + "\t" + regs;
  }

  public void setFunction(String fkn) {
    function = fkn;
  }

  public String getFunction() {
    return function;
  }

  public String toString() {
    return getASMLine();
  }


  public void setExtWord(boolean b) {
      extWord = b;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/LogListener.java`:

```java
package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;

public interface LogListener {

    public void log(Loggable source, String message);
    public void logw(Loggable source, WarningType type, String message) throws EmulationException;

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/InterruptMultiplexer.java`:

```java
package se.sics.mspsim.core;

public class InterruptMultiplexer implements InterruptHandler {

    private final MSP430Core cpu;
    private final int vector;

    int interruptBits;

    public InterruptMultiplexer(MSP430Core cpu, int vector) {
        this.cpu = cpu;
        this.vector = vector;
    }

    public void updateInterrupt(boolean value, int bit) {
        if (value) interruptBits |= 1 << bit;
        else interruptBits &= ~(1 << bit);
        cpu.flagInterrupt(vector, this, interruptBits > 0);
    }

    
    public void interruptServiced(int vector) {
        /* do nothing??? */
    }

    public String getName() {
        return "InterruptMultiplexer vector " + vector +  " bits: " + interruptBits;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/SimEvent.java`:

```java
/*
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SimEvent
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 6 nov 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

/**
 *
 */
public class SimEvent {

  public enum Type {
    START,
    STOP
  };

  private Type type;

  public SimEvent(Type type) {
    this.type = type;
  }

  public Type getType() {
    return type;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/EventListener.java`:

```java
package se.sics.mspsim.core;
import se.sics.mspsim.util.ProxySupport;

public interface EventListener {

    public void event(EventSource source, String event, Object data);

    public static class Proxy extends ProxySupport<EventListener> implements EventListener {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void event(EventSource source, String event, Object data) {
            EventListener[] listeners = this.listeners;
            for(EventListener listener : listeners) {
                listener.event(source, event, data);
            }
        }

    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/EmulationException.java`:

```java
package se.sics.mspsim.core;

public class EmulationException extends RuntimeException {
  private static final long serialVersionUID = -3837451031129913060L;

  public EmulationException(String msg) {
    super(msg);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/RAMOffsetSegment.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * RAMOffsetMemory
 *
 * Author  : Niclas Finne
 * Created : Oct 24 21:47:42 2012
 */

package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;

class RAMOffsetSegment implements Memory {

    private final MSP430Core core;
    private final int memory[];
    private final int offset;

    RAMOffsetSegment(MSP430Core core, int offset) {
        this.core = core;
        this.memory = core.memory;
        this.offset = offset;
    }

    @Override public int read(int address, AccessMode mode, AccessType type)
            throws EmulationException {
        address += offset;
        int val = memory[address] & 0xff;
        if (mode != AccessMode.BYTE) {
            val |= (memory[address + 1] << 8);
            if ((address & 1) != 0) {
                core.printWarning(WarningType.MISALIGNED_READ, address);
            }
            if (mode == AccessMode.WORD20) {
                val |= (memory[address + 2] << 16) | (memory[address + 3] << 24);
            }
            val &= mode.mask;
        }
        return val;
    }

    @Override public void write(int dstAddress, int dst, AccessMode mode)
            throws EmulationException {
        dstAddress += offset;
        memory[dstAddress] = dst & 0xff;
        if (mode != AccessMode.BYTE) {
            memory[dstAddress + 1] = (dst >> 8) & 0xff;
            if ((dstAddress & 1) != 0) {
                core.printWarning(WarningType.MISALIGNED_WRITE, dstAddress);
            }
            if (mode != AccessMode.WORD) {
                memory[dstAddress + 2] = (dst >> 16) & 0xff;
                memory[dstAddress + 3] = (dst >> 24) & 0xff;
            }
        }
    }

    @Override public int get(int address, AccessMode mode) {
        return read(address, mode, AccessType.READ);
    }

    @Override public void set(int address, int data, AccessMode mode) {
        write(address, data, mode);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/UnifiedClockSystem.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * UnifiedClockSystem
 *
 * Author  : Joakim Eriksson
 * Author  : Adam Dunkels
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;
import se.sics.mspsim.util.Utils;

public class UnifiedClockSystem extends ClockSystem {

  private static final int UCSCTL0 = 0x0160;
  private static final int UCSCTL1 = 0x0162;
  private static final int UCSCTL2 = 0x0164;
  private static final int UCSCTL3 = 0x0166;
  private static final int UCSCTL4 = 0x0168;
  private static final int UCSCTL5 = 0x016a;
  private static final int UCSCTL6 = 0x016c;
  private static final int UCSCTL7 = 0x016e;
  private static final int UCSCTL8 = 0x0170;

/* UCSCTL0 Control Bits */
//  private static final int RESERVED            = 0x0001;    /* RESERVED */
//  private static final int RESERVED            = 0x0002;    /* RESERVED */
//  private static final int RESERVED            = 0x0004;    /* RESERVED */
  private static final int MOD_BITPOS          = 3;
  private static final int MOD_BITWIDTH        = 5;
  private static final int MOD0                = 0x0008;    /* Modulation Bit Counter Bit : 0 */
  private static final int MOD1                = 0x0010;    /* Modulation Bit Counter Bit : 1 */
  private static final int MOD2                = 0x0020;    /* Modulation Bit Counter Bit : 2 */
  private static final int MOD3                = 0x0040;    /* Modulation Bit Counter Bit : 3 */
  private static final int MOD4                = 0x0080;    /* Modulation Bit Counter Bit : 4 */

  private static final int DCO_BITPOS          = 8;
  private static final int DCO_BITWIDTH        = 5;
  private static final int DCO0                = 0x0100;    /* DCO TAP Bit : 0 */
  private static final int DCO1                = 0x0200;    /* DCO TAP Bit : 1 */
  private static final int DCO2                = 0x0400;    /* DCO TAP Bit : 2 */
  private static final int DCO3                = 0x0800;    /* DCO TAP Bit : 3 */
  private static final int DCO4                = 0x1000;    /* DCO TAP Bit : 4 */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
//  private static final int RESERVED            = 0x4000;    /* RESERVED */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */


/* UCSCTL1 Control Bits */
  private static final int DISMOD              = 0x0001;    /* Disable Modulation */
//  private static final int RESERVED            = 0x0002;    /* RESERVED */
//  private static final int RESERVED            = 0x0004;    /* RESERVED */
//  private static final int RESERVED            = 0x0008;    /* RESERVED */
  private static final int DCORSEL_BITPOS      = 4;
  private static final int DCORSEL_BITWIDTH    = 3;
  private static final int DCORSEL0            = 0x0010;    /* DCO Freq. Range Select Bit : 0 */
  private static final int DCORSEL1            = 0x0020;    /* DCO Freq. Range Select Bit : 1 */
  private static final int DCORSEL2            = 0x0040;    /* DCO Freq. Range Select Bit : 2 */
//  private static final int RESERVED            = 0x0080;    /* RESERVED */
//  private static final int RESERVED            = 0x0100;    /* RESERVED */
//  private static final int RESERVED            = 0x0200;    /* RESERVED */
//  private static final int RESERVED            = 0x0400;    /* RESERVED */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
//  private static final int RESERVED            = 0x1000;    /* RESERVED */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
//  private static final int RESERVED            = 0x4000;    /* RESERVED */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */


/* UCSCTL2 Control Bits */
  private static final int FLLN_BITPOS         = 0;
  private static final int FLLN_BITWIDTH       = 10;
  private static final int FLLN0               = 0x0001;    /* FLL Multipier Bit : 0 */
  private static final int FLLN1               = 0x0002;    /* FLL Multipier Bit : 1 */
  private static final int FLLN2               = 0x0004;    /* FLL Multipier Bit : 2 */
  private static final int FLLN3               = 0x0008;    /* FLL Multipier Bit : 3 */
  private static final int FLLN4               = 0x0010;    /* FLL Multipier Bit : 4 */
  private static final int FLLN5               = 0x0020;    /* FLL Multipier Bit : 5 */
  private static final int FLLN6               = 0x0040;    /* FLL Multipier Bit : 6 */
  private static final int FLLN7               = 0x0080;    /* FLL Multipier Bit : 7 */
  private static final int FLLN8               = 0x0100;    /* FLL Multipier Bit : 8 */
  private static final int FLLN9               = 0x0200;    /* FLL Multipier Bit : 9 */
//  private static final int RESERVED            = 0x0400;    /* RESERVED */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
  private static final int FLLD_BITPOS         = 12;
  private static final int FLLD_BITWIDTH       = 3;
  private static final int FLLD0               = 0x1000;    /* Loop Divider Bit : 0 */
  private static final int FLLD1               = 0x2000;    /* Loop Divider Bit : 1 */
  private static final int FLLD2               = 0x4000;    /* Loop Divider Bit : 1 */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */


/* UCSCTL3 Control Bits */
  private static final int FLLREFDIV_BITPOS    = 0;
  private static final int FLLREFDIV_BITWIDTH  = 3;
  private static final int FLLREFDIV0          = 0x0001;    /* Reference Divider Bit : 0 */
  private static final int FLLREFDIV1          = 0x0002;    /* Reference Divider Bit : 1 */
  private static final int FLLREFDIV2          = 0x0004;    /* Reference Divider Bit : 2 */
//  private static final int RESERVED            = 0x0008;    /* RESERVED */
  private static final int SELREF_BITPOS        = 4;
  private static final int SELREF_BITWIDTH      = 3;
  private static final int SELREF0             = 0x0010;    /* FLL Reference Clock Select Bit : 0 */
  private static final int SELREF1             = 0x0020;    /* FLL Reference Clock Select Bit : 1 */
  private static final int SELREF2             = 0x0040;    /* FLL Reference Clock Select Bit : 2 */
//  private static final int RESERVED            = 0x0080;    /* RESERVED */
//  private static final int RESERVED            = 0x0100;    /* RESERVED */
//  private static final int RESERVED            = 0x0200;    /* RESERVED */
//  private static final int RESERVED            = 0x0400;    /* RESERVED */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
//  private static final int RESERVED            = 0x1000;    /* RESERVED */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
//  private static final int RESERVED            = 0x4000;    /* RESERVED */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */

/* UCSCTL3 Control Bits */

  private static final int FLLREFDIV_0         = 0x0000;    /* Reference Divider: f(LFCLK);/1 */
  private static final int FLLREFDIV_1         = 0x0001;    /* Reference Divider: f(LFCLK);/2 */
  private static final int FLLREFDIV_2         = 0x0002;    /* Reference Divider: f(LFCLK);/4 */
  private static final int FLLREFDIV_3         = 0x0003;    /* Reference Divider: f(LFCLK);/8 */
  private static final int FLLREFDIV_4         = 0x0004;    /* Reference Divider: f(LFCLK);/12 */
  private static final int FLLREFDIV_5         = 0x0005;    /* Reference Divider: f(LFCLK);/16 */
  private static final int FLLREFDIV_6         = 0x0006;    /* Reference Divider: f(LFCLK);/16 */
  private static final int FLLREFDIV_7         = 0x0007;    /* Reference Divider: f(LFCLK);/16 */
  private static final int FLLREFDIV__1        = 0x0000;    /* Reference Divider: f(LFCLK);/1 */
  private static final int FLLREFDIV__2        = 0x0001;    /* Reference Divider: f(LFCLK);/2 */
  private static final int FLLREFDIV__4        = 0x0002;    /* Reference Divider: f(LFCLK);/4 */
  private static final int FLLREFDIV__8        = 0x0003;    /* Reference Divider: f(LFCLK);/8 */
  private static final int FLLREFDIV__12       = 0x0004;    /* Reference Divider: f(LFCLK);/12 */
  private static final int FLLREFDIV__16       = 0x0005;    /* Reference Divider: f(LFCLK);/16 */
  private static final int SELREF_0            = 0x0000;    /* FLL Reference Clock Select 0 */
  private static final int SELREF_1            = 0x0010;    /* FLL Reference Clock Select 1 */
  private static final int SELREF_2            = 0x0020;    /* FLL Reference Clock Select 2 */
  private static final int SELREF_3            = 0x0030;    /* FLL Reference Clock Select 3 */
  private static final int SELREF_4            = 0x0040;    /* FLL Reference Clock Select 4 */
  private static final int SELREF_5            = 0x0050;    /* FLL Reference Clock Select 5 */
  private static final int SELREF_6            = 0x0060;    /* FLL Reference Clock Select 6 */
  private static final int SELREF_7            = 0x0070;    /* FLL Reference Clock Select 7 */
  private static final int SELREF__XT1CLK      = 0x0000;    /* Multiply Selected Loop Freq. By XT1CLK */
  private static final int SELREF__REFOCLK     = 0x0020;    /* Multiply Selected Loop Freq. By REFOCLK */
  private static final int SELREF__XT2CLK      = 0x0050;    /* Multiply Selected Loop Freq. By XT2CLK */

/* UCSCTL4 Control Bits */
  private static final int SELM0               = 0x0001;   /* MCLK Source Select Bit: 0 */
  private static final int SELM1               = 0x0002;   /* MCLK Source Select Bit: 1 */
  private static final int SELM2               = 0x0004;   /* MCLK Source Select Bit: 2 */
//  private static final int RESERVED            = 0x0008;    /* RESERVED */
  private static final int SELS0               = 0x0010;   /* SMCLK Source Select Bit: 0 */
  private static final int SELS1               = 0x0020;   /* SMCLK Source Select Bit: 1 */
  private static final int SELS2               = 0x0040;   /* SMCLK Source Select Bit: 2 */
//  private static final int RESERVED            = 0x0080;    /* RESERVED */
  private static final int SELA0               = 0x0100;   /* ACLK Source Select Bit: 0 */
  private static final int SELA1               = 0x0200;   /* ACLK Source Select Bit: 1 */
  private static final int SELA2               = 0x0400;   /* ACLK Source Select Bit: 2 */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
//  private static final int RESERVED            = 0x1000;    /* RESERVED */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
//  private static final int RESERVED            = 0x4000;    /* RESERVED */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */

/* UCSCTL4 Control Bits */
  private static final int SELM__XT1CLK        = 0x0000;   /* MCLK Source Select XT1CLK */
  private static final int SELM__VLOCLK        = 0x0001;   /* MCLK Source Select VLOCLK */
  private static final int SELM__REFOCLK       = 0x0002;   /* MCLK Source Select REFOCLK */
  private static final int SELM__DCOCLK        = 0x0003;   /* MCLK Source Select DCOCLK */
  private static final int SELM__DCOCLKDIV     = 0x0004;   /* MCLK Source Select DCOCLKDIV */
  private static final int SELM__XT2CLK        = 0x0005;   /* MCLK Source Select XT2CLK */

  private static final int SELS__XT1CLK        = 0x0000;   /* SMCLK Source Select XT1CLK */
  private static final int SELS__VLOCLK        = 0x0010;   /* SMCLK Source Select VLOCLK */
  private static final int SELS__REFOCLK       = 0x0020;   /* SMCLK Source Select REFOCLK */
  private static final int SELS__DCOCLK        = 0x0030;   /* SMCLK Source Select DCOCLK */
  private static final int SELS__DCOCLKDIV     = 0x0040;   /* SMCLK Source Select DCOCLKDIV */
  private static final int SELS__XT2CLK        = 0x0050;   /* SMCLK Source Select XT2CLK */

  private static final int SELA__XT1CLK        = 0x0000;   /* ACLK Source Select XT1CLK */
  private static final int SELA__VLOCLK        = 0x0100;   /* ACLK Source Select VLOCLK */
  private static final int SELA__REFOCLK       = 0x0200;   /* ACLK Source Select REFOCLK */
  private static final int SELA__DCOCLK        = 0x0300;   /* ACLK Source Select DCOCLK */
  private static final int SELA__DCOCLKDIV     = 0x0400;   /* ACLK Source Select DCOCLKDIV */
  private static final int SELA__XT2CLK        = 0x0500;   /* ACLK Source Select XT2CLK */

/* UCSCTL5 Control Bits */
  private static final int DIVM0               = 0x0001;   /* MCLK Divider Bit: 0 */
  private static final int DIVM1               = 0x0002;   /* MCLK Divider Bit: 1 */
  private static final int DIVM2               = 0x0004;   /* MCLK Divider Bit: 2 */
//  private static final int RESERVED            = 0x0008;    /* RESERVED */
  private static final int DIVS_BITPOS         = 4;
  private static final int DIVS_BITWIDTH       = 3;
  private static final int DIVS0               = 0x0010;   /* SMCLK Divider Bit: 0 */
  private static final int DIVS1               = 0x0020;   /* SMCLK Divider Bit: 1 */
  private static final int DIVS2               = 0x0040;   /* SMCLK Divider Bit: 2 */
//  private static final int RESERVED            = 0x0080;    /* RESERVED */
  private static final int DIVA0               = 0x0100;   /* ACLK Divider Bit: 0 */
  private static final int DIVA1               = 0x0200;   /* ACLK Divider Bit: 1 */
  private static final int DIVA2               = 0x0400;   /* ACLK Divider Bit: 2 */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
  private static final int DIVPA0              = 0x1000;   /* ACLK from Pin Divider Bit: 0 */
  private static final int DIVPA1              = 0x2000;   /* ACLK from Pin Divider Bit: 1 */
  private static final int DIVPA2              = 0x4000;   /* ACLK from Pin Divider Bit: 2 */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */

/* UCSCTL6 Control Bits */
  private static final int XT1OFF              = 0x0001;    /* High Frequency Oscillator 1 (XT1); disable */
  private static final int SMCLKOFF            = 0x0002;    /* SMCLK Off */
  private static final int XCAP0               = 0x0004;   /* XIN/XOUT Cap Bit: 0 */
  private static final int XCAP1               = 0x0008;   /* XIN/XOUT Cap Bit: 1 */
  private static final int XT1BYPASS           = 0x0010;    /* XT1 bypass mode : 0: internal 1:sourced from external pin */
  private static final int XTS                 = 0x0020;   /* 1: Selects high-freq. oscillator */
  private static final int XT1DRIVE0           = 0x0040;    /* XT1 Drive Level mode Bit 0 */
  private static final int XT1DRIVE1           = 0x0080;    /* XT1 Drive Level mode Bit 1 */
  private static final int XT2OFF              = 0x0100;    /* High Frequency Oscillator 2 (XT2); disable */
//  private static final int RESERVED            = 0x0200;    /* RESERVED */
//  private static final int RESERVED            = 0x0400;    /* RESERVED */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
  private static final int XT2BYPASS           = 0x1000;    /* XT2 bypass mode : 0: internal 1:sourced from external pin */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
  private static final int XT2DRIVE0           = 0x4000;    /* XT2 Drive Level mode Bit 0 */
  private static final int XT2DRIVE1           = 0x8000;    /* XT2 Drive Level mode Bit 1 */

/* UCSCTL7 Control Bits */
  private static final int DCOFFG              = 0x0001;    /* DCO Fault Flag */
  private static final int XT1LFOFFG           = 0x0002;    /* XT1 Low Frequency Oscillator Fault Flag */
  private static final int XT1HFOFFG           = 0x0004;    /* XT1 High Frequency Oscillator 1 Fault Flag */
  private static final int XT2OFFG             = 0x0008;    /* High Frequency Oscillator 2 Fault Flag */
//  private static final int RESERVED            = 0x0010;    /* RESERVED */
//  private static final int RESERVED            = 0x0020;    /* RESERVED */
//  private static final int RESERVED            = 0x0040;    /* RESERVED */
//  private static final int RESERVED            = 0x0080;    /* RESERVED */
//  private static final int RESERVED            = 0x0100;    /* RESERVED */
//  private static final int RESERVED            = 0x0200;    /* RESERVED */
//  private static final int RESERVED            = 0x0400;    /* RESERVED */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
//  private static final int RESERVED            = 0x1000;    /* RESERVED */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
//  private static final int RESERVED            = 0x4000;    /* RESERVED */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */

/* UCSCTL8 Control Bits */
  private static final int ACLKREQEN           = 0x0001;    /* ACLK Clock Request Enable */
  private static final int MCLKREQEN           = 0x0002;    /* MCLK Clock Request Enable */
  private static final int SMCLKREQEN          = 0x0004;    /* SMCLK Clock Request Enable */
  private static final int MODOSCREQEN         = 0x0008;    /* MODOSC Clock Request Enable */
//  private static final int RESERVED            = 0x0010;    /* RESERVED */
//  private static final int RESERVED            = 0x0020;    /* RESERVED */
//  private static final int RESERVED            = 0x0040;    /* RESERVED */
//  private static final int RESERVED            = 0x0080;    /* RESERVED */
//  private static final int RESERVED            = 0x0100;    /* RESERVED */
//  private static final int RESERVED            = 0x0200;    /* RESERVED */
//  private static final int RESERVED            = 0x0400;    /* RESERVED */
//  private static final int RESERVED            = 0x0800;    /* RESERVED */
//  private static final int RESERVED            = 0x1000;    /* RESERVED */
//  private static final int RESERVED            = 0x2000;    /* RESERVED */
//  private static final int RESERVED            = 0x4000;    /* RESERVED */
//  private static final int RESERVED            = 0x8000;    /* RESERVED */


  private static final int ACLK_FRQ = 32768;
  private static final int MAX_DCO_FRQ = 16000000;

  private final Timer[] timers;

  private int currentDcoFrequency;

  /**
   * Creates a new <code>UnifiedClockSystem</code> instance.
   *
   */
  public UnifiedClockSystem(MSP430Core cpu, int[] memory, int offset, Timer[] timers) {
    super("UnifiedClockSystem", cpu, memory, offset);
    this.timers = timers;
  }

  public int getMaxDCOFrequency() {
      return MAX_DCO_FRQ;
  }

  public int getAddressRangeMin() {
    return UCSCTL0;
  }

  public int getAddressRangeMax() {
    return UCSCTL8;
  }

  public void reset(int type) {
    // Set the reset states, according to the SLAU208h data sheet.
    write(UCSCTL0, 0x0000, true, cpu.cycles);
    write(UCSCTL1, 0x0020, true, cpu.cycles);
    write(UCSCTL2, 0x101f, true, cpu.cycles);
    write(UCSCTL3, 0x0000, true, cpu.cycles);
    write(UCSCTL4, 0x0044, true, cpu.cycles);
    write(UCSCTL5, 0x0000, true, cpu.cycles);
    write(UCSCTL6, 0xc1cd, true, cpu.cycles);
    write(UCSCTL7, 0x0703, true, cpu.cycles);
    write(UCSCTL8, 0x0707, true, cpu.cycles);
  }

  // do nothing?
  public int read(int address, boolean word, long cycles) {
    int val = memory[address];
    if (word) {
      val |= memory[(address + 1) & 0xffff] << 8;
    }
    return val;
  }

  public void write(int address, int data, boolean word, long cycles) {
    // Currently ignores the word flag...
    if (DEBUG) log("Write to UnifiedClockSystem: " +
		       Utils.hex16(address) + " => " + Utils.hex16(data));

    memory[address] = data & 0xff;
    if (word) memory[address + 1] = (data >> 8) & 0xff;

    setConfiguration(cycles);
  }

  public void interruptServiced(int vector) {
  }


  private void setConfiguration(long cycles) {
    // Read a configuration from the UCSCTL* registers and compute the timer setup

    // Read Modulation counter and DCO TAP from UCSCTL0 (currently unused)
    int modulationBitCounter = ((read(UCSCTL0, true, cycles) >> MOD_BITPOS) & ((1 << MOD_BITWIDTH) - 1));
    int dcoTap = ((read(UCSCTL0, true, cycles) >> DCO_BITPOS) & ((1 << DCO_BITWIDTH) - 1));

    // Read modulation disable bit (currently unused)
    int disableModulation = ((read(UCSCTL1, true, cycles) & DISMOD));

    // Read DCO range selection from UCSCTL1 register
    int dcoRange = ((read(UCSCTL1, true, cycles) >> DCORSEL_BITPOS) & ((1 << DCORSEL_BITWIDTH) - 1));

    // Read DCO FLL multiplier and loop divider from the UCSCTL2 register
    int dcoFLLMultiplier = (read(UCSCTL2, true, cycles) >> FLLN_BITPOS) & ((1 << FLLN_BITWIDTH) - 1);
    int dcoLoopDivider = (read(UCSCTL2, true, cycles) >> FLLD_BITPOS) & ((1 << FLLD_BITWIDTH) - 1);

    // FLL reference clock divider and selection from UCSCTL3 (currently unused)
    int fllRefDiv = (read(UCSCTL3, true, cycles) >> FLLREFDIV_BITPOS) & ((1 << FLLREFDIV_BITWIDTH) - 1);
    int selRef = (read(UCSCTL3, true, cycles) >> SELREF_BITPOS) & ((1 << SELREF_BITWIDTH) - 1);

    // SMCLK divisor
    int divSMclk = (read(UCSCTL5, true, cycles) >> DIVS_BITPOS) & ((1 << DIVS_BITWIDTH) - 1);

    int newDcoFrequency = (dcoFLLMultiplier + 1) * ACLK_FRQ;

    if (newDcoFrequency != currentDcoFrequency) {
      currentDcoFrequency = newDcoFrequency;
      cpu.setDCOFrq(currentDcoFrequency, currentDcoFrequency / (1 << divSMclk));

      if (timers != null) {
	  for(int i = 0; i < timers.length; i++) {
	      timers[i].resetCounter(cycles);
	  }
      }
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/MSP430Config.java`:

```java
package se.sics.mspsim.core;

import java.util.ArrayList;

import se.sics.mspsim.util.Utils;

public abstract class MSP430Config {
    
    public static class TimerConfig {
        public final int ccr0Vector;
        public final int ccrXVector;
        public final int ccrCount;
        public final int offset;
        public final String name;
        public final int[] srcMap;
        public final int timerIVAddr;
        
        public TimerConfig(int ccr0Vec, int ccrXVec, int ccrCount, int offset,
                int[] srcMap, String name, int tiv) {
            ccr0Vector = ccr0Vec;
            ccrXVector = ccrXVec;
            this.ccrCount = ccrCount;
            this.name = name;
            this.offset = offset;
            this.srcMap = srcMap;
            this.timerIVAddr = tiv;
        }
    }

    public static class UARTConfig {
        private static final int USCI_2 = 1;
        private static final int USCI_5 = 2;
        
        public final int txVector;
        public final int rxVector;
        public final int offset;
        public final String name;
        public final int txBit;
        public final int rxBit;
        public final int sfrAddr;
        public final boolean usciA;
        public final int type;
        
        public UARTConfig(String name, int vector, int offset) {
            type = USCI_5;
            txVector = rxVector = vector;
            this.txBit = this.rxBit = 0;
            this.offset = offset;
            this.name = name;
            this.usciA = false;
            this.sfrAddr = 0;
        }

        public UARTConfig(int txVector, int rxVector, int txBit, int rxBit, int sftAddr, int offset,
                    String name, boolean usciA) {
            this.type = USCI_2;
            this.txVector = txVector;
            this.rxVector = rxVector;
            this.txBit = txBit;
            this.rxBit = rxBit;
            this.offset = offset;
            this.name = name;
            this.usciA = usciA;
            this.sfrAddr = sftAddr;
        }
    }

    public UARTConfig[] uartConfig;
    
    /* default for the 149/1611 */
    public TimerConfig[] timerConfig = {
            new TimerConfig(6, 5, 3, 0x160, Timer.TIMER_Ax149, "TimerA", Timer.TAIV),
            new TimerConfig(13, 12, 7, 0x180, Timer.TIMER_Bx149, "TimerB", Timer.TBIV)
    };
    
    /* Memory configuration */
    public int maxMemIO = 0x200;
    public int maxMem = 64*1024;
    public int maxInterruptVector = 15;
    
    public int mainFlashStart = 0x0000;
    public int mainFlashSize = 48 * 1024;

    public int infoMemStart = 0x0000;
    public int infoMemSize = 2 * 128;

    public int ramStart = 0x2000;
    public int ramSize = 2048;

    public int ramMirrorStart = 0x0;
    public int ramMirrorSize = 0x0;
    public int ramMirrorAddress = 0x0;
    
    public int flashControllerOffset = 0x128;
    
    public boolean MSP430XArch = false;

    public int sfrOffset = 0;

    public int watchdogOffset = 0x120;
    
    public abstract int setup(MSP430Core cpu, ArrayList<IOUnit> ioUnits);

    
    public boolean isRAM(int address) {
        return address >= ramStart && address < ramStart + ramSize;
    }

    public boolean isRAMMirror(int address) {
        return ramMirrorSize > 0 && address >= ramMirrorStart && address < ramMirrorStart + ramMirrorSize;
    }

    public boolean isFlash(int address) {
        return address >= mainFlashStart && address < mainFlashStart + mainFlashSize;
    }

    public boolean isInfoMem(int address) {
        return address >= infoMemStart && address < infoMemStart + infoMemSize;
    }

    public boolean isIO(int address) {
        return address < maxMemIO;
    }
    
    public String getAddressAsString(int addr) {
        return Utils.hex16(addr);
    }


    public void infoMemConfig(int start, int size) {
        infoMemStart = start;
        infoMemSize = size;
    }
    
    public void mainFlashConfig(int start, int size) {
        mainFlashStart = start;
        mainFlashSize = size;
        if (maxMem < start + size) {
            maxMem = start + size;
        }
    }
    
    /* ignored for now */
    public void ramConfig(int start, int size) {
       ramStart = start;
       ramSize = size;
    }

    public void ramMirrorConfig(int start, int size, int address) {
        ramMirrorStart = start;
        ramMirrorSize = size;
        ramMirrorAddress = address;
    }

    public int getMaxClockSpeed() {
        return 4915200;
    }

    public void ioMemSize(int size) {
        maxMemIO = size;
    }

    public ClockSystem createClockSystem(MSP430Core cpu, int[] memory, Timer[] timers) {
        return new BasicClockModule(cpu, memory, 0, timers, getMaxClockSpeed());
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/USCI.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * USCI Module for the MSP430xf2xxx series.
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;


public class USCI extends IOUnit implements SFRModule, DMATrigger, USARTSource {

  // USART 0/1 register offset (0x60 / 0xD0)
  public static final int UAxCTL0 = 0;
  public static final int UAxCTL1 = 1;
  public static final int UAxBR0 = 2;
  public static final int UAxBR1 = 3;
  public static final int UAxMCTL = 4;
  public static final int UAxSTAT = 5;
  public static final int UAxRXBUF = 6;
  public static final int UAxTXBUF = 7;
  
  // SPI related registers
  public static final int UBxCTL0 = 8;
  public static final int UBxCTL1 = 9;
  public static final int UBxBR0 = 0xa;
  public static final int UBxBR1 = 0xb;
  public static final int UBxSTAT = 0xd;
  public static final int UBxRXBUF = 0xe;
  public static final int UBxTXBUF = 0xf;
  
  // IrDA related (negative offset ??)
  public static final int UABCTL = -3; /* very odd... */
  public static final int UIRTCTL = -2;
  public static final int UIRRCTL = -1;
  
  // Interrupt flags...
  public static final int UTXIFG0 = 0x80;
  public static final int URXIFG0 = 0x40;

  public static final int UTXIFG1 = 0x20;
  public static final int URXIFG1 = 0x10;

  // USART SRF mod enable registers (absolute + 1)
  public static final int ME1 = 4;
  public static final int IE1 = 0;
  public static final int IFG1 = 2;

  private final int uartID;

  // Flags.
  public static final int UTCTL_TXEMPTY = 0x01;
  public static final int UTCTL_URXSE = 0x08;
  public static final int USCI_BUSY = 0x01;
  
  private USARTListener usartListener;

  private int utxifg;
  private int urxifg;
  private int rxVector;

  private int clockSource = 0;
  private int baudRate = 0;
  private int tickPerByte = 1000;
  private long nextTXReady = -1;
  private int nextTXByte = -1;
  private int txShiftReg = -1;
  private boolean transmitting = false;

  private final SFR sfr;
  private final int sfrAddress;

  /* ifg and ie if not in sfr... - assume IE in sfraddr and IFG in addr + 1*/
  private int ifgAddress = 0;
  private int ieAddress = 0;

  private int uctl0;
  private int uctl1;
  private int umctl;
  private int ubr0;
  private int ubr1;
  private int urxbuf;
  private int utxbuf;
  private int ustat;
  private int txbit;
  
  private boolean txEnabled = false;
  private boolean rxEnabled = false;
  private boolean spiMode = false;
  
  /* DMA controller that needs to be called at certain times */
  private DMA dma;
  private int dmaIndex;
  
  private boolean usciA = true; /* if this is an USCI A or B */
  
  private TimeEvent txTrigger = new TimeEvent(0) {
    public void execute(long t) {
        // Ready to transmit new byte!
        handleTransmit(t);
    }
  };
  
  /**
   * Creates a new <code>USART</code> instance.
   *
   */
  public USCI(MSP430Core cpu, int uartID, int[] memory, MSP430Config config) {
    super(config.uartConfig[uartID].name, cpu, memory, config.uartConfig[uartID].offset);
    this.uartID = uartID;
    MSP430Config.UARTConfig uartConfig = config.uartConfig[uartID];

    // Initialize - transmit = ok...
    // and set which interrupts are used
    if (uartConfig.sfrAddr < 2) {
        sfr = cpu.getSFR();
        sfrAddress = uartConfig.sfrAddr;
        sfr.registerSFDModule(uartConfig.sfrAddr, uartConfig.rxBit, this, uartConfig.rxVector);
        sfr.registerSFDModule(uartConfig.sfrAddr, uartConfig.txBit, this, uartConfig.txVector);
    } else {
        sfr = null;
        sfrAddress = 0;
        ieAddress = uartConfig.sfrAddr;
        ifgAddress = uartConfig.sfrAddr + 1;
    }
    utxifg = 1 << uartConfig.txBit;
    urxifg = 1 << uartConfig.rxBit;
    txbit = uartConfig.txBit;
    rxVector = uartConfig.rxVector;
    usciA = uartConfig.usciA;
    reset(0);
  }

  public void setDMA(DMA dma) {
      this.dma = dma;
  }

  
  public void reset(int type) {
    nextTXReady = cpu.cycles + 100;
    txShiftReg = nextTXByte = -1;
    transmitting = false;
    clrBitIFG(urxifg);
    setBitIFG(utxifg); /* empty at start! */
    ustat &= ~USCI_BUSY;
    txEnabled = true; //false;
    rxEnabled = true; //false;
  }

  public void enableChanged(int reg, int bit, boolean enabled) {
    if (DEBUG) log("enableChanged: " + reg + " bit: " + bit +
        " enabled = " + enabled + " txBit: " + txbit);
    if (bit == txbit) {
      txEnabled = enabled;
    } else {
      rxEnabled = enabled;
    }
  }
  
  private void setBitIFG(int bits) {
//    if ((bits) > 0) {
//        System.out.println(getName() + " Set utxifg = " + utxifg +
//                " sfrA: " + sfrAddress + " bits: " + bits);
//    }
    if (sfr != null) {
        sfr.setBitIFG(sfrAddress, bits);
//        System.out.println("SFR =>" + sfr.getIFG(sfrAddress));
    } else {
        memory[ifgAddress] |= bits;
    }
    if (dma != null) {
        /* set bit first, then trigger DMA transfer - this should
         * be made via a 1 cycle or so delayed action */
        if ((bits & urxifg) > 0) dma.trigger(this, 0);
        if ((bits & utxifg) > 0) dma.trigger(this, 1);
    }
  }

  private void clrBitIFG(int bits) {
//      if ((bits & utxifg) > 0) {
//          System.out.println(getName() + " Clear utxifg");
//      }
      if (sfr != null) {
          sfr.clrBitIFG(sfrAddress, bits);
      } else {
          memory[ifgAddress] &= ~bits;
      }
  }

  private int getIFG() {
      if (sfr != null)
          return sfr.getIFG(sfrAddress);
      return memory[ifgAddress];
  }

  private boolean isIEBitsSet(int bits) {
      if (sfr != null)
          return sfr.isIEBitsSet(sfrAddress, bits);
      return (memory[ieAddress] & bits) > 0;
  }

  /* reuse USART listener API for USCI */
  @Override
  public synchronized void addUSARTListener(USARTListener listener) {
      usartListener = USARTListener.Proxy.INSTANCE.add(usartListener, listener);
  }

  @Override
  public synchronized void removeUSARTListener(USARTListener listener) {
      usartListener = USARTListener.Proxy.INSTANCE.remove(usartListener, listener);
  }

  // Only 8 bits / read!
  public void write(int address, int data, boolean word, long cycles) {
    if (address == ieAddress || address == ifgAddress) {
        memory[address] = data;
    }
    address = address - offset;

    // Indicate ready to write!!! - this should not be done here...
//    System.out.println(">>>> Write to " + getName() + " at " +
//            address + " = " + data);
    switch (address) {
    case UAxCTL0:
    case UBxCTL0:
      uctl0 = data;
      spiMode = (data & 0x01) > 0;
      if (DEBUG) log(" write to UAxCTL0 " + data);
      break;
    case UAxCTL1:
    case UBxCTL1:
        /* emulate the reset */
        if ((uctl1 & 1) == 1 && (data & 1) == 0)
            reset(0);
      uctl1 = data;
      if (DEBUG) log(" write to UAxCTL1 " + data);

      if (((data >> 6) & 3) == 1) {
        clockSource = MSP430Constants.CLK_ACLK;
        if (DEBUG) {
          log(" Selected ACLK as source");
        }
      } else {
        clockSource = MSP430Constants.CLK_SMCLK;
        if (DEBUG) {
          log(" Selected SMCLK as source");
        }
      }
      updateBaudRate();
      break;
    case UAxMCTL:
      umctl = data;
      if (DEBUG) log(" write to UMCTL " + data);
      break;
    case UAxBR0:
    case UBxBR0:
      ubr0 = data;
      updateBaudRate();
      break;
    case UAxBR1:
    case UBxBR1:
      ubr1 = data;
      updateBaudRate();
      break;
    case UAxSTAT:
    case UBxSTAT:
        //ustat = data;
      break;
    case UAxTXBUF:
    case UBxTXBUF:
      if (DEBUG) log(": USART_UTXBUF:" + (char) data + " = " + data + "\n");
      if (txEnabled || (spiMode && rxEnabled)) {
        // Interruptflag not set!
        clrBitIFG(utxifg);
        /* the TX is no longer empty ! */
        ustat |= USCI_BUSY;
        /* should the interrupt be flagged off here ? - or only the flags */
        if (DEBUG) log(" flagging off transmit interrupt");
        //      cpu.flagInterrupt(transmitInterrupt, this, false);

        // Schedule on cycles here
        // TODO: adding 3 extra cycles here seems to give
        // slightly better timing in some test...

        nextTXByte = data;
        if (!transmitting) {
            /* how long time will the copy from the TX_BUF to the shift reg take? */
            /* assume 3 cycles? */
            nextTXReady = cycles + 1; //tickPerByte + 3;
            cpu.scheduleCycleEvent(txTrigger, nextTXReady);
        }
      } else {
        log("Ignoring UTXBUF data since TX not active...");
      }
      utxbuf = data;
      break;
    }
  }

  public int read(int address, boolean word, long cycles) {
      if (address == ieAddress || address == ifgAddress) {
          return memory[address];
      }
    address = address - offset;
//    System.out.println(">>>>> Read from " + getName() + " at " +
//            address);
    
    switch (address) {
    case UAxCTL0:
    case UBxCTL0:
      if (DEBUG) log(" read from UCTL");
      return uctl0;
    case UAxCTL1:
    case UBxCTL1:
      if (DEBUG) log(" read from UTCTL: " + uctl1);
      return uctl1;
    case UAxMCTL:
      return umctl;
    case UAxBR0:
    case UBxBR0:
      return ubr0;
    case UAxBR1:
    case UBxBR1:
      return ubr1;
    case UAxTXBUF:
    case UBxTXBUF:
      return utxbuf;
    case UAxSTAT:
    case UBxSTAT:
//      System.out.println(getName() + " Reading STAT: " + ustat);
      return ustat;
    case UAxRXBUF:
    case UBxRXBUF:
      int tmp = urxbuf;
      // When byte is read - the interruptflag is cleared!
      // and error status should also be cleared later...
      // is this cleared also on the MSP430x2xx series???
      if (MSP430Constants.DEBUGGING_LEVEL > 0) {
          log(" clearing rx interrupt flag " + cpu.getPC() + " byte: " + tmp);
      }
      clrBitIFG(urxifg);
      /* This should be changed to a state rather than an "event" */
      /* Force callback since this is not used as a state */
      stateChanged(USARTListener.RXFLAG_CLEARED, true);
      return tmp;
    }
    return 0;
  }

  private void updateBaudRate() {
    int div = ubr0 + (ubr1 << 8);
    if (div == 0) {
      div = 1;
    }
    if (clockSource == MSP430Constants.CLK_ACLK) {
      if (DEBUG) {
        log(" Baud rate is (bps): " + cpu.aclkFrq / div + " div = " + div);
      }
      baudRate = cpu.aclkFrq / div;
    } else {
      if (DEBUG) {     
        log(" Baud rate is (bps): " + cpu.smclkFrq / div + " div = " + div);
      }
      baudRate = cpu.smclkFrq / div;
    }
    if (baudRate == 0) baudRate = 1;
    // Is this correct??? Is it the DCO or smclkFRQ we should have here???
    tickPerByte = (8 * cpu.smclkFrq) / baudRate;
    if (DEBUG) {
      log(" Ticks per byte: " + tickPerByte);
    }
  }

  // We should add "Interrupt serviced..." to indicate that its latest
  // Interrupt was serviced...
  public void interruptServiced(int vector) {
    /* NOTE: this is handled by SFR : clear IFG bit if interrupt is serviced */
//      System.out.println(getName() + " SFR irq " + vector + " " + txShiftReg + " " + getIFG());
  }

  private void handleTransmit(long cycles) {
    if (cpu.getMode() >= MSP430Core.MODE_LPM3) {
      logw(WarningType.EXECUTION, "Warning: USART transmission during LPM!!! " + nextTXByte);
    }

    if (transmitting) {
        /* in this case we have shifted out the last character */
        USARTListener listener = this.usartListener;
        if (listener != null && txShiftReg != -1) {
            listener.dataReceived(this, txShiftReg);
        }
        /* nothing more to transmit after this - stop transmission */
        if (nextTXByte == -1) {
            /* ~BUSY - nothing more to send - and last data already in RX */
            ustat &= ~USCI_BUSY;
            transmitting = false;
            txShiftReg = -1;
        }
    }

    /* any more chars to transmit? */
    if (nextTXByte != -1) {
        txShiftReg = nextTXByte;
        nextTXByte = -1;
        /* txbuf always empty after this */
        setBitIFG(utxifg);
        transmitting = true;
        nextTXReady = cycles + tickPerByte + 1;
        cpu.scheduleCycleEvent(txTrigger, nextTXReady);
    }

    if (DEBUG) {
      if (isIEBitsSet(utxifg)) {
        log(" flagging on transmit interrupt");
      }
      log(" Ready to transmit next at: " + cycles);
    }
  }


  public boolean isReceiveFlagCleared() {
    return (getIFG() & urxifg) == 0;
  }

  // A byte have been received!
  // This needs to be complemented with a method for checking if the USART
  // is ready for next byte (readyForReceive) that respects the current speed
  public void byteReceived(int b) {
      //System.out.println(getName() + " byte received: " + b + " enabled:" + rxEnabled);
      if (!rxEnabled) return;
    
    if (DEBUG || true) {
      log(" byteReceived: " + b + " " + (char) b);
    }
    urxbuf = b & 0xff;
    // Indicate interrupt also!
    setBitIFG(urxifg);

    // Check if the IE flag is enabled! - same as the IFlag to indicate!
    if (isIEBitsSet(urxifg)) {
      if (DEBUG) {
        log(" flagging receive interrupt ");
      }
    }
  }
  
  public String info() {
      return "UTXIE: " + isIEBitsSet(utxifg) + "  URXIE:" + isIEBitsSet(urxifg) + "\n" +
      "UTXIFG: " + ((getIFG() & utxifg) > 0) + "  URXIFG:" + ((getIFG() & urxifg) > 0);
  }

  public boolean getDMATriggerState(int index) {
      if (index == 0) {
          return (getIFG() & urxifg) > 0;
      } else {
          return (getIFG() & utxifg) > 0;
      }
  }
  
  public void clearDMATrigger(int index) {
//      System.out.println("UART clearing DMA " + index);
      if (index == 0) {
          /* clear RX - might be different in different modes... */
//          System.out.println("UART clearing read bit!");
          clrBitIFG(urxifg);
          stateChanged(USARTListener.RXFLAG_CLEARED, true);
      } else {
          /* clear TX - might be different in different modes... */
          clrBitIFG(utxifg);
      }
  }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/EventSource.java`:

```java
package se.sics.mspsim.core;

public interface EventSource {
  public String getName();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/ADC12.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ADC12
 *
 * Each time a sample is converted the ADC12 system will check for EOS flag
 * and if not set it just continues with the next conversion (x + 1). 
 * If EOS next conversion is startMem.
 * Interrupt is triggered when the IE flag are set! 
 *
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

import java.util.Arrays;

public class ADC12 extends IOUnit {

  public static final int ADC12CTL0 = 0x01A0;// Reset with POR
  public static final int ADC12CTL1 = 0x01A2;// Reset with POR
  public static final int ADC12IFG = 0x01A4; //Reset with POR
  public static final int ADC12IE = 0x01A6; //Reset with POR
  public static final int ADC12IV = 0x01A8; //Reset with POR
  public static final int ADC12MEM0 = 0x0140; //Unchanged
  public static final int ADC12MEM1 = 0x0142; //Unchanged
  public static final int ADC12MEM2 = 0x0144; //Unchanged
  public static final int ADC12MEM3 = 0x0146; //Unchanged
  public static final int ADC12MEM4 = 0x0148; //Unchanged
  public static final int ADC12MEM5 = 0x014A; //Unchanged
  public static final int ADC12MEM6 = 0x014C; //Unchanged
  public static final int ADC12MEM7 = 0x014E; //Unchanged
  public static final int ADC12MEM8 = 0x0150; //Unchanged
  public static final int ADC12MEM9 = 0x0152; //Unchanged
  public static final int ADC12MEM10 = 0x0154; //Unchanged
  public static final int ADC12MEM11 = 0x0156; //Unchanged
  public static final int ADC12MEM12 = 0x0158; //Unchanged
  public static final int ADC12MEM13 = 0x015A; //Unchanged
  public static final int ADC12MEM14 = 0x015C; //Unchanged
  public static final int ADC12MEM15 = 0x015E; //Unchanged
  public static final int ADC12MCTL0 = 0x080; //Reset with POR
  public static final int ADC12MCTL1 = 0x081; //Reset with POR
  public static final int ADC12MCTL2 = 0x082; //Reset with POR
  public static final int ADC12MCTL3 = 0x083; //Reset with POR
  public static final int ADC12MCTL4 = 0x084; //Reset with POR
  public static final int ADC12MCTL5 = 0x085; //Reset with POR
  public static final int ADC12MCTL6 = 0x086; //Reset with POR
  public static final int ADC12MCTL7 = 0x087; //Reset with POR
  public static final int ADC12MCTL8 = 0x088; //Reset with POR
  public static final int ADC12MCTL9 = 0x089; //Reset with POR
  public static final int ADC12MCTL10 = 0x08A; //Reset with POR
  public static final int ADC12MCTL11 = 0x08B; //Reset with POR
  public static final int ADC12MCTL12 = 0x08C; //Reset with POR
  public static final int ADC12MCTL13 = 0x08D; //Reset with POR
  public static final int ADC12MCTL14 = 0x08E; //Reset with POR
  public static final int ADC12MCTL15 = 0x08F; //Reset with POR
  
  public static final int[] SHTBITS = new int[] {
    4, 8, 16, 32, 64, 96, 128, 192,
    256, 384, 512, 768, 1024, 1024, 1024, 1024
  };

  public static final int BUSY_MASK = 0x01;
  public static final int EOS_MASK = 0x80;

  public static final int CONSEQ_SINGLE = 0x00;
  public static final int CONSEQ_SEQUENCE = 0x01;
  public static final int CONSEQ_REPEAT_SINGLE = 0x02;
  public static final int CONSEQ_REPEAT_SEQUENCE = 0x03;
  public static final int CONSEQ_SEQUENCE_MASK = 0x01;

  private int adc12ctl0 = 0;
  private int adc12ctl1 = 0;
  private int[] adc12mctl = new int[16]; 
  private int[] adc12mem = new int[16]; 
  private int adc12Pos = 0;
  
  private int shTime0 = 4;
  private int shTime1 = 4;
  private boolean adc12On = false;
  private boolean enableConversion;
  private boolean startConversion;
  private boolean isConverting;
  
  private int shSource = 0;
  private int startMem = 0;
  private int adcDiv = 1;

  private ADCInput adcInput[] = new ADCInput[16];
  
  private int conSeq;
  private int adc12ie;
  private int adc12ifg;
  private int adc12iv;
  
  private int adcSSel;
  private int adc12Vector = 7;

  private TimeEvent adcTrigger = new TimeEvent(0) {
    public void execute(long t) {
//      System.out.println(getName() + " **** executing update timers at " + t + " cycles=" + cpu.cycles);
      convert();
    }
  };

  
  public ADC12(MSP430Core cpu) {
    super("ADC12", cpu, cpu.memory, 0);
  }

  public void reset(int type) {
    enableConversion = false;
    startConversion = false;
    isConverting = false;
    adc12ctl0 = 0;
    adc12ctl1 = 0;
    shTime0 = shTime1 = 4;
    adc12On = false;
    shSource = 0;
    startMem = adc12Pos = 0;
    adcDiv = 1;

    conSeq = 0;
    adc12ie = 0;
    adc12ifg = 0;
    adc12iv = 0;
    adcSSel = 0;

    Arrays.fill(adc12mctl, 0);
  }

  public void setADCInput(int adindex, ADCInput input) {
    adcInput[adindex] = input;
  }

  // write a value to the IO unit
  public void write(int address, int value, boolean word, long cycles) {
    switch (address) {
    case ADC12CTL0:
      if (enableConversion) {
        // Ongoing conversion: only some parts may be changed
        adc12ctl0 = (adc12ctl0 & 0xfff0) + (value & 0xf);
      } else {
        adc12ctl0 = value;
        shTime0 = SHTBITS[(value >> 8) & 0x0f];
        shTime1 = SHTBITS[(value >> 12) & 0x0f];
        adc12On = (value & 0x10) > 0;
      }
      enableConversion = (value & 0x02) > 0;
      startConversion = (value & 0x01) > 0;
      
      if (DEBUG) log("Set SHTime0: " + shTime0 + " SHTime1: " + shTime1 + " ENC:" +
          enableConversion + " Start: " + startConversion + " ADC12ON: " + adc12On);
      if (adc12On && enableConversion && startConversion && !isConverting) {
        // Set the start time to be now!
        isConverting = true;
        adc12Pos = startMem;
        int delay = adcDiv * ((adc12Pos < 8 ? shTime0 : shTime1) + 13);
        cpu.scheduleTimeEvent(adcTrigger, cpu.getTime() + delay);
      }
      break;
    case ADC12CTL1:
      if (enableConversion) {
        // Ongoing conversion: only some parts may be changed
        adc12ctl1 = (adc12ctl1 & 0xfff8) + (value & 0x6);
      } else {
        adc12ctl1 = value & 0xfffe;
        startMem = (value >> 12) & 0xf;
        shSource = (value >> 10) & 0x3;
        adcDiv = ((value >> 5) & 0x7) + 1;
        adcSSel = (value >> 3) & 0x03;
      }
      conSeq = (value >> 1) & 0x03;
      if (DEBUG) log("Set startMem: " + startMem + " SHSource: " + shSource +
          " ConSeq-mode:" + conSeq + " Div: " + adcDiv + " ADCSSEL: " + adcSSel);
      break;
    case ADC12IE:
      adc12ie = value;
      break;
    case ADC12IFG:
      adc12ifg = value;
      break;
    default:
      if (address >= ADC12MCTL0 && address <= ADC12MCTL15)  {
        if (enableConversion) {
          /* Ongoing conversion: not possible to modify */
        } else {
          adc12mctl[address - ADC12MCTL0] = value & 0xff;
          if (DEBUG) log("ADC12MCTL" + (address - ADC12MCTL0)
              + " source = " + (value & 0xf)
              + (((value & EOS_MASK) != 0) ? " EOS bit set" : ""));
        }
      }
    }
  }

  // read a value from the IO unit
  public int read(int address, boolean word, long cycles) {
    switch(address) {
    case ADC12CTL0:
      return adc12ctl0;
    case ADC12CTL1:
      return isConverting ? (adc12ctl1 | BUSY_MASK) : adc12ctl1;
    case ADC12IE:
      return adc12ie;
    case ADC12IFG:
      return adc12ifg;
    default:
      if (address >= ADC12MCTL0 && address <= ADC12MCTL15)  {
        return adc12mctl[address - ADC12MCTL0];
      } else if (address >= ADC12MEM0 && address <= ADC12MEM15) {
        int reg = (address - ADC12MEM0) / 2;
        // Clear ifg!
        adc12ifg &= ~(1 << reg);
//        System.out.println("Read ADCMEM" + (reg / 2));        
        if (adc12iv == reg * 2 + 6) {
          cpu.flagInterrupt(adc12Vector, this, false);
          adc12iv = 0;
//          System.out.println("** de-Trigger ADC12 IRQ for ADCMEM" + adc12Pos);
        }
        return adc12mem[reg];
      }
    }
    return 0;
  }

  int smp = 0;
  private void convert() {
    // If off then just return...
    if (!adc12On) {
      isConverting = false;
      return;
    }
    boolean runAgain = enableConversion && conSeq != CONSEQ_SINGLE;
    // Some noise...
    ADCInput input = adcInput[adc12mctl[adc12Pos] & 0xf];
    adc12mem[adc12Pos] = input != null ? input.nextData() : 2048 + 100 - smp & 255;
    smp += 7;
    adc12ifg |= (1 << adc12Pos);
    if ((adc12ie & (1 << adc12Pos)) > 0) {
      // This should check if there already is an higher iv!
      adc12iv = adc12Pos * 2 + 6;
      //System.out.println("** Trigger ADC12 IRQ for ADCMEM" + adc12Pos);
      cpu.flagInterrupt(adc12Vector, this, true);
    }
    if ((conSeq & CONSEQ_SEQUENCE_MASK) != 0) {
      // Increase
      if ((adc12mctl[adc12Pos] & EOS_MASK) == EOS_MASK) {
        adc12Pos = startMem;
        if (conSeq == CONSEQ_SEQUENCE) {
          // Single sequence only
          runAgain = false;
        }
      } else {
        adc12Pos = (adc12Pos + 1) & 0x0f;
      }
    }
    if (!runAgain) {
      isConverting = false;
    } else {
      int delay = adcDiv * ((adc12Pos < 8 ? shTime0 : shTime1) + 13);
      cpu.scheduleTimeEvent(adcTrigger, adcTrigger.time + delay);
    }
  }
  
  public void interruptServiced(int vector) {
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/ADC12Plus.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ADC12
 *
 * Each time a sample is converted the ADC12 system will check for EOS flag
 * and if not set it just continues with the next conversion (x + 1). 
 * If EOS next conversion is startMem.
 * Interrupt is triggered when the IE flag are set! 
 *
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */

package se.sics.mspsim.core;

import java.util.Arrays;

import se.sics.mspsim.core.EmulationLogger.WarningType;


/**
 * ADC12 Plus IO peripheral
 * 
 * This module extends the functionality of the ADC12 by adding one
 * configuration register which controls the power consumption of this
 * peripheral. Additionally, implements several resolutions (8 to 12-bit)
 * 
 * The rest of functionalities are the same as the standard ADC12
 * 
 * @author Joakim Eriksson <joakime@sics.se>
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public class ADC12Plus extends IOUnit {

	/**
	 * Address and size for IO configuration
	 */
	public static int OFFSET = 0x0700;
	public static int SIZE = 0x3e;

	public static final int ADC12CTL0 = 0x00;// Reset with POR
	public static final int ADC12CTL1 = 0x02;// Reset with POR
	public static final int ADC12CTL2 = 0x04;// Reset with POR XXX

	public static final int ADC12IFG = 0x0a; // Reset with POR
	public static final int ADC12IE = 0x0c; // Reset with POR
	public static final int ADC12IV = 0x0e; // Reset with POR

	public static final int ADC12MEM0 = 0x20; // Unchanged
	public static final int ADC12MEM1 = 0x22; // Unchanged
	public static final int ADC12MEM2 = 0x24; // Unchanged
	public static final int ADC12MEM3 = 0x26; // Unchanged
	public static final int ADC12MEM4 = 0x28; // Unchanged
	public static final int ADC12MEM5 = 0x2A; // Unchanged
	public static final int ADC12MEM6 = 0x2C; // Unchanged
	public static final int ADC12MEM7 = 0x2E; // Unchanged
	public static final int ADC12MEM8 = 0x30; // Unchanged
	public static final int ADC12MEM9 = 0x32; // Unchanged
	public static final int ADC12MEM10 = 0x34; // Unchanged
	public static final int ADC12MEM11 = 0x36; // Unchanged
	public static final int ADC12MEM12 = 0x38; // Unchanged
	public static final int ADC12MEM13 = 0x3A; // Unchanged
	public static final int ADC12MEM14 = 0x3C; // Unchanged
	public static final int ADC12MEM15 = 0x3E; // Unchanged

	public static final int ADC12MCTL0 = 0x0010; // Reset with POR
	public static final int ADC12MCTL1 = 0x0011; // Reset with POR
	public static final int ADC12MCTL2 = 0x0012; // Reset with POR
	public static final int ADC12MCTL3 = 0x0013; // Reset with POR
	public static final int ADC12MCTL4 = 0x0014; // Reset with POR
	public static final int ADC12MCTL5 = 0x0015; // Reset with POR
	public static final int ADC12MCTL6 = 0x0016; // Reset with POR
	public static final int ADC12MCTL7 = 0x0017; // Reset with POR
	public static final int ADC12MCTL8 = 0x0018; // Reset with POR
	public static final int ADC12MCTL9 = 0x0019; // Reset with POR
	public static final int ADC12MCTL10 = 0x001A; // Reset with POR
	public static final int ADC12MCTL11 = 0x001B; // Reset with POR
	public static final int ADC12MCTL12 = 0x001C; // Reset with POR
	public static final int ADC12MCTL13 = 0x001D; // Reset with POR
	public static final int ADC12MCTL14 = 0x001E; // Reset with POR
	public static final int ADC12MCTL15 = 0x001F; // Reset with POR

	public static final int[] SHTBITS = new int[] { 4, 8, 16, 32, 64, 96, 128,
			192, 256, 384, 512, 768, 1024, 1024, 1024, 1024 };

	public static final int BUSY_MASK = 0x01;
	public static final int EOS_MASK = 0x80;

	public static final int CONSEQ_SINGLE = 0x00;
	public static final int CONSEQ_SEQUENCE = 0x01;
	public static final int CONSEQ_REPEAT_SINGLE = 0x02;
	public static final int CONSEQ_REPEAT_SEQUENCE = 0x03;
	public static final int CONSEQ_SEQUENCE_MASK = 0x01;

	private int adc12ctl0 = 0;
	private int adc12ctl1 = 0;
	private int adc12ctl2 = 0;
	private int[] adc12mctl = new int[16];
	private int[] adc12mem = new int[16];
	private int adc12Pos = 0;

	private int shTime0 = 4;
	private int shTime1 = 4;
	private boolean adc12On = false;
	private boolean enableConversion;
	private boolean startConversion;
	private boolean isConverting;

	private int shSource = 0;
	private int startMem = 0;
	private int adcDiv = 1;

	private ADCInput adcInput[] = new ADCInput[16];

	private int conSeq;
	private int adc12ie;
	private int adc12ifg;
	private int adc12iv;

	private int adcSSel;
	private int adc12Vector = 0x38;

	private TimeEvent adcTrigger = new TimeEvent(0) {
		public void execute(long t) {
			// System.out.println(getName() + " **** executing update timers at " +
			// t + " cycles=" + cpu.cycles);
			convert();
		}
	};

	/* These are CTL2 variables */
	private int bitsResolution = 12;
	private boolean formatSigned = false;
	private int clockPredivider = 1;

	/* Reference voltage 2.5V or 1.5V */
	private boolean ref25V = false;

	public ADC12Plus(MSP430Core cpu, int offset, int intVector) {
		super("ADC12Plus", cpu, cpu.memory, offset);
		adc12Vector = intVector;
	}

	public void reset(int type) {
		enableConversion = false;
		startConversion = false;
		isConverting = false;
		adc12ctl0 = 0;
		adc12ctl1 = 0;
		adc12ctl2 = 0;
		shTime0 = shTime1 = 4;
		adc12On = false;
		shSource = 0;
		startMem = adc12Pos = 0;
		adcDiv = 1;

		conSeq = 0;
		adc12ie = 0;
		adc12ifg = 0;
		adc12iv = 0;
		adcSSel = 0;

		Arrays.fill(adc12mctl, 0);

		clockPredivider = 1;
		formatSigned = false;
		bitsResolution = 12;
		ref25V = false;
	}

	public void setADCInput(int adindex, ADCInput input) {
		adcInput[adindex] = input;
	}

	/**
	 * Get the maximum input voltage set by the configuration of the registers
	 * (in mV)
	 * 
	 * @return
	 */
	public int getMaxInVoltage() {
		if (ref25V) {
			return 2500;
		} else {
			return 1500;
		}
	}

	/**
	 * Get the minimum in voltage set by the registers (in mV)
	 * 
	 * @return
	 */
	public int getMinInVoltage() {
		// TODO
		return 0;
	}

	// write a value to the IO unit
	public void write(int address, int value, boolean word, long cycles) {
		address -= offset;
		switch (address) {
		case ADC12CTL0:
			if (enableConversion) {
				// Ongoing conversion: only some parts may be changed
				adc12ctl0 = (adc12ctl0 & 0xfff0) + (value & 0xf);
			} else {
				adc12ctl0 = value;
				shTime0 = SHTBITS[(value >> 8) & 0x0f];
				shTime1 = SHTBITS[(value >> 12) & 0x0f];
				adc12On = (value & 0x10) > 0;
			}
			enableConversion = (value & 0x02) > 0;
			startConversion = (value & 0x01) > 0;
			ref25V = (value & 0x20) > 0;

			if (DEBUG)
				log("Set SHTime0: " + shTime0 + " SHTime1: " + shTime1 + " ENC:"
						+ enableConversion + " Start: " + startConversion
						+ " ADC12ON: " + adc12On);
			if (adc12On && enableConversion && startConversion && !isConverting) {
				// Set the start time to be now!
				isConverting = true;
				adc12Pos = startMem;
				int delay = clockPredivider * adcDiv
						* ((adc12Pos < 8 ? shTime0 : shTime1) + 13);
				cpu.scheduleTimeEvent(adcTrigger, cpu.getTime() + delay);
			}
			break;
		case ADC12CTL1:
			if (enableConversion) {
				// Ongoing conversion: only some parts may be changed
				adc12ctl1 = (adc12ctl1 & 0xfff8) + (value & 0x6);
			} else {
				adc12ctl1 = value & 0xfffe;
				startMem = (value >> 12) & 0xf;
				shSource = (value >> 10) & 0x3;
				adcDiv = ((value >> 5) & 0x7) + 1;
				adcSSel = (value >> 3) & 0x03;
			}
			conSeq = (value >> 1) & 0x03;
			if (DEBUG)
				log("Set startMem: " + startMem + " SHSource: " + shSource
						+ " ConSeq-mode:" + conSeq + " Div: " + adcDiv + " ADCSSEL: "
						+ adcSSel);
			break;

		case ADC12CTL2: /* Low Power Specs */
			if (enableConversion) {
				/*
				 * Clock pre divider can't be modified when conversion is already
				 * enabled
				 */
				value &= 0xfeff;
				value |= (adc12ctl2 & 0x100);
			}
			clockPredivider = ((value & 0x100) > 0) ? 4 : 1;
			/* bit resolution 8, 10, 12 */
			int tmp = (value & 0x30) >> 4;
			tmp = (tmp <= 2) ? tmp * 2 : 4;
			bitsResolution = tmp + 8;
			formatSigned = ((value & 0x08) > 0);
			if (formatSigned) {
				logw(WarningType.EMULATION_ERROR, "signed format not implemented");
			}
			adc12ctl2 = value;
			break;
		case ADC12IE:
			adc12ie = value;
			break;
		case ADC12IFG:
			adc12ifg = value;
			break;
		default:
			if (address >= ADC12MCTL0 && address <= ADC12MCTL15) {
				if (enableConversion) {
					/* Ongoing conversion: not possible to modify */
				} else {
					adc12mctl[address - ADC12MCTL0] = value & 0xff;
					if (DEBUG)
						log("ADC12MCTL" + (address - ADC12MCTL0) + " source = "
								+ (value & 0xf)
								+ (((value & EOS_MASK) != 0) ? " EOS bit set" : ""));
				}
			}
		}
	}

	// read a value from the IO unit
	public int read(int address, boolean word, long cycles) {
		address -= offset;
		switch (address) {
		case ADC12CTL0:
			return adc12ctl0;
		case ADC12CTL1:
			return isConverting ? (adc12ctl1 | BUSY_MASK) : adc12ctl1;
		case ADC12IE:
			return adc12ie;
		case ADC12IFG:
			return adc12ifg;
		default:
			if (address >= ADC12MCTL0 && address <= ADC12MCTL15) {
				return adc12mctl[address - ADC12MCTL0];
			} else if (address >= ADC12MEM0 && address <= ADC12MEM15) {
				int reg = (address - ADC12MEM0) / 2;
				// Clear ifg!
				adc12ifg &= ~(1 << reg);
				// System.out.println("Read ADCMEM" + (reg / 2));
				if (adc12iv == reg * 2 + 6) {
					cpu.flagInterrupt(adc12Vector, this, false);
					adc12iv = 0;
					// System.out.println("** de-Trigger ADC12 IRQ for ADCMEM" +
					// adc12Pos);
				}
				return adc12mem[reg];
			}
		}
		return 0;
	}

	int smp = 0;

	private void convert() {
		// If off then just return...
		if (!adc12On) {
			isConverting = false;
			return;
		}
		boolean runAgain = enableConversion && conSeq != CONSEQ_SINGLE;
		// Some noise...
		ADCInput input = adcInput[adc12mctl[adc12Pos] & 0xf];
		int reading = input != null ? input.nextData() : 2048 + 100 - smp & 255;
		/* Adapt resolution to 8, 10, 12 bits */
		float percent = (reading - getMinInVoltage()) * 1f
				/ ((getMaxInVoltage() - getMinInVoltage()) * 1f);
		reading = (int) (((1L << bitsResolution) - 1) * percent);
		adc12mem[adc12Pos] = reading;
		smp += 7;
		adc12ifg |= (1 << adc12Pos);
		if ((adc12ie & (1 << adc12Pos)) > 0) {
			// This should check if there already is an higher iv!
			adc12iv = adc12Pos * 2 + 6;
			// System.out.println("** Trigger ADC12 IRQ for ADCMEM" + adc12Pos);
			cpu.flagInterrupt(adc12Vector, this, true);
		}
		if ((conSeq & CONSEQ_SEQUENCE_MASK) != 0) {
			// Increase
			if ((adc12mctl[adc12Pos] & EOS_MASK) == EOS_MASK) {
				adc12Pos = startMem;
				if (conSeq == CONSEQ_SEQUENCE) {
					// Single sequence only
					runAgain = false;
				}
			} else {
				adc12Pos = (adc12Pos + 1) & 0x0f;
			}
		}
		if (!runAgain) {
			isConverting = false;
		} else {
			int delay = clockPredivider * adcDiv
					* ((adc12Pos < 8 ? shTime0 : shTime1) + 13);
			cpu.scheduleTimeEvent(adcTrigger, adcTrigger.getTime() + delay);
		}
	}

	public void interruptServiced(int vector) {
	}

	/**
	 * Get the reference voltage if it is 1.5 volts or 2.5V
	 * 
	 * @return
	 */
	public boolean isRef25V() {
		return ref25V;
	}

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/USARTSource.java`:

```java
package se.sics.mspsim.core;

public interface USARTSource {

    public void addUSARTListener(USARTListener listener);
    public void removeUSARTListener(USARTListener listener);

    public void addStateChangeListener(StateChangeListener listener);
    public void removeStateChangeListener(StateChangeListener listener);

    /* for input into this UART */
    public boolean isReceiveFlagCleared();
    public void byteReceived(int b);
    
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Multiplier.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Multiplier
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

public class Multiplier extends IOUnit {

  public static final int MPY = 0x130;
  public static final int MPYS = 0x132;
  public static final int MAC = 0x134;
  public static final int MACS = 0x136;
  public static final int OP2 = 0x138;
  public static final int RESLO = 0x13a;
  public static final int RESHI = 0x13c;
  public static final int SUMEXT = 0x13e;

  private int mpy;
  private int mpys;
  private int op2;

  private int resLo;
  private int resHi;
  private int mac;
  private int macs;
  private int sumext;
  
  private int op1;

  private boolean signed = false;  
  private boolean accumulating = false;
  /**
   * Creates a new <code>Multiplier</code> instance.
   *
   */
  public Multiplier(MSP430Core cpu, int memory[], int offset) {
    super("Multiplier", "Hardware Multiplier", cpu, memory, offset);
  }

  public int read(int address, boolean word, long cycles) {
    switch (address) {
    case MPY:
      return mpy;
    case MPYS:
      return mpys;
    case MAC:
      return mac;
    case MACS:
      return macs;
    case OP2:
      return op2;
    case RESHI:
      if (DEBUG) log("read res hi: " + resHi );
      return resHi;
    case RESLO:
      if (DEBUG) log("read res lo: " + resLo );
      return resLo;
    case SUMEXT:
      if (DEBUG) log("read sumext: " + sumext);
      return sumext;
    default:
        logw(WarningType.EMULATION_ERROR, "read unhandled address: 0x" + Utils.hex(address, 4));
        return 0;
    }
  }

  public void write(int address, int data, boolean word, long cycles) {
    if (DEBUG) {
      log("write to: $" + Utils.hex(address, 4) + " data = " + data + " word = " + word);
    }
    switch(address) {
    case MPY:
      op1 = mpy = data;
      if (DEBUG) log("Write to MPY: " + data);
      signed = false;
      accumulating = false;
      break;
    case MPYS:
      op1 = mpys = data;
      if (DEBUG) log("Write to MPYS: " + data);
      signed = true;
      accumulating = false;
      break;
    case MAC:
      op1 = mac = data;
      if (DEBUG) log("Write to MAC: " + data);
      signed = false;
      accumulating = true;
      break;
    case MACS:
      op1 = macs = data;
      if (DEBUG) log("Write to MACS: " + data);
      signed = true;
      accumulating = true;
      break;
    case RESLO:
      resLo = data;
      break;
    case RESHI:
      resHi = data;
      break;
    case OP2:
      if (DEBUG) log("Write to OP2: " + data);
      sumext = 0;
      op2 = data;
      // Expand to word
      if (signed) {
        if (!word) {
          if (op1 > 0x80) op1 = op1 | 0xff00;
          if (op2 > 0x80) op2 = op2 | 0xff00;
        }
        op1 = op1 > 0x8000 ? op1 - 0x10000 : op1;
        op2 = op2 > 0x8000 ? op2 - 0x10000 : op2;
      }
      
      long res = (long) op1 * (long) op2;
      if (DEBUG) log("O1:" + op1 + " * " + op2 + " = " + res);

      if (signed) {
        sumext = res < 0 ? 0xffff : 0;
      }
      
      if (accumulating) {
        res += ((long) resHi << 16) + resLo;
        if (!signed) {
          sumext = res > 0xffffffffL ? 1 : 0;
        }
      } else if (!signed) {
        sumext = 0;
      }
      
      resHi = (int) ((res >> 16) & 0xffff);
      resLo = (int) (res & 0xffff);
      if (DEBUG) log(" ===> result = " + res);
      break;
    }
  }

  @Override
  public void interruptServiced(int vector) {
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Flash.java`:

```java
/*
 * Copyright (c) 2009, Friedrich-Alexander University Erlangen, Germany
 * 
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of mspsim.
 *
 */
/**
 * @author Klaus Stengel <siklsten@informatik.stud.uni-erlangen.de>
 * @author Víctor Ariño <victor.arino@tado.com>
 */
package se.sics.mspsim.core;

import java.util.Arrays;

import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.core.Memory.AccessMode;
import se.sics.mspsim.util.Utils;

public class Flash extends IOUnit {
  
  private static final int FCTL1 = 0x00;
  private static final int FCTL2 = 0x02;
  private static final int FCTL3 = 0x04;
  private static final int FCTL4 = 0x06;
  
  /* Size of the flash controller */
  public static final int SIZE = 8;

  private static final int FRKEY =   0x9600;
  private static final int FWKEY =   0xA500;
  private static final int KEYMASK = 0xff00;
  private static final int CMDMASK = 0x00ff;

  private static final int BLKWRT = 0x80;
  private static final int WRT =    0x40;
  
  private static final int ERASE_SHIFT = 1;
  private static final int ERASE_MASK = 0x06;
  
  /* Erase modes needs to be first due to usage of ordinality */
  private enum WriteMode {
    NONE,
    ERASE_SEGMENT,
    ERASE_MAIN,
    ERASE_ALL,
    WRITE_SINGLE,
    WRITE_BLOCK,
    WRITE_BLOCK_FINISH
  }
  
  private static final int EMEX =    0x20;
  private static final int LOCK =    0x10;
  private static final int WAIT =    0x08;
  private static final int ACCVIFG = 0x04;
  private static final int KEYV =    0x02;
  private static final int BUSY =    0x01;

  private static final int FSSEL_SHIFT = 6;
  private static final int FSSEL_MASK = 0xc0;

  private static final int RESET_VECTOR = 15;
  private static final int NMI_VECTOR = 14;
  private static final int ACCVIE = 1 << 5;
  
  private enum ClockSource {
    ACLK,
    MCLK,
    SMCLK
  };
  
  private static final int MASS_ERASE_TIME = 5297;
  private static final int SEGMENT_ERASE_TIME = 4819;
  
  private static final int WRITE_TIME = 35;

  private static final int BLOCKWRITE_FIRST_TIME = 30;
  private static final int BLOCKWRITE_TIME = 21;
  private static final int BLOCKWRITE_END_TIME = 6;

  private static final int FN_MASK = 0x3f;
  private static final int LOCKINFO = 0x80;

  private FlashRange main_range;
  private FlashRange info_range;
  
  private int mode;      /* FCTL1 */
  private int clockcfg;  /* FCTL2 */
  private int statusreg; /* FCTL3 */

  private boolean locked;
  private boolean wait;
  private boolean blocked_cpu;

  private WriteMode currentWriteMode;
  private int blockwriteCount;
  
  /**
   * Infomem Configurations
   */
  private int infomemcfg = 0;
  /**
   * Whether the infomem is locked or not
   */
  private boolean lockInfo = true;
  
  private TimeEvent end_process = new TimeEvent(0) {
    public void execute(long t) {
      blocked_cpu = false;
      
      switch(currentWriteMode) {
      case NONE:
        break;
        
      case ERASE_SEGMENT:
      case ERASE_MAIN:
      case ERASE_ALL:
        // Erase flags are automatically cleared after each erase
	mode = 0;
	currentWriteMode = WriteMode.NONE;
	cpu.isFlashBusy = false;
	break;
	
      case WRITE_SINGLE:
	cpu.isFlashBusy = false;
	// WRT flags are NOT automatically cleared
	break;
	
      case WRITE_BLOCK:
	blockwriteCount++;
	if (blockwriteCount == 64) {
	  // FIXME: What happens if we try to write more than 64 bytes
	  // on real hardware???
	  logw(WarningType.EXECUTION, "Last access in block mode. Forced exit?");
	  currentWriteMode = WriteMode.WRITE_BLOCK_FINISH;
	}
/*	if (DEBUG) {
	  System.out.println("Write cycle complete, flagged WAIT.");
	} */
	wait = true;
	break;
	
      case WRITE_BLOCK_FINISH:
	if (DEBUG) {
	  log("Programming voltage dropped, write mode disabled.");
	}
	currentWriteMode = WriteMode.NONE;
	cpu.isFlashBusy = false;
	wait = true;
	mode = 0;
	break;
      }
    }
  };
  
  public Flash(MSP430Core cpu, int[] memory, FlashRange main_range,
      FlashRange info_range, int offset) {
    super("Flash", "Internal Flash", cpu, memory, offset);
    this.main_range = main_range;
    this.info_range = info_range;
    locked = true;

    Arrays.fill(memory, main_range.start, main_range.end, 0xff);
    Arrays.fill(memory, info_range.start, info_range.end, 0xff);

    reset(MSP430.RESET_POR);
  }

  public boolean blocksCPU() {
    return blocked_cpu;
  }
  
  public void interruptServiced(int vector) {
    cpu.flagInterrupt(vector, this, false);
  }
  
  public boolean addressInFlash(int address) {
    if (main_range.isInRange(address)) {
      return true;
    }
    if (info_range.isInRange(address)) {
      return true;
    }
    
    return false;
  }
  
  private int getFlashClockDiv() {
    return (clockcfg & FN_MASK) + 1;
  }
  
  private void waitFlashProcess(int time) {
    int instr_addr = cpu.getPC();
    int freqdiv = getFlashClockDiv();
    int myfreq;
    double finish_msec;
    
    cpu.isFlashBusy = true;
    if (addressInFlash(instr_addr)) {
      blocked_cpu = true;
    }
    
    switch(getClockSource()) {
    case ACLK:
      myfreq = cpu.aclkFrq / freqdiv;
      finish_msec = ((double)time * freqdiv * 1000) / cpu.aclkFrq;
      if (DEBUG)
        log("Using ACLK source with f=" + myfreq + "Hz. Time required=" + finish_msec + " ms");
      cpu.scheduleTimeEventMillis(end_process, finish_msec);
      break;
      
    case SMCLK:
      myfreq = cpu.smclkFrq / freqdiv;
      finish_msec = ((double)time * freqdiv * 1000) / cpu.smclkFrq;
      /* if (DEBUG)
	System.out.println("Flash: Using SMCLK source with f=" + myfreq 
	    + " Hz\nFlash: Time required=" + finish_msec + " ms"); */
      cpu.scheduleTimeEventMillis(end_process, finish_msec);
      break;

      
    case MCLK:
      if (DEBUG)
	log("Using MCLK source with div=" + freqdiv);
      cpu.scheduleCycleEvent(end_process, (long)time * freqdiv);
      break;
    }
  }
  
  public boolean needsTick() {
    return false;
  }
  
  public void flashWrite(int address, int data, AccessMode dataMode) {
    int wait_time = -1;
    
    if (locked) {
      if (DEBUG) {
        log("Write to flash blocked because of LOCK flag.");
      }
      return;
    }
    
    if (lockInfo && info_range.isInRange(address)) {
      if (DEBUG) {
        log("Write to infomem blocked because of LOCKINFO flag.");
      }
    }
    
    if (cpu.isFlashBusy || wait == false) {
      if (!((mode & BLKWRT) != 0 && wait)) {
	triggerAccessViolation("Flash write prohbited while BUSY=1 or WAIT=0");
	return;
      }
    }
    
    switch(currentWriteMode) {
    case ERASE_SEGMENT:
      int a_area_start[] = new int[1];
      int a_area_end[] = new int[1];
      getSegmentRange(address, a_area_start, a_area_end);
      int area_start = a_area_start[0];
      int area_end = a_area_end[0];
      
      if (DEBUG) {
	log("Segment erase @" + Utils.hex(address, 4) + 
	    ": erasing area " + Utils.hex(area_start, 4) + "-" +
	    Utils.hex(area_end, 4));
      }
      for (int i = area_start; i < area_end; i++) {
	memory[i] = 0xff;
      }
      waitFlashProcess(SEGMENT_ERASE_TIME);
      break;
      
    case ERASE_MAIN:
      if (! main_range.isInRange(address)) {
	return;
      }
      for (int i = main_range.start; i < main_range.end; i++) {
	memory[i] = 0xff;
      }
      waitFlashProcess(MASS_ERASE_TIME);
      break;
      
    case ERASE_ALL:
      for (int i = main_range.start; i < main_range.end; i++) {
	memory[i] = 0xff;
      }
      for (int i = info_range.start; i < main_range.end; i++) {
	memory[i] = 0xff;
      }
      waitFlashProcess(MASS_ERASE_TIME);
      break;
    case WRITE_SINGLE:
    case WRITE_BLOCK:
      if (currentWriteMode == WriteMode.WRITE_BLOCK) {
        wait = false;
        // TODO: Register target block and verify all writes stay in the same
        // block. What does the real hardware on random writes?!?
        if (blockwriteCount == 0) {
          wait_time = BLOCKWRITE_FIRST_TIME;
          if (DEBUG) {
            log("Flash write in block mode started @" + Utils.hex(address, 4));
          }
          if (addressInFlash(cpu.getPC())) {
            logw(WarningType.EXECUTION, "Oops. Block write access only allowed when executing from RAM.");
          }
        } else {
          wait_time = BLOCKWRITE_TIME;
        }
      } else {
        wait_time = WRITE_TIME;
      }
      /* Flash memory allows clearing bits only */
      memory[address] &= data & 0xff;
      if (dataMode != AccessMode.BYTE) {
          memory[address + 1] &= (data >> 8) & 0xff;
          if (dataMode == AccessMode.WORD20) {
              /* TODO should the write really write the full word? CHECK THIS */
              memory[address + 2] &= (data >> 16) & 0xff;
              memory[address + 3] &= (data >> 24) & 0xff;
          }
      }
      if (DEBUG) {
        log("Writing $" + Utils.hex20(data) + " to $" + Utils.hex(address, 4) + " (" + dataMode.bytes + " bytes)");
      }
      waitFlashProcess(wait_time);
      break;
    }
  }
  
  public void notifyRead(int address) {
    if (cpu.isFlashBusy) {
      triggerAccessViolation("Flash read not allowed while BUSY flag set");
      return;
    }
    if (DEBUG) {
      if (wait == false && currentWriteMode == WriteMode.WRITE_BLOCK) {
	log("Reading flash prohibited. Would read 0x3fff!!!"); 
	log("CPU PC=$" + Utils.hex(cpu.getPC(), 4) 
	    + " read address $" + Utils.hex(address, 4));
      }
    }
  }
  
  private FlashRange getFlashRange(int address) {
    if (main_range.isInRange(address)) {
      return main_range;
    }
    if (info_range.isInRange(address)) {
      return info_range;
    }
    return null;
  }
  
  private void getSegmentRange(int address, int[] start, int[] end) {
    FlashRange addr_type = getFlashRange(address);
    int segsize, ioffset;
    
    if (addr_type == null) {
      throw new RuntimeException("Address not in flash");
    }
    
    segsize = addr_type.segment_size;
    ioffset = address - addr_type.start;
    
    ioffset /= segsize;
    ioffset *= segsize;
    
    start[0] = addr_type.start + ioffset;
    end[0] = start[0] + segsize;
  }
  
  public int read(int address, boolean word, long cycles) {
    address = address - offset;
      
    if (address == FCTL1) {
      return mode | FRKEY;
    }
    if (address == FCTL2) {
      return clockcfg | FRKEY;
    }
    if (address == FCTL3) {
      int retval = statusreg | FRKEY;
      
      if (cpu.isFlashBusy)
	retval |= BUSY;
      
      if (locked)
	retval |= LOCK;
      
      if (wait)
	retval |= WAIT;
      
      return retval;
    }
    if (address == FCTL4) {
      return infomemcfg | FRKEY;
    }

    return 0;
  }

  private ClockSource getClockSource() {
    switch((clockcfg & FSSEL_MASK) >> FSSEL_SHIFT) {
      case 0:
      return ClockSource.ACLK;
      case 1:
      return ClockSource.MCLK;
      case 2:
      case 3:
      return ClockSource.SMCLK;
    }
    throw new RuntimeException("Bad clock source");
  }

  private boolean checkKey(int value) {
    if ((value & KEYMASK) == FWKEY)
      return true;

    logw(WarningType.EXECUTION, "Bad key accessing flash controller --> reset");
    statusreg |= KEYV;
    cpu.flagInterrupt(RESET_VECTOR, this, true);
    return false;
  }

  private void triggerEmergencyExit() {
    mode = 0;
    cpu.isFlashBusy = false;
    wait = true;
    locked = true;
    currentWriteMode = WriteMode.NONE;   
  }
  
  private WriteMode getEraseMode(int regdata) {
    int idx = (regdata & ERASE_MASK) >> ERASE_SHIFT;
    
    for (WriteMode em : WriteMode.values()) {
      if (em.ordinal() == idx)
	return em;
    }
    throw new IllegalArgumentException("Invalid erase mode: " + regdata);
  }
  
  private void triggerErase(int newmode) {
    currentWriteMode = getEraseMode(newmode);
  }
  
  private void triggerLockFlash() {
    locked = true;
  }
  
  private void triggerUnlockFlash() {
    locked = false;
  }
  
  private void triggerAccessViolation(String reason) {
    logw(WarningType.EXECUTION, "Access violation: " + reason + ". PC=$" + Utils.hex(cpu.getPC(), 4));

    statusreg |= ACCVIFG;
    if (cpu.getSFR().isIEBitsSet(SFR.IE1, ACCVIE)) {
      cpu.flagInterrupt(NMI_VECTOR, this, true);
    }
  }
  
  private void triggerSingleWrite() {
    /*if (DEBUG) {
      System.out.println("Single write triggered");
    }*/
    currentWriteMode = WriteMode.WRITE_SINGLE;
  }
  
  private void triggerBlockWrite() {
    if (DEBUG) {
      log("Block write triggered");
    }
    currentWriteMode = WriteMode.WRITE_BLOCK;
    blockwriteCount = 0;
  }
  
  private void triggerEndBlockWrite() {
    if (DEBUG) {
      log("Got end of flash block write");
    }
    currentWriteMode = WriteMode.WRITE_BLOCK_FINISH;
    waitFlashProcess(BLOCKWRITE_END_TIME);
  }
  
  public void write(int address, int value, boolean word, long cycles) {
    address = address - offset;
    if (!word) {
      logw(WarningType.EXECUTION, "Invalid access type to flash controller");
      return;
    }

    if (!(address == FCTL1 || address == FCTL2 || address == FCTL3 
   		 || address == FCTL4)) {
      return;
    }

    if (!checkKey(value)) {
      return;
    }

    int regdata = value & CMDMASK;
    switch (address) {
    case FCTL1:
      // access violation while erase/write in progress
      // exception: block write mode and WAIT==1
//      if ((mode & ERASE_MASK) != 0 || (mode & WRT) != 0) {
      if (cpu.isFlashBusy && ((mode & BLKWRT) == 0 || wait == false)) {
          //	if (!((mode & BLKWRT) != 0 && wait)) {
        triggerAccessViolation("FCTL1 write not allowed while erase/write active");
        return;
      }

      if ((mode & ERASE_MASK) != (regdata & ERASE_MASK)) {
	if ((mode & ERASE_MASK) == 0) {
	  triggerErase(regdata);
	}
	mode &= ~ERASE_MASK;
	mode |= regdata & ERASE_MASK;
      }

      if ((mode & WRT) != (regdata & WRT)) {
	if ((regdata & WRT) != 0) {
	  if ((regdata & BLKWRT) != 0) {
	    triggerBlockWrite();
	    mode |= BLKWRT;
	  } else {
	    triggerSingleWrite();
	  }
	}
	mode &= ~WRT;
	mode |= regdata & WRT;
      }
      
      if ((mode & BLKWRT) != 0 && (regdata & BLKWRT) == 0) {
	triggerEndBlockWrite();
	mode &= ~BLKWRT;
      }
      break;

    case FCTL2:
      // access violation if BUSY==1
      if (cpu.isFlashBusy) {
	triggerAccessViolation(
	    "Register write to FCTL2 not allowed when busy");
	return;
      }
      clockcfg = regdata;
      break;

    case FCTL3:
      if ((statusreg & EMEX) == 0 && (regdata & EMEX) != 0) {
	triggerEmergencyExit();
      }

      if (locked && (regdata & LOCK) == 0) {
	triggerUnlockFlash();
      } else {
	if (!locked && (regdata & LOCK) != 0) {
	  triggerLockFlash();
	}
      }

      if (((statusreg ^ regdata) & KEYV) != 0) {
	statusreg ^= KEYV;
      }
      if (((statusreg ^ regdata) & ACCVIFG) != 0) {
	statusreg ^= ACCVIFG;
      }

      break;
    case FCTL4:
      lockInfo = (regdata & LOCKINFO) > 0;
      infomemcfg = regdata;
      break;
    }
  }

  public void reset(int type) {
    if (DEBUG) {
      log("Got reset!");
    }

    if (type == MSP430.RESET_POR)
      statusreg = 0;
    
    mode = 0;
    clockcfg = 0x42;
    cpu.isFlashBusy = false;
    wait = true;
    locked = true;
    currentWriteMode = WriteMode.NONE;
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/StatusRegister.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare, http://www.thingsquare.com/.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

package se.sics.mspsim.core;

public class StatusRegister {
	static final int NEGATIVE = MSP430Constants.NEGATIVE;
	static final int ZERO = MSP430Constants.ZERO;
	static final int CARRY = MSP430Constants.CARRY;
	static final int OVERFLOW = MSP430Constants.OVERFLOW;

	static final boolean DEBUG = false;

	/* Tested with ADDA_IMM, ADDA_REG */
	public static int updateSR(int sr, int src, int dstArg, int dstResult) {
		sr &= ~(NEGATIVE | ZERO | CARRY | OVERFLOW);

		int dst20 = dstResult & 0xfffff;
		boolean srcNegative = (dstArg & (1 << 19)) != 0;
		boolean oldDstNegative = (dstArg & (1 << 19)) != 0;
		boolean dstNegative = (dst20 & (1 << 19)) != 0;

		if (dstNegative) {
			/* negative */
			sr |= NEGATIVE;
			if (DEBUG) {
				System.out.println("sr: negative");
			}
		}
		if (dst20 == 0) {
			/* zero */
			sr |= ZERO;
			if (DEBUG) {
				System.out.println("sr: zero");
			}
		}
		if (dstResult > dst20) {
			/* carry */
			sr |= CARRY;
			if (DEBUG) {
				System.out.println("sr: carry");
			}
		}
		if (srcNegative && oldDstNegative && !dstNegative) {
			/* overflow */
			sr |= OVERFLOW;
			if (DEBUG) {
				System.out.println("sr: overflow (--+)");
			}
		}
		if (!srcNegative && !oldDstNegative && dstNegative) {
			sr |= OVERFLOW;
			if (DEBUG) {
				System.out.println("sr: overflow (++-)");
			}
		}

		if (DEBUG) {
			System.out.printf("sr: updated sr 0x%02x\n", sr);
		}
		return sr;
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/TimeEvent.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * TimeEvent
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

public abstract class TimeEvent {
  // For linking events...
  TimeEvent nextEvent;
  TimeEvent prevEvent;

  // Keeps track of where this is scheduled
  EventQueue scheduledIn = null;
  String name;
  
  protected long time;

  public TimeEvent(long time) {
    this.time = time;
  }

  public TimeEvent(long time, String name) {
    this.time = time;
    this.name = name;
  }

  public final long getTime() {
    return time;
  }

  public boolean isScheduled() {
    return scheduledIn != null;
  }
  
  public boolean remove() {
    if (scheduledIn != null) {
      return scheduledIn.removeEvent(this);
    }
    return false;
  }
  
  public abstract void execute(long t);

  public String getShort() {
    return "" + time + ": " + (name != null ? name : this.getClass().getName());
  }

} // TimeEvent

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Multiplier32.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Multiplier
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

public class Multiplier32 extends IOUnit {

    public static final int MPY = 0x00;
    public static final int MPYS = 0x02;
    public static final int MAC = 0x04;
    public static final int MACS = 0x06;
    public static final int OP2 = 0x08;
    public static final int RESLO = 0x0a;
    public static final int RESHI = 0x0c;
    public static final int SUMEXT = 0x0e;

    public static final int MPY32L = 0x010;
    public static final int MPY32H = 0x012;
    public static final int MPYS32L = 0x014;
    public static final int MPYS32H = 0x016;
    public static final int MAC32L = 0x018;
    public static final int MAC32H = 0x01a;
    public static final int MACS32L = 0x01c;
    public static final int MACS32H = 0x01e;
    public static final int OP2L = 0x20;
    public static final int OP2H = 0x22;
    public static final int RES0 = 0x24;
    public static final int RES1 = 0x26;
    public static final int RES2 = 0x28;
    public static final int RES3 = 0x2a;
    public static final int MPY32CTL0 = 0x2c;

    private int mpy;
    private int mpys;
    private int op2;

    private int resLo;
    private int resHi;
    private int mac;
    private int macs;
    private int sumext;

    private int op1;

    private int mpy32L;
    private int mpy32H;
    private int mpys32L;
    private int mpys32H;
    private int mac32L;
    private int mac32H;
    private int macs32L;
    private int macs32H;
    private int op2L;
    private int op2H;
    private int res0;
    private int res1;
    private int res2;
    private int res3;
    private int mpy32ctl0;
    private long res64;

    private boolean signed = false;
    private boolean accumulating = false;

    /**
     * Creates a new <code>Multiplier32</code> instance.
     *
     */
    public Multiplier32(MSP430Core cpu, int memory[], int offset) {
        super("Multiplier32", "Hardware Multiplier 32", cpu, memory, offset);
    }

    @Override
    public int read(int address, boolean word, long cycles) {
        address = address - offset;
        switch (address) {
        case MPY:
            return mpy;
        case MPYS:
            return mpys;
        case MAC:
            return mac;
        case MACS:
            return macs;
        case OP2:
            return op2;
        case RESHI:
            if (DEBUG) log("read res hi: " + resHi );
            return resHi;
        case RESLO:
            if (DEBUG) log("read res lo: " + resLo );
            return resLo;
        case SUMEXT:
            if (DEBUG) log("read sumext: " + sumext);
            return sumext;
        case MPY32L:
            return mpy32L;
        case MPY32H:
            return mpy32H;
        case MPYS32L:
            return mpys32L;
        case MPYS32H:
            return mpys32H;
        case MAC32L:
            return mac32L;
        case MAC32H:
            return mac32H;
        case MACS32L:
            return macs32L;
        case MACS32H:
            return macs32H;
        case OP2L:
            return op2L;
        case OP2H:
            return op2H;
        case RES0:
            return res0;
        case RES1:
            return res1;
        case RES2:
            return res2;
        case RES3:
            return res3;
        case MPY32CTL0:
            return mpy32ctl0;
        default:
            logw(WarningType.EMULATION_ERROR, "read unhandled address: 0x" + Utils.hex(address, 4));
            return 0;
        }
    }

    @Override
    public void write(int address, int data, boolean word, long cycles) {
        address = address - offset;
        if (DEBUG) {
            log("write to: $" + Utils.hex(address, 4) + " data=" + data + " word=" + word);
        }
        switch(address) {
        case MPY:
            if (DEBUG) log("Write to MPY: " + data);
            op1 = mpy = data;
            signed = false;
            accumulating = false;
            break;
        case MPYS:
            op1 = mpys = data;
            if (DEBUG) log("Write to MPYS: " + data);
            signed = true;
            accumulating = false;
            break;
        case MAC:
            op1 = mac = data;
            if (DEBUG) log("Write to MAC: " + data);
            signed = false;
            accumulating = true;
            break;
        case MACS:
            op1 = macs = data;
            if (DEBUG) log("Write to MACS: " + data);
            signed = true;
            accumulating = true;
            break;
        case RESLO:
            resLo = data;
            break;
        case RESHI:
            resHi = data;
            break;
        case OP2:
            if (DEBUG) log("Write to OP2: " + data);
            sumext = 0;
            op2 = data;
            // Expand to word
            if (signed) {
                if (!word) {
                    if (op1 > 0x80) op1 = op1 | 0xff00;
                    if (op2 > 0x80) op2 = op2 | 0xff00;
                }
                op1 = op1 > 0x8000 ? op1 - 0x10000 : op1;
                op2 = op2 > 0x8000 ? op2 - 0x10000 : op2;
            }

            long res = (long) op1 * (long) op2;
            if (DEBUG) log("O1:" + op1 + " * " + op2 + " = " + res);

            if (signed) {
                sumext = res < 0 ? 0xffff : 0;
            }

            if (accumulating) {
                res += ((long) resHi << 16) + resLo;
                if (!signed) {
                    sumext = res > 0xffffffffL ? 1 : 0;
                }
            } else if (!signed) {
                sumext = 0;
            }

            resHi = (int) ((res >> 16) & 0xffff);
            resLo = (int) (res & 0xffff);
            if (DEBUG) log(" ===> result = " + res);
            break;
        case MPY32L:
            op1 = mpy32L = data;
            signed = false;
            accumulating = false;
            break;
        case MPY32H:
            mpy32H = data;
            op1 = (op1 & 0xffff) | (data << 16);
            break;
        case MPYS32L:
            if (!word && data >= 0x80) {
                data -= 0x100;
            }
            op1 = mpy32L = data;
            signed = true;
            accumulating = false;
            break;
        case MPYS32H:
            if (!word & data > 0x80) {
                data -= 0x100;
            }
            mpys32H = data;
            op1 = (op1 & 0xffff) | (data << 16);
            break;
        case MAC32L:
            op1 = mac32L = data;
            signed = false;
            accumulating = true;
            break;
        case MAC32H:
            mac32H = data;
            op1 = (op1 & 0xffff) | (data << 16);
            break;
        case MACS32L:
            if (!word & data > 0x80) {
                data -= 0x100;
            }
            op1 = macs32L = data;
            signed = true;
            accumulating = true;
            break;
        case MACS32H:
            if (!word & data > 0x80) {
                data -= 0x100;
            }
            macs32H = data;
            op1 = (op1 & 0xffff) | (data << 16);
            break;
        case OP2L:
            if (signed && !word && data >= 0x80) {
                data -= 0x80;
            }
            op2L = op2 = data;
            break;
        case OP2H: {
            long p;
            if (signed && !word && data >= 0x80) {
                data -= 0x80;
            }
            op2 = (op2 & 0xffff) | (data << 16);

            /* FIXME: Doesn't set SUMEXT and MPYC properly. */
            if (signed) {
                p = (long) op1 * (long) op2;
            }
            else {
                long uop1, uop2;
                uop1 = op1;
                if (uop1 < 0) {
                    uop1 += 0x100000000L;
                }
                uop2 = op2;
                if (uop2 < 0) {
                    uop2 += 0x100000000L;
                }

                p = uop1 * uop2;
            }
            if (accumulating) {
                res64 += p;
            } else {
                res64 = p;
            }
            
            /* FIXME: Ignore accumulate. */
            resLo = res0 = (int) res64 & 0xffff;
            resHi = res1 = (int) (res64 >> 16) & 0xffff;
            res2 = (int) (res64 >> 32) & 0xffff;
            res3 = (int) (res64 >> 48) & 0xffff;

            break;
        }
        default:
            logw(WarningType.EMULATION_ERROR, "**** Not yet implemented multiplier 32 register: 0x" + Utils.hex(address, 4));
            break;
        }
    }

    @Override
    public void interruptServiced(int vector) {
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/StateChangeListener.java`:

```java
/*
 * Copyright (c) 2010-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * StateChangeListener
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 17 jul 2010
 */

package se.sics.mspsim.core;
import se.sics.mspsim.util.ProxySupport;

/**
 *
 */
public interface StateChangeListener {

    public void stateChanged(Object source, int oldState, int newState);

    public static class Proxy extends ProxySupport<StateChangeListener> implements StateChangeListener {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void stateChanged(Object source, int oldState, int newState) {
            StateChangeListener[] listeners = this.listeners;
            for(StateChangeListener listener : listeners) {
                listener.stateChanged(source, oldState, newState);
            }
        }

    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/SimEventListener.java`:

```java
/*
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SimEventListener
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 6 nov 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

/**
 *
 */
public interface SimEventListener {

  public void simChanged(SimEvent event);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/GlobalWatchedMemory.java`:

```java
package se.sics.mspsim.core;

public class GlobalWatchedMemory implements Memory {

    private final Memory wrappedMemory;
    private MemoryMonitor monitor;

    GlobalWatchedMemory(Memory wrapped) {
        this.wrappedMemory = wrapped;
    }

    public Memory getWatchedMemory() {
        return wrappedMemory;
    }

    public boolean hasGlobalMonitor() {
        return monitor != null;
    }

    public synchronized void addGlobalMonitor(MemoryMonitor mon) {
        monitor = MemoryMonitor.Proxy.INSTANCE.add(monitor, mon);
    }

    public synchronized void removeGlobalMonitor(MemoryMonitor mon) {
        monitor = MemoryMonitor.Proxy.INSTANCE.remove(monitor, mon);
    }

    @Override
    public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
        final MemoryMonitor mon = monitor;
        if (mon != null) {
            mon.notifyReadBefore(address, mode, type);

            int val = wrappedMemory.read(address, mode, type);

            mon.notifyReadAfter(address, mode, type);
            return val;
        }
        return wrappedMemory.read(address, mode, type);
    }

    @Override
    public void write(int dstAddress, int data, AccessMode mode) throws EmulationException {
        MemoryMonitor mon = monitor;
        if (mon != null) {
            mon.notifyWriteBefore(dstAddress, data, mode);
            wrappedMemory.write(dstAddress, data, mode);
            mon.notifyWriteAfter(dstAddress, data, mode);
        } else {
            wrappedMemory.write(dstAddress, data, mode);
        }
    }

    @Override
    public int get(int address, AccessMode mode) {
        return wrappedMemory.get(address, mode);
    }

    @Override
    public void set(int address, int data, AccessMode mode) {
        wrappedMemory.set(address, data, mode);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/MSP430Core.java`:

```java
/**
 * Copyright (c) 2007, 2008, 2009, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * MSP430Core
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;

import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.core.Memory.AccessMode;
import se.sics.mspsim.core.Memory.AccessType;
import se.sics.mspsim.util.ComponentRegistry;
import se.sics.mspsim.util.DefaultEmulationLogger;
import se.sics.mspsim.util.MapEntry;
import se.sics.mspsim.util.MapTable;
import se.sics.mspsim.util.Utils;

/**
 * The CPU of the MSP430
 */
public class MSP430Core extends Chip implements MSP430Constants {

  public static final int RETURN = 0x4130;

  public static final boolean debugInterrupts = false;

  public static final boolean EXCEPTION_ON_BAD_OPERATION = true;

  // Try it out with 64 k memory
  public final int MAX_MEM;
  public final int MAX_MEM_IO;
  
  // 16 registers of which some are "special" - PC, SP, etc.
  public final int[] reg = new int[16];

  private final RegisterMonitor[] regWriteMonitors = new RegisterMonitor[16];
  private final RegisterMonitor[] regReadMonitors = new RegisterMonitor[16];

  // true => breakpoints can occur!
  boolean breakpointActive = true;

  public final int memory[];
  private final Flash flash;
  boolean isFlashBusy;
  boolean isStopping = false;

  private final Memory memorySegments[];
  Memory currentSegment;

  public long cycles = 0;
  public long cpuCycles = 0;
  MapTable map;
  public final boolean MSP430XArch;
  public final MSP430Config config;

  private final ArrayList<IOUnit> ioUnits;
  private final SFR sfr;
  private final Watchdog watchdog;
  private final ClockSystem bcs;

  // From the possible interrupt sources - to be able to indicate is serviced.
  // NOTE: 64 since more modern MSP430's have more than 16 vectors (5xxx has 64).
  private InterruptHandler interruptSource[] = new InterruptHandler[64];
  public int MAX_INTERRUPT;
  
  protected int interruptMax = -1;
  // Op/instruction represents the last executed OP / instruction
  private int op;
  public int instruction;
  private int extWord;
  int servicedInterrupt = -1;
  InterruptHandler servicedInterruptUnit = null;

  protected boolean interruptsEnabled = false;
  protected boolean cpuOff = false;

  // Not private since they are needed (for fast access...)
  public int dcoFrq = 2500000;
  int aclkFrq = 32768;
  public int smclkFrq = dcoFrq;

  long lastCyclesTime = 0;
  long lastVTime = 0;
  long currentTime = 0;
  long lastMicrosDelta;
  double currentDCOFactor = 1.0;
  
  // Clk A can be "captured" by timers - needs to be handled close to CPU...?
//  private int clkACaptureMode = CLKCAPTURE_NONE;
  // Other clocks too...
  long nextEventCycles;
  private EventQueue vTimeEventQueue = new EventQueue();
  private long nextVTimeEventCycles;

  private EventQueue cycleEventQueue = new EventQueue();
  private long nextCycleEventCycles;
  
  private ArrayList<Chip> chips = new ArrayList<Chip>();

  final ComponentRegistry registry;
  Profiler profiler;

  public MSP430Core(int type, ComponentRegistry registry, MSP430Config config) {
    super("MSP430", "MSP430 Core", null);

    logger = registry.getComponent(EmulationLogger.class);
    if (logger == null) {
        logger = new DefaultEmulationLogger(this, System.out);
        registry.registerComponent("logger", logger);
    }
    
    MAX_INTERRUPT = config.maxInterruptVector;
    MAX_MEM_IO = config.maxMemIO;
    MAX_MEM = config.maxMem;
    MSP430XArch = config.MSP430XArch;

    memory = new int[MAX_MEM];
    memorySegments = new Memory[MAX_MEM >> 8];

    flash = new Flash(this, memory,
            new FlashRange(config.mainFlashStart, config.mainFlashStart + config.mainFlashSize, 512, 64),
            new FlashRange(config.infoMemStart, config.infoMemStart + config.infoMemSize, 128, 64),
            config.flashControllerOffset);

    currentSegment = new Memory() {
        @Override
        public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
            if (address >= MAX_MEM) {
            	throw new EmulationException("Reading outside memory: 0x" + Utils.hex(address, 4));
            }
            return memorySegments[address >> 8].read(address, mode, type);
        }
        @Override
        public void write(int address, int data, AccessMode mode) throws EmulationException {
            if (address >= MAX_MEM) {
                throw new EmulationException("Writing outside memory: 0x" + Utils.hex(address, 4));
            }
            memorySegments[address >> 8].write(address, data, mode);
        }
        @Override
        public int get(int address, AccessMode mode) {
            if (address >= MAX_MEM) {
                throw new EmulationException("Reading outside memory: 0x" + Utils.hex(address, 4));
            }
            return memorySegments[address >> 8].get(address, mode);
        }
        @Override
        public void set(int address, int data, AccessMode mode) {
            if (address >= MAX_MEM) {
                throw new EmulationException("Writing outside memory: 0x" + Utils.hex(address, 4));
            }
            memorySegments[address >> 8].set(address, data, mode);
        }
    };

//    System.out.println("Set up MSP430 Core with " + MAX_MEM + " bytes memory");

    /* this is for detecting writes/read to/from non-existing IO */
    IOUnit voidIO = new IOUnit("void", this, memory, 0) {
        public void interruptServiced(int vector) {
        }
        public void write(int address, int value, boolean word, long cycles) {
            cpu.logw(WarningType.VOID_IO_WRITE, "*** IOUnit write to non-existent IO at $" + Utils.hex(address, 4));
        }
        public int read(int address, boolean word, long cycles) {
            cpu.logw(WarningType.VOID_IO_READ, "*** IOUnit read from non-existent IO at $" + Utils.hex(address, 4));
            return 0;
        }
    };

    /* setup memory segments */
    int maxSeg = MAX_MEM >> 8;
    Memory ramSegment = new RAMSegment(this);
    RAMOffsetSegment ramMirrorSegment = null;
    Memory flashSegment = new FlashSegment(this, flash);
    IOSegment ioSegment = new IOSegment(this, MAX_MEM_IO, voidIO);
    Memory noMemorySegment = new NoMemSegment(this);
    for (int i = 0; i < maxSeg; i++) {
        if (config.isRAM(i << 8)) {
//            System.out.println("Setting RAM segment at: " + Utils.hex16(i << 8));
            memorySegments[i] = ramSegment;
        } else if (config.isRAMMirror(i << 8)) {
            if (ramMirrorSegment == null) {
                ramMirrorSegment = new RAMOffsetSegment(this, config.ramMirrorAddress - config.ramMirrorStart);
            }
//            System.out.println("Setting RAM mirror segment at: " + Utils.hex(i << 8, 4)
//                    + " => " + Utils.hex((i << 8) + ramMirrorSegment.getOffset()));
            memorySegments[i] = ramMirrorSegment;
        } else if (config.isFlash(i << 8) || config.isInfoMem(i << 8)) {
//            System.out.println("Setting Flash segment at: " + Utils.hex16(i << 8));
            memorySegments[i] = flashSegment;
        } else if (config.isIO(i << 8)) {
//            System.out.println("Setting IO segment at: " + Utils.hex16(i << 8));
            memorySegments[i] = ioSegment;
        } else {
//            System.out.println("Setting NoMem segment at: " + Utils.hex16(i << 8));
            memorySegments[i] = noMemorySegment;
        }
    }

    this.registry = registry;
    this.config = config;
    // The CPU need to register itself as chip
    addChip(this);

    // Ignore type for now...
    setModeNames(MODE_NAMES);
    // IOUnits should likely be placed in a hashtable?
    // Maybe for debugging purposes...
    ioUnits = new ArrayList<IOUnit>();

    ioSegment.setIORange(config.flashControllerOffset, Flash.SIZE, flash);
 
    /* Setup special function registers */
    sfr = new SFR(this, memory);
    ioSegment.setIORange(config.sfrOffset, 0x10, sfr);

    // first step towards making core configurable
    Timer[] timers = new Timer[config.timerConfig.length];
    for (int i = 0; i < config.timerConfig.length; i++) {
        Timer t = new Timer(this, memory, config.timerConfig[i]);
        ioSegment.setIORange(config.timerConfig[i].offset, 0x20, t);
        ioSegment.setIORange(config.timerConfig[i].timerIVAddr, 1, t);
        timers[i] = t;
    }

    bcs = config.createClockSystem(this, memory, timers);
    ioSegment.setIORange(bcs.getAddressRangeMin(), bcs.getAddressRangeMax() - bcs.getAddressRangeMin() + 1, bcs);

    // SFR and Basic clock system.
    ioUnits.add(sfr);
    ioUnits.add(bcs);

    config.setup(this, ioUnits);

    /* timers after ports ? */
    ioUnits.addAll(Arrays.asList(timers));

    watchdog = new Watchdog(this, config.watchdogOffset);
    ioSegment.setIORange(config.watchdogOffset, 1, watchdog);

    ioUnits.add(watchdog);

    bcs.reset(0);
  }

  public void setIORange(int address, int range, IOUnit io) {
      if (address + range > MAX_MEM_IO) {
          throw new IllegalStateException("Outside IO memory: 0x" + Utils.hex(address, 4));
      }
      IOSegment ioSegment = (IOSegment) memorySegments[address >> 8];
      ioSegment.setIORange(address, range, io);
  }

  public Profiler getProfiler() {
    return profiler;
  }

  public void setProfiler(Profiler prof) {
    registry.registerComponent("profiler", prof);
    profiler = prof;
    profiler.setCPU(this);
  }

  public synchronized void addGlobalMonitor(MemoryMonitor mon) {
      GlobalWatchedMemory gwm;
      if (currentSegment instanceof GlobalWatchedMemory) {
          gwm = (GlobalWatchedMemory)currentSegment;
      } else {
          currentSegment = gwm = new GlobalWatchedMemory(currentSegment);
      }
      gwm.addGlobalMonitor(mon);
  }

  public synchronized void removeGlobalMonitor(MemoryMonitor mon) {
      if (currentSegment instanceof GlobalWatchedMemory) {
          GlobalWatchedMemory gwm = (GlobalWatchedMemory)currentSegment;
          gwm.removeGlobalMonitor(mon);
          if (!gwm.hasGlobalMonitor()) {
              // No more monitors - switch back to normal memory
              currentSegment = gwm.getWatchedMemory();
          }
      }
  }

  public ComponentRegistry getRegistry() {
    return registry;
  }

  public SFR getSFR() {
    return sfr;
  }

  public void addChip(Chip chip) {
    chips.add(chip);
  }

  public Chip getChip(String name) {
    for(Chip chip : chips) {
      if (name.equalsIgnoreCase(chip.getID()) || name.equalsIgnoreCase(chip.getName())) {
        return chip;
      }
    }
    return null;
  }

  public <T extends Chip> T getChip(Class<T> type) {
    for(Chip chip : chips) {
      if (type.isInstance(chip)) {
        return type.cast(chip);
      }
    }
    return null;
  }

  public <T extends Chip> T getChip(Class<T> type, String name) {
      for(Chip chip : chips) {
        if (type.isInstance(chip) &&
                (name.equalsIgnoreCase(chip.getID()) || name.equalsIgnoreCase(chip.getName()))) {
          return type.cast(chip);
        }
      }
      return null;
  }

  public Chip[] getChips() {
      return chips.toArray(new Chip[chips.size()]);
  }

  public <T extends Chip> T[] getChips(Class<T> type) {
      ArrayList<T> list = new ArrayList<T>();
      for(Chip chip : chips) {
          if (type.isInstance(chip)) {
              list.add(type.cast(chip));
          }
      }
      @SuppressWarnings("unchecked")
      T[] tmp = (T[]) java.lang.reflect.Array.newInstance(type, list.size());
      return list.toArray(tmp);
  }

  public Loggable[] getLoggables() {
      Loggable[] ls = new Loggable[ioUnits.size() + chips.size()];
      for (int i = 0; i < ioUnits.size(); i++) {
          ls[i] = ioUnits.get(i);
      }
      for (int i = 0; i < chips.size(); i++) {
          ls[i + ioUnits.size()] = chips.get(i);
      }
      return ls;
  }

  public Loggable getLoggable(String name) {
      Loggable l = getChip(name);
      if (l == null) {
          l = getIOUnit(name);
      }
      return l;
  }

  public boolean hasWatchPoint(int address) {
      Memory mem = memorySegments[address >> 8];
      if (mem instanceof WatchedMemory) {
          return ((WatchedMemory)mem).hasWatchPoint(address);
      }
      return false;
  }

  public synchronized void addWatchPoint(int address, MemoryMonitor mon) {
      int seg = address >> 8;
      WatchedMemory wm;
      if (memorySegments[seg] instanceof WatchedMemory) {
          wm = (WatchedMemory) memorySegments[seg];
      } else {
          wm = new WatchedMemory(address & 0xfff00, memorySegments[seg]);
          memorySegments[seg] = wm;
      }
      wm.addWatchPoint(address, mon);
  }

  public synchronized void removeWatchPoint(int address, MemoryMonitor mon) {
      if (memorySegments[address >> 8] instanceof WatchedMemory) {
          WatchedMemory wm = (WatchedMemory) memorySegments[address >> 8];
          wm.removeWatchPoint(address, mon);
      }
  }

  public synchronized void addRegisterMonitor(int r, RegisterMonitor mon) {
      addRegisterWriteMonitor(r, mon);
      addRegisterReadMonitor(r, mon);
  }

  public synchronized void removeRegisterMonitor(int r, RegisterMonitor mon) {
      removeRegisterWriteMonitor(r, mon);
      removeRegisterReadMonitor(r, mon);
  }

  public synchronized void addRegisterWriteMonitor(int r, RegisterMonitor mon) {
      regWriteMonitors[r] = RegisterMonitor.Proxy.INSTANCE.add(regWriteMonitors[r], mon);
  }

  public synchronized void removeRegisterWriteMonitor(int r, RegisterMonitor mon) {
      regWriteMonitors[r] = RegisterMonitor.Proxy.INSTANCE.remove(regWriteMonitors[r], mon);
  }

  public synchronized void addRegisterReadMonitor(int r, RegisterMonitor mon) {
      regReadMonitors[r] = RegisterMonitor.Proxy.INSTANCE.add(regReadMonitors[r], mon);
  }

  public synchronized void removeRegisterReadMonitor(int r, RegisterMonitor mon) {
      regReadMonitors[r] = RegisterMonitor.Proxy.INSTANCE.remove(regReadMonitors[r], mon);
  }

  public void writeRegister(int r, int value) {
      value &= 0xfffff;
    
      /* PC must never be odd */
      if (r == PC && (value % 2) != 0) {
          /* With a solid compiler, this should never happen.
           * Yet, this has been observed at least once with msp430-gcc 4.6.3. */
          System.out.println("Warning: tried to write odd PC, not allowed! PC=0x" + Integer.toHexString(value));
          value -= 1;
      }

      /* SR can never take values above 0xfff */
      if (r == SR) {
          value &= 0xfff;
      }

    // Before the write!
//    if (value >= MAX_MEM) {
//        System.out.println("Writing larger than MAX_MEM to " + r + " value:" + value);
//        new Throwable().printStackTrace();
//    }
      
      RegisterMonitor rwm = regWriteMonitors[r];
    if (rwm != null) {
        // TODO Add register access mode
        rwm.notifyWriteBefore(r, value, AccessMode.WORD);
        reg[r] = value;
        rwm.notifyWriteAfter(r, value, AccessMode.WORD);
    } else {
        reg[r] = value;
    }
    if (r == SR) {
      boolean oldCpuOff = cpuOff;
      if (debugInterrupts) {
          if (((value & GIE) == GIE) != interruptsEnabled) {
              System.out.println("InterruptEnabled changed: " + !interruptsEnabled);
          }
      }
      boolean oldIE = interruptsEnabled;
      interruptsEnabled = ((value & GIE) == GIE);

//      if (debugInterrupts) System.out.println("Wrote to InterruptEnabled: " + interruptsEnabled + " was: " + oldIE);
      
      if (oldIE == false && interruptsEnabled && servicedInterrupt >= 0) {
//          System.out.println("*** Interrupts enabled while in interrupt : " +
//                  servicedInterrupt + " PC: $" + getAddressAsString(reg[PC]));
          /* must handle pending immediately */
          handlePendingInterrupts();
      }
      
      cpuOff = ((value & CPUOFF) == CPUOFF);
      if (cpuOff != oldCpuOff) {
// 	System.out.println("LPM CPUOff: " + cpuOff + " cycles: " + cycles);
      }
      if (cpuOff) {
        boolean scg0 = (value & SCG0) == SCG0;
        boolean scg1 = (value & SCG1) == SCG1;
        boolean oscoff = (value & OSCOFF) == OSCOFF;
        if (oscoff && scg1 && scg0) {
          setMode(MODE_LPM4);
        } else if (scg1 && scg0){
          setMode(MODE_LPM3);
        } else if (scg1) {
          setMode(MODE_LPM2);
        } else if (scg0) {
          setMode(MODE_LPM1);
        } else {
          setMode(MODE_LPM0); 
        }
      } else {
        setMode(MODE_ACTIVE);
      }
    }
  }

  public int readRegister(int r) {
    int value;
    RegisterMonitor rrm = regReadMonitors[r];
    if (rrm != null) {
        // TODO Register access mode
        rrm.notifyReadBefore(r, AccessMode.WORD);
        value = reg[r];
        rrm.notifyReadAfter(r, AccessMode.WORD);
    } else {
        value = reg[r];
    }
    return value;
  }

  public int readRegisterCG(int r, int m) {
      // CG1 + m == 0 => SR!
    if ((r == CG1 && m != 0) || r == CG2) {
      // No monitoring here... just return the CG values
      return CREG_VALUES[r - 2][m];
    }
    int value;
    RegisterMonitor rrm = regReadMonitors[r];
    if (rrm != null) {
        // TODO Register access mode
        rrm.notifyReadBefore(r, AccessMode.WORD);
        value = reg[r];
        rrm.notifyReadAfter(r, AccessMode.WORD);
    } else {
        value = reg[r];
    }
    return value;
  }

  public int incRegister(int r, int value) {
    int registerValue;
    RegisterMonitor rm = regReadMonitors[r];
    if (rm != null) {
        rm.notifyReadBefore(r, AccessMode.WORD);
        registerValue = reg[r];
        rm.notifyReadAfter(r, AccessMode.WORD);
    } else {
        registerValue = reg[r];
    }
    rm = regWriteMonitors[r];
    registerValue += value;
    if (rm != null) {
      rm.notifyWriteBefore(r, registerValue, AccessMode.WORD);
      reg[r] = registerValue;
      rm.notifyWriteAfter(r, registerValue, AccessMode.WORD);
    } else {
      reg[r] = registerValue;
    }
    return reg[r];
  }

  public void setACLKFrq(int frequency) {
    aclkFrq = frequency;
  }

  public void setDCOFrq(int frequency, int smclkFrq) {
    dcoFrq = frequency;
    this.smclkFrq = smclkFrq;
    // update last virtual time before updating DCOfactor
    lastVTime = getTime();
    lastCyclesTime = cycles;
    lastMicrosDelta = 0;

    currentDCOFactor = 1.0 * bcs.getMaxDCOFrequency() / frequency;

    /*    System.out.println("*** DCO: MAX:" + bcs.getMaxDCOFrequency() +
	  " current: " + frequency + " DCO_FAC = " + currentDCOFactor);*/
    if (DEBUG)
      log("Set smclkFrq: " + smclkFrq);
    dcoReset();
  }

  /* called after dcoReset */
  protected void dcoReset() {
  }
  
  // returns global time counted in max speed of DCOs (~5Mhz)
  public long getTime() {
    long diff = cycles - lastCyclesTime;
    return lastVTime + (long) (diff * currentDCOFactor);
  }

  // Converts a virtual time to a cycles time according to the current
  // cycle speed
  private long convertVTime(long vTime) {
    long tmpTime = lastCyclesTime + (long) ((vTime - lastVTime) / currentDCOFactor);
//    System.out.println("ConvertVTime: vTime=" + vTime + " => " + tmpTime);
    return tmpTime;
  }
  
  // get elapsed time in seconds
  public double getTimeMillis() {
      return 1000.0 * getTime() / bcs.getMaxDCOFrequency();
  }
  
  private void executeEvents() {
    if (cycles >= nextVTimeEventCycles) {
      if (vTimeEventQueue.eventCount == 0) {
        nextVTimeEventCycles = cycles + 10000;
      } else {
        TimeEvent te = vTimeEventQueue.popFirst();
        long now = getTime();
//        if (now > te.time) {
//          System.out.println("VTimeEvent got delayed by: " + (now - te.time) + " at " +
//              cycles + " target Time: " + te.time + " class: " + te.getClass().getName());
//        }
        te.execute(now);
        if (vTimeEventQueue.eventCount > 0) {
          nextVTimeEventCycles = convertVTime(vTimeEventQueue.nextTime);
        } else {
          nextVTimeEventCycles = cycles + 10000;          
        }
      }
    }
    
    if (cycles >= nextCycleEventCycles) {
      if (cycleEventQueue.eventCount == 0) {
        nextCycleEventCycles = cycles + 10000;
      } else {
        TimeEvent te = cycleEventQueue.popFirst();
        te.execute(cycles);
        if (cycleEventQueue.eventCount > 0) {
          nextCycleEventCycles = cycleEventQueue.nextTime;
        } else {
          nextCycleEventCycles = cycles + 10000;          
        }
      }
    }
    
    // Pick the one with shortest time in the future.
    nextEventCycles = nextCycleEventCycles < nextVTimeEventCycles ? 
        nextCycleEventCycles : nextVTimeEventCycles;
  }
  
  /**
   * Schedules a new Time event using the cycles counter
   * @param event
   * @param cycles
   */
  public void scheduleCycleEvent(TimeEvent event, long cycles) {
    long currentNext = cycleEventQueue.nextTime;
    cycleEventQueue.addEvent(event, cycles);
    if (currentNext != cycleEventQueue.nextTime) {
      nextCycleEventCycles = cycleEventQueue.nextTime;
      if (nextEventCycles > nextCycleEventCycles) {
        nextEventCycles = nextCycleEventCycles;
      }
    }
  }

  
  /**
   * Schedules a new Time event using the virtual time clock
   * @param event
   * @param time
   */
  public void scheduleTimeEvent(TimeEvent event, long time) {
    long currentNext = vTimeEventQueue.nextTime;
    vTimeEventQueue.addEvent(event, time);
    if (currentNext != vTimeEventQueue.nextTime) {
      // This is only valid when not having a cycle event queue also...
      // if we have it needs to be checked also!
      nextVTimeEventCycles = convertVTime(vTimeEventQueue.nextTime);
      if (nextEventCycles > nextVTimeEventCycles) {
        nextEventCycles = nextVTimeEventCycles;
      }
      /* Warn if someone schedules a time backwards in time... */
      if (cycles > nextVTimeEventCycles) {
        logger.logw(this, WarningType.EMULATION_ERROR, "Scheduling time event backwards in time!!!");
        throw new IllegalStateException("Cycles are passed desired future time...");
      }
    }
  }
  
  
  /**
   * Schedules a new Time event msec milliseconds in the future
   * @param event
   * @param msec
   */
  public long scheduleTimeEventMillis(TimeEvent event, double msec) {
      /*    System.out.println("MAX_DCO " + bcs.getMaxDCOFrequency());*/
    long time = (long) (getTime() + msec / 1000 * bcs.getMaxDCOFrequency());
//    System.out.println("Scheduling at: " + time + " (" + msec + ") getTime: " + getTime());
    scheduleTimeEvent(event, time);
    return time;
  }

  public void printEventQueues(PrintStream out) {
      out.println("Current cycles: " + cycles + "  virtual time:" + getTime());
      out.println("Cycle event queue: (next time: " + nextCycleEventCycles + ")");
      cycleEventQueue.print(out);
      out.println("Virtual time event queue: (next time: " + nextVTimeEventCycles + ")");
      vTimeEventQueue.print(out);
  }
 
  // Should also return active units...
  public IOUnit getIOUnit(String name) {
    for (IOUnit ioUnit : ioUnits) {
      if (name.equalsIgnoreCase(ioUnit.getID()) ||
          name.equalsIgnoreCase(ioUnit.getName())) {
	return ioUnit;
      }
    }
    return null;
  }

  public <T> T getIOUnit(Class<T> type) {
      for (IOUnit ioUnit : ioUnits) {
          if (type.isInstance(ioUnit)) {
              return type.cast(ioUnit);
          }
      }
      return null;
  }

  public <T> T getIOUnit(Class<T> type, String name) {
      for (IOUnit ioUnit : ioUnits) {
          if (type.isInstance(ioUnit)
                  && (name.equalsIgnoreCase(ioUnit.getID())
                          || name.equalsIgnoreCase(ioUnit.getName()))) {
              return type.cast(ioUnit);
          }
      }
      return null;
  }

  private void resetIOUnits() {
      for (IOUnit ioUnit : ioUnits) {
          ioUnit.reset(RESET_POR);
      }
  }

  private void internalReset() {
    for (int i = 0, n = interruptSource.length; i < n; i++) {
      interruptSource[i] = null;
    }
    servicedInterruptUnit = null;
    servicedInterrupt = -1;
    interruptMax = -1;
    writeRegister(SR, 0);
   
    cycleEventQueue.removeAll();
    vTimeEventQueue.removeAll();

    for (Chip chip : chips) {
      chip.notifyReset();
    }
    // Needs to be last since these can add events...
    resetIOUnits();
  
    if (profiler != null) {
        profiler.resetProfile();
    }
  }

  public EmulationLogger getLogger() {
      return logger;
  }
  
  public void reset() {
    flagInterrupt(MAX_INTERRUPT, null, true);
  }

  // Indicate that we have an interrupt now!
  // We should only get same IOUnit for same interrupt level
  public void flagInterrupt(int interrupt, InterruptHandler source,
      boolean triggerIR) {
    if (triggerIR) {
      interruptSource[interrupt] = source;

      if (debugInterrupts) {
        if (source != null) {
          System.out.println("### Interrupt " + interrupt  + " flagged ON by " + source.getName() + " prio: " + interrupt);
        } else {
          System.out.println("### Interrupt " + interrupt + " flagged ON by <null>");
        }
      }

      // MAX priority is executed first - update max if this is higher!
      if (interrupt > interruptMax) {
        interruptMax = interrupt;
      }
      if (interruptMax == MAX_INTERRUPT) {
        // This can not be masked at all!
        interruptsEnabled = true;
        servicedInterrupt = -1; /* Make sure this interrupt will be executed immediately */
      }
    } else {
      if (interruptSource[interrupt] == source) {
        if (debugInterrupts) {
          System.out.println("### Interrupt flagged OFF by " + source.getName() + " prio: " + interrupt);
        }
        interruptSource[interrupt] = null;
        reevaluateInterrupts();
      }
    }
  }

  private void reevaluateInterrupts() {
    interruptMax = -1;
    for (int i = 0; i < interruptSource.length; i++) {
      if (interruptSource[i] != null)
        interruptMax = i;
    }
  }

  // returns the currently serviced interrupt (vector ID)
  public int getServicedInterrupt() {
    return servicedInterrupt;
  }

  // This will be called after an interrupt have been handled
  // In the main-CPU loop
  public void handlePendingInterrupts() {
    // By default no int. left to process...
    
    reevaluateInterrupts();
    
    servicedInterrupt = -1;
    servicedInterruptUnit = null;
  }  

  void profileCall(int dst, int pc) {
      MapEntry function = map.getEntry(dst);
      if (function == null) {
          function = getFunction(map, dst);
      }
      profiler.profileCall(function, cpuCycles, pc);
  }
  
  void printWarning(EmulationLogger.WarningType type, int address) throws EmulationException {
      String message;
      switch(type) {
      case MISALIGNED_READ:
          message = "**** Illegal read - misaligned word from $" +
                  getAddressAsString(address) + " at $" + getAddressAsString(reg[PC]);
          break;
      case MISALIGNED_WRITE:
          message = "**** Illegal write - misaligned word to $" +
                  getAddressAsString(address) + " at $" + getAddressAsString(reg[PC]);
          break;
      case ADDRESS_OUT_OF_BOUNDS_READ:
          message = "**** Illegal read - out of bounds from $" +
                  getAddressAsString(address) + " at $" + getAddressAsString(reg[PC]);
          break;
      case ADDRESS_OUT_OF_BOUNDS_WRITE:
          message = "**** Illegal write -  out of bounds from $" +
                  getAddressAsString(address) + " at $" + getAddressAsString(reg[PC]);
          break;
      default:
          message = "**** " + type + " address $" + getAddressAsString(address) +
          " at $" + getAddressAsString(reg[PC]);
          break;
      }
      logger.logw(this, type, message);
  }

  public void generateTrace(PrintStream out) {
    /* Override if a stack trace or other additional warning info should
     * be printed */ 
  }

  private int serviceInterrupt(int pc) {
    int pcBefore = pc;
    int spBefore = readRegister(SP);
    int sp = spBefore;
    int sr = readRegister(SR);
    
    if (profiler != null) {
      profiler.profileInterrupt(interruptMax, cycles);
    }
        
    if (flash.blocksCPU()) {
      /* TODO: how should this error/warning be handled ?? */
      throw new IllegalStateException(
          "Got interrupt while flash controller blocks CPU. CPU CRASHED.");
    }
    
    // Only store stuff on irq except reset... - not sure if this is correct...
    // TODO: Check what to do if reset is called!
    if (interruptMax < MAX_INTERRUPT) {
      // Push PC and SR to stack
      // store on stack - always move 2 steps (W) even if B.
      writeRegister(SP, sp = spBefore - 2);
      currentSegment.write(sp, pc, AccessMode.WORD);

      writeRegister(SP, sp = sp - 2);
      currentSegment.write(sp, (sr & 0x0fff) | ((pc & 0xf0000) >> 4), AccessMode.WORD);
    }
    // Clear SR
    writeRegister(SR, 0); // sr & ~CPUOFF & ~SCG1 & ~OSCOFF);

    // Jump to the address specified in the interrupt vector
    pc = currentSegment.read(0xfffe - (MAX_INTERRUPT - interruptMax) * 2, AccessMode.WORD, AccessType.READ);
    writeRegister(PC, pc);

    servicedInterrupt = interruptMax;
    servicedInterruptUnit = interruptSource[servicedInterrupt];

    // Flag off this interrupt - for now - as soon as RETI is
    // executed things might change!
    reevaluateInterrupts();
    
    if (servicedInterrupt == MAX_INTERRUPT) {
        if (debugInterrupts) System.out.println("**** Servicing RESET! => $" + getAddressAsString(pc));
        internalReset();
    }
    
    
    // Interrupts take 6 cycles!
    cycles += 6;

    if (debugInterrupts) {
      System.out.println("### Executing interrupt: " +
			 servicedInterrupt + " at "
			 + pcBefore + " to " + pc +
			 " SP before: " + spBefore +
			 " Vector: " + Utils.hex16(0xfffe - (MAX_INTERRUPT - servicedInterrupt) * 2));
    }
    
    // And call the serviced routine (which can cause another interrupt)
    if (servicedInterruptUnit != null) {
      if (debugInterrupts) {
        System.out.println("### Calling serviced interrupt on: " +
                           servicedInterruptUnit.getName());
      }
      servicedInterruptUnit.interruptServiced(servicedInterrupt);
    }
    return pc;
  }

  /* returns true if any instruction was emulated - false if CpuOff */
  public int emulateOP(long maxCycles) throws EmulationException {
    //System.out.println("CYCLES BEFORE: " + cycles);
    int pc = readRegister(PC);
    long startCycles = cycles;
    
    // -------------------------------------------------------------------
    // Interrupt processing [after the last instruction was executed]
    // -------------------------------------------------------------------
    if (interruptsEnabled && servicedInterrupt == -1 && interruptMax >= 0) {
      pc = serviceInterrupt(pc);
    }

    /* Did not execute any instructions */
    if (cpuOff || flash.blocksCPU()) {
      //       System.out.println("Jumping: " + (nextIOTickCycles - cycles));
      // nextEventCycles must exist, otherwise CPU can not wake up!?

      // If CPU is not active we must run the events here!!!
      // this can trigger interrupts that wake the CPU
      // -------------------------------------------------------------------
      // Event processing - note: This can trigger IRQs!
      // -------------------------------------------------------------------
      /* This can flag an interrupt! */
      while (cycles >= nextEventCycles) {
        executeEvents();
      }

      if (interruptsEnabled && interruptMax > 0) {
          /* can not allow for jumping to nextEventCycles since that would jump too far */
          return -1;
      }

      if (maxCycles >= 0 && maxCycles < nextEventCycles) {
        // Should it just freeze or take on extra cycle step if cycles > max?
        cycles = cycles < maxCycles ? maxCycles : cycles;
      } else {
        cycles = nextEventCycles;
      }
      return -1;
    }

    int pcBefore = pc;
    instruction = currentSegment.read(pc, AccessMode.WORD, AccessType.EXECUTE);
    if (isStopping) {
        // Signaled to stop the execution before performing the instruction
        return -2;
    }
    int ext3_0 = 0;
    int ext10_7 = 0;
    int extSrc = 0;
    int extDst = 0;
    boolean repeatsInDstReg = false;
    boolean wordx20 = false;

    /* check for extension words */
    if ((instruction & 0xf800) == 0x1800) {
        extWord = instruction;
        ext3_0 = instruction & 0xf; /* bit 3 - 0 - either repeat count or dest 19-16 */
        ext10_7 = (instruction >> 7) & 0xf; /* bit 10 - 7 - src 19-16 */
        extSrc = ext10_7 << 16;
        extDst = ext3_0 << 16;
        pc += 2;

	// Bit 7 in the extension word indicates that the number of
	// repeats is found in the register pointed to by ext3_0. If
	// the bit is 0, ext3_0 contains the number of repeats. If the
	// bit is 1, ext3_0 contains the register number that holds
	// the number of repeats.
	if ((instruction & 0x80) == 0x80) {
	    repeatsInDstReg = true;
	}
	// Bit 6 indicates whether or not the data length mode should
	// be 20 bits. A one means traditional MSP430 mode; a zero
	// indicates 20 bit mode. (XXX: there is a reserved data
	// length mode if this bit is zero and the MSP430 instruction
	// that follows the extension word also has a zero bit data
	// length mode.)
	wordx20 = (instruction & 0x40) == 0;

	instruction = currentSegment.read(pc, AccessMode.WORD, AccessType.EXECUTE);
        /*System.out.println("*** Extension word!!! " + Utils.hex16(extWord) +
                "  read the instruction too: " + Utils.hex16(instruction) + " at " + Utils.hex16(pc - 2));*/
    } else {
        extWord = 0;
    }
    
    op = instruction >> 12;
    int sp = 0;
    int sr = 0;
    int rval = 0; /* register value */
    int repeats = 1; /* msp430X can repeat some instructions in some cases */
    boolean zeroCarry = false; /* msp430X can zero carry in repeats */
    boolean word = (instruction & 0x40) == 0;

    /* NOTE: there is a mode when wordx20 = true & word = true that is resereved */
    AccessMode mode = wordx20 ? AccessMode.WORD20 : (word ? AccessMode.WORD : AccessMode.BYTE);
    
    //if (mode == AccessMode.WORD20) System.out.println("WORD20 not really supported...");

    // Destination vars
    int dstRegister = 0;
    int dstAddress = -1;
    boolean dstRegMode = false;
    int dst = -1;

    boolean write = false;
    boolean updateStatus = true;

    // When is PC increased  probably immediately (e.g. here)?
    pc += 2;

    writeRegister(PC, pc);

    switch (op) {
    case 0:
        // MSP430X - additional instructions
        op = instruction & 0xf0f0;
        if (!MSP430XArch) 
            throw new EmulationException("Executing MSP430X instruction but MCU is not a MSP430X");
//        System.out.println("Executing MSP430X instruction op:" + Utils.hex16(op) +
//                " ins:" + Utils.hex16(instruction) + " PC = $" + getAddressAsString(pc - 2));
        int src = 0;
        /* data is either bit 19-16 or src register */
        int srcData = (instruction & 0x0f00) >> 8;
        int dstData = (instruction & 0x000f);
        boolean rrword = true;
        mode = AccessMode.WORD20;

        switch(op) {
        // 20 bit register write
        case MOVA_IND:
        	/* Read from address in src register (20-bit?), move to destination register (=20 bit). */
        	writeRegister(dstData, currentSegment.read(readRegister(srcData), mode, AccessType.READ));
        	updateStatus = false;
        	cycles += 3;
            break;
        case MOVA_IND_AUTOINC:
            if (profiler != null && instruction == 0x0110) {
                profiler.profileReturn(cpuCycles);
            }
            writeRegister(PC, pc);
            /* read from address in register */
            src = readRegister(srcData);
//            System.out.println("Reading $" + getAddressAsString(src) +
//                    " from register: " + srcData);
            dst = currentSegment.read(src, mode, AccessType.READ);
//            System.out.println("Reading from mem: $" + getAddressAsString(dst));
            writeRegister(srcData, src + 4);
//            System.out.println("*** Writing $" + getAddressAsString(dst) + " to reg: " + dstData);
            writeRegister(dstData, dst);
            updateStatus = false;
	    cycles += 3;
            break;
        case MOVA_ABS2REG:
            src = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
            writeRegister(PC, pc += 2);
            dst = src + (srcData << 16);
            //System.out.println(Utils.hex20(pc) + " MOVA &ABS Reading from $" + getAddressAsString(dst) + " to reg: " + dstData);
            dst = currentSegment.read(dst, mode,  AccessType.READ);
            //System.out.println("   => $" + getAddressAsString(dst));
            writeRegister(dstData, dst);
            updateStatus = false;
	    cycles += 4;
            break;
	case MOVA_INDX2REG:
		/* Read data from address in memory, indexed by source
		 * register, and place into destination register. */
		int index = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
		int indexModifier = readRegister(srcData);

		index = convertTwoComplement16(index);
		indexModifier = convertTwoComplement20(indexModifier);

		writeRegister(dstData, currentSegment.read(indexModifier + index, mode, AccessType.READ));
		writeRegister(PC, pc += 2);
		updateStatus = false;
		cycles += 4;
		break;

	case MOVA_REG2ABS:
            dst = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
            writeRegister(PC, pc += 2);
	    currentSegment.write(dst + (dstData << 16), readRegister(srcData), mode);
            updateStatus = false;
	    cycles += 4;
            break;

	case MOVA_REG2INDX:
		/* Read data from register, write to address in memory,
		 * indexed by source register. */
		index = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
		indexModifier = readRegister(dstData);

		index = convertTwoComplement16(index);
		indexModifier = convertTwoComplement20(indexModifier);

		currentSegment.write(indexModifier + index, readRegister(srcData), mode);
		writeRegister(PC, pc += 2);
		updateStatus = false;
		cycles += 4;
		break;

        case MOVA_IMM2REG:
            src = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
            writeRegister(PC, pc += 2);
            dst = src + (srcData << 16);
//            System.out.println("*** Writing $" + getAddressAsString(dst) + " to reg: " + dstData);
            dst &= 0xfffff;
            writeRegister(dstData, dst);
            updateStatus = false;
	    cycles += 2;
            break;


        case ADDA_IMM:
        	// For all immediate instructions, the data low 16 bits of
        	// the data is stored in the following word (PC + 2) and
        	// the high 4 bits in the instruction word, which we have
        	// masked out as srcData.
        	int immData = currentSegment.read(pc, AccessMode.WORD, AccessType.READ) + (srcData << 16);
        	writeRegister(PC, pc += 2);
        	int dstArg = readRegister(dstData);
        	dst = dstArg + immData;

        	sr = StatusRegister.updateSR(readRegister(SR), immData, dstArg, dst);
    		writeRegister(SR, sr);
    		updateStatus = false;

        	dst &= 0xfffff;
        	writeRegister(dstData, dst);
        	cycles += 3;
        	break;

	case CMPA_IMM: {
		/* Status Bits N: Set if result is negative (src > dst), reset if positive (src ≤ dst)
	       Z: Set if result is zero (src = dst), reset otherwise (src ≠ dst)
	       C: Set if there is a carry from the MSB, reset otherwise
	       V: Set if the subtraction of a negative source operand from a positive destination
	       operand delivers a negative result, or if the subtraction of a positive source
	       operand from a negative destination operand delivers a positive result, reset
	       otherwise (no overflow) */
		immData = currentSegment.read(pc, AccessMode.WORD, AccessType.READ) + (srcData << 16);
		writeRegister(PC, pc += 2);
		sr = readRegister(SR);

		int destRegValue = readRegister(dstData);
		sr &= ~(NEGATIVE | ZERO | CARRY | OVERFLOW);
		if (destRegValue >= immData) {
			sr |= CARRY;
		}
		if (destRegValue < immData) {
			sr |= NEGATIVE;
		}
		if (destRegValue == immData) {
			sr |= ZERO;
		}

		int cmpTmp = destRegValue - immData;
		int b = 0x80000; // CMPA always use 20 bit data length

		if (((destRegValue ^ cmpTmp) & b) == 0 &&
				(((destRegValue ^ immData) & b) != 0)) {
			sr |= OVERFLOW;
		}

		writeRegister(SR, sr);
		updateStatus = false;
		cycles += 3;
		break;
	}
        case SUBA_IMM:
            immData = currentSegment.read(pc, AccessMode.WORD, AccessType.READ) + (srcData << 16);
            writeRegister(PC, pc += 2);
	    dst = readRegister(dstData) - immData;
	    writeRegister(dstData, dst);
	    cycles += 3;
	    break;

        case MOVA_REG:
	    cycles += 1;
	    /* as = 0 since register mode */
	    writeRegister(dstData, readRegisterCG(srcData, 0));
		updateStatus = false;
	    break;

        case CMPA_REG: {
        	sr = readRegister(SR);
        	sr &= ~(NEGATIVE | ZERO | CARRY | OVERFLOW);
        	int destRegValue = readRegister(dstData);
        	int srcRegValue = readRegisterCG(srcData, 0);
        	if (destRegValue >= srcRegValue) {
        		sr |= CARRY;
        	}
        	if (destRegValue < srcRegValue) {
        		sr |= NEGATIVE;
        	}
        	if (destRegValue == srcRegValue) {
        		sr |= ZERO;
        	}

        	int cmpTmp = destRegValue - srcRegValue;
        	int b = 0x80000; // CMPA always use 20 bit data length

        	if (((destRegValue ^ cmpTmp) & b) == 0 &&
        			(((destRegValue ^ srcRegValue) & b) != 0)) {
        		sr |= OVERFLOW;
        	}

        	writeRegister(SR, sr);
        	updateStatus = false;
        	cycles += 1;
        	break;
        }

	case ADDA_REG:
	    // Assume AS = 2
	    dst = readRegister(dstData) + readRegisterCG(srcData, 2);
	    writeRegister(dstData, dst);
    	sr = StatusRegister.updateSR(readRegister(SR), readRegisterCG(srcData, 2), dstData, dst);
		writeRegister(SR, sr);
		updateStatus = false;
	    cycles += 1;
	    break;
        case SUBA_REG:
            // Assume AS = 2
	    dst = readRegister(dstData) - readRegisterCG(srcData, 2);
	    writeRegister(dstData, dst);
	    cycles += 1;
	    break;

        case RRXX_ADDR:
            rrword = false;
        case RRXX_WORD:
            int count = ((instruction >> 10) & 0x03) + 1;
            dst = readRegister(dstData);
            sr = readRegister(SR);
            int nxtCarry = 0;
	    int carry = (sr & CARRY) > 0? 1: 0;
            if (rrword) {
                mode = AccessMode.WORD;
                dst = dst & 0xffff;
            }
	    cycles += 1 + count;
            switch(instruction & RRMASK) {
            /* if word zero anything above */
            case RRCM:
                /* if (rrword): Rotate right through carry the 16-bit CPU register content
		   if (!rrword): Rotate right through carry the 20-bit CPU register content */

		/* Pull the (count) lowest bits from dst - those will
		 * be placed in the (count) high bits of dst after the
		 * instruction is complete. */
		int dst_low = dst & ((1 << count) - 1);

		/* Grab the bit that will be in the carry flag when instruction completes. */
		nxtCarry = (dst & (1 << (count + 1))) > 0? CARRY: 0;

		/* Rotate dst. */
		dst = dst >> (count);

		/* Rotate the high bits, insert into dst. */
		if (rrword) {
		    dst |= (dst_low << (17 - count)) | (carry << (16 - count));
		} else {
		    dst |= (dst_low << (21 - count)) | (carry << (20 - count));
		}
                break;
            case RRAM:
//                System.out.println("RRAM executing");
                /* roll in MSB from above */
                /* 1 11 111 1111 needs to get in if MSB is 1 */
                if ((dst & (rrword ? 0x8000 : 0x80000)) > 0) {
                    /* add some 1 bits above MSB if MSB is 1 */
                    dst = dst | (rrword ? 0xf8000 : 0xf80000);
                }
                dst = dst >> (count - 1);
                nxtCarry = (dst & 1) > 0 ? CARRY : 0;
                dst = dst >> 1;
                break;
            case RLAM:
		//                System.out.println("RLAM executing at " + pc);
                /* just roll in "zeroes" from left */
                dst = dst << (count - 1);
                nxtCarry = (dst & (rrword ? 0x8000 : 0x80000)) > 0 ? CARRY : 0;
                dst = dst << 1;
                break;
            case RRUM:
                //System.out.println("RRUM executing");
                /* just roll in "zeroes" from right */
                dst = dst >> (count - 1);
                nxtCarry = (dst & 1) > 0 ? CARRY : 0;
                dst = dst >> 1;
                break;
            }
            /* clear overflow - set carry according to above OP */
            writeRegister(SR, (sr & ~(CARRY | OVERFLOW)) | nxtCarry);
            dst = dst & (rrword ? 0xffff : 0xfffff);
            writeRegister(dstData, dst);
            break;
        default:
            System.out.println("MSP430X instruction not yet supported: " +
			       Utils.hex16(instruction) +
			       " op " + Utils.hex16(op));
            throw new EmulationException("Found unsupported MSP430X instruction " +
					 Utils.hex16(instruction) +
					 " op " + Utils.hex16(op));
        }
        break;
    case 1:
    {
      // -------------------------------------------------------------------
      //  Single operand instructions
      // -------------------------------------------------------------------

      // Register
      dstRegister = instruction & 0xf;
      
      /* check if this is a MSP430X CALLA instruction */
      if ((op = instruction & CALLA_MASK) > RETI) {
          pc = readRegister(PC);

          dst = -1; /* will be -1 if not a call! */
          /* do not update status after these instructions!!! */
          updateStatus = false;
          switch(op) {
          case CALLA_REG:
              // The CALLA operations increase the SP before 
              // address resolution!
              // store on stack - always move 2 steps before resolution
              sp = readRegister(SP) - 2;
              writeRegister(SP, sp);

              dst = readRegister(dstRegister);
              /*System.out.println("CALLA REG => " + Utils.hex20(dst));*/
              cycles += 5;
              break;
          case CALLA_INDEX:
              /* CALLA X(REG) => REG + X is the address*/
              sp = readRegister(SP) - 2;
              writeRegister(SP, sp);

//              System.out.println("CALLA INDX: R" + dstRegister);
              dst = readRegister(dstRegister);

              /* what happens if wrapping here??? */
              /* read the index which is from -15 bit - +15 bit. - so extend sign to 20-bit */
              int index = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
              index = convertTwoComplement16(index);

//              System.out.println("CALLA INDX: Reg = " + Utils.hex20(dst) + " INDX: " +  index);

              dst += index;
              dst &= 0xfffff;

//              System.out.println("CALLA INDX => " + Utils.hex20(dst));
              dst = currentSegment.read(dst, AccessMode.WORD20, AccessType.READ);
//              System.out.println("CALLA Read from INDX => " + Utils.hex20(dst));
              cycles += 5;
              pc += 2;
//              System.exit(0);
              break;
          case CALLA_IMM:
              sp = readRegister(SP) - 2;
              writeRegister(SP, sp);

              dst = (dstRegister << 16) | currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
              pc += 2;
              cycles += 5;
              break;
          case CALLA_IND:
              sp = readRegister(SP) - 2;
              writeRegister(SP, sp);

              dstAddress = readRegister(dstRegister);
              
              dst = currentSegment.read(dstAddress, AccessMode.WORD20, AccessType.READ);
              cycles += 5;
              break;
          case CALLA_ABS:
              sp = readRegister(SP) - 2;
              writeRegister(SP, sp);

              /* read the address of where the address to call is */
              dst = (dstRegister << 16) | currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
              dst = currentSegment.read(dst, AccessMode.WORD20, AccessType.READ);
              pc += 2;
              cycles += 7;
              break;
          default:
        	  AccessMode type = AccessMode.WORD;
        	  int size = 2;
        	  sp = readRegister(SP);
        	  /* check for PUSHM... POPM... */
        	  switch(op & 0x1f00) {
        	  case PUSHM_A:
        		  type = AccessMode.WORD20;
        		  size = 4;
        		  cycles += 2;
        	  case PUSHM_W:
        		  int n = 1 + ((instruction >> 4) & 0x0f);
        		  int regNo = instruction & 0x0f;

        		  //                  System.out.println("PUSHM " + (type == AccessMode.WORD20 ? "A" : "W") +
        		  //                          " n: " + n + " " + regNo + " at " + Utils.hex16(pcBefore));

        		  /* decrease stack pointer and write n times */
        		  for(int i = 0; i < n; i++) {
        			  sp -= size;
        			  cycles += 2;
        			  currentSegment.write(sp, this.reg[regNo], type);
        			  /*System.out.println("Saved reg: " + (regNo) + " was " + reg[regNo]);*/
        			  regNo--;

        			  /* what happens if regNo is wrapped ??? */
        			  if (regNo < 0) regNo = 15;
        		  }
        		  writeRegister(SP, sp);
        		  break;
        	  case POPM_A:
        		  type = AccessMode.WORD20;
        		  size = 4;
        		  cycles += 2;
        	  case POPM_W:
        		  n = 1 + ((instruction >> 4) & 0x0f);
        		  regNo = instruction & 0x0f;
        		  /* read and increase stack pointer n times */

        		  for(int i = 0; i < n; i++) {
        			  cycles += 2;
        			  this.reg[regNo] = currentSegment.read(sp, type, AccessType.READ);
        			  regNo++;
        			  //                      System.out.println("Restored reg: " + (regNo - 1) + " to " + reg[regNo - 1]);
        			  sp += size;
        			  /* what happens if regNo is wrapped ??? */
        			  if (regNo > 15) regNo = 0;
        		  }

        		  writeRegister(SP, sp);
        		  break;
        	  default:
            	  System.out.println("CALLA/PUSH/POP: mode not implemented");
            	  throw new EmulationException("CALLA: mode not implemented "
            			  + Utils.hex16(instruction) + " => " + Utils.hex16(op));
              }
          }
          // store current PC on stack. (current PC points to next instr.)
          /* store 20 bits on stack (costs two words) */
          if (dst != -1) {
              currentSegment.write(sp, (pc >> 16) & 0xf, AccessMode.WORD);
              sp = sp - 2;
              currentSegment.write(sp, pc & 0xffff, AccessMode.WORD);
              writeRegister(SP, sp);
              writeRegister(PC, dst);
              
              if (profiler != null) {
                  profileCall(dst, pc);
              }
          }
      } else {
          // Address mode of destination...
          int ad = (instruction >> 4) & 3;
          int nxtCarry = 0;
          op = instruction & 0xff80;
          if (op == PUSH || op == CALL) {
              // The PUSH and CALL operations increase the SP before 
              // address resolution!
              // store on stack - always move 2 steps (W) even if B./
              sp = readRegister(SP) - 2;
              writeRegister(SP, sp);
          }

          if ((dstRegister == CG1 && ad > AM_INDEX) || dstRegister == CG2) {
              dstRegMode = true;
              cycles++;
          } else {
              switch(ad) {
              // Operand in register!
              case AM_REG:
                  dstRegMode = true;
                  cycles++;
                  break;
              case AM_INDEX:
                  // TODO: needs to handle if SR is used!
                  rval = readRegisterCG(dstRegister, ad);

                  if (extWord != 0) {
                    /* MSP430X Instruction With Indexed Mode */
                    /*
                     * TODO XXX There are MSP430X instructions without extension
                     * words!
                     */
                    /*
                     * "The operand address is the sum of the 20-bit CPU register
                     * content and the 20-bit index."
                     */
                    dstAddress = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
                    dstAddress += extDst;
                    dstAddress += rval;
                    dstAddress &= 0xfffff;
                  } else {
                    if (rval <= 0xffff) {
                      /* Indexed Mode in Lower 64-KB Memory */
                      /*
                       * ".. the calculated memory address bits 19:16 are cleared
                       * after the addition of the CPU register Rn and the signed
                       * 16-bit index."
                       */
                      dstAddress = convertTwoComplement16(currentSegment.read(pc, AccessMode.WORD, AccessType.READ));
                      dstAddress += rval;
                      dstAddress &= 0xffff;
                    } else {
                      /* MSP430 Instruction With Indexed Mode in Upper Memory */
                      /*
                       * "The operand may be located in memory in the range Rn +-32
                       * KB, because the index, X, is a signed 16-bit value"
                       */
                      dstAddress = convertTwoComplement16(currentSegment.read(pc, AccessMode.WORD, AccessType.READ));
                      dstAddress += rval;
                      dstAddress &= 0xfffff;
                    }
                  }

                  // When is PC incremented - assuming immediately after "read"?
                  pc += 2;
                  writeRegister(PC, pc);
                  cycles += 4;
                  break;
                  // Indirect register
              case AM_IND_REG:
                  dstAddress = readRegister(dstRegister)  + extDst;

                  cycles += 3;
                  break;
                  // Bugfix suggested by Matt Thompson
              case AM_IND_AUTOINC:
                  if (dstRegister == PC) {
                      dstAddress = pc;

                      dst = currentSegment.read(dstAddress, mode != AccessMode.BYTE ? AccessMode.WORD : AccessMode.BYTE, AccessType.READ);
                      
                      dst += extDst;
                      pc += 2;
                      writeRegister(PC, pc);
                  } else {
                      dstAddress = readRegister(dstRegister) + extDst;
                      writeRegister(dstRegister, dstAddress + mode.bytes); // XXX (word ? 2 : 1));
                  }
                  cycles += 3;
                  break;
              }
          }

          // Perform the read
          if (dstRegMode) {
              dst = readRegisterCG(dstRegister, ad);

	      dst &= mode.mask;
	      
              /* set the repeat here! */
	      if (repeatsInDstReg) {
		  repeats = 1 + readRegister(ext3_0);
	      } else {
		  repeats = 1 + ext3_0;
	      }
              zeroCarry = (extWord & EXTWORD_ZC) > 0;

//              if (repeats > 1) {
//                  System.out.println("*** Repeat " + repeats + " ZeroCarry: " + zeroCarry);
//              }
          } else if (dst == -1) {
              dst = currentSegment.read(dstAddress, mode, AccessType.READ);
          }
          
          /* TODO: test add the loop here! */
          while(repeats-- > 0) {
              sr = readRegister(SR);
              /* always clear carry before repeat */
              if (repeats >= 0) {
                  if (zeroCarry) {
                      sr = sr & ~CARRY;
                      //System.out.println("ZC => Cleared carry...");
                  }
                  //System.out.println("*** Repeat: " + repeats);
              }
              switch(op) {
              case RRC:
                  nxtCarry = (dst & 1) > 0 ? CARRY : 0;
                  dst = dst >> 1;
                  dst |= (sr & CARRY) > 0 ? mode.msb : 0;

                  // Indicate write to memory!!
                  write = true;
                  // Set the next carry!
                  writeRegister(SR, (sr & ~(CARRY | OVERFLOW)) | nxtCarry);
                  break;
              case SWPB:
                  int tmp = dst;
                  dst = ((tmp >> 8) & 0xff) + ((tmp << 8) & 0xff00);
                  write = true;
                  updateStatus = false;
                  break;
              case RRA:
                  nxtCarry = (dst & 1) > 0 ? CARRY : 0;
                  dst = (dst & mode.msb) | dst >> 1;
                  write = true;
                  writeRegister(SR, (sr & ~(CARRY | OVERFLOW)) | nxtCarry);
                  break;
              case SXT:
                  // Extend Sign (bit 8-15 => same as bit 7)
                  dst = (dst & 0x80) > 0 ? dst | 0xfff00 : dst & 0x7f;
                  write = true;
                  sr = sr & ~(CARRY | OVERFLOW);
                  if (dst != 0) {
                      sr |= CARRY;
                  }
                  writeRegister(SR, sr);
                  break;
              case PUSH:
                  if (mode == AccessMode.WORD20) {
                      sp = readRegister(SP) - 2;
                      writeRegister(SP, sp);
                  }
                  currentSegment.write(sp, dst, mode);

                  /* if REG or INDIRECT AUTOINC then add 2 cycles, otherwise 1 */
                  cycles += (ad == AM_REG || ad == AM_IND_AUTOINC) ? 2 : 1;
                  write = false;
                  updateStatus = false;
                  break;
              case CALL:
                  // store current PC on stack. (current PC points to next instr.)
                  pc = readRegister(PC);

                  //	memory[sp] = pc & 0xff;
                  //	memory[sp + 1] = pc >> 8;
                  currentSegment.write(sp, pc, AccessMode.WORD);
                  writeRegister(PC, dst);

                  /* Additional cycles: REG => 3, AM_IND_AUTO => 2, other => 1 */
                  cycles += (ad == AM_REG) ? 3 : (ad == AM_IND_AUTOINC) ? 2 : 1;

                  /* profiler will be called during calls */
                  if (profiler != null) {
                      profileCall(dst, pc);
                  }

                  write = false;
                  updateStatus = false;
                  break;
              case RETI:
                  // Put Top of stack to Status DstRegister (TOS -> SR)
                  servicedInterrupt = -1; /* needed before write to SR!!! */
                  sp = readRegister(SP);
                  sr = currentSegment.read(sp, AccessMode.WORD, AccessType.READ);
                  writeRegister(SR, sr & 0x0fff);
                  sp = sp + 2;
                  //	writeRegister(SR, memory[sp++] + (memory[sp++] << 8));
                  // TOS -> PC
                  //	writeRegister(PC, memory[sp++] + (memory[sp++] << 8));
                  writeRegister(PC, currentSegment.read(sp, AccessMode.WORD, AccessType.READ) | (sr & 0xf000) << 4);
                  sp = sp + 2;
                  writeRegister(SP, sp);
                  write = false;
                  updateStatus = false;

                  cycles += 4;

                  if (debugInterrupts) {
                      System.out.println("### RETI at " + pc + " => " + reg[PC] +
                              " SP after: " + reg[SP]);
                  }        
                  if (profiler != null) {
                      profiler.profileRETI(cycles);
                  }

                  // This assumes that all interrupts will get back using RETI!
                  handlePendingInterrupts();

                  break;
              default:
                  System.out.println("Error: Not implemented instruction:" +
                          Utils.hex16(instruction));
              }
              if (repeats > 0) {
                  dst &= mode.mask;
              }
          }
      }
    }
    break;
    // Jump instructions
    case 2:
    case 3:
      // 10 bits for address for these => 0x00fc => remove 2 bits
      int jmpOffset = instruction & 0x3ff;
      jmpOffset = (jmpOffset & 0x200) == 0 ?
	2 * jmpOffset : -(2 * (0x200 - (jmpOffset & 0x1ff)));
      boolean jump = false;

      // All jump takes two cycles
      cycles += 2;
      sr = readRegister(SR);
      switch(instruction & 0xfc00) {
      case JNE:
	jump = (sr & ZERO) == 0;
	break;
      case JEQ:
	jump = (sr & ZERO) > 0;
	break;
      case JNC:
	jump = (sr & CARRY) == 0;
	break;
      case JC:
	jump = (sr & CARRY) > 0;
	break;
      case JN:
	jump = (sr & NEGATIVE) > 0;
	break;
      case JGE:
	jump = (sr & NEGATIVE) > 0 == (sr & OVERFLOW) > 0;
	break;
      case JL:
	jump = (sr & NEGATIVE) > 0 != (sr & OVERFLOW) > 0;
	break;
      case JMP:
	jump = true;
	break;
      default:
        logw(WarningType.EMULATION_ERROR, "Not implemented instruction: #" + Utils.binary16(instruction));
      }
      // Perform the Jump
      if (jump) {
        writeRegister(PC, pc + jmpOffset);
      }
      updateStatus = false;
      break;
    default:
      // ---------------------------------------------------------------
      // Double operand instructions!
      // ---------------------------------------------------------------
      dstRegister = instruction & 0xf;
      int srcRegister = (instruction >> 8) & 0xf;
      int as = (instruction >> 4) & 3;

      // AD: 0 => register direct, 1 => register index, e.g. X(Rn)
      dstRegMode = ((instruction >> 7) & 1) == 0;
      dstAddress = -1;
      int srcAddress = -1;
      src = 0;

      // Some CGs should be handled as registry reads only...
      if ((srcRegister == CG1 && as > AM_INDEX) || srcRegister == CG2) {
        src = CREG_VALUES[srcRegister - 2][as];
        src &= mode.mask;
        cycles += dstRegMode ? 1 : 4;
      } else {
	switch(as) {
	  // Operand in register!
	case AM_REG:
	  // CG handled above!
	  src = readRegister(srcRegister);
	  src &= mode.mask;
	  cycles += dstRegMode ? 1 : 4;
	  /* add cycle if destination register = PC */
          if (dstRegister == PC) cycles++;
          
          if (dstRegMode) {
              /* possible to have repeat, etc... */
              /* TODO: decode the # also */
	      if (repeatsInDstReg) {
		  repeats = 1 + readRegister(ext3_0);
	      } else {
		  repeats = 1 + ext3_0;
	      }

              zeroCarry = (extWord & EXTWORD_ZC) > 0;
          }
          
	  break;
	case AM_INDEX: {
	  // Indexed if reg != PC & CG1/CG2 - will PC be incremented?
	  int sval = readRegisterCG(srcRegister, as);

	  if (extWord != 0) {
	    /* MSP430X Instruction With Indexed Mode */
	    /*
	     * TODO XXX There are MSP430X instructions without extension
	     * words!
	     */
	    /*
	     * "The operand address is the sum of the 20-bit CPU register
	     * content and the 20-bit index."
	     */
	    srcAddress = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
	    srcAddress += extSrc;
	    srcAddress += sval;
	    srcAddress &= 0xfffff;
	  } else {
	    if (sval <= 0xffff) {
	      /* Indexed Mode in Lower 64-KB Memory */
	      /*
	       * ".. the calculated memory address bits 19:16 are cleared
	       * after the addition of the CPU register Rn and the signed
	       * 16-bit index."
	       */
	      srcAddress = convertTwoComplement16(currentSegment.read(pc, AccessMode.WORD, AccessType.READ));
	      srcAddress += sval;
	      srcAddress &= 0xffff;
	    } else {
	      /* MSP430 Instruction With Indexed Mode in Upper Memory */
	      /*
	       * "The operand may be located in memory in the range Rn +-32
	       * KB, because the index, X, is a signed 16-bit value"
	       */
	      srcAddress = convertTwoComplement16(currentSegment.read(pc, AccessMode.WORD, AccessType.READ));
	      srcAddress += sval;
	      srcAddress &= 0xfffff;
	    }
	  }

	  pc += 2;
	  writeRegister(PC, pc);
	  cycles += dstRegMode ? 3 : 6;
	  break;
	}
	  // Indirect register
	case AM_IND_REG:
	  srcAddress = readRegister(srcRegister);
	  cycles += dstRegMode ? 2 : 5;
	  break;
	case AM_IND_AUTOINC:
		if (srcRegister == PC) {
			/* PC is always handled as word */
			if (mode == AccessMode.BYTE) {
				src = currentSegment.read(pc, AccessMode.BYTE,
						AccessType.READ);
			} else {
				src = currentSegment.read(pc, AccessMode.WORD,
						AccessType.READ);
			}
			src += extSrc;

			pc += 2;
			writeRegister(PC, pc);
			cycles += dstRegMode ? 2 : 5;
		} else {
			srcAddress = readRegister(srcRegister);
			incRegister(srcRegister, mode.bytes);
			cycles += dstRegMode ? 2 : 5;
		}

		/* If destination register is PC another cycle is consumed */
		if (dstRegister == PC) {
			cycles++;
		}
		break;
	}
      }

      // Perform the read of destination!
      if (dstRegMode) {
        if (op != MOV) {
          dst = readRegister(dstRegister);
          dst &= mode.mask;
        }
      } else {
        // PC Could have changed above!
        pc = readRegister(PC);

        if (dstRegister == 2) {
          /* absolute mode */
          dstAddress = currentSegment.read(pc, AccessMode.WORD, AccessType.READ); //memory[pc] + (memory[pc + 1] << 8);
          dstAddress += extDst;
        } else {
          // CG here - probably not!???
          rval = readRegister(dstRegister);

          if (extWord != 0) {
            /* MSP430X Instruction With Indexed Mode */
            /*
             * TODO XXX There are MSP430X instructions without extension
             * words!
             */
            /*
             * "The operand address is the sum of the 20-bit CPU register
             * content and the 20-bit index."
             */
            dstAddress = currentSegment.read(pc, AccessMode.WORD, AccessType.READ);
            dstAddress += extDst;
            dstAddress += rval;
            dstAddress &= 0xfffff;
          } else {
            if (rval <= 0xffff) {
              /* Indexed Mode in Lower 64-KB Memory */
              /*
               * ".. the calculated memory address bits 19:16 are cleared
               * after the addition of the CPU register Rn and the signed
               * 16-bit index."
               */
              dstAddress = convertTwoComplement16(currentSegment.read(pc, AccessMode.WORD, AccessType.READ));
              dstAddress += rval;
              dstAddress &= 0xffff;
            } else {
              /* MSP430 Instruction With Indexed Mode in Upper Memory */
              /*
               * "The operand may be located in memory in the range Rn +-32
               * KB, because the index, X, is a signed 16-bit value"
               */
              dstAddress = convertTwoComplement16(currentSegment.read(pc, AccessMode.WORD, AccessType.READ));
              dstAddress += rval;
              dstAddress &= 0xfffff;
            }
          }
        }

        if (op != MOV) {
        	dst = currentSegment.read(dstAddress, mode, AccessType.READ);
        }
        pc += 2;
        incRegister(PC, 2);
      }

      // **** Perform the read...
      if (srcAddress != -1) {

//        if (srcAddress  > 0xffff) {
//            System.out.println("SrcAddress is: " + Utils.hex20(srcAddress));
//        }
//	srcAddress = srcAddress & 0xffff;
        src = currentSegment.read(srcAddress, mode, AccessType.READ);

//	src = currentSegment.read(srcAddress, word ? AccessMode.WORD : AccessMode.BYTE, AccessType.READ);

	// 	  if (debug) {
	// 	    System.out.println("Reading from " + getAddressAsString(srcAddress) +
	// 			       " => " + src);
	// 	  }
      }

      /* TODO: test add the loop here! */
      while(repeats-- > 0) {
          sr = readRegister(SR);
          if (repeats >= 0) {
              if (zeroCarry) {
                  sr = sr & ~CARRY;
                  //System.out.println("ZC => Cleared carry...");
              }
              //System.out.println("*** Repeat: " + repeats);
          }

          int tmp = 0;
          int tmpAdd = 0;
          switch (op) {
          case MOV: // MOV
              dst = src;
              write = true;
              updateStatus = false;

              if (instruction == RETURN && profiler != null) {
                  profiler.profileReturn(cpuCycles);
              }

              break;
              // FIX THIS!!! - make SUB a separate operation so that
              // it is clear that overflow flag is correct...
          case SUB:
              // Carry always 1 with SUB
              tmpAdd = 1;
          case SUBC:
              // Both sub and subc does one complement (not) + 1 (or carry)
              src = (src ^ 0xffff) & 0xffff;
          case ADDC: // ADDC
              if (op == ADDC || op == SUBC)
                  tmpAdd = ((sr & CARRY) > 0) ? 1 : 0;
          case ADD: // ADD
              // Tmp gives zero if same sign! if sign is different after -> overf.
              sr &= ~(OVERFLOW | CARRY);
	      int b = word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
              tmp = (src ^ dst) & b;
              // Includes carry if carry should be added...

              dst = dst + src + tmpAdd;
	      int b2 = word ? 0xffff : (wordx20 ? 0xfffff : 0xff);
              if (dst > b2) {
                  sr |= CARRY;
              }
              // If tmp == 0 and currenly not the same sign for src & dst
              if (tmp == 0 && ((src ^ dst) & b) != 0) {
                  sr |= OVERFLOW;
                  // 	    System.out.println("OVERFLOW - ADD/SUB " + Utils.hex16(src)
                  // 			       + " + " + Utils.hex16(tmpDst));
              }

              // 	  System.out.println(Utils.hex16(dst) + " [SR=" +
              // 			     Utils.hex16(reg[SR]) + "]");
              writeRegister(SR, sr);
              write = true;
              break;
          case CMP: // CMP
              // Set CARRY if A >= B, and it's clear if A < B
	      b = mode.msb;
              sr = (sr & ~(CARRY | OVERFLOW)) | (dst >= src ? CARRY : 0);

              tmp = (dst - src);

              if (((src ^ tmp) & b) == 0 && (((src ^ dst) & b) != 0)) {
                  sr |= OVERFLOW;
              }
              writeRegister(SR, sr);
              // Must set dst to the result to set the rest of the status register
              dst = tmp;
              break;
          case DADD: // DADD
              if (DEBUG)
                  log("DADD: Decimal add executed - result error!!!");
              // Decimal add... this is wrong... each nibble is 0-9...
              // So this has to be reimplemented...
              dst = dst + src + ((sr & CARRY) > 0 ? 1 : 0);
              write = true;
              break;
          case BIT: // BIT
              dst = src & dst;
              // Clear overflow and carry!
              sr = sr & ~(CARRY | OVERFLOW);
              // Set carry if result is non-zero!
              if (dst != 0) {
                  sr |= CARRY;
              }
              writeRegister(SR, sr);
              break;
          case BIC: // BIC
              // No status reg change
              // 	  System.out.println("BIC: =>" + Utils.hex16(dstAddress) + " => "
              // 			     + Utils.hex16(dst) + " AS: " + as +
              // 			     " sReg: " + srcRegister + " => " + src +
              // 			     " dReg: " + dstRegister + " => " + dst);
              dst = (~src) & dst;

              write = true;
              updateStatus = false;
              break;
          case BIS: // BIS
              dst = src | dst;
              write = true;
              updateStatus = false;
              break;
          case XOR: // XOR
              sr = sr & ~(CARRY | OVERFLOW);
	      b = mode.msb; //word ? 0x8000 : (wordx20 ? 0x80000 : 0x80);
              if ((src & b) != 0 && (dst & b) != 0) {
                  sr |= OVERFLOW;
              }
              dst = src ^ dst;
              if (dst != 0) {
                  sr |= CARRY;
              }
              write = true;
              writeRegister(SR, sr);
              break;
          case AND: // AND
              sr = sr & ~(CARRY | OVERFLOW);
              dst = src & dst;
              if (dst != 0) {
                  sr |= CARRY;
              }
              write = true;
              writeRegister(SR, sr);
              break;
          default:
              String address = getAddressAsString(pc);
              logw(WarningType.EMULATION_ERROR, 
                      "DoubleOperand not implemented: op = " + Integer.toHexString(op) + " at " + address);
              if (EXCEPTION_ON_BAD_OPERATION) {
                  EmulationException ex = new EmulationException("Bad operation: $" + Integer.toHexString(op) + " at $" + address);
                  ex.initCause(new Throwable("" + pc));
                  throw ex;
              }
          } /* after switch(op) */
          /* If we have the same register as dst and src then copy here to get input
           * in next loop
           */
          if (repeats > 0 && srcRegister == dstRegister) {
              src = dst;
              src &= mode.mask;
              dst &= mode.mask;
          }
      }
    }
    
    /* Processing after each instruction */
    dst &= mode.mask;
    if (write) {
      if (dstRegMode) {
	writeRegister(dstRegister, dst);
      } else {
        currentSegment.write(dstAddress, dst, mode);
      }
    }
    if (updateStatus) {
      // Update the Zero and Negative status!
      // Carry and overflow must be set separately!
      sr = readRegister(SR);
      sr = (sr & ~(ZERO | NEGATIVE)) |
	((dst == 0) ? ZERO : 0) | ((dst & mode.msb) > 0 ? NEGATIVE : 0);
      writeRegister(SR, sr);
    }

    //System.out.println("CYCLES AFTER: " + cycles);

    // -------------------------------------------------------------------
    // Event processing (when CPU is awake)
    // -------------------------------------------------------------------
    while (cycles >= nextEventCycles) {
      executeEvents();
    }
    
    cpuCycles += cycles - startCycles;
    
    /* return the address that was executed */
    return pcBefore;
  }
  
  private static int convertTwoComplement16(int index) {
	  if(index > 0x8000) {
		  return -(0x10000 - index);
	  }
	  return index;
  }
  private static int convertTwoComplement20(int index) {
	  if(index > 0x80000) {
		  return -(0x100000 - index);
	  }
	  return index;
  }

  public int getModeMax() {
    return MODE_MAX;
  }

  MapEntry getFunction(MapTable map, int address) {
    MapEntry function = new MapEntry(MapEntry.TYPE.function, address, 0,
        "fkn at $" + getAddressAsString(address), null, true);
    map.setEntry(function);
    return function;
  }

  public Memory getMemory() {
      return currentSegment;
  }

  public int getPC() {
    return reg[PC];
  }

  public int getSR() {
      return reg[SR];
  }

  public int getSP() {
      return reg[SP];
  }

  public int getRegister(int register) {
      return reg[register];
  }

  public String getAddressAsString(int addr) {
      return config.getAddressAsString(addr);
  }

  public int getConfiguration(int parameter) {
      return 0;
  }

  public String info() {
      StringBuilder buf = new StringBuilder();
      buf.append(" Mode: " + getModeName(getMode())
              + "  ACLK: " + aclkFrq + " Hz  SMCLK: " + smclkFrq + " Hz\n"
              + " Cycles: " + cycles + "  CPU Cycles: " + cpuCycles
              + "  Time: " + (long)getTimeMillis() + " msec\n");
      buf.append(" Interrupt enabled: " + interruptsEnabled +  " HighestInterrupt: " + interruptMax);
      for (int i = 0; i < MAX_INTERRUPT; i++) {
          int value = currentSegment.get(0xfffe - i * 2, AccessMode.WORD); 
          if (value != 0xffff) {
              buf.append(" Vector " + (MAX_INTERRUPT - i) + " at $"
                      + Utils.hex16(0xfffe - i * 2) + " -> $"
                      + Utils.hex16(value) + "\n");
          }
      }
      return buf.toString();
  }

  public int getAclkFrq() {
    return aclkFrq;
  }

  public int getSmclkFrq() {
    return smclkFrq;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/USART.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * USART
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;

public class USART extends IOUnit implements SFRModule, DMATrigger, USARTSource {

  // USART 0/1 register offset (0x70 / 0x78)
  public static final int UCTL = 0;
  public static final int UTCTL = 1;
  public static final int URCTL = 2;
  public static final int UMCTL = 3;
  public static final int UBR0 = 4;
  public static final int UBR1 = 5;
  public static final int URXBUF = 6;
  public static final int UTXBUF = 7;

  public static final int UTXIFG0 = 0x80;
  public static final int URXIFG0 = 0x40;

  public static final int UTXIFG1 = 0x20;
  public static final int URXIFG1 = 0x10;

  // USART SRF mod enable registers (absolute + 1)
  public static final int ME1 = 4;
  public static final int IE1 = 0;
  public static final int IFG1 = 2;

  private final int uartID;

  public static final int USART0_RX_VEC = 9;
  public static final int USART0_TX_VEC = 8;
  public static final int USART0_RX_BIT = 6;
  public static final int USART0_TX_BIT = 7;
  
  public static final int USART1_RX_VEC = 3;
  public static final int USART1_TX_VEC = 2;
  public static final int USART1_RX_BIT = 4;
  public static final int USART1_TX_BIT = 5;

  
  
  // Flags.
  public static final int UTCTL_TXEMPTY = 0x01;
  public static final int UTCTL_URXSE = 0x08;

  private USARTListener usartListener;

  private int utxifg;
  private int urxifg;
  private int rxVector;

  private int clockSource = 0;
  private int baudRate = 0;
  private int tickPerByte = 1000;
  private long nextTXReady = -1;
  private int nextTXByte = -1;
  private int txShiftReg = -1;
  private boolean transmitting = false;
  private int nextRXByte = -1;
  private boolean receiving = false;

  private final SFR sfr;

  private int uctl;
  private int utctl;
  private int urctl;
  private int umctl;
  private int ubr0;
  private int ubr1;
  private int urxbuf;
  private int utxbuf;
  private int txbit;
  
  private boolean txEnabled = false;
  private boolean rxEnabled = false;
  private boolean spiMode = false;
  
  /* DMA controller that needs to be called at certain times */
  private DMA dma;
  
  private TimeEvent txTrigger = new TimeEvent(0) {
    public void execute(long t) {
        // Ready to transmit new byte!
        handleTransmit(t);
    }
  };

  private TimeEvent rxTrigger = new TimeEvent(0) {
      public void execute(long t) {
          handleReceive();
      }
  };

  /**
   * Creates a new <code>USART</code> instance.
   *
   */
  public USART(MSP430Core cpu, int uartID, int[] memory, int offset) {
    super("USART" + uartID, "USART " + uartID, cpu, memory, offset);
    this.uartID = uartID;
    sfr = cpu.getSFR();

    // Initialize - transmit = ok...
    // and set which interrupts are used
    if (uartID == 0) {
      sfr.registerSFDModule(0, USART0_RX_BIT, this, USART0_RX_VEC);
      sfr.registerSFDModule(0, USART0_TX_BIT, this, USART0_TX_VEC);
      utxifg = UTXIFG0;
      urxifg = URXIFG0;
      txbit = USART0_TX_BIT;
      rxVector = USART0_RX_VEC;
    } else {
      sfr.registerSFDModule(1, USART1_RX_BIT, this, USART1_RX_VEC);
      sfr.registerSFDModule(1, USART1_TX_BIT, this, USART1_TX_VEC);
      utxifg = UTXIFG1;
      urxifg = URXIFG1;
      txbit = USART1_TX_BIT;
      rxVector = USART1_RX_VEC;
    }
    reset(0);
  }

  public void setDMA(DMA dma) {
      this.dma = dma;
  }

  
  public void reset(int type) {
    nextTXReady = cpu.cycles + 100;
    txShiftReg = nextTXByte = -1;
    transmitting = false;
    clrBitIFG(urxifg);
    setBitIFG(utxifg); /* empty at start! */
    utctl |= UTCTL_TXEMPTY;
    txEnabled = false;
    rxEnabled = false;
  }

  public void enableChanged(int reg, int bit, boolean enabled) {
    if (DEBUG) log("enableChanged: " + reg + " bit: " + bit +
        " enabled = " + enabled + " txBit: " + txbit);
    if (bit == txbit) {
      txEnabled = enabled;
    } else {
      rxEnabled = enabled;
    }
  }
  
  private void setBitIFG(int bits) {
//    if ((bits & utxifg) > 0) {
//        System.out.println(getName() + " Set utxifg");
//    }
    if (dma != null) {
        sfr.setBitIFG(uartID, bits);
        /* set bit first, then trigger DMA transfer - this should
         * be made via a 1 cycle or so delayed action */
        if ((bits & urxifg) > 0) dma.trigger(this, 0);
        if ((bits & utxifg) > 0) dma.trigger(this, 1);
    }
  }

  private void clrBitIFG(int bits) {
//      if ((bits & utxifg) > 0) {
//          System.out.println(getName() + " Clear utxifg");
//      }
    sfr.clrBitIFG(uartID, bits);
  }

  private int getIFG() {
    return sfr.getIFG(uartID);
  }

  private boolean isIEBitsSet(int bits) {
    return sfr.isIEBitsSet(uartID, bits);
  }

  @Override
  public synchronized void addUSARTListener(USARTListener listener) {
      usartListener = USARTListener.Proxy.INSTANCE.add(usartListener, listener);
  }

  @Override
  public synchronized void removeUSARTListener(USARTListener listener) {
      usartListener = USARTListener.Proxy.INSTANCE.remove(usartListener, listener);
  }

  // Only 8 bits / read!
  public void write(int address, int data, boolean word, long cycles) {
    address = address - offset;

    // Indicate ready to write!!! - this should not be done here...
//     if (uartID == 0) memory[IFG1] |= 0x82;
//     else memory[IFG1 + 1] |= 0x20;

//     System.out.println(">>>> Write to " + getName() + " at " +
// 		       address + " = " + data);
    switch (address) {
    case UCTL:
      uctl = data;
      spiMode = (data & 0x04) > 0;
      if (DEBUG) log(" write to UCTL " + data);
      break;
    case UTCTL:
      utctl = data;
      if (DEBUG) log(" write to UTCTL " + data);

      if (((data >> 4) & 3) == 1) {
        clockSource = MSP430Constants.CLK_ACLK;
        if (DEBUG) {
          log(" Selected ACLK as source");
        }
      } else {
        clockSource = MSP430Constants.CLK_SMCLK;
        if (DEBUG) {
          log(" Selected SMCLK as source");
        }
      }
      if ((data & UTCTL_URXSE) == UTCTL_URXSE) {
          sfr.setAutoclear(rxVector, false);
      } else {
          sfr.setAutoclear(rxVector, true);
      }
      updateBaudRate();
      break;
    case URCTL:
      urctl = data;
      break;
    case UMCTL:
      umctl = data;
      if (DEBUG) log(" write to UMCTL " + data);
      break;
    case UBR0:
      ubr0 = data;
      updateBaudRate();
      break;
    case UBR1:
      ubr1 = data;
      updateBaudRate();
      break;
    case UTXBUF:
      if (DEBUG) log(" USART_UTXBUF: " + data + " " + (data > 32 ? (char)data : '.'));
      if (txEnabled || (spiMode && rxEnabled)) {
        // Interruptflag not set!
        clrBitIFG(utxifg);
        /* the TX is no longer empty ! */
        utctl &= ~UTCTL_TXEMPTY;
        /* should the interrupt be flagged off here ? - or only the flags */
        if (DEBUG) log(" flagging off transmit interrupt");
        //      cpu.flagInterrupt(transmitInterrupt, this, false);

        // Schedule on cycles here
        // TODO: adding 3 extra cycles here seems to give
        // slightly better timing in some test...

        nextTXByte = data;
        if (!transmitting) {
            /* how long time will the copy from the TX_BUF to the shift reg take? */
            /* assume 3 cycles? */
            nextTXReady = cycles + 1; //tickPerByte + 3;
            cpu.scheduleCycleEvent(txTrigger, nextTXReady);
        }
      } else {
        log("Ignoring UTXBUF data since TX not active...");
      }
      utxbuf = data;
      break;
    }
  }

  public int read(int address, boolean word, long cycles) {
    address = address - offset;
//     System.out.println(">>>>> Read from " + getName() + " at " +
// 		       address + " = " + memory[address]);
    
    switch (address) {
    case UCTL:
      if (DEBUG) log(" read from UCTL");
      return uctl;
    case UTCTL:
      if (DEBUG) log(" read from UTCTL: " + utctl);
      return utctl;
    case URCTL:
      return urctl;
    case UMCTL:
      return umctl;
    case UBR0:
      return ubr0;
    case UBR1:
      return ubr1;
    case UTXBUF:
      return utxbuf;
    case URXBUF:
      int tmp = urxbuf;
      // When byte is read - the interruptflag is cleared!
      // and error status should also be cleared later...
      if (MSP430Constants.DEBUGGING_LEVEL > 0) {
          log(" clearing rx interrupt flag " + cpu.getPC() + " byte: " + tmp);
      }
      clrBitIFG(urxifg);
      /* This should be changed to a state rather than an "event" */
      /* Force callback since this is not used as a state */
      stateChanged(USARTListener.RXFLAG_CLEARED, true);
      return tmp;
    }
    return 0;
  }

  private void updateBaudRate() {
    int div = ubr0 + (ubr1 << 8);
    if (div == 0) {
      div = 1;
    }
    if (clockSource == MSP430Constants.CLK_ACLK) {
      if (DEBUG) {
        log(" Baud rate is (bps): " + cpu.aclkFrq / div + " div = " + div);
      }
      baudRate = cpu.aclkFrq / div;
    } else {
      if (DEBUG) {     
        log(" Baud rate is (bps): " + cpu.smclkFrq / div + " div = " + div);
      }
      baudRate = cpu.smclkFrq / div;
    }
    if (baudRate == 0) baudRate = 1;
    // Is this correct??? Is it the DCO or smclkFRQ we should have here???
    tickPerByte = (8 * cpu.smclkFrq) / baudRate;
    if (DEBUG) {
      log(" Ticks per byte: " + tickPerByte);
    }
  }

  // We should add "Interrupt serviced..." to indicate that its latest
  // Interrupt was serviced...
  public void interruptServiced(int vector) {
    /* NOTE: this is handled by SFR : clear IFG bit if interrupt is serviced */
//      System.out.println(getName() + " SFR irq " + vector + " " + txShiftReg + " " + getIFG());
  }

  private void handleTransmit(long cycles) {
    if (cpu.getMode() >= MSP430Core.MODE_LPM3) {
      logw(WarningType.EXECUTION, "Warning: USART transmission during LPM!!! " + nextTXByte);
    }

    if (transmitting) {
        /* in this case we have shifted out the last character */
        USARTListener listener = this.usartListener;
        if (listener != null && txShiftReg != -1) {
            listener.dataReceived(this, txShiftReg);
        }
        /* nothing more to transmit after this - stop transmission */
        if (nextTXByte == -1) {
            /* TXEMPTY means both TXBUF and shiftreg empty */
            utctl |= UTCTL_TXEMPTY;
            transmitting = false;
            txShiftReg = -1;
        }
    }

    /* any more chars to transmit? */
    if (nextTXByte != -1) {
        txShiftReg = nextTXByte;
        nextTXByte = -1;
        transmitting = true;
        /* txbuf always empty after this */
        setBitIFG(utxifg);
        nextTXReady = cycles + tickPerByte + 1;
        cpu.scheduleCycleEvent(txTrigger, nextTXReady);
    }

    if (DEBUG) {
      if (isIEBitsSet(utxifg)) {
        log(" flagging on transmit interrupt");
      }
      log(" Ready to transmit next at: " + cycles);
    }
  }


  public boolean isReceiveFlagCleared() {
    return !receiving && (getIFG() & urxifg) == 0;
  }

  // A byte have been received!
  // This needs to be complemented with a method for checking if the USART
  // is ready for next byte (readyForReceive) that respects the current speed
  public void byteReceived(int b) {
    if (!rxEnabled) return;
    if (DEBUG) {
      log(" byteReceived: " + b + " " + (b > 32 ? (char)b : '.'));
    }
    nextRXByte = b & 0xff;
    if (!receiving) {
      receiving = true;
      cpu.scheduleCycleEvent(rxTrigger, cpu.cycles + 1);
    }
  }

  private void handleReceive() {
    receiving = false;
    urxbuf = nextRXByte;

    // Indicate interrupt!
    setBitIFG(urxifg);

    if (DEBUG) {
      // Check if the IE flag is enabled! - same as the IFlag to indicate!
      if (isIEBitsSet(urxifg)) {
        log(" flagging receive interrupt ");
      }
    }
  }

  public String info() {
      return "  UTXIE: " + isIEBitsSet(utxifg) + "  URXIE: " + isIEBitsSet(urxifg) + "\n" +
      "  UTXIFG: " + ((getIFG() & utxifg) > 0) + "  URXIFG: " + ((getIFG() & urxifg) > 0) + "\n" +
      "  Baudrate: " + baudRate + " bps  Cycles per byte: " + tickPerByte;
  }

  public boolean getDMATriggerState(int index) {
      if (index == 0) {
          return (getIFG() & urxifg) > 0;
      } else {
          return (getIFG() & utxifg) > 0;
      }
  }

  public void clearDMATrigger(int index) {
      if (index == 0) {
          /* clear RX - might be different in different modes... */
          if (DEBUG) {
              log("clearing DMA read bit!");
          }
          clrBitIFG(urxifg);
          stateChanged(USARTListener.RXFLAG_CLEARED, true);
      } else {
          if (DEBUG) {
              log("clearing DMA " + index);
          }
          /* clear TX - might be different in different modes... */
          clrBitIFG(utxifg);
      }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/EventQueue.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * EventQueue
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

import java.io.PrintStream;

public class EventQueue {

  private TimeEvent first;
  public long nextTime;
  public int eventCount = 0;

  public EventQueue() {
  }

  public void addEvent(TimeEvent event, long time) {
    event.time = time;
    addEvent(event);
  }

  public void addEvent(TimeEvent event) {
    if (event.scheduledIn != null) {
      event.remove();
    }
    if (first == null) {
      first = event;
    } else {
      TimeEvent pos = first;
      TimeEvent lastPos = first;
      while (pos != null && pos.time < event.time) {
        lastPos = pos;
        pos = pos.nextEvent;
      }
      // Here pos will be the first TE after event
      // and lastPos the first before
      if (pos == first) {
        // Before all other
        event.nextEvent = pos;
        first = event;
      } else {
        event.nextEvent = pos;
        lastPos.nextEvent = event;
      }
    }
    if (first != null) {
      nextTime = first.time;
    } else {
      nextTime = 0;
    }
    event.scheduledIn = this;
    eventCount++;
  }

  // Not yet impl.
  public boolean removeEvent(TimeEvent event) {
    TimeEvent pos = first;
    TimeEvent lastPos = first;
//  System.out.println("Removing: " + event.getShort() + "  Before remove: ");
//  print();
    while (pos != null && pos != event) {
      lastPos = pos;
      pos = pos.nextEvent;
    }
    if (pos == null) return false;
    // pos == event!
    if (pos == first) {
      // remove it from first pos.
      first = pos.nextEvent;
    } else {
      // else link prev to next...
      lastPos.nextEvent = pos.nextEvent;
    }
    // unlink
    pos.nextEvent = null;

    if (first != null) {
      nextTime = first.time;
    } else {
      nextTime = 0;
    }
//  System.out.println("Removed =>");
//  print();
    event.scheduledIn = null;
    eventCount--;
    return true;
  }

  public TimeEvent popFirst() {
    TimeEvent tmp = first;
    if (tmp != null) {
      first = tmp.nextEvent;
      // Unlink.
      tmp.nextEvent = null;

      // No longer scheduled!
      tmp.scheduledIn = null;

      eventCount--;
    }

    if (first != null) {
      nextTime = first.time;
    } else {
      nextTime = 0;
    }
    return tmp;
  }

  public void removeAll() {
    TimeEvent t = first;
    while(t != null) {
      TimeEvent clr = t;
      t = t.nextEvent;
      clr.nextEvent = null;
      clr.time = 0;
      clr.scheduledIn = null;
    }
    first = null;
    eventCount = 0;
  }
  
  public void print(PrintStream out) {
    TimeEvent t = first;
    out.print("nxt: " + nextTime + " [");
    while(t != null) {
      out.print(t.getShort());
      t = t.nextEvent;
      if (t != null) out.print(", ");
    }
    out.println("]");
  }
} // LLEventQueue

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Watchdog.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * Watchdog
 *
 * Author  : Joakim Eriksson
 * Created : 22 apr 2008
 * Updated : $Date:$
 *           $Revision:$
 */
package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

/**
 * @author joakim
 *
 */
public class Watchdog extends IOUnit implements SFRModule {
  
  private static final int WDTHOLD = 0x80;
  private static final int WDTCNTCL = 0x08;
  private static final int WDTMSEL = 0x10;
  private static final int WDTSSEL = 0x04;
  private static final int WDTISx = 0x03;
  
  private static final int WATCHDOG_VECTOR = 10;
  private static final int WATCHDOG_INTERRUPT_BIT = 0;
  private static final int WATCHDOG_INTERRUPT_VALUE = 1 << WATCHDOG_INTERRUPT_BIT;
  
  private static final int[] DELAY = {
    32768, 8192, 512, 64
  };

  private int resetVector = 15;

  private int wdtctl = 0x4;
  private int offset;
  
  public boolean wdtOn = true;
  private boolean hold = false;

  // The current "delay" when started/clered (or hold)
  private int delay;
  // The target time for this timer
  private long targetTime;
  // Timer ACLK
  private boolean sourceACLK = false;

  // Timer or WDT mode
  private boolean timerMode = false;
  
  private TimeEvent wdtTrigger = new TimeEvent(0, "Watchdog") {
    public void execute(long t) {
//      System.out.println(getName() + " **** executing update timers at " + t + " cycles=" + core.cycles);
      triggerWDT(t);
    }
  };

  public Watchdog(MSP430Core cpu, int address) {
    super("Watchdog", cpu, cpu.memory, address);

    resetVector = cpu.MAX_INTERRUPT;
    
    this.offset = address;
    cpu.getSFR().registerSFDModule(0, WATCHDOG_INTERRUPT_BIT, this, WATCHDOG_VECTOR);
  }
   
  public void interruptServiced(int vector) {
    cpu.flagInterrupt(vector, this, false);
  }

  public void reset(int type) {
      super.reset(type);
      wdtctl = 0x4;
  }

  private void triggerWDT(long time) {
      // Here the WDT triggered!!!
      if (timerMode) {
          SFR sfr = cpu.getSFR();
          sfr.setBitIFG(0, WATCHDOG_INTERRUPT_VALUE);
          scheduleTimer();
          System.out.println("WDT trigger - will set interrupt flag (no reset)");
          cpu.generateTrace(System.out);
      } else {
          System.out.println("WDT trigger - will reset node!");
          cpu.generateTrace(System.out);
          cpu.flagInterrupt(resetVector, this, true);
      }
  }
  
  public int read(int address, boolean word, long cycles) {
	  return wdtctl | 0x6900;
  }

  public void write(int address, int value, boolean word, long cycles) {
    if (address == offset) {
      if ((value >> 8) == 0x5a) {
        wdtctl = value & 0xff;
        if (DEBUG) log("Wrote to WDTCTL: " + Utils.hex8(wdtctl) + " from $" + Utils.hex(cpu.getPC(), 4));
        
        // Is it on?
        wdtOn = (value & 0x80) == 0;
//        boolean lastACLK = sourceACLK;
        sourceACLK = (value & WDTSSEL) != 0;
        if ((value & WDTCNTCL) != 0) {
          // Clear timer => reset the delay
          delay = DELAY[value & WDTISx];
        }
        timerMode = (value & WDTMSEL) != 0;
        // Start it if it should be started!
        if (wdtOn) {
          if (DEBUG) log("Setting WDTCNT to count: " + delay);
          scheduleTimer();
        } else {
          // Stop it and remember current "delay" left!
          wdtTrigger.remove();
        }
      } else {
        // Trigger reset!!
        logw(WarningType.EXECUTION, "illegal write to WDTCTL (" + value + ") from $" + Utils.hex(cpu.getPC(), 4)
            + " - reset!!!!");
        cpu.flagInterrupt(resetVector, this, true);
      }
    }
  }

  private void scheduleTimer() {
      if (sourceACLK) {
          if (DEBUG) log("setting delay in ms (ACLK): " + 1000.0 * delay / cpu.aclkFrq);
          targetTime = cpu.scheduleTimeEventMillis(wdtTrigger, 1000.0 * delay / cpu.aclkFrq);
      } else {
          if (DEBUG) log("setting delay in cycles");
          cpu.scheduleCycleEvent(wdtTrigger, targetTime = cpu.cycles + delay);
      }
  }

  public void enableChanged(int reg, int bit, boolean enabled) {
      if (DEBUG) log("*** Watchdog module enabled: " + enabled);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/USARTListener.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * USARTListener
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import se.sics.mspsim.util.ProxySupport;

public interface USARTListener {

    public static final int RXFLAG_CLEARED = 1;
    public void dataReceived(USARTSource source, int data);

    public static class Proxy extends ProxySupport<USARTListener> implements USARTListener {
        public static final Proxy INSTANCE = new Proxy();

        @Override
        public void dataReceived(USARTSource source, int data) {
            USARTListener[] listeners = this.listeners;
            for(USARTListener listener : listeners) {
                listener.dataReceived(source, data);
            }
        }

    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/IOUnit.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * IOUnit
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import se.sics.mspsim.core.EmulationLogger.WarningType;

public abstract class IOUnit implements InterruptHandler, Loggable {

  protected final MSP430Core cpu;
  protected final int[] memory;
  protected final int offset;

  protected final String id;
  protected final String name;

  private StateChangeListener stateListener;
  private int ioState;
  protected int logLevel;
  protected boolean DEBUG = false;

  protected EmulationLogger logger;

  public IOUnit(String id, MSP430Core cpu, int[] memory, int offset) {
    this(id, id, cpu, memory, offset);
  }

  public IOUnit(String id, String name, MSP430Core cpu, int[] memory, int offset) {
    this.id = id;
    this.name = name;
    this.cpu = cpu;
    this.memory = memory;
    this.offset = offset;
    logger = cpu.getLogger();
  }

  @Override
  public int getLogLevel() {
      return logLevel;
  }

  @Override 
  public void setLogLevel(int l) {
      logLevel = l;
      DEBUG = logLevel == Loggable.DEBUG;
  }

  public void addStateChangeListener(StateChangeListener listener) {
      stateListener = StateChangeListener.Proxy.INSTANCE.add(stateListener, listener);
  }

  public void removeStateChangeListener(StateChangeListener listener) {
      stateListener = StateChangeListener.Proxy.INSTANCE.remove(stateListener, listener);
  }


  protected void stateChanged(int newState) {
      stateChanged(newState, false);
  }
  /* Called by subclasses to inform about changes of state */
  protected void stateChanged(int newState, boolean forceCallback) {
      if (forceCallback || ioState != newState) {
          int oldState = ioState;
          ioState = newState;
          /* inform listeners */
          StateChangeListener listener = stateListener;
          if (listener != null) {
              listener.stateChanged(this, oldState, ioState);
          }
      }
  }
  
  public void reset(int type) {
  }

  // write
  // write a value to the IO unit
  public abstract void write(int address, int value, boolean word, long cycles);

  // read
  // read a value from the IO unit
  public abstract int read(int address, boolean word, long cycles);

  public String getID() {
      return id;
  }

  public String getName() {
      return name;
  }
  
  protected void log(String msg) {
      logger.log(this, msg);
  }

  protected void logw(WarningType type, String msg) {
      logger.logw(this, type, msg);
  }

  public String info() {
      return "* no info";
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/BasicClockModule.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * BasicClockModule
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;
import se.sics.mspsim.util.Utils;

public class BasicClockModule extends ClockSystem {

  private static final int DCOCTL = 0x56; // 0x60
  private static final int BCSCTL1 = 0x57; // 0x84 
  private static final int BCSCTL2 = 0x58;

  private static final int ACLK_FRQ = 32768;
  // DCO_FRQ what default frq is the DCO running at???
  private static final int DCO_FRQ = 2500000;
  // What frequency steps to take for the DCO?
  // We have 8 bits + 3 => 11 bits => 2048 combinations...
  // => What is lowest frq??? (zero)
  // Max speed is 8Mhz (CPU limits it) - is max DCO 8Mhz?
  // Based on the scatterweb code it looks like less than
  // 5Mhz is more correct...
  private final int MAX_DCO_FRQ;
  private final int MIN_DCO_FRQ = 1000;
  private final int DCO_FACTOR;

  private Timer[] timers;

  private int dcoFrequency;
  private int dcoModulator;
  private int resistorSel;
  // These will give =>
  private int calcDCOFrq;
  private int divAclk = 1;
  private int lfxt1Mode;
  private int xt2Off;
  private int mclkSel;
  private int divMclk = 1;
  private int smclSel;
  private int divSMclk = 1;
  private int dcoResitorSel;

  /**
   * Creates a new <code>BasicClockModule</code> instance.
   *
   */
  public BasicClockModule(MSP430Core core, int[] memory, int offset, Timer[] timers, int maxClockSpeed) {

    super("BasicClockModule", core, memory, offset);
    MAX_DCO_FRQ = maxClockSpeed;
    DCO_FACTOR = (MAX_DCO_FRQ - MIN_DCO_FRQ) / 2048;
    this.timers = timers;
    //    reset(0);
  }

  public int getMaxDCOFrequency() {
    return MAX_DCO_FRQ;
  }

  public int getAddressRangeMin() {
    return DCOCTL;
  }

  public int getAddressRangeMax() {
    return BCSCTL2;
  }

  public void reset(int type) {
    write(DCOCTL, 0x60, false, cpu.cycles);
    write(BCSCTL1, 0x84, false, cpu.cycles);
    write(BCSCTL2, 0, false, cpu.cycles);
  }

  // do nothing?
  public int read(int address, boolean word, long cycles) {
    int val = memory[address];
    if (word) {
      val |= memory[(address + 1) & 0xffff] << 8;
    }
    return val;
  }

  public void write(int address, int data, boolean word, long cycles) {
    // Currently ignores the word flag...
    if (DEBUG) log("Write to BasicClockModule: " +
		       Utils.hex16(address) + " => " + Utils.hex16(data));

    memory[address] = data & 0xff;
    if (word) memory[address + 1] = (data >> 8) & 0xff;


    switch (address) {
    case DCOCTL:
      dcoFrequency = (data >> 5) & 0x7;
      dcoModulator = data & 0x1f;
      if (DEBUG) log("Write: BCM DCOCTL0: DCO Frq:" + dcoFrequency +
			 "  dcoMod:" + dcoModulator);
      break;
    case BCSCTL1:
      resistorSel = data & 0x7;
      divAclk = 1 << ((data >> 4) & 3);
      lfxt1Mode = (data >> 6) & 1;
      xt2Off = (data >> 7) & 1;
      if (DEBUG) log("Write: BCM BCSCTL1: RSel:" + resistorSel +
			 " DivACLK:" + divAclk + " ACLKFrq: " +
			 ACLK_FRQ / divAclk);
      cpu.setACLKFrq(ACLK_FRQ / divAclk);
      updateTimers(cycles);
      break;
    case BCSCTL2:
      mclkSel = (data >> 6) & 3;
      divMclk = 1 << ((data >> 4) & 3);
      smclSel = (data >> 3) & 1;
      divSMclk = 1 << ((data >> 2) & 3);
      dcoResitorSel = data & 1;
      if (DEBUG) log("Write: BCM BCSCTL2: SMCLKDIV: " +
			 divSMclk + " SMCLK_SEL: "
			 + smclSel + " MCLKSel: " + mclkSel + " divMclk: " +
			 divMclk + " DCOResitorSel: " + dcoResitorSel);
      break;
    }

    // resistor selects three bits gives the highest impact on the DCO_FACTOR
    // then dcoFrq and last dcoModulator
    int newcalcDCOFrq = ((dcoFrequency << 5) + dcoModulator +
			 (resistorSel << 8)) * DCO_FACTOR + MIN_DCO_FRQ;
    if (newcalcDCOFrq != calcDCOFrq) {
      calcDCOFrq = newcalcDCOFrq;
      if (DEBUG) log("BCM  DCO_Speed: " + calcDCOFrq);
      cpu.setDCOFrq(calcDCOFrq, calcDCOFrq / divSMclk);
      updateTimers(cycles);
    }
  }

  private void updateTimers(long cycles) {
    if (timers != null) {
      for(int i = 0; i < timers.length; i++) {
        timers[i].resetCounter(cycles);
      }
    }
  }
  
  public void interruptServiced(int vector) {
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/RAMSegment.java`:

```java
package se.sics.mspsim.core;

import se.sics.mspsim.core.EmulationLogger.WarningType;

public class RAMSegment implements Memory {

    private final MSP430Core core;
    private final int memory[];

    public RAMSegment(MSP430Core core) {
        this.core = core;
        this.memory = core.memory;
    }

    @Override
    public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
        int val = memory[address] & 0xff;
        if (mode != AccessMode.BYTE) {
            val |= (memory[address + 1] << 8);
            if ((address & 1) != 0) {
                core.printWarning(WarningType.MISALIGNED_READ, address);
            }
            if (mode == AccessMode.WORD20) {
                /* will the read really get data from the full word? CHECK THIS */
                val |= (memory[address + 2] << 16) | (memory[address + 3] << 24);
                val &= 0xfffff;
            } else {
                val &= 0xffff;
            }
        }
        return val;
    }

    @Override
    public void write(int dstAddress, int dst, AccessMode mode) throws EmulationException {
        // assume RAM
        memory[dstAddress] = dst & 0xff;
        if (mode != AccessMode.BYTE) {
            memory[dstAddress + 1] = (dst >> 8) & 0xff;
            if ((dstAddress & 1) != 0) {
                core.printWarning(WarningType.MISALIGNED_WRITE, dstAddress);
            }
            if (mode != AccessMode.WORD) {
                memory[dstAddress + 2] = (dst >> 16) & 0xff; /* should be 0x0f ?? */
                memory[dstAddress + 3] = (dst >> 24) & 0xff; /* will be only zeroes*/
            }
        }
    }

    @Override
    public int get(int address, AccessMode mode) {
        return read(address, mode, AccessType.READ);
    }

    @Override
    public void set(int address, int data, AccessMode mode) {
        write(address, data, mode);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/FlashRange.java`:

```java
/*
 * Copyright (c) 2009, Friedrich-Alexander University Erlangen, Germany
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of mspsim.
 *
 */
/**
 * @author Klaus Stengel <siklsten@informatik.stud.uni-erlangen.de>
 */
package se.sics.mspsim.core;

public class FlashRange {
  public int start;
  public int end;
  public int segment_size;
  public int blocksize;
  
  public FlashRange(int start, int end, int segment_size, int blocksize) {
    this.start = start;
    this.end = end;
    this.segment_size = segment_size;
    this.blocksize = blocksize;
  }

  public boolean isInRange(int address) {
    if (address >= start && address < end) {
      return true;
    }
    return false;
  }
}


```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/RF1A.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.core;

import se.sics.mspsim.chip.CC1101;
import se.sics.mspsim.chip.CC1101.GDOListener;
import se.sics.mspsim.core.IOPort.PinState;

public class RF1A extends IOUnit implements InterruptHandler {
    private boolean DEBUG = true;
    
    public static int ADDRESS = 0xf00;
    public static int SIZE = 64;

    private static final int RF1AIFCTL0 = 0x00;
    private static final int RF1AIFCTL1 = 0x02;
    private static final int RF1AIFCTL2 = 0x04;
    private static final int RF1AIFERR = 0x06;
    private static final int RF1AIFERRV = 0x0c;
    private static final int RF1AIFIV = 0x0e;
    private static final int RF1AINSTRW = 0x10;
    private static final int RF1AINSTR1W = 0x12;
    private static final int RF1AINSTR2B = 0x14;
    private static final int RF1ADINW = 0x16;
    private static final int RF1ADOUTB = 0x20;
    private static final int RF1ASTATB = 0x21;
    private static final int RF1ASTAT1W = 0x22;
    private static final int RF1ASTAT2W = 0x24;
    private static final int RF1ADOUT0W = 0x28;
    private static final int RF1ADOUT1W = 0x2a;
    private static final int RF1ADOUT2W = 0x2c;
    private static final int RF1AIN = 0x30;
    private static final int RF1AIFG = 0x32;
    private static final int RF1AIES = 0x34;
    private static final int RF1AIE = 0x36;
    private static final int RF1AIV = 0x38;
    private static final int RF1ARXFIFO = 0x3c;
    private static final int RF1ATXFIFO = 0x3e;

    private CC1101 cc1101;

    private boolean interruptOnCC1101GDO0 = false;
    private boolean gdo0IsHigh = false;

    public RF1A(final MSP430Core cpu, int[] memory) {
        super("RF1A", "RF1A", cpu, memory, ADDRESS);
        cc1101 = new CC1101(cpu);
        cc1101.setGDO0Listener(new GDOListener() {
          public void event(PinState state) {
            /* cc430f5137 datasheet p. 17 */
            gdo0IsHigh = (state == PinState.HI);
            cpu.flagInterrupt(53, RF1A.this, gdo0IsHigh);
          }
        });

        reset(0);
    }    

    public void reset(int type) {
        /* Initial values */
        memory[ADDRESS + 0x00] = 0x0000; /* RF1AIFCTL0 */
        memory[ADDRESS + 0x02] = 0x0000; /* RF1AIFCTL1 */
        memory[ADDRESS + 0x04] = 0x0000; /* RF1AIFCTL2 */
        memory[ADDRESS + 0x06] = 0x0000; /* RF1AIFERR */
        memory[ADDRESS + 0x0c] = 0x0000; /* RF1AIFERRV */
        memory[ADDRESS + 0x0e] = 0x0000; /* RF1AIFIV */
        memory[ADDRESS + 0x10] = 0x0000; /* RF1AINSTRW */

        memory[ADDRESS + 0x12] = 0x0000; /* RF1AINSTR1W */
        memory[ADDRESS + 0x14] = 0x0000; /* RF1AINSTR2B */
        memory[ADDRESS + 0x16] = 0x0000; /* RF1ADINW */

        memory[ADDRESS + 0x20] = 0x0000; /* RF1ASTAT0W */
        memory[ADDRESS + 0x22] = 0x0000; /* RF1ASTAT1W */
        memory[ADDRESS + 0x24] = 0x0000; /* RF1ASTAT2W */
        memory[ADDRESS + 0x28] = 0x0000; /* RF1ADOUT0W */

        memory[ADDRESS + 0x2a] = 0x0000; /* RF1ADOUT1W */
        memory[ADDRESS + 0x2c] = 0x0000; /* RF1ADOUT2W */

        memory[ADDRESS + 0x30] = 0x0000; /* RF1AIN */
        memory[ADDRESS + 0x32] = 0x0000; /* RF1AIFG */
        memory[ADDRESS + 0x34] = 0x0000; /* RF1AIES */
        memory[ADDRESS + 0x36] = 0x0000; /* RF1AIE */
        memory[ADDRESS + 0x38] = 0x0000; /* RF1AIV */

        memory[ADDRESS + 0x3c] = 0x0000; /* RF1ARXFIFO */
        memory[ADDRESS + 0x3e] = 0x0000; /* RF1ATXFIFO */

        interruptOnCC1101GDO0 = false;

        ioAddress = -1;
        ioBurst = false;
        ioRead = false;
        ioWrite = false;
        expectingDummyWrite = false;
    }

    private int ioAddress = -1;
    private boolean ioBurst = false;
    private boolean ioRead = false;
    private boolean ioWrite = false;
    private boolean expectingDummyWrite = false;
    public void write(int address, int value, boolean word, long cycles) {
        /*if (DEBUG) {
            System.out.printf(this.getName() + ": Write to 0x%04x: 0x%04x\n", address, value);
        }*/

        if (address == ADDRESS + RF1AIE) {
          /* Configure interrupts */
          interruptOnCC1101GDO0 = (value & 1) != 0;
        } else if (address == ADDRESS + RF1AINSTRW + 1) {
            /* Store address. Read/write? Burst/single? */
            expectingDummyWrite = false;
            ioBurst = CC1101.spiIsBurst(value);
            if (!ioBurst && CC1101.spiIsStrobe(value)) {
              /* Execute strobe command */
              cc1101.setLastInstructionWasRead(false); /* This is probably wrong! */
              ioBurst = false;
              ioRead = false;
              ioWrite = false;
              expectingDummyWrite = true;
              cc1101.strobe(value & (~CC1101.SPI_READ_BIT) & (~CC1101.SPI_BURST_BIT));
            } else {
              /* Store address */
              ioRead = CC1101.spiIsRead(value);
              ioWrite = !ioRead;
              cc1101.setLastInstructionWasRead(ioRead);
              ioAddress = value & (~CC1101.SPI_READ_BIT) & (~CC1101.SPI_BURST_BIT);
              if (DEBUG) {
                if (ioAddress == CC1101.CC1101_RXFIFO) {
                } else if (ioAddress == CC1101.CC1101_MARCSTATE) {
                } else if (ioAddress == CC1101.CC1101_RXBYTES) {
                } else if (ioAddress == CC1101.CC1101_TXBYTES) {
                } else {
                  System.out.printf("IO address 0x%04x (" + (ioRead?"read":"write") + ", " + (ioBurst?"burst":"single") + ")\n", ioAddress);
                }
              }
              if (ioRead) {
                expectingDummyWrite = true;
              }
            }
        } else if (address == ADDRESS + RF1AINSTRW) {
            if (expectingDummyWrite) {
                /* Ignore dummy write */
                expectingDummyWrite = false;
                return;
            }
            
            if (!ioRead && !ioWrite) {
                System.out.printf("Error: Unknown data mode for write 0x%04x\n", address);
                return;
            } else if (ioRead) {
                System.out.printf("Error: writing in read mode: 0x%04x\n", address);
                return;
            }
            
            /* Write CC1101 register */
            cc1101.setReg(ioAddress, value);
            if (ioBurst) {
                if (ioAddress != CC1101.CC1101_TXFIFO && ioAddress != CC1101.CC1101_PATABLE) {
                    ioAddress++;
                }
            } else {
                ioWrite = false;
            }
        }
    }

    public int read(int address, boolean word, long cycles) {
        /*if (DEBUG) {
            System.out.printf(this.getName() + ": Read from 0x%04x\n", address);
        }*/

        if (address == ADDRESS + RF1AIV) {
          if (interruptOnCC1101GDO0 && gdo0IsHigh) {
            return 2; /* RF1AIV_RFIFG0 */
          }
          return 0;
        } else if (address == ADDRESS + RF1AIFCTL1) {
            /* XXX TODO: CTL1 always return 0xFF */
            return 0xff;
        } else if (address == ADDRESS + RF1ASTAT1W + 1) {
          /* Marcstate */
          return cc1101.getMarcstate();
        } else if (!word && address == ADDRESS + RF1ASTATB) {
            /* Status byte */
            return cc1101.getStatusByte();
        } else if (address == ADDRESS + RF1ADOUTB) {
            /* Return last received byte from emulated SPI interface */
            
            if (!ioRead && !ioWrite) {
                System.out.printf("Error: Unknown data mode for read 0x%04x\n", address);
                return -1;
            } else if (ioWrite) {
                System.out.printf("Error: reading in write mode: 0x%04x\n", address);
                return -1;
            }

            /* Read CC1101 register */
            int val = cc1101.getReg(ioAddress);

            if (ioBurst) {
                if (ioAddress != CC1101.CC1101_TXFIFO && ioAddress != CC1101.CC1101_PATABLE) {
                    ioAddress++;
                }
            } else {
                ioRead = false;
            }

            return val;
        }
        return -1;
    }

    public void interruptServiced(int vector) {
        if (DEBUG) {
            System.out.println(this.getName() + ": Interrupt services vector: " + vector);
        }
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/NoMemSegment.java`:

```java
package se.sics.mspsim.core;

public class NoMemSegment implements Memory {

    private final MSP430Core core;

    NoMemSegment(MSP430Core core) {
        this.core = core;
    }

    @Override
    public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
        throw new EmulationException("Illegal read - out of bounds at $" + core.config.getAddressAsString(address));
//        core.printWarning(MSP430Constants.ADDRESS_OUT_OF_BOUNDS_READ, address);
//        return 0;
    }

    @Override
    public void write(int dstAddress, int dst, AccessMode mode) throws EmulationException {
        throw new EmulationException("Illegal write - out of bounds at $" + core.config.getAddressAsString(dstAddress));
        // core.printWarning(MSP430Constants.ADDRESS_OUT_OF_BOUNDS_WRITE, dstAddress);
    }

    @Override
    public int get(int address, AccessMode mode) {
        return read(address, mode, AccessType.READ);
    }

    @Override
    public void set(int address, int data, AccessMode mode) {
        write(address, data, mode);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/SFR.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * SFR
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

/**
 * SFR - emulation of special function registers
 */
public class SFR extends IOUnit {

  public static final int IE1 = 0;
  public static final int IE2 = 1;
  public static final int IFG1 = 2;
  public static final int IFG2 = 3;
  public static final int ME1 = 4;
  public static final int ME2 = 5;

  private int ie1 = 0;
  private int ie2 = 0;
  private int ifg1 = 0;
  private int ifg2 = 0;
  private int me1 = 0;
  private int me2 = 0;

  /* 64 = max number of interrupts */
  private SFRModule[] sfrModule = new SFRModule[64];
  private int[] irqVector = new int[64];
  private boolean[] irqTriggered = new boolean[64];
  private boolean[] autoclear = new boolean[64];
  private int[] irqTriggeredPos = new int[64];

  public SFR(MSP430Core cpu, int[] memory) {
    super("SFR", "Special Function Register", cpu, memory, 0);
    reset(0);
  }

  public void reset(int type) {
    ie1 = 0;
    ie2 = 0;
    ifg1 = 0;
    ifg2 = 0;
    me1 = 0;
    me2 = 0;
    /* no IRQ - but all are autoclear */
    for (int i = 0; i < irqTriggered.length; i++) {
      irqTriggered[i] = false;
      autoclear[i] = true;
    }
  }

  /* reg = 0/1
   * bit = 0-7 (LSB-MSB)
   * module = the module that will be "called"
   */
  public void registerSFDModule(int reg, int bit, SFRModule module, int irqVec) {
    int pos = reg * 8 + bit;
    sfrModule[pos] = module;
    irqVector[pos] = irqVec;
  }
  
  // write
  // write a value to the IO unit
  public void write(int address, int value, boolean word,
			     long cycles) {
    if (DEBUG) log("write to: " + address + " = " + value);
    switch (address) {
    case IE1:
    case IE2:
        updateIE(address - IE1, value);
      break;
    case IFG1:
    case IFG2:
      updateIFG(address - IFG1, value);
      break;
    case ME1:
    case ME2:
      updateME(address - ME1, value);
    }
    memory[address] = value;
  }

  // read
  // read a value from the IO unit
  public int read(int address, boolean word, long cycles) {
    if (DEBUG) log("read from: " + address);
    switch (address) {
    case IE1:
      return ie1;
    case IE2:
      return ie2;
    case IFG1:
      return ifg1;
    case IFG2:
      return ifg2;
    case ME1:
      return me1;
    case ME2:
      return me2;
    default:
      return memory[address];
    }
  }

  private void updateIE(int pos, int value) {
    int oldVal = pos == 0 ? ie1 : ie2;
    int change = oldVal ^ value;
    if (pos == 0) {
      ie1 = value;
    } else {
      ie2 = value;
    }
    updateIRQ(pos, change);
  }

  private void updateIFG(int pos, int value) {
    int oldVal = pos == 0 ? ifg1 : ifg2;
    int change = oldVal ^ value;
    if (pos == 0) {
      ifg1 = value;
    } else {
      ifg2 = value;
    }
    updateIRQ(pos, change);
  }

  private void updateME(int pos, int value) {
    int oldVal = pos == 0 ? me1 : me2;
    int change = oldVal ^ value;
    if (pos == 0) {
      me1 = value;
    } else {
      me2 = value;
    }
    int reg = pos;
    pos = pos * 8;
    for (int i = 0; i < 8; i++) {
      if ((change & 1) == 1)  {
        if (sfrModule[pos] != null) {
          if (DEBUG) log("Calling enable changed on module: " +
              sfrModule[pos].getName() + " enabled = " + (value & 1) + " bit " + i);
          sfrModule[pos].enableChanged(reg, i, (value & 1) > 0);
        }
      }
      change = change >> 1;
      value = value >> 1;
      pos++;
    }
  }
  
  private void updateIRQ(int pos, int change) {
    int ifg = pos == 0 ? ifg1 : ifg2;
    int ie = pos == 0 ? ie1 : ie2;
    pos = pos * 8;
    for (int i = 0; i < 8; i++) {
      if ((change & 1) == 1)  {
        if (sfrModule[pos] != null && !irqTriggered[irqVector[pos]]) {
          /* interrupt goes directly to the module responsible */
          if (DEBUG) log("flagging interrupt: " +
              sfrModule[pos].getName() + " pos: " + pos + " ie: " + (ie & 1) + " ifg:" + (ifg & 1) + " chg: " + change);
          if ((ie & ifg & 1) > 0) {
            int vector = irqVector[pos];
            irqTriggered[vector] = true;
            irqTriggeredPos[vector] = pos;
            cpu.flagInterrupt(vector, this, true);
          }
          //          cpu.flagInterrupt(irqVector[pos], sfrModule[pos], (ie & ifg & 1) > 0);
        }
      }
      pos++;
      change = change >> 1;
      ifg = ifg >> 1;
      ie = ie >> 1;
    }
  }
  
  public void setBitIFG(int index, int bits) {
    int value = index == 0 ? ifg1 : ifg2;
    int after = value | bits;
    int change = value ^ after;
    if (index == 0) ifg1 = after;
    else ifg2 = after;
    
    updateIRQ(index, change);
  }

  public void clrBitIFG(int index, int bits) {
    int value = index == 0 ? ifg1 : ifg2;
    int after = value & ~bits;
    int change = value ^ after;
    if (index == 0) ifg1 = after;
    else ifg2 = after;
    updateIRQ(index, change);
  }

  public boolean isIEBitsSet(int index, int flags) {
    if (index == 0) return (ie1 & flags) == flags;
    else return (ie2 & flags) == flags;
  }

  public int getIFG(int index) {
    if (index == 0) return ifg1;
    else return ifg2;
  }

  public void setAutoclear(int vector, boolean b) {
      autoclear[vector] = b;
  }

  
  public void interruptServiced(int vector) {
    irqTriggered[vector] = false;
    int pos = irqTriggeredPos[vector];
    if (autoclear[vector]) {
        /* clear the bits that correspond to this vector! */
        int bit = pos & 7;
        if (pos < 8) {
            ifg1 &= ~(1 << bit);
        } else {
            ifg2 &= ~(1 << bit);
        }
        if (DEBUG) {
            log("cleared interrupt for " + sfrModule[pos] + " vector: " + vector);
        }
    }
    cpu.flagInterrupt(vector, this, false);
    if (sfrModule[pos] != null) {
      sfrModule[pos].interruptServiced(vector);
    }
  }

} // SFR

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/SFRModule.java`:

```java
package se.sics.mspsim.core;


public interface SFRModule extends InterruptHandler {
  
  public void enableChanged(int reg, int bit, boolean enabled);
  
//  public void ieChanged(int reg, int bit, boolean enabled);

  /* public void interruptServiced(int reg, int bit); */
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/WatchedMemory.java`:

```java
package se.sics.mspsim.core;

public class WatchedMemory implements Memory {

    private final int start;
    private final Memory wrappedMemory;
    private final MemoryMonitor watchPoints[] = new MemoryMonitor[Memory.SEGMENT_SIZE];

    WatchedMemory(int start, Memory wrapped) {
        this.start = start;
        this.wrappedMemory = wrapped;
    }

    @Override
    public int read(int address, AccessMode mode, AccessType type) throws EmulationException {
        final int a = address - start;
        int val;
        MemoryMonitor mon = watchPoints[a];
        if (mon != null) {
            mon.notifyReadBefore(address, mode, type);
            val = wrappedMemory.read(address, mode, type);
            mon.notifyReadAfter(address, mode, type);
        } else {
            val = wrappedMemory.read(address, mode, type);
        }
        return val;
    }

    @Override
    public void write(int dstAddress, int dst, AccessMode mode) throws EmulationException {
        final int a = dstAddress - start;
        final MemoryMonitor mon = watchPoints[a];
        if (mon != null) {
            mon.notifyWriteBefore(dstAddress, dst, mode);
            wrappedMemory.write(dstAddress, dst, mode);
            mon.notifyWriteAfter(dstAddress, dst, mode);
        } else {
            wrappedMemory.write(dstAddress, dst, mode);
        }
    }

    @Override
    public int get(int address, AccessMode mode) {
        return wrappedMemory.get(address, mode);
    }

    @Override
    public void set(int address, int data, AccessMode mode) {
        wrappedMemory.set(address, data, mode);
    }

    public boolean hasWatchPoint(int address) {
        MemoryMonitor mon = watchPoints[address - start];
        return mon != null;
    }

    public synchronized void addWatchPoint(int address, MemoryMonitor mon) {
        final int a = address - start;
        watchPoints[a] = MemoryMonitor.Proxy.INSTANCE.add(watchPoints[a], mon);
    }

    public synchronized void removeWatchPoint(int address, MemoryMonitor mon) {
        final int a = address - start;
        watchPoints[a] = MemoryMonitor.Proxy.INSTANCE.remove(watchPoints[a], mon);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/MSP430Constants.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * MSP430Constants
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

public interface MSP430Constants {

  public static final String VERSION = "0.99";
  
  public static final int MODE_BYTE = 0;
  public static final int MODE_WORD = 1;
  public static final int MODE_WORD20 = 2;
  
  public static final int MODE_BIT_SIZE[] = {8, 16, 20};
  
  public static final int MODE_MASK[] = {0xff, 0xffff, 0xfffff};
  
  /* memory tags - not used yet*/
  public static final int READ_MONITOR = 0x1000;
  public static final int WRITE_MONITOR = 0x2000;
  public static final int EXEC_MONITOR = 0x4000;
  public static final int MEM_FLASH = 0x100;
  public static final int MEM_IO = 0x200;
  
  public static final int RESET_PUC = 0;
  public static final int RESET_POR = 1;
  
  // MODES
  public static final int MODE_ACTIVE = 0;
  public static final int MODE_LPM0 = 1;
  public static final int MODE_LPM1 = 2;
  public static final int MODE_LPM2 = 3;
  public static final int MODE_LPM3 = 4;
  public static final int MODE_LPM4 = 5;
  public static final int MODE_MAX = MODE_LPM4;

  public static String[] MODE_NAMES = {
    "active", "lpm0", "lpm1", "lpm2", "lpm3", "lpm4" 
  };
  
  public static final int CLK_ACLK = 1;
  public static final int CLK_SMCLK = 2;

  // Instructions (full length)
  public static final int RRC = 0x1000;
  public static final int SWPB = 0x1080;
  public static final int RRA = 0x1100;
  public static final int SXT = 0x1180;
  public static final int PUSH = 0x1200;
  public static final int CALL = 0x1280;
  public static final int RETI = 0x1300;

  // Conditional Jumps [
  public static final int JNE = 0x2000;
  public static final int JEQ = 0x2400;
  public static final int JNC = 0x2800;
  public static final int JC = 0x2C00;

  // Conditional Jumps & jumps...
  public static final int JN = 0x3000;
  public static final int JGE = 0x3400;
  public static final int JL = 0x3800;
  public static final int JMP = 0x3C00;

  // Short ones...
  public static final int MOV = 0x4;
  public static final int ADD = 0x5;
  public static final int ADDC = 0x6;
  public static final int SUBC = 0x7;
  public static final int SUB = 0x8;
  public static final int CMP = 0x9;
  public static final int DADD = 0xa;
  public static final int BIT = 0xb;
  public static final int BIC = 0xc;
  public static final int BIS = 0xd;
  public static final int XOR = 0xe;
  public static final int AND = 0xf;

  
  // MSP430X instructions
  public static final int MOVA_IND = 0x0000;
  public static final int MOVA_IND_AUTOINC = 0x0010; /* Indirect with increment */
  public static final int MOVA_ABS2REG = 0x0020;
  public static final int MOVA_INDX2REG = 0x0030;
  public static final int MOVA_REG2ABS = 0x0060;
  public static final int MOVA_REG2INDX = 0x0070;
  public static final int MOVA_IMM2REG = 0x0080;
  public static final int CMPA_IMM = 0x0090;
  public static final int ADDA_IMM = 0x00a0;
  public static final int SUBA_IMM = 0x00b0;
  public static final int MOVA_REG = 0x00c0;
  public static final int CMPA_REG = 0x00d0;
  public static final int ADDA_REG = 0x00e0;
  public static final int SUBA_REG = 0x00f0;
  
  public static final int RRXX_ADDR = 0x0040;
  public static final int RRXX_WORD = 0x0050;
  
  public static final int RRMASK = 0x0300;
  public static final int RRCM = 0x0000; /* rotate right through carry C -> MSB -> MSB-1 ... -> C */
  public static final int RRAM = 0x0100; /* rotate right arithmetically MSB -> MSB -> MSB-1 ...->C*/ 
  public static final int RLAM = 0x0200; /* rotate left arithm. C <- MSB-1 ... <- 0 */
  public static final int RRUM = 0x0300; /* rotate right unsigned 0 -> MSB -> MSB -1, ... */

  
  public static final int CALLA_MASK = 0xfff0;
  public static final int CALLA_REG = 0x1340;
  public static final int CALLA_INDEX = 0x1350;
  public static final int CALLA_IND = 0x1360;
  public static final int CALLA_IND_AUTOINC = 0x1370;
  public static final int CALLA_ABS = 0x1380;
  public static final int CALLA_EDE = 0x1390; /* x(PC) */
  public static final int CALLA_IMM = 0x13b0;
  
  public static final int PUSHM_A = 0x1400;
  public static final int PUSHM_W = 0x1500;
  public static final int POPM_A = 0x1600;
  public static final int POPM_W = 0x1700;
    
  
  public static final int EXTWORD_ZC = 0x100;
  public static final int EXTWORD_REPEAT = 0x80;
  public static final int EXTWORD_AL = 0x40;
  public static final int EXTWORD_SRC = 0x780;
  public static final int EXTWORD_DST = 0x0f;
  
  
  
  
  public static final String[] TWO_OPS = {
    "-","-","-","-","MOV", "ADD", "ADDC", "SUBC", "SUB",
    "CMP", "DADD", "BIT", "BIC", "BIS", "XOR", "AND"
  };

  public static final String[] REGISTER_NAMES = {
    "PC", "SP", "SR", "CG1", "CG2"
  };

  public static final int PC = 0;
  public static final int SP = 1;
  public static final int SR = 2;
  public static final int CG1 = 2;
  public static final int CG2 = 3;

  public static final int[][] CREG_VALUES = new int[][]{
    {0, 0, 4, 8}, {0, 1, 2, 0xffff}
  };

  public static final int CARRY_B = 0;
  public static final int ZERO_B = 1;
  public static final int NEGATIVE_B = 2;
  public static final int OVERFLOW_B = 8;
  public static final int GIE_B = 3;

  public static final int CARRY = 1;
  public static final int ZERO = 2;
  public static final int NEGATIVE = 4;
  public static final int OVERFLOW = 1 << OVERFLOW_B;
  public static final int GIE = 1 << GIE_B;

  /* For the LPM management */
  public static final int CPUOFF = 0x0010;
  public static final int OSCOFF = 0x0020;
  public static final int SCG0 = 0x0040;
  public static final int SCG1 = 0x0080;

// #define C                   0x0001
// #define Z                   0x0002
// #define N                   0x0004
// #define V                   0x0100
// #define GIE                 0x0008
// #define CPUOFF              0x0010
// #define OSCOFF              0x0020
// #define SCG0                0x0040
// #define SCG1                0x0080


  public static final int AM_REG = 0;
  public static final int AM_INDEX = 1;
  public static final int AM_IND_REG = 2;
  public static final int AM_IND_AUTOINC = 3;

  public static final int CLKCAPTURE_NONE = 0;
  public static final int CLKCAPTURE_UP = 1;
  public static final int CLKCAPTURE_DWN = 2;
  public static final int CLKCAPTURE_BOTH = 3;


  public static final int DEBUGGING_LEVEL = 0;
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/InterruptHandler.java`:

```java
/**
 * 
 */
package se.sics.mspsim.core;

/**
 * @author joakim
 *
 */
public interface InterruptHandler {
  // We should add "Interrupt serviced..." to indicate that its latest
  // Interrupt was serviced...
  public void interruptServiced(int vector);
  public String getName();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/AES128.java`:

```java
/* Copyright (c) 2013, tado° GmbH. Munich, Germany.
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. Neither the name of the Institute nor the names of its contributors 
 *    may be used to endorse or promote products derived from this software 
 *    without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND 
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE. 
 *
 * This file is part of MSPSim.
 * 
 * Author: Víctor Ariño <victor.arino@tado.com>
 * 
 */
package se.sics.mspsim.core;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

import se.sics.mspsim.core.EmulationLogger.WarningType;


/**
 * AES128 msp430 peripheral emulation
 * 
 * TODO: 
 * 	advanced cipher modes
 * 	longer key support 
 * 	interrupts 
 * 	timing concerns 
 * 	first round key operations
 * 
 * @author Víctor Ariño <victor.arino@tado.com>
 */
public class AES128 extends IOUnit {

	/**
	 * Address and size for IO configuration
	 */
	public static int OFFSET = 0x09C0;
	public static int SIZE = 12;

	/**
	 * Enable/Disable debug output of the module
	 */
	private static boolean DEBUG = false;

	/**
	 * Register definition as in the documentation Offset from 0xff80
	 */
	public static final int AES_VECTOR = 0x005A;

	/* Main registers */
	public static final int AESACTL0 = 0x00;
	public static final int AESACTL1 = 0x02;
	public static final int AESASTAT = 0x04;
	public static final int AESAKEY = 0x06;
	public static final int AESADIN = 0x08;
	public static final int AESADOUT = 0x0a;

	/* AESACTL0 Control Bits */
	public static final int AESSWRST = 0x0080;
	public static final int AESRDYIFG = 0x0100;
	public static final int AESERRFG = 0x0800;
	public static final int AESRDYIE = 0x1000;

	public static final int AESOP_0 = 0x0000;
	public static final int AESOP_1 = 0x0001;
	public static final int AESOP_2 = 0x0002;
	public static final int AESOP_3 = 0x0003;

	/* AESASTAT Control Bits */
	public static final int AESBUSY = 0x0001;
	public static final int AESKEYWR = 0x0002;
	public static final int AESDINWR = 0x0004;
	public static final int AESDOUTRD = 0x0008;
	public static final int AESCMEN = 0x8000;

	/* Cipher modes */
	private static final int MODE_ECB = 0;
	private static final int MODE_CBC = 1;
	private static final int MODE_OFB = 2;
	private static final int MODE_CFB = 3;

	/* Key lengths */
	private static final int KEY_128 = 0;
	private static final int KEY_192 = 1;
	private static final int KEY_256 = 2;

	/**
	 * Emulate peripheral using the default offset
	 * 
	 * @param cpu
	 */
	public AES128(MSP430Core cpu) {
		this(cpu, OFFSET);
	}

	/**
	 * Emulate peripheral using custom offset
	 * 
	 * @param cpu
	 * @param offset
	 */
	public AES128(MSP430Core cpu, int offset) {
		super("CRC", cpu, cpu.memory, offset);
	}

	/**
	 * Clear everything when reset. The cleared fields are specified in the
	 * manual
	 */
	public void reset(int type) {
		/*
		 * AES software reset. Immediately resets the complete AES accelerator
		 * module even when busy except for the AESRDYIE, the AESKLx and the
		 * AESOPx bits. It also clears the (internal) state memory.
		 */
		key.clear();
		inData.clear();
		outData.clear();
		isBusy = false;
		advancedCipherMode = false;
		interruptEnable = false;
		errorFlag = false;
		resetFlag = false;
		cipherMode = MODE_ECB;
		cipherBlockCounter = 0;
	}

	/**
	 * Variable holders for the different registers needed by this peripheral
	 */

	/* avoid using NIO resources */
	private static class ByteBuffer {
	    byte[] buffer;
	    int pos;

	    ByteBuffer(int size) {
	        buffer = new byte[size]; 
	        pos = 0;
	    }

	    public int position() {
	        return pos;
	    }

	    public void position(int p) {
	        pos = p;
	    }

	    public boolean hasRemaining() {
	        return pos < buffer.length;
	    }

	    public void clear() {
	        pos = 0;
	    }

	    public void resetPos() {
	        pos = 0;
	    }

	    public byte[] array() {
	        return buffer;
	    }

	    public void put(byte[] bytes) {
	        for (int i = 0; i < bytes.length; i++) {
                    put(bytes[i]);
                }
	    }

	    public void put(byte data) {
	        buffer[pos++] = data;
	    }

	    /* assume that calling code is ok... */
	    public byte get() {
	        return buffer[pos++];
	    }
	    
	    public int limit() {
	        return buffer.length;
	    }
	}

	private ByteBuffer key = new ByteBuffer(16);
	private ByteBuffer inData = new ByteBuffer(16);
	private ByteBuffer outData = new ByteBuffer(16);

	/**
	 * Syntax sugar
	 */
	private boolean isBusy = false;

	/**
	 * Nice names for buffer operations :-)
	 */
	private int bytesReadOut() {
		return outData.position();
	}

	private int bytesWrittenIn() {
		return inData.position();
	}

	private int bytesKeyWritten() {
		return key.position();
	}

	private boolean allBytesReadOut() {
		return !outData.hasRemaining();
	}

	private boolean isKeyReady() {
		return !key.hasRemaining();
	}

	private boolean isDataReady() {
		return !inData.hasRemaining();
	}

	private int getStatReg() {
		int stat = 0;
		stat |= (bytesReadOut() & 0x0f) << 12;
		stat |= (bytesWrittenIn() & 0x0f) << 8;
		stat |= (bytesKeyWritten() & 0x0f) << 4;
		stat |= (allBytesReadOut() ? 1 : 0) << 3;
		stat |= ((isDataReady() ? 1 : 0) & 0x01) << 2;
		stat |= ((isKeyReady() ? 1 : 0) & 0x01) << 1;
		stat |= ((isBusy ? 1 : 0) & 0x01);
		return stat & 0xffff;
	}

	/* AESACTL0 register */
	private boolean advancedCipherMode = false;
	private boolean interruptEnable = false;
	private boolean errorFlag = false;
	private boolean readyInterruptFlag = false;
	private boolean resetFlag = false;
	private int cipherMode = MODE_ECB;
	private int keyLength = KEY_128;
	private int operation = AESOP_0;
	private int cipherBlockCounter = 0;

	/**
	 * CTL0 Register built upon variables
	 * 
	 * @return uint16_t register
	 */
	private int getCTL0Reg() {
		int ctl0 = 0;
		ctl0 |= ((advancedCipherMode ? 1 : 0) & 0x01) << 15;
		ctl0 |= ((interruptEnable ? 1 : 0) & 0x01) << 12;
		ctl0 |= ((errorFlag ? 1 : 0) & 0x01) << 11;
		ctl0 |= ((readyInterruptFlag ? 1 : 0) & 0x01) << 8;
		ctl0 |= ((resetFlag ? 1 : 0) & 0x01) << 7;
		ctl0 |= (cipherMode & 0x03) << 5;
		ctl0 |= (keyLength & 0x03) << 2;
		ctl0 |= (operation & 0x03);
		return ctl0 & 0xffff;
	}

	private int getCTL1Reg() {
		int ctl1 = cipherBlockCounter;
		return ctl1 & 0x000f;
	}

	/**
	 * Java implementation of the AES encryption algorithm
	 * 
	 * This method encrypts whatever is in inData using key and sets it into
	 * outData
	 */
	private void aesEncrypt() {
		log("encrypt");
		Cipher cipher;
		SecretKeySpec spec = new SecretKeySpec(key.array(), "AES");
		try {
			cipher = Cipher.getInstance("AES/ECB/NoPadding");
			cipher.init(Cipher.ENCRYPT_MODE, spec);
			byte[] bytes = cipher.doFinal(inData.array());
			outData.clear();
			outData.put(bytes);
			outData.resetPos();
		} catch (Exception e) {
			log(e.getStackTrace().toString());
		}
	}

	/**
	 * Java implementation of the AES decryption algorithm
	 * 
	 * This method decrypts whatever is in inData using key and sets it into
	 * outData
	 */
	private void aesDecrypt() {
		log("decrypt");
		Cipher cipher;
		SecretKeySpec spec = new SecretKeySpec(key.array(), "AES");
		try {
			cipher = Cipher.getInstance("AES/ECB/NoPadding");
			cipher.init(Cipher.DECRYPT_MODE, spec);
			byte[] bytes = cipher.doFinal(inData.array());
			outData.clear();
			outData.put(bytes);
			outData.resetPos();
		} catch (Exception e) {
			log(e.getStackTrace().toString());
		}
	}

	/*
	 * The inherited log function is not working for whatever reason. A quick
	 * redefinition helps a lot while developing the module
	 */
	@Override
	protected void log(String msg) {
		if (DEBUG) {
			System.out.println(msg);
		}
	}

	/**
	 * Log using printf format
	 * 
	 * @param format
	 * @param arguments
	 */
	protected void log(final String format, final Object... arguments) {
		if (DEBUG) {
			System.out.printf(format, arguments);
		}
	}

	/**
	 * The registers are written
	 */
	public void write(int address, int value, boolean word, long cycles) {
		log("write @ %x <-- %x (word=%b)\n", address, value, word);
		int lo = (value) & 0xff; // low byte
		int hi = (value >> 8) & 0xff; // high byte

		switch (address - offset) {
		case AESACTL0:
			if ((value & AESSWRST) == AESSWRST) {
				reset(0);
			}

			if (!(advancedCipherMode && cipherBlockCounter > 0)) {
				advancedCipherMode = ((value & AESCMEN) == AESCMEN);
			}

			interruptEnable = ((value & AESRDYIE) == AESRDYIE);
			errorFlag = ((value & AESERRFG) == AESERRFG);
			readyInterruptFlag = ((value & AESRDYIFG) == AESRDYIFG);

			if (!(advancedCipherMode && cipherBlockCounter > 0)
					&& !advancedCipherMode) {
				cipherMode = ((value & 0x60) >> 5);
			}

			keyLength = ((value & 0xC) >> 2);

			if (!(advancedCipherMode && cipherBlockCounter > 0)) {
				operation = value & 0x03;
			}
			break;

		case AESACTL1:
			/* Only lower byte allowed */
			if (!(advancedCipherMode && cipherBlockCounter > 0)) {
				value &= 0x000f;
				cipherBlockCounter = value;
			}

			break;

		case AESASTAT:
			/* Only two fields can be written in this register */
			value &= (AESDINWR | AESKEYWR);

			if ((value & AESKEYWR) == 0) {
				/*
				 * This flag can only be cleared if the advanceModeSupport is not
				 * enabled (ref. User Guide)
				 */
				if (!advancedCipherMode) {
					value |= AESKEYWR;
				} else {
					key.resetPos();
				}
			} else {
				isBusy = true;
				key.position(key.limit());
				switch (operation) {
				case AESOP_0: // encrypt
					aesEncrypt();
					break;
				case AESOP_1: // decrypt
					aesDecrypt();
					break;
				case AESOP_2: // gen 1st round key
					logw(WarningType.ILLEGAL_IO_WRITE, "to implement");
					break;
				case AESOP_3: // decrypt 1st round key
					logw(WarningType.ILLEGAL_IO_WRITE, "to implement");
					break;
				}
				isBusy = false;
				readyInterruptFlag = true;
			}

			if ((value & AESDINWR) == 0) {
				if (!advancedCipherMode) {
					value |= AESKEYWR;
				} else {
					inData.resetPos();
				}
			} else {
				inData.position(inData.limit());
			}

			break;

		case AESAKEY:
			if (key.hasRemaining()) {
				/* Clear the ready interrupt flag */
				readyInterruptFlag = false;
				key.put((byte) lo);
				if (word && key.hasRemaining()) {
					key.put((byte) hi);
				}
			}
			break;

		case AESADIN:
			if (inData.hasRemaining()) {
				/* Clear the ready interrupt flag */
				readyInterruptFlag = false;
				inData.put((byte) lo);
				if (word && inData.hasRemaining()) {
					inData.put((byte) hi);
				}
			}
			break;
		}

		log("ctl0: %04x\nstat: %04x\n", getCTL0Reg(), getStatReg());
	}

	/**
	 * Registers are read
	 */
	public int read(int address, boolean word, long cycles) {
		log("read %x (word?%b)\n", address, word);
		switch (address - offset) {
		case AESACTL0:
			return getCTL0Reg();
		case AESACTL1:
			if (advancedCipherMode) {
				return cipherBlockCounter;
			}
		case AESASTAT:
			return getStatReg();
		case AESADOUT:
			if (isDataReady()) {
				/* Clear the ready interrupt flag */
				readyInterruptFlag = false;
				if (outData.hasRemaining()) {
					int temp = outData.get() & 0xff;
					if (word && outData.hasRemaining()) {
						temp |= (outData.get() << 8) & 0xff00;
					}
					return temp & 0xffff;
				}
			}
		}
		return 0;
	}

	public void interruptServiced(int vector) {
		if (vector == AES_VECTOR) {
			readyInterruptFlag = false;
		}
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/ClockSystem.java`:

```java
/**
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ClockSystem
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.core;

public abstract class ClockSystem extends IOUnit {

  public abstract int getMaxDCOFrequency();
  public abstract int getAddressRangeMin();
  public abstract int getAddressRangeMax();

  public ClockSystem(String type, MSP430Core cpu, int[] memory, int offset) {
    super(type, cpu, memory, offset);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/SysReg.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.core;

public class SysReg extends IOUnit {
	public static int ADDRESS = 0x180;
	public static int SIZE = 0x1f;

	/*
	 * This is only a stub to avoid immediate Mspsim exceptions.
	 * TODO XXX: Implement me!
	 * 
System control SYSCTL 00h
Bootstrap loader configuration area SYSBSLC 02h
JTAG mailbox control SYSJMBC 06h
JTAG mailbox input 0 SYSJMBI0 08h
JTAG mailbox input 1 SYSJMBI1 0Ah
JTAG mailbox output 0 SYSJMBO0 0Ch
JTAG mailbox output 1 SYSJMBO1 0Eh
Bus Error vector generator SYSBERRIV 18h
User NMI vector generator SYSUNIV 1Ah
System NMI vector generator SYSSNIV 1Ch
Reset vector generator SYSRSTIV 1Eh
	 */

	public SysReg(MSP430Core cpu, int[] memory) {
		super("SysReg", "System registers", cpu, memory, SysReg.ADDRESS);
		reset(0);
	}

	public void reset(int type) {
	}

	public void write(int address, int value, boolean word, long cycles) {
		if (DEBUG)
			log(this.getName() + ": Write to: "
					+ String.format("0x%05x = 0x%05x", address, value));
		memory[address] = value;
	}

	public int read(int address, boolean word, long cycles) {
		if (DEBUG)
			log(this.getName()
					+ ": Read from: "
					+ String.format("0x%05x = 0x%05x", address, memory[address]));
		return memory[address];
	}

	public void interruptServiced(int vector) {
		if (DEBUG)
			log(this.getName() + ": Interrupt services vector: " + vector);
	}
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/OperatingModeListener.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * OperatingModeListener - allow listening on IOUnits operating mode.
 *
 * Author  : Joakim Eriksson
 * Created : 17 jan 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.core;

/**
 * @author Joakim
 *
 */
public interface OperatingModeListener {
  public void modeChanged(Chip source, int mode);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/IOPort.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * IOPort
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package  se.sics.mspsim.core;
import java.util.Arrays;

import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

public class IOPort extends IOUnit {

    public enum PinState { LOW, HI };

    public enum PortReg {IN, OUT, DIR, SEL, SEL2, IFG, IES, IE, REN, DS, IV_L, IV_H};

    /* portmaps for 1611 */
    private static final PortReg[] PORTMAP_INTERRUPT = 
        {PortReg.IN, PortReg.OUT, PortReg.DIR, PortReg.IFG, PortReg.IES, PortReg.IE, PortReg.SEL}; 
    private static final PortReg[] PORTMAP_NO_INTERRUPT = 
        {PortReg.IN, PortReg.OUT, PortReg.DIR, PortReg.SEL};

    private final int port;
    private final int interrupt;

    // External pin state!
    private final PinState pinState[] = new PinState[8];

    private final PortReg[] portMap;

    private PortListener portListener = null;

    /* Registers for Digital I/O */

    private int in;
    private int out;
    private int dir;
    private int sel;
    private int sel2;
    private int ie;
    private int ifg;
    private int ies; /* edge select */
    private int ren;
    private int ds;

    private int iv; /* low / high */

    private Timer[] timerCapture = new Timer[8];

    private IOPort ioPair;
    
    /**
     * Creates a new <code>IOPort</code> instance.
     *
     */
    public IOPort(MSP430Core cpu, int port, int interrupt, int[] memory, int offset) {
        this(cpu, port, interrupt, memory, offset,
                interrupt == 0 ? PORTMAP_NO_INTERRUPT : PORTMAP_INTERRUPT);
    }

    /* Create an IOPort with a special PortMap */
    public IOPort(MSP430Core cpu, int port,
            int interrupt, int[] memory, int offset, PortReg[] portMap) {
        super("P" + port, "Port " + port, cpu, memory, offset);
        this.port = port;
        this.interrupt = interrupt;
        this.ie = 0;
        this.ifg = 0;
        this.portMap = portMap;

//        System.out.println("Port " + port + " interrupt vector: " + interrupt);
        /* register all the registers from the port-map */
        for (int i = 0; i < portMap.length; i++) {
            if (portMap[i] != null) {
//                System.out.println("  P" + port + portMap[i] + " at " + Utils.hex16(offset + i));
                cpu.setIORange(offset + i, 1, this);
            }
        }
    }
    
    public static IOPort parseIOPort(MSP430Core cpu, int interrupt, String specification, IOPort last) {
        /* Specification = Px=Offset,REG Off, ... */
        String[] specs = specification.split(",");
        int port = specs[0].charAt(1) - '0';
        int offset = Integer.parseInt(specs[0].substring(3), 16);

        PortReg[] portMap = new PortReg[0x20]; /* Worst case port-map */
        int highest = -1;
        for (int i = 1; i < specs.length; i++) {
            String[] preg = specs[i].split(" ");
            PortReg pr = PortReg.valueOf(preg[0]);
            int offs = Integer.parseInt(preg[1], 16);
            if (offs >= portMap.length) {
                portMap = Arrays.copyOf(portMap, offs + 1);
            }
            portMap[offs] = pr;
            if (offs > highest) {
                highest = offs;
            }
        }
        if (highest + 1 < portMap.length) {
            portMap = Arrays.copyOf(portMap, highest + 1);
        }
        IOPort newPort = new IOPort(cpu, port, interrupt, cpu.memory, offset, portMap);
        if (last != null && offset == last.offset && offset > 0) {
            // This port is a pair with previous port to allow 16 bits writes
            last.ioPair = newPort;
        }
        return newPort;
    }

    public int getPort() {
        return port;
    }

    public int getIn() {
        return in;
    }

    public int getOut() {
        return out;
    }

    public int getDirection() {
        return dir;
    }

    public int getSelect() {
        return sel;
    }

    public synchronized void addPortListener(PortListener newListener) {
        portListener = PortListenerProxy.addPortListener(portListener, newListener);
    }

    public synchronized void removePortListener(PortListener oldListener) {
        portListener = PortListenerProxy.removePortListener(portListener, oldListener);
    }

    public void setTimerCapture(Timer timer, int pin) {
        if (DEBUG) {
            log("Setting timer capture for pin: " + pin);
        }
        timerCapture[pin] = timer;
    }

    private void updateIV() {
        int bitval = 0x01;
        iv = 0;
        int ie_ifg = ifg & ie;
        for (int i = 0; i < 8; i++) {
            if ((bitval & ie_ifg) > 0) {
                iv = 2 + i * 2;
                break;
            }
            bitval = bitval << 1;
        }
        //System.out.println("*** Setting IV to: " + iv + " ifg: " + ifg);
        cpu.flagInterrupt(interrupt, this, (ifg & ie) > 0);
    }

    public int getRegister(PortReg register) {
        switch(register) {
        case DIR:
            return dir;
        case IE:
            return ie;
        case IES:
            return ies;
        case IFG:
            return ifg;
        case IN:
            return in;
        case IV_H:
            return (iv >> 8) & 0xff;
        case IV_L:
            return iv & 0xff;
        case OUT:
            return out;
        case REN:
            return ren;
        case DS:
            return ds;
        case SEL:
            return sel;
        case SEL2:
            return sel2;
        }
        return 0;
    }

    /* only byte access!!! */
    private int readPort(PortReg function, long cycles) {
        switch(function) {
        case OUT:
            return out;
        case IN:
            return in;
        case DIR:
            return dir;
        case REN:
            return ren;
        case IFG:
            return ifg;
        case IE:
            return ie;
        case IES:
            return ies;
        case SEL:
            return sel;
        case SEL2:
            return sel2;
        case DS:
            return ds;
        case IV_L: {
            int v = iv & 0xff;
            // Clear highest interrupt
            if (iv != 0) {
                if (iv > 1 && iv < 17) {
                    ifg &= ~(1 << ((iv - 2) / 2));
                }
                updateIV();
            }
            return v;
        }
        case IV_H: {
            int v = iv >> 8;
            return v;
        }
        }
        /* default is zero ??? */
        return 0;
    }

    private void writePort(PortReg function, int data, long cycles) {
        switch(function) {
        case OUT: {
            out = data;
            PortListener listener = portListener;
            if (listener != null) {
            	listener.portWrite(this, out | (~dir) & 0xff);
            }
            break;
        }
        case IN:
            logw(WarningType.ILLEGAL_IO_WRITE, "WARNING: writing to read-only " + getID() + "IN");
            throw new EmulationException("Writing to read-only " + getID() + "IN");
            //          in = data;
        case DIR: {
            dir = data;
            PortListener listener = portListener;
            if (listener != null) {
                // Any output configured pin (pin-bit = 0) should have 1 here?! 
                //              if (name.equals("1"))
                //                System.out.println(getName() + " write to IOPort via DIR reg: " + Utils.hex8(data));
                listener.portWrite(this, out | (~dir) & 0xff);
            }
            break;
        }
        case REN:
            ren = data;
            break;
        case IFG:
            if (DEBUG) {
                log("Setting IFlag: " + data);
            }
            ifg = data;
            updateIV();
            break;
        case IE:
            ie = data;
            if (DEBUG) {
                log("Setting IE: " + data);
            }
            cpu.flagInterrupt(interrupt, this, (ifg & ie) > 0);
            break;
        case IES:
            ies = data;
            break;
        case SEL:
            sel = data;
            break;
        case SEL2:
            sel2 = data;
            break;
        case DS:
            ds = data;
            break;
        case IV_L:
            // IV can not be written but highest interrupt should be cleared
            // on access.
            if (iv != 0) {
                if (iv > 1 && iv < 17) {
                    ifg &= ~(1 << ((iv - 2) / 2));
                }
                updateIV();
            }
            break;
        case IV_H:
            // IV_H can not be written
            break;
        }
    }


    public int read(int address, boolean word, long cycles) {
        PortReg reg = portMap[address - offset];
        /* only byte read allowed if not having an ioPair */
        if (word && reg == PortReg.IV_L) {
            /* Read hi first then low => update on low!!! */
            return (readPort(PortReg.IV_H, cycles) << 8) | readPort(reg, cycles);
        } else if (word && ioPair != null) {
            /* read same function from both */
            return readPort(reg, cycles) | (ioPair.readPort(reg, cycles) << 8);
        }
        /* NOTE: read of PIV might be wrong here - might be word access on IV? */
        return readPort(reg, cycles);
    }


    public void write(int address, int data, boolean word, long cycles) {
        int iAddress = address - offset;
        PortReg fun = portMap[iAddress];
        if (DEBUG) {
            log("Writing to " + getID() + fun +
                    " ($" + Utils.hex(address, 2) +
                    ") => $" + Utils.hex(data, 2) + "=#" +
                    Utils.binary8(data) + (word ? " (word)" : ""));
        }

        /* only byte write - need to convert any word write here... */
        if (word && ioPair != null) {
            writePort(fun, data & 0xff, cycles);
            ioPair.writePort(fun, data >> 8, cycles);
        } else {
            writePort(fun, data, cycles);
        }
    }

    public void interruptServiced(int vector) {
    }

    // for HW to set hi/low on the pins...
    public void setPinState(int pin, PinState state) {
        if (pinState[pin] != state) {
            pinState[pin] = state;
            int bit = 1 << pin;
            if (state == PinState.HI) {
                in |= bit;
            } else {
                in &= ~bit;
            }
            if (interrupt > 0) {
                if ((ies & bit) == 0) {
                    // LO/HI transition
                    if (state == PinState.HI) {
                        ifg |= bit;
                        if (DEBUG) {
                            log("Flagging interrupt (HI): " + bit);
                        }
                        updateIV();
                    }
                } else {
                    // HI/LO transition
                    if (state == PinState.LOW) {
                        ifg |= bit;
                        if (DEBUG) {
                            log("Flagging interrupt (LOW): " + bit);
                        }
                        updateIV();
                    }
                }
            }

            if (timerCapture[pin] != null) {
                /* should not be pin and 0 here
                 * pin might need configuration and 0 can maybe also be 1? 
                 */
                //        if (DEBUG) log("Notifying timer of changed pin value");
                timerCapture[pin].capture(pin, 0, state);
            }

        }
    }

    public void reset(int type) {
        int oldValue = out | (~dir) & 0xff;

        Arrays.fill(pinState, PinState.LOW);
        in = 0;
        dir = 0;
        ren = 0;
        ifg = 0;
        ie = 0;
        iv = 0;
        cpu.flagInterrupt(interrupt, this, (ifg & ie) > 0);

        PortListener listener = portListener;
        int newValue = out | (~dir) & 0xff;
        if (oldValue != newValue && listener != null) {
            listener.portWrite(this, newValue);
        }
    }

    public String info() {
        StringBuilder sb = new StringBuilder();
        sb.append(" $").append(Utils.hex(offset, 2)).append(':');
        for (int i = 0, n = portMap.length; i < n; i++) {
            PortReg reg = portMap[i];
            if (reg != null) {
                sb.append(' ').append(reg).append("($").append(Utils.hex(i, 2)).append("):$")
                .append(Utils.hex(0, 2));
            }
        }
        return sb.toString();
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Loggable.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 */
package se.sics.mspsim.core;

/**
 * @author joakime
 *
 */
public interface Loggable {

  public static int SEVERE = 0;
  public static int WARNING = 1;
  public static int INFO = 2;
  public static int DEBUG = 3;
  
  public int getLogLevel();
  public void setLogLevel(int level);
    
  public String getID();
  public String getName();
  public String info();

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/DMATrigger.java`:

```java
package se.sics.mspsim.core;

public interface DMATrigger {
    public void setDMA(DMA dma);
    public boolean getDMATriggerState(int index);
    public void clearDMATrigger(int index);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/PMMDummy.java`:

```java
/*
 * Copyright (c) 2012, Thingsquare.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

package se.sics.mspsim.core;

public class PMMDummy extends IOUnit {
    public static int SIZE = 0x10;

    public PMMDummy(MSP430Core cpu, int[] memory, int address) {
        super("PMMDummy", "PMMDummy", cpu, memory, address);
        reset(0);
    }

    public void reset(int type) {
    }

    public void write(int address, int value, boolean word, long cycles) {
        memory[address] = value;
    }

    public int read(int address, boolean word, long cycles) {
        return memory[address];
    }

    public void interruptServiced(int vector) {
        if (DEBUG) {
            log(this.getName() + ": Interrupt services vector: " + vector);
        }
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/core/Timer.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Timer
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.core;
import se.sics.mspsim.core.EmulationLogger.WarningType;
import se.sics.mspsim.util.Utils;

/**
 * Timer.java
 *
 * How should ports be connected to clock capture???
 * E.g. if port 1.2 give a signal then a capture is made on T_A[2]?!
 * (if it is configured to do that).
 * => some kind of listener on the ports ???
 *
 * ===> how do we capture the internal clocks
 * TACTL2 => ACLK if configured for that
 * - same as any port - some kind of listener that we add when
 *   the configuration is in that way.?!
 * All low-level clocks should probably be ticked by the "cpu"-loop in
 * some way, but configured by the BasicClockModule, otherwise it will
 * be too time consuming (probably).
 * CLCK Capture needs to be moved into the CPU since it is "time-critical"...
 * Other captures (ports, etc) could be handled separately (i think)
 *
 * Several capturers can be "looking" at the same signal
 * and capture at different edges - how implement that efficiently?
 *
 * ___---___---___
 *
 * ==> Reads might be another problem. If a loop is just checking the
 * counter it will be reading same value for a long time. Needs to "capture"
 * reads to Timers by some simple means...
 */
public class Timer extends IOUnit {

  public static final int TBIV = 0x011e;
  public static final int TAIV = 0x012e;

//  public static final int TACCR0_VECTOR = 6;
//  // Other is on 5
//  public static final int TACCR1_VECTOR = 5;
//
//  public static final int TBCCR0_VECTOR = 13;
//  // Other is on 12
//  public static final int TBCCR1_VECTOR = 12;

  public static final int TCTL = 0;
  public static final int TCCTL0 = 2;
  public static final int TCCTL1 = 4;
  public static final int TCCTL2 = 6;
  public static final int TCCTL3 = 8;
  public static final int TCCTL4 = 0xa;
  public static final int TCCTL5 = 0xc;
  public static final int TCCTL6 = 0xe;

  public static final int TR = 0x10;
  public static final int TCCR0 = 0x12;
  public static final int TCCR1 = 0x14;
  public static final int TCCR2 = 0x16;
  public static final int TCCR3 = 0x18;
  public static final int TCCR4 = 0x1a;
  public static final int TCCR5 = 0x1c;
  public static final int TCCR6 = 0x1e;

  public static final int STOP = 0;
  public static final int UP = 1;
  public static final int CONTIN = 2;
  public static final int UPDWN = 3;

  // Different capture modes...
  public static final int CAP_NONE = 0;
  public static final int CAP_UP = 1;
  public static final int CAP_DWN = 2;
  public static final int CAP_BOTH = 3;

  public static final int TCLR = 0x4;

  public static final int SRC_ACLK = 0;
  public static final int SRC_MCLK = 1;
  public static final int SRC_SMCLK = 2;
  public static final int SRC_PORT = 0x100;
  public static final int SRC_GND = 0x200;
  public static final int SRC_VCC = 0x201;
  public static final int SRC_CAOUT = 0x202; // Internal ??? What is this?

  public static final int CC_I = 0x08;
  public static final int CC_IFG = 0x01; // Bit 0
  public static final int CC_IE = 0x10;  // Bit 4
  public static final int CC_TRIGGER_INT = CC_IE | CC_IFG;

  public static final int CM_NONE = 0;
  public static final int CM_RISING = 1;
  public static final int CM_FALLING = 2;
  public static final int CM_BOTH = 3;

  
  // Number of cycles passed since current counter value was set
  // useful for setting expected compare and capture times to correct time.
  // valid for timer A
  private final int timerOverflow;
  private long nextTimerTrigger = 0;
  
  // this is used to create "tick" since last reset of the timer.
  // it will contain the full number of ticks since that reset and
  // is used to calculate the real counter value
  private long counterStart = 0;
  private long counterAcc;

  // Counter stores the current timer counter register (TR)
  private int counter = 0;
  private int counterPassed = 0;

  // Input map for timer A
  public static final int[] TIMER_Ax149 = new int[] {
    SRC_PORT + 0x10, SRC_ACLK, SRC_SMCLK, SRC_PORT + 0x21, // Timer
    SRC_PORT + 0x11, SRC_PORT + 0x22, SRC_GND, SRC_VCC,    // Cap 0
    SRC_PORT + 0x12, SRC_CAOUT, SRC_GND, SRC_VCC,          // Cap 1
    SRC_PORT + 0x13, SRC_ACLK, SRC_GND, SRC_VCC            // Cap 2
  };

  // Input map for timer B (configurable in later versions for other MSP430 versions)
  public static final int[] TIMER_Bx149 = new int[] {
    SRC_PORT + 0x47, SRC_ACLK, SRC_SMCLK, SRC_PORT + 0x47, // Timer
    SRC_PORT + 0x40, SRC_PORT + 0x40, SRC_GND, SRC_VCC,    // Cap 0
    SRC_PORT + 0x41, SRC_PORT + 0x41, SRC_GND, SRC_VCC,    // Cap 1
    SRC_PORT + 0x42, SRC_PORT + 0x42, SRC_GND, SRC_VCC,    // Cap 2
    SRC_PORT + 0x43, SRC_PORT + 0x43, SRC_GND, SRC_VCC,    // Cap 3
    SRC_PORT + 0x44, SRC_PORT + 0x44, SRC_GND, SRC_VCC,    // Cap 4
    SRC_PORT + 0x45, SRC_PORT + 0x45, SRC_GND, SRC_VCC,    // Cap 5
    SRC_PORT + 0x46, SRC_ACLK, SRC_GND, SRC_VCC            // Cap 6
  };

  public static final String[] capNames = new String[] {
    "NONE", "RISING", "FALLING", "BOTH"
  };

  public static final String[] modeNames = {
      "STOP", "UP", "CONT", "UPDWN"
  };

  
  private final int tiv;
  private int inputDivider = 1;

  // If clocked by anything other than the SubMainClock at full
  // speed this needs to be calculated for correct handling.
  // Should be something like inputDivider * SMCLK_SPEED / CLK_SRC_SPEED;
  private double cyclesMultiplicator = 1;

  private int clockSource;
  private int clockSpeed;
  private int mode;
  
  // The IO registers
  private int tctl;

  private boolean interruptEnable = false;
  private boolean interruptPending = false;

  private final int ccr1Vector;
  private final int ccr0Vector;

  // Support variables Max 7 compare regs for now (timer b)
  private final int noCompare;
  private final CCR ccr[];

  /* this is class represents a capture and compare register */
  private class CCR extends TimeEvent {
      int tcctl;
      int tccr;

      int expCompare;
      int expCapInterval;
      long expCaptureTime;

      int capMode;
      boolean captureOn = false;
      int inputSel;
      int inputSrc;
      long cyclesLeft = 0;
      boolean sync;
      int outMode;

      final int interruptVector;
      final int index;

      public CCR(long time, String name, int vector, int index) {
          super(time, name);
          interruptVector = vector;
          this.index = index;
      }
      
      String getName() {
          return "CCR " + index;
      }

      public void execute(long t) {
          if (mode == STOP) {
              //System.out.println("**** IGNORING EXECUTION OF CCR - timer stopped!!!");
              return;
          }
          long cycles = cpu.cycles;
          updateCounter(cycles);

          if (expCaptureTime != -1 && cycles >= expCaptureTime) {
              /* sometimes the event seems to be triggered too early... */
              if (counter < tccr) {
                  if (DEBUG) log("**** Counter too small: " + counter + " vs " + tccr);
                  int diff = tccr - counter;
                  expCaptureTime = cycles + (long) (diff * cyclesMultiplicator);
                  update();
                  return;
              }
              if (DEBUG) {
                  log((captureOn ? "CAPTURE: " : "COMPARE: ") + index +
                          " Cycles: " + cycles + " expCap: " + expCaptureTime +
                          " => ExpCR: " + Utils.hex16(expCompare) +
                          " TR: " + counter + " CCR" + index + ": " + tccr + " pass: " +
                          counterPassed);
              }
              // Set the interrupt flag...
              tcctl |= CC_IFG;

              if (captureOn) {
                  // Write the expected capture time to the register (counter could
                  // differ slightly)
                  tccr = expCompare;
                  // Update capture times... for next capture
                  expCompare = (expCompare + expCapInterval) & 0xffff;
                  expCaptureTime += expCapInterval * cyclesMultiplicator;
                  if (DEBUG) {
                      log("setting expCaptureTime to next capture: " + expCaptureTime);
                  }
              } else {
                  // Update expected compare time for this compare/cap register
                  // 0x10000 cycles... e.g. a full 16 bits wrap of the timer
                  expCaptureTime = expCaptureTime + (long) (0x10000 * cyclesMultiplicator);
                  if (DEBUG) {
                      log("setting expCaptureTime to full wrap: " + expCaptureTime);
                  }
              }
              /* schedule again! */
              update();
              triggerInterrupt(cycles);
          }
      }

      /* this method only takes care of the interrupt triggering! */
      public void triggerInterrupt(long cycles) {
          /* trigger if trigger should be... */
          if ((tcctl & CC_TRIGGER_INT) == CC_TRIGGER_INT) {
              if (index == 0) {
                  if (DEBUG) log("triggering interrupt");
                  cpu.flagInterrupt(interruptVector, Timer.this, true);
              } else if (lastTIV == 0) {
                  lastTIV = index * 2;
                  if (DEBUG) log("triggering interrupt TIV: " + lastTIV);
                  cpu.flagInterrupt(interruptVector, Timer.this, true);
              } else if (lastTIV > index * 2) {
                  /* interrupt already triggered, but set to this lower IRQ */
                  lastTIV = index * 2;
              }
          }
      }

      public void updateCaptures(long cycles) {
          int divisor = 1;
          int frqClk = 1;
          /* used to set next capture independent of counter when another clock is source
           * for the capture register!
           */
          boolean clkSource = false;

          if (clockSource == SRC_SMCLK) {
              frqClk = cpu.smclkFrq / inputDivider;
          } else if (clockSource == SRC_ACLK) {
              frqClk = cpu.aclkFrq / inputDivider;
          }

          // Handle the captures...
          if (captureOn) {
              if (inputSrc == SRC_ACLK) {
                  divisor = cpu.aclkFrq;
                  clkSource = true;
              }

              if (DEBUG) {
                  log("expCapInterval[" + index + "] frq = " +
                          frqClk + " div = " + divisor + " SMCLK_FRQ: " + cpu.smclkFrq);
              }

              // This is used to calculate expected time before next capture of
              // clock-edge to occur - including what value the compare reg. will get
              expCapInterval = frqClk / divisor;
              // This is not 100% correct - depending on clock mode I guess...
              if (clkSource) {
                  /* assume that this was capture recently */
                  //            System.out.println(">>> ACLK! fixing with expCompare!!!");
                  expCompare = (tccr + expCapInterval) & 0xffff;
              } else {
                  expCompare = (counter + expCapInterval) & 0xffff;
              }
              // This could be formulated in something other than cycles...
              // ...??? should be multiplied with clockspeed diff also?
              expCaptureTime = cycles + (long)(expCapInterval * cyclesMultiplicator);
              if (DEBUG) {
                  log("Expected compare " + index +
                          " => " + expCompare + "  Diff: " + expCapInterval);
                  log("Expected cap time: " + expCaptureTime + " cycMult: " + cyclesMultiplicator);
                  log("Capture: " + captureOn);
              }
              update();
          }
      }

      public void update() {
          /* schedule this capture register for update*/
          if (expCaptureTime != -1 && expCaptureTime != time) {
              if (DEBUG) log(cpu.cycles + ":" + ">> SCHEDULING " + getName() + " = " + tccr +
                      " TR: " + counter + " at: " + expCaptureTime);
              cpu.scheduleCycleEvent(this, expCaptureTime);
          }
      }
      
      public void timerStarted(long cycles) {
          if (cyclesLeft != 0) {
              expCaptureTime = cycles + cyclesLeft;
              update();
          }
      }
      
      public void timerStopped(long cycles) {
          if (expCaptureTime != -1) {
              cyclesLeft = cycles - expCaptureTime;
              if (cyclesLeft < 0) {
                  cyclesLeft = 0;
              }
          }
      }

      public String info() {
          return "CCR" + index + ":" +
          "  CM: " + capNames[capMode] +
          "  CCIS:" + inputSel + "  Source: " +
          getSourceName(inputSrc) +
          "  Capture: " + captureOn +
          " IFG: " + ((tcctl & CC_IFG) > 0) + " IE: " + ((tcctl & CC_IE) > 0);
      }

  }

  private TimeEvent counterTrigger = new TimeEvent(0, "Timer Counter Trigger") {
      public void execute(long t) {
          interruptPending = true;
          /* and can be something else if mode is another... */
          // This should be updated whenever clockspeed changes...
          nextTimerTrigger = (long) (nextTimerTrigger + 0x10000 * cyclesMultiplicator);
//          System.out.println("*** scheduling counter trigger..." + nextTimerTrigger + " now = " + t);
          cpu.scheduleCycleEvent(this, nextTimerTrigger);
          
          
          if (lastTIV == 0 && interruptEnable) {
              lastTIV = memory[tiv] = timerOverflow;
              cpu.flagInterrupt(ccr1Vector, Timer.this, true);
          } else {
//              System.out.println("*** Did not trigger interrupt: " + interruptEnable);
          }
      }
  };
  
  private int lastTIV;

  private final int[] srcMap;

  private long triggerTime;
  
  /**
   * Creates a new <code>Timer</code> instance.
   *
   */

  public Timer(MSP430Core cpu, int[] memory, MSP430Config.TimerConfig config) {
    super(config.name, config.name, cpu, memory, config.offset);
    this.srcMap = config.srcMap;
    // noCompare = (srcMap.length / 4) - 1;
    noCompare = config.ccrCount;
    if (srcMap == TIMER_Ax149) {
      timerOverflow = 0x0a;
    } else {
      timerOverflow = 0x0e;
    }
    tiv = config.timerIVAddr;
    ccr0Vector = config.ccr0Vector;
    ccr1Vector = config.ccrXVector;

    counterTrigger.name += ' ' + config.name;

    ccr = new CCR[noCompare];
    for (int i = 0; i < noCompare; i++) {
        ccr[i] = new CCR(0, "CCR" + i + " " + config.name, i == 0 ? ccr0Vector : ccr1Vector, i);
    }
    
    reset(0);
  }

  public void reset(int type) {

      /* reset the capture and compare registers */
      for (int i = 0, n = noCompare; i < n; i++) {
          CCR reg = ccr[i];
          reg.expCompare = -1;
          reg.expCaptureTime = -1;
          reg.expCapInterval = 0;
          reg.outMode = 0;
          reg.capMode = 0;
          reg.inputSel = 0;
          reg.inputSrc = 0;
          reg.captureOn = false;
          reg.tcctl = 0;
          reg.tccr = 0;
      }

      tctl = 0;
      lastTIV = 0;
      interruptEnable = false;
      interruptPending = false;
      counter = 0;
      counterPassed = 0;
      counterStart = 0;
      counterAcc = 0;
      clockSource = 0;
      cyclesMultiplicator = 1;
      mode = STOP;
      nextTimerTrigger = 0;
      inputDivider = 1;
  }

  // Should handle read of byte also (currently ignores that...)
  public int read(int address, boolean word, long cycles) {

//      if (DEBUG) log("read from: $" + Utils.hex(address, 4));

      if (address == tiv) {
      // should clear registers for cause of interrupt (highest value)?
      // but what if a higher value have been triggered since this was
      // triggered??? -> does that matter???
      // But this mess the TIV up too early......
      // Must DELAY the reset of interrupt flags until next read...?
      int val = lastTIV;
      resetTIV(cycles);
      return val;
    }
    int val = 0;
    int index = address - offset;
    switch(index) {
    case TR:
      val = updateCounter(cycles);
//      System.out.println(getName() + " TR read => " + val);
      break;
    case TCTL:
      val = tctl;
      if (interruptPending) {
        val |= 1;
      } else {
        val &= 0xfffe;
      }
      if (DEBUG) {
        log("Read: " +
            " CTL: inDiv:" + inputDivider +
            " src: " + getSourceName(clockSource) +
            " IEn:" + interruptEnable + " IFG: " +
            interruptPending + " mode: " + mode);
      }
      break;
    case TCCTL0:
    case TCCTL1:
    case TCCTL2:
    case TCCTL3:
    case TCCTL4:
    case TCCTL5:
    case TCCTL6:
      int i = (index - TCCTL0) / 2;
      updateTCCTL(i, cycles);
      val = ccr[i].tcctl;
      break;
    case TCCR0:
    case TCCR1:
    case TCCR2:
    case TCCR3:
    case TCCR4:
    case TCCR5:
    case TCCR6:
      i = (index - TCCR0) / 2;
      if (i >= noCompare) {
          throw new EmulationException(getName() + " Reading from CCR register that is not available " + i);
      }
      val = ccr[i].tccr;
      break;
    default:
      logw(WarningType.VOID_IO_READ, "Not supported read, returning zero!!! addr: " + index + " addr: $" + Utils.hex(address, 4));
    }
    
    if (DEBUG) {
      log("Read " + getName(address) + "($" + Utils.hex(address, 4) + ") => $" +
          Utils.hex16(val) + " (" + val + ")");
    }

    // It reads the interrupt flag for capture...
    return val & 0xffff;
  }

  /* here we need to update things such as CCI / Capture/Compare Input value
   * and other dynamic values
   */
  private void updateTCCTL(int cctl, long cycles) {
      if (cctl >= noCompare) {
          throw new EmulationException(getName() + " Trying to write to non-existent CCTL register: " + cctl);
      }
    // update the CCI depending on speed of clocks...
    boolean input = false;
    /* if ACLK we can calculate edge... */
    if (ccr[cctl].inputSrc == SRC_ACLK) {
      /* needs the TimerA clock speed here... */
      int aTicks = clockSpeed / cpu.aclkFrq;
      updateCounter(cycles);
      
      /* only calculate this if clock runs faster then ACLK - otherwise it
       * this will be dividing by zero... 
       */
      if (aTicks > 0 && counter % aTicks > aTicks / 2) {
        input = true;
      }
    }
    ccr[cctl].tcctl = (ccr[cctl].tcctl & ~CC_I) | (input ? CC_I : 0);    
  }

  private void resetTIV(long cycles) {
    if (lastTIV == timerOverflow) {
      interruptPending = false;
      if (DEBUG) {
        log("Clearing TIV - overflow ");
      }
    } else if (lastTIV / 2 < noCompare) {
      if (DEBUG) {
	log(cpu.cycles + ": Clearing IFG for CCR" + (lastTIV/2));
      }
      // Clear interrupt flags!
      ccr[lastTIV / 2].tcctl &= ~CC_IFG;
    }

    /* flag this interrupt off */
    cpu.flagInterrupt(ccr1Vector, this, false);
    lastTIV = 0;

    /* reevaluate interrupts for the ccr1 vector - possibly flag on again... */
    for (int i = 1; i < noCompare; i++) {
        ccr[i].triggerInterrupt(cycles);
    }
    /* if the timer overflow interrupt is triggering - lowest priority => signal! */
    if (lastTIV == 0 && interruptEnable & interruptPending) {
        lastTIV = timerOverflow;
        cpu.flagInterrupt(ccr1Vector, this, true);
    }
  }

  public void write(int address, int data, boolean word, long cycles) {
    // This does not handle word/byte difference yet... assumes it gets
    // all 16 bits when called!!!

    if (address == tiv) {
      // should clear registers for cause of interrupt (highest value)?
      // but what if a higher value have been triggered since this was
      // triggered??? -> does that matter???
      // But this mess the TIV up too early......
      // Must DELAY the reset of interrupt flags until next read...?
      resetTIV(cycles);
    }

    int iAddress = address - offset;

    if (DEBUG) log("write to: $" + Utils.hex(address, 4) +
            " => " + iAddress + " = " + data);


    switch (iAddress) {
    case TR:
      setCounter(data, cycles);
      break;
    case TCTL:
      if (DEBUG) {
        log("wrote to TCTL: " + Utils.hex16(data));
      }
      inputDivider = 1 << ((data >> 6) & 3);
      clockSource = srcMap[(data >> 8) & 3];

      updateCyclesMultiplicator();

      if ((data & TCLR) != 0) {
	counter = 0;
	resetCounter(cycles);
	
	for (int i = 0; i < noCompare; i++) {
            ccr[i].updateCaptures(cycles);
        }
      }

      int newMode = (data >> 4) & 3;
      if (mode == STOP && newMode != STOP) {
        // Set the initial counter to the value that counter should have after
        // recalculation
        resetCounter(cycles);
        
        // Wait until full wrap before setting the IRQ flag!
        nextTimerTrigger = (long) (cycles + cyclesMultiplicator * ((0xffff - counter) & 0xffff));
        if (DEBUG) {
          log("Starting timer!");
        }

        for (int i = 0; i < noCompare; i++) {
            ccr[i].timerStarted(cycles);
        }
        
        if (DEBUG) log(cpu.cycles + ": Timer started: " + counter + "  CCR1:" + ccr[1].expCaptureTime);
        
      }
      if (mode != STOP && newMode == STOP) {
          /* call update counter to remember how many cycles that passed before this stop... */
          updateCounter(cycles);
          for (int i = 0; i < noCompare; i++) {
              ccr[i].timerStopped(cycles);
          }
          if (DEBUG) log(cpu.cycles + ": Timer stopped: " + counter + "  CCR1:" + ccr[1].expCaptureTime);
      }
      
      mode = newMode;
      
      interruptEnable = (data & 0x02) > 0;

      if (DEBUG) {
	log("Write:  CTL: inDiv:" + inputDivider +
	        " src: " + getSourceName(clockSource) +
	        " IEn:" + interruptEnable + " IFG: " +
	        interruptPending + " mode: " + mode +
	        ((data & TCLR) != 0 ? " CLR" : ""));
      }

      // Write to the tctl.
      tctl = data;
      // Clear clear bit
      tctl &= ~0x04;

      // Clear interrupt pending if so requested...
      if ((data & 0x01) == 0) {
        interruptPending = false;
      }

      //    updateCaptures(-1, cycles);
      for (int i = 0; i < noCompare; i++) {
          ccr[i].updateCaptures(cycles);
      }
      
      break;
    case TCCTL0:
    case TCCTL1:
    case TCCTL2:
    case TCCTL3:
    case TCCTL4:
    case TCCTL5:
    case TCCTL6:
      // Control register...
      int index = (iAddress - TCCTL0) / 2;
      CCR reg = ccr[index];
      reg.tcctl = data;
      reg.outMode = (data >> 5)& 7;
      boolean oldCapture = reg.captureOn;
      reg.captureOn = (data & 0x100) > 0;
      reg.sync = (data & 0x800) > 0;
      reg.inputSel = (data >> 12) & 3;
      int src = reg.inputSrc = srcMap[4 + index * 4 + reg.inputSel];
      reg.capMode = (data >> 14) & 3;

      /* capture a port state? */
      if (!oldCapture && reg.captureOn && (src & SRC_PORT) != 0) {
        int port = (src & 0xff) >> 4;
        int pin = src & 0x0f;
        IOPort ioPort = cpu.getIOUnit(IOPort.class, "P" + port);
        if (DEBUG) log("Assigning Port: " + port + " pin: " + pin +
            " for capture");
        ioPort.setTimerCapture(this, pin);
      }
      
      updateCounter(cycles);
      
      if (DEBUG) {
	log(getName() + "Write: CCTL" + index + ": => " + Utils.hex16(data) +
	        " CM: " + capNames[reg.capMode] +
	        " CCIS:" + reg.inputSel + " name: " +
	        getSourceName(reg.inputSrc) +
	        " Capture: " + reg.captureOn +
	        " IE: " + ((data & CC_IE) != 0));
      }

      reg.updateCaptures(cycles);
//      updateCaptures(index, cycles);
      break;
      // Write to compare register!
    case TCCR0:
    case TCCR1:
    case TCCR2:
    case TCCR3:
    case TCCR4:
    case TCCR5:
    case TCCR6:
      // update of compare register
      index = (iAddress - TCCR0) / 2;
      updateCounter(cycles);
      if (index == 0) {
        // Reset the counter to bring it down to a smaller value...
        // Check if up or updwn and reset if counter too high...
        if (counter > data && (mode == UPDWN || mode == UP)) {
          counter = 0;
          resetCounter(cycles);
        }
      }
      if (ccr[index] == null)
          logw(WarningType.VOID_IO_WRITE, "Timer write to " + Utils.hex16(address));
      ccr[index].tccr = data;

      int diff = data - counter;
      if (diff <= 0) {
        // Ok we need to wrap!
        diff += 0x10000;
      }
      if (DEBUG) {
	log("Write: Setting compare " + index + " to " +
	        Utils.hex16(data) + " TR: " +
	        Utils.hex16(counter) + " diff: " + Utils.hex16(diff));
      }
      // Use the counterPassed information to compensate the expected capture/compare time!!!
      ccr[index].expCaptureTime = cycles + (long)(cyclesMultiplicator * diff + 1) - counterPassed;
      if (DEBUG && counterPassed > 0) {
        log("Comp: " + counterPassed + " cycl: " + cycles + " TR: " +
            counter + " CCR" + index + " = " + data + " diff = " + diff + " cycMul: " + cyclesMultiplicator + " expCyc: " +
            ccr[index].expCaptureTime);
      }
      counterPassed = 0;
      if (DEBUG) {
	log("Cycles: " + cycles + " expCap[" + index + "]: " + ccr[index].expCaptureTime
	        + " ctr:" + counter + " data: " + data + " ~" +
	        (100 * (cyclesMultiplicator * diff * 1L) / 2500000) / 100.0 + " sec" +
	        "at cycles: " + ccr[index].expCaptureTime);
      }
      ccr[index].update();
      //calculateNextEventTime(cycles);
    }
  }
  void updateCyclesMultiplicator() {
    cyclesMultiplicator = inputDivider;
    if (clockSource == SRC_ACLK) {
      cyclesMultiplicator = (cyclesMultiplicator * cpu.smclkFrq) /
      cpu.aclkFrq;
      if (DEBUG) {
        log("setting multiplicator to: " + cyclesMultiplicator);
      }
    }
    clockSpeed = (int) (cpu.smclkFrq / cyclesMultiplicator);
  }
  
  void resetCounter(long cycles) {
      double divider = 1.0;
      if (clockSource == SRC_ACLK) {
          // Should later be divided with DCO clock?
          divider = 1.0 * cpu.smclkFrq / cpu.aclkFrq;
      }
      divider = divider * inputDivider;
        
      // These calculations assume that we have a big counter that counts from
      // last reset and upwards (without any roundoff errors).
      // tick - represent the counted value since last "reset" of some kind
      // counterAcc - represent the value of the counter at the last reset.
      long cycctr = cycles - counterStart;
      double tick = cycctr / divider;
      counterPassed = (int) (divider * (tick - (long) (tick)));
      
    counterStart = cycles - counterPassed;
    // set counterACC to the last returned value (which is the same
    // as bigCounter except that it is "moduloed" to a smaller value
    counterAcc = counter;
    updateCyclesMultiplicator();
    if (DEBUG) { 
      log("Counter reset at " + cycles +  " cycMul: " + cyclesMultiplicator);
    }

    cpu.scheduleCycleEvent(counterTrigger, cycles + (long)((0x10000 - counter) * cyclesMultiplicator));
//    System.out.println("(re)Scheduling counter trigger..." + counterTrigger.time + " now = " + cycles + " ctr: " + counter);

  }
  
  private void setCounter(int newCtr, long cycles) {
    counter = newCtr;
    resetCounter(cycles);
  }

  private int updateCounter(long cycles) {
    if (mode == STOP) return counter;
    
    // Needs to be non-integer since smclk Frq can be lower
    // than aclk
    /* this should be cached and changed whenever clockSource change!!! */
    double divider = 1;
    if (clockSource == SRC_ACLK) {
      // Should later be divided with DCO clock?
      divider = 1.0 * cpu.smclkFrq / cpu.aclkFrq;
    }
    divider = divider * inputDivider;
    
    // These calculations assume that we have a big counter that counts from
    // last reset and upwards (without any roundoff errors).
    // tick - represent the counted value since last "reset" of some kind
    // counterAcc - represent the value of the counter at the last reset.
    long cycctr = cycles - counterStart;
    double tick = cycctr / divider;
    counterPassed = (int) (divider * (tick - (long) (tick)));
    long bigCounter = (long) (tick + counterAcc);
    
    switch (mode) {
    case CONTIN:
      counter = (int) (bigCounter & 0xffff);
      break;
    case UP:
      if (ccr[0].tccr == 0) {
	counter = 0;
      } else {
	counter = (int) (bigCounter % ccr[0].tccr);
      }
      break;
    case UPDWN:
      if (ccr[0].tccr == 0) {
	counter = 0;
      } else {
	counter = (int) (bigCounter % (ccr[0].tccr * 2));
	if (counter > ccr[0].tccr) {
	  // Should back down to start again!
	  counter = 2 * ccr[0].tccr - counter;
	}
      }
    }
//    System.out.println("CounterStart: " + counterStart + " C:" + cycles + " bigCounter: " + bigCounter +
//        " counter" + counter);

    if (DEBUG) {
      log("Updating counter cycctr: " + cycctr +
          " divider: " + divider + " mode:" + mode + " => " + counter);
    }
   return counter;
  }

  public String getSourceName(int source) {
    switch (source) {
    case SRC_ACLK:
      return "ACLK";
    case SRC_VCC:
      return "VCC";
    case SRC_GND:
      return "GND";
    case SRC_SMCLK:
      return "SMCLK";
    default:
      if ((source & SRC_PORT) == SRC_PORT) {
	return "Port " + ((source & 0xf0) >> 4) + "." +
	  (source & 0xf);
      }
    }
    return "";
  }

  /**
   * capture - perform a capture if the timer CCRx is configured for captures
   * Note: capture may only be called when value has changed
   * @param ccrIndex - the capture register
   * @param source - the capture source (0/1)
   */
  public void capture(int ccrIndex, int source, IOPort.PinState value) {
      CCR reg = ccr[ccrIndex];
      if (ccrIndex < noCompare && reg.captureOn && reg.inputSel == source) {
          /* This is obviously a capture! */
          boolean rise = (reg.capMode & CM_RISING) != 0;
          boolean fall = (reg.capMode & CM_FALLING) != 0;
          if ((value == IOPort.PinState.HI && rise) ||
                  (value == IOPort.PinState.LOW && fall)) {
              //      System.out.println("*** Capture on CCR_" + ccrIndex + " " + " value: " +
              //            value);
              // update counter values and compare register
              updateCounter(cpu.cycles);
              reg.tccr = counter;
              
              // Set the interrupt flag...
              reg.tcctl |= CC_IFG;
              reg.triggerInterrupt(cpu.cycles);
              /* triggerInterrupts(cpu.cycles); */
          }
    }
  }
  
  // The interrupt has been serviced...
  // Some flags should be cleared (the highest priority flags)?
  public void interruptServiced(int vector) {
    if (vector == ccr0Vector) {
      // Reset the interrupt trigger in "core".
      cpu.flagInterrupt(ccr0Vector, this, false);
      // Remove the flag also - but only for the dedicated vector (CCR0)
      ccr[0].tcctl &= ~CC_IFG;
    }
    if (MSP430Core.debugInterrupts) {
      System.out.println(getName() + " >>>> interrupt Serviced " + lastTIV + 
          " at cycles: " + cpu.cycles + " servicing delay: " + (cpu.cycles - triggerTime));
    }
    /* old method is replaced */
    /* triggerInterrupts(cpu.cycles); */
  }

  public int getModeMax() {
    return 0;
  }

  private String getName(int address) {
    int reg = address - offset;
    if (reg == 0) return "TCTL";
    if (reg < 0x10) return "TCTL" + (reg - 2) / 2;
    if (reg == 0x10) return "TR";
    if (reg < 0x20) return "TCCR" + (reg - 0x12) / 2;
    return " UNDEF(" + Utils.hex(address, 4) + ")";
  }

  @Override
  public String info() {
      StringBuilder sb = new StringBuilder();
      sb.append("  Source: " + getSourceName(clockSource) + "  Speed: " + clockSpeed
              + " Hz  inDiv: " + inputDivider + "  Multiplier: " + cyclesMultiplicator + '\n'
              + "  Mode: " + modeNames[mode] + "  IEn: " + interruptEnable
              + "  IFG: " + interruptPending + "  TR: " + updateCounter(cpu.cycles) + '\n');
      for (CCR reg : ccr) {
          sb.append("  ").append(reg.info()).append('\n');
      }
      return sb.toString();
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/emulink/EmuLink.java`:

```java
/*
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * EmuLink
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 11 oct 2012
 */

package se.sics.mspsim.emulink;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Hashtable;

import se.sics.json.JSONArray;
import se.sics.json.JSONObject;
import se.sics.json.ParseException;
import se.sics.mspsim.Main;
import se.sics.mspsim.core.MSP430Constants;
import se.sics.mspsim.platform.GenericNode;
import se.sics.mspsim.util.Utils;

public class EmuLink {

    private Socket socket;
    private BufferedReader in;
    private PrintWriter out;
    private boolean isConnected = false;
    private long globalEtime = 0L;
    private long globalLastTime = 0L;

    private final Hashtable<String, GenericNode> nodes = new Hashtable<String, GenericNode>();

    public boolean isConnected() {
        return !isConnected;
    }

    String[] getNodes(JSONObject json) {
        JSONArray nodes;
        String node;
        String[] nString = null;
        if ((nodes = json.getJSONArray("node")) != null) {
            nString = new String[nodes.size()];
            for(int i = 0, n = nodes.size(); i < n; i++) {
                node = nodes.getAsString(i);
                nString[i] = node;
            }
        } else if ((node = json.getAsString("node")) != null) {
            nString = new String[1];
            nString[0] = node;
        }
        return nString;
    }
    
    private boolean createNode(String type, String id) {
        String nt = Main.getNodeTypeByPlatform(type);
        System.out.println("EmuLink: Creating node '" + id + "' of type '" + type + "' => " + nt);
        GenericNode node = Main.createNode(nt);
        if (node == null) {
            System.err.println("EmuLink: failed to create node '" + id + "' of type '" + type + "'");
            return false;
        }
        nodes.put(id, node);
        return true;
    }
    
    private boolean createNodes(JSONObject json) {
        String type = json.getAsString("type");
        System.out.println("Should create: " + type);

        String[] nodes = getNodes(json);
        if (nodes != null) {
            for (int i = 0; i < nodes.length; i++) {
                createNode(type, nodes[i]);
            }
        }
        return true;
    }

    protected void processInput(Reader input) throws IOException, ParseException {
        StringBuilder sb = new StringBuilder();
        int brackets = 0;
        boolean stuffed = false;
        boolean quoted = false;
        while (isConnected()) {
            int c = input.read();
            if (c < 0) {
                disconnect();
                break;
            }
            sb.append((char)c);
            if (stuffed) {
                stuffed = false;
            } else if (c == '\\') {
                stuffed = true;
            } else if (quoted) {
                if (c == '"') {
                    quoted = false;
                }
            } else if (c == '"') {
                quoted = true;
            } else if (c == '{') {
                brackets++;
            } else if (c == '}') {
                brackets--;
                if (brackets == 0) {
                    JSONObject json = JSONObject.parseJSONObject(sb.toString());
                    sb.setLength(0);
                    if (!handleMessage(json)) {
                        // This connection should no longer be kept alive
                        break;
                    }
                }
            }
        }
    };

    protected boolean handleMessage(JSONObject json) {
        System.out.println("EmuLink: RECV " + json.toJSONString());
        String event = json.getAsString("event");
        if ("emulation_control".equals(event)) {
            String command = json.getAsString("data");
            if ("start".equals(command)) {
                String[] nodes = getNodes(json);
                long etime = json.getAsLong("etime", 0);

                if (etime == 0) {
                    if (nodes == null) {
                        for (GenericNode node : this.nodes.values()) {
                            node.start();
                        }
                    } else {
                        for(String id : nodes) {
                            GenericNode node = this.nodes.get(id);
                            if (node != null) {
                                node.start();
                            } else {
                                System.err.println("EmuLink: could not find node '" + id + "'");
                            }
                        }
                    }
                } else {
                    // Execute for specified time
                    globalEtime += etime;
                    if (nodes == null) {
                        for (GenericNode node : this.nodes.values()) {
                            long t0 = System.nanoTime(), t1;
                            node.getCPU().stepMicros(globalLastTime, etime);
                            t1 = System.nanoTime();
                            System.out.println("EmuLink: node " + node.getID()
                                    + " is now at $" + Utils.hex(node.getCPU().getRegister(MSP430Constants.PC), 4)
                                    + " " + (long)(node.getCPU().getTimeMillis() + 0.5) + "/" + (globalEtime / 1000)
                                    + " (elapsed " + (t1 - t0) + " ns)");
                        }

                    } else {
                        for(String id : nodes) {
                            GenericNode node = this.nodes.get(id);
                            if (node != null) {
                                long t0 = System.nanoTime(), t1;
                                node.getCPU().stepMicros(globalLastTime, etime);
                                t1 = System.nanoTime();
                                System.out.println("EmuLink: node " + node.getID()
                                        + " is now at $" + Utils.hex(node.getCPU().getRegister(MSP430Constants.PC), 4)
                                        + " " + (long)(node.getCPU().getTimeMillis() + 0.5) + "/" + (globalEtime / 1000)
                                        + " (elapsed " + (t1 - t0) + " ns)");
                            } else {
                                System.err.println("EmuLink: could not find node '" + id + "'");
                            }
                        }
                    }
                    globalLastTime = etime;
                }
            } else if ("stop".equals(command)) {
                String[] nodes = getNodes(json);
                if (nodes == null) {
                    for (GenericNode node : this.nodes.values()) {
                        node.stop();
                    }
                } else {
                    for(String id : nodes) {
                        GenericNode node = this.nodes.get(id);
                        if (node != null) {
                            node.stop();
                        } else {
                            System.err.println("EmuLink: could not find node '" + id + "'");
                        }
                    }
                }
            } else if ("close".equals(command)) {
                sendToSimulator("{\"response\":\"emulation_control\",\"data\":1}");

                // Time to close the connection
                return false;
            }
            sendToSimulator("{\"response\":\"emulation_control\",\"data\":1}");

        } else if ("create".equals(event)) {
            createNodes(json);
            sendToSimulator("{\"response\":\"create\",\"data\":1}");
        } else if ("write".equals(event)) {
            String[] nodes = getNodes(json);
            String file = json.getAsString("file");
            if (nodes == null) {
                System.err.println("EmuLink: no node specified for write");
            } else if (file == null) {
                System.err.println("EmuLink: no file specified for write");
            } else if (!new File(file).isFile()) {
                System.err.println("EmuLink: could not find file '" + file + "' for write");
            } else {
                for(String id : nodes) {
                    GenericNode node = this.nodes.get(id);
                    if (node == null) {
                        System.err.println("EmuLink: could not find node '" + id + "'");
                        continue;
                    }
                    try {
                        node.loadFirmware(file);
                        node.getCPU().reset();
                    } catch (IOException e) {
                        System.err.println("EmuLink: failed to load firmware '" + file + "'");
                        e.printStackTrace();
                    }
                }
            }
            sendToSimulator("{\"response\":\"write\",\"data\":1}");
        } else if ("remove".equals(event)) {
            // TODO remove nodes
        } else if ("serial".equals(event)) {
            int data = json.getAsInt("data", -1);
            JSONArray nodes;
            String node;
            if (data < 0) {
                // No data - ignore serial event
            } else if ((nodes = json.getJSONArray("node")) != null) {
                for(int i = 0, n = nodes.size(); i < n; i++) {
                    node = nodes.getAsString(i);
                    if (node != null) {
                        sendSerialToNode(node, data);
                    }
                }
            } else if ((node = json.getAsString("node")) != null) {
                sendSerialToNode(node, data);
            } else {
                // No target node specified
            }
        } else {
            System.err.println("EmuLink: ignoring unhandled event '" + event + "'");
        }
        return true;
    }

    protected void sendToSimulator(String message) {
        if (out != null) {
            out.write(message);
            out.flush();
        }
    }

    protected void sendSerialToNode(String node, int data) {
    }

    protected void disconnect() {
        boolean isDisconnecting = isConnected;
        isConnected = false;
        try {
            if (isDisconnecting) {
                System.err.println("EmuLink: disconnecting...");
            }
            if (out != null) {
                out.close();
                out = null;
            }
            if (in != null) {
                in.close();
                in = null;
            }
            if (socket != null) {
                socket.close();
                socket = null;
            }
            if (isDisconnecting) {
                System.err.println("EmuLink: disconnected");
            }
        } catch (IOException e) {
            System.err.println("EmuLink: failed to close emulation link connection");
            e.printStackTrace();
        }
    }

    public void run() {
        try (ServerSocket serverSocket = new ServerSocket(8000)) {

            while(true) {

                System.out.println("EmuLink: Waiting for connection...");
                try {
                    socket = serverSocket.accept();
                } catch (IOException e) {
                    System.out.println("Accept failed: 8000");
                    System.exit(-1);
                }
                System.out.println("EmuLink: Connection accepted...");

                try {
                    out = new PrintWriter(socket.getOutputStream(), true);
                    in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    processInput(in);
                } catch (Exception e) {
                    System.err.println("EmuLink: emulator link connection failed");
                    e.printStackTrace();
                } finally {
                    disconnect();
                }
            }
        } catch (IOException e) {
            System.out.println("Could not listen on port: 8000");
            System.exit(-1);
        }
    }

    public static void main(String[] args) {
        EmuLink el = new EmuLink();
        el.run();
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/config/MSP430f1611Config.java`:

```java
/**
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson
 */

package se.sics.mspsim.config;

import java.util.ArrayList;

import se.sics.mspsim.core.ADC12;
import se.sics.mspsim.core.DMA;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.InterruptMultiplexer;
import se.sics.mspsim.core.MSP430Config;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.Multiplier;
import se.sics.mspsim.core.Timer;
import se.sics.mspsim.core.USART;

public class MSP430f1611Config extends MSP430Config {

    
    public MSP430f1611Config() {
        maxInterruptVector = 15;

        /* configuration for the timers */
        TimerConfig timerA = new TimerConfig(6, 5, 3, 0x160, Timer.TIMER_Ax149, "TimerA", Timer.TAIV);
        TimerConfig timerB = new TimerConfig(13, 12, 7, 0x180, Timer.TIMER_Bx149, "TimerB", Timer.TBIV);
 
        timerConfig = new TimerConfig[] {timerA, timerB};
        
        /* configure memory */
        infoMemConfig(0x1000, 128 * 2);
        mainFlashConfig(0x4000, 48 * 1024);
        ramConfig(0x1100, 10 * 1024);
        ramMirrorConfig(0x200, 2 * 1024, 0x1100);
    }
    

    public int setup(MSP430Core cpu, ArrayList<IOUnit> ioUnits) {
        USART usart0 = new USART(cpu, 0, cpu.memory, 0x70);
        USART usart1 = new USART(cpu, 1, cpu.memory, 0x78);
        cpu.setIORange(0x70, 8, usart0);
        cpu.setIORange(0x78, 8, usart1);

        Multiplier mp = new Multiplier(cpu, cpu.memory, 0);
        cpu.setIORange(0x130, 0x0f, mp);

        // Usarts
        ioUnits.add(usart0);
        ioUnits.add(usart1);

        DMA dma = new DMA("dma", cpu, cpu.memory, 0);
        cpu.setIORange(0x1e0, 24, dma);

        /* DMA Ctl */
        cpu.setIORange(0x122, 1, dma);
        cpu.setIORange(0x124, 1, dma);

        /* configure the DMA */
        dma.setDMATrigger(DMA.URXIFG0, usart0, 0);
        dma.setDMATrigger(DMA.UTXIFG0, usart0, 1);
        dma.setDMATrigger(DMA.URXIFG1, usart1, 0);
        dma.setDMATrigger(DMA.UTXIFG1, usart1, 1);
        dma.setInterruptMultiplexer(new InterruptMultiplexer(cpu, 0));

        ioUnits.add(dma);
        
        // Add port 1,2 with interrupt capability!
        // IOPorts will add themselves to the CPU
        ioUnits.add(new IOPort(cpu, 1, 4, cpu.memory, 0x20));
        ioUnits.add(new IOPort(cpu, 2, 1, cpu.memory, 0x28));

        // Add port 3,4 & 5,6
        for (int i = 0, n = 2; i < n; i++) {
            ioUnits.add(new IOPort(cpu, (3 + i), 0, cpu.memory, 0x18 + i * 4));
            ioUnits.add(new IOPort(cpu, (5 + i), 0, cpu.memory, 0x30 + i * 4));
        }

        ADC12 adc12 = new ADC12(cpu);
        ioUnits.add(adc12);
        cpu.setIORange(0x080, 16, adc12);
        cpu.setIORange(0x140, 16, adc12);
        cpu.setIORange(0x150, 16, adc12);
        cpu.setIORange(0x1a0, 10, adc12);

        return 3 + 6;
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/config/MSP430f5437Config.java`:

```java
/**
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson
 */

package se.sics.mspsim.config;

import java.util.ArrayList;
import se.sics.mspsim.core.ClockSystem;
import se.sics.mspsim.core.GenericUSCI;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.MSP430Config;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.Multiplier32;
import se.sics.mspsim.core.PMM;
import se.sics.mspsim.core.SysReg;
import se.sics.mspsim.core.Timer;
import se.sics.mspsim.core.UnifiedClockSystem;
import se.sics.mspsim.util.Utils;

public class MSP430f5437Config extends MSP430Config {

    // NOTE: this MCU also needs to configure 
    // - positions of all timers (A0, A1, B)
    // - memory configuration
    // - 
    private static final String portConfig[] = {
            "P1=200,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A,IV_L 0E,IV_H 0F,IES 18,IE 1A,IFG 1C",
            "P2=200,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B,IV_L 1E,IV_H 1F,IES 19,IE 1B,IFG 1D",
            "P3=220,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P4=220,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            "P5=240,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P6=240,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            "P7=260,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P8=260,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            "P9=280,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P:=280,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            };
    
    
    
    public MSP430f5437Config() {
        /* 64 vectors for the MSP430f54xx series */
        maxInterruptVector = 63;
        MSP430XArch = true;
        flashControllerOffset = 0x140;
        sfrOffset = 0x100;
        
        /* configuration for the timers - need to set-up new source maps!!! */
        TimerConfig timerA0 = new TimerConfig(54, 53, 5, 0x340, Timer.TIMER_Bx149, "TimerA0", 0x340 + 0x2e);
        TimerConfig timerA1 = new TimerConfig(49, 48, 3, 0x380, Timer.TIMER_Ax149, "TimerA1", 0x380 + 0x2e);
        TimerConfig timerB0 = new TimerConfig(60, 59, 7, 0x3C0, Timer.TIMER_Bx149, "TimerB0",  0x3C0 + 0x2e);
        timerConfig = new TimerConfig[] {timerA0, timerA1, timerB0};
        
        uartConfig = new UARTConfig[] {
                new UARTConfig("USCI A0", 57, 0x5c0),
                new UARTConfig("USCI B0", 56, 0x5e0),
                new UARTConfig("USCI A1", 46, 0x600),
                new UARTConfig("USCI B1", 45, 0x620),
                new UARTConfig("USCI A2", 52, 0x640),
                new UARTConfig("USCI B2", 51, 0x660),
                new UARTConfig("USCI A3", 44, 0x680),
                new UARTConfig("USCI B3", 43, 0x6a0)
        };

        /* configure memory */
        infoMemConfig(0x1800, 128 * 4);
        mainFlashConfig(0x5c00, 256 * 1024);
        ramConfig(0x1c00, 16 * 1024);
        ioMemSize(0x800); /* 2 KB of IO Memory */
        
        watchdogOffset = 0x15c;
        // bsl, IO, etc at a later stage...
    }

    public int setup(MSP430Core cpu, ArrayList<IOUnit> ioUnits) {
    
        Multiplier32 mp = new Multiplier32(cpu, cpu.memory, 0x4c0);
        cpu.setIORange(0x4c0, 0x2e, mp);

        /* this code should be slightly more generic... and be somewhere else... */
        for (int i = 0, n = uartConfig.length; i < n; i++) {
            GenericUSCI usci = new GenericUSCI(cpu, i, cpu.memory, this);
            /* setup 0 - 1f as IO addresses */
            cpu.setIORange(uartConfig[i].offset, 0x20, usci);
//            System.out.println("Adding IOUnit USCI: " + usci.getName());
            ioUnits.add(usci);
        }
        IOPort last = null;
        ioUnits.add(last = IOPort.parseIOPort(cpu, 47, portConfig[0], last));
        ioUnits.add(last = IOPort.parseIOPort(cpu, 42, portConfig[1], last));
        
        for (int i = 2; i < portConfig.length; i++) {
            ioUnits.add(last = IOPort.parseIOPort(cpu, 0, portConfig[i], last));
        }

		/* XXX: Stub IO units: Sysreg and PMM */
		SysReg sysreg = new SysReg(cpu, cpu.memory);
		cpu.setIORange(SysReg.ADDRESS, SysReg.SIZE, sysreg);
		ioUnits.add(sysreg);

		PMM pmm = new PMM(cpu, cpu.memory, 0x120);
		cpu.setIORange(0x120, PMM.SIZE, pmm);
		ioUnits.add(pmm);

        return portConfig.length + uartConfig.length;
    }

    @Override
    public String getAddressAsString(int addr) {
        return Utils.hex20(addr);
    }

    @Override
    public ClockSystem createClockSystem(MSP430Core cpu, int[] memory, Timer[] timers) {
        return new UnifiedClockSystem(cpu, memory, 0, timers);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/config/MSP430f2617Config.java`:

```java
/**
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson
 */

package se.sics.mspsim.config;

import java.util.ArrayList;

import se.sics.mspsim.core.ADC12;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.MSP430Config;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.Multiplier;
import se.sics.mspsim.core.Timer;
import se.sics.mspsim.core.USCI;
import se.sics.mspsim.util.Utils;

public class MSP430f2617Config extends MSP430Config {

    private static final String portConfig[] = {
        "P1=0,IN 20,OUT 21,DIR 22,IFG 23,IES 24,IE 25,SEL 26,SEL2 41,REN 27",
        "P2=0,IN 28,OUT 29,DIR 2A,IFG 2B,IES 2C,IE 2D,SEL 2E,SEL2 42,REN 2F",
        "P3=0,IN 18,OUT 19,DIR 1A,SEL 1B,SEL2 43,REN 10",
        "P4=0,IN 1C,OUT 1D,DIR 1E,SEL 1F,SEL2 44,REN 11",
        "P5=0,IN 30,OUT 31,DIR 32,SEL 33,SEL2 45,REN 12",
        "P6=0,IN 34,OUT 35,DIR 36,SEL 37,SEL2 46,REN 13",
        "P7=0,IN 38,OUT 3A,DIR 3C,SEL 3E,SEL2 47,REN 14",
        "P8=0,IN 39,OUT 3B,DIR 3D,SEL 3F,SEL2 48,REN 15"
    };

    public MSP430f2617Config() {
        /* 32 vectors for the MSP430X series */
        maxInterruptVector = 31;
        MSP430XArch = true;
        
        /* configuration for the timers */
        TimerConfig timerA = new TimerConfig(25, 24, 3, 0x160, Timer.TIMER_Ax149, "TimerA", Timer.TAIV);
        TimerConfig timerB = new TimerConfig(29, 28, 7, 0x180, Timer.TIMER_Bx149, "TimerB", Timer.TBIV);
        timerConfig = new TimerConfig[] {timerA, timerB};

        /* TX Vec, RX Vec, TX Bit, RX Bit, SFR-reg, Offset, Name, A?*/
        UARTConfig uA0 = new UARTConfig(22, 23, 1, 0, 1, 0x60, "USCI A0", true);
        UARTConfig uB0 = new UARTConfig(22, 23, 3, 2, 1, 0x68, "USCI B0", false);
        UARTConfig uA1 = new UARTConfig(16, 17, 1, 0, 6, 0xD0, "USCI A1", true);
        UARTConfig uB1 = new UARTConfig(16, 17, 3, 2, 6, 0xD8, "USCI B1", false);
        uartConfig = new UARTConfig[] {uA0, uB0, uA1, uB1};

        /* configure memory */
        infoMemConfig(0x1000, 128 * 2);
        mainFlashConfig(0x3100, 92 * 1024);
        ramConfig(0x1100, 8 * 1024);
        ramMirrorConfig(0x200, 2 * 1024, 0x1100);
    }

    public int setup(MSP430Core cpu, ArrayList<IOUnit> ioUnits) {

        Multiplier mp = new Multiplier(cpu, cpu.memory, 0);
        cpu.setIORange(0x130, 0x0f, mp);

        USCI usciA0 = new USCI(cpu, 0, cpu.memory, this);
        USCI usciB0 = new USCI(cpu, 1, cpu.memory, this);
        USCI usciA1 = new USCI(cpu, 2, cpu.memory, this);
        USCI usciB1 = new USCI(cpu, 3, cpu.memory, this);
        cpu.setIORange(0x60, 8, usciA0);
        cpu.setIORange(0x68, 8, usciB0);
        cpu.setIORange(0xd0, 8, usciA1);
        cpu.setIORange(0xd8, 8, usciB1);

        /* usciBx for i2c mode */
        cpu.setIORange(0x118, 2, usciB0);
        cpu.setIORange(0x11a, 2, usciB0);
        cpu.setIORange(0x17c, 2, usciB1);
        cpu.setIORange(0x17e, 2, usciB1);

        ioUnits.add(usciA0);
        ioUnits.add(usciB0);
        ioUnits.add(usciA1);
        ioUnits.add(usciB1);
        
        /* usciA1 handles interrupts for both usciA1 and B1 */
        cpu.setIORange(0x06, 2, usciA1);

        // Add port 1,2 with interrupt capability!
        // IOPorts will add themselves to the CPU
        IOPort last = null;
        ioUnits.add(last = IOPort.parseIOPort(cpu, 18, portConfig[0], last));
        ioUnits.add(last = IOPort.parseIOPort(cpu, 19, portConfig[1], last));

        for (int i = 2; i < portConfig.length; i++) {
            ioUnits.add(last = IOPort.parseIOPort(cpu, 0, portConfig[i], last));
        }

        ADC12 adc12 = new ADC12(cpu);
        ioUnits.add(adc12);
        cpu.setIORange(0x080, 16, adc12);
        cpu.setIORange(0x140, 16, adc12);
        cpu.setIORange(0x150, 16, adc12);
        cpu.setIORange(0x1a0, 10, adc12);

        /* 4 usci units + 6 io port*/
        return 4 + 6;
    }

    @Override
    public int getMaxClockSpeed() {
        return 9000000;
    }

    @Override
    public String getAddressAsString(int addr) {
        return Utils.hex20(addr);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/config/MSP430f149Config.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson, Niclas Finne
 */

package se.sics.mspsim.config;

public class MSP430f149Config extends MSP430f1611Config {

    public MSP430f149Config() {
        /* MSP430f149 is similar to MSP430f1611 but the memory map is different */
        infoMemConfig(0x1000, 128 * 2);
        mainFlashConfig(0x1100, 60 * 1024);
        ramConfig(0x0200, 2 * 1024);
        // No mirrored RAM
        ramMirrorConfig(0, 0, 0);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/config/CC430f5137Config.java`:

```java
/**
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson
 */

package se.sics.mspsim.config;

import java.util.ArrayList;

import se.sics.mspsim.core.ClockSystem;
import se.sics.mspsim.core.GenericUSCI;
import se.sics.mspsim.core.IOPort;
import se.sics.mspsim.core.IOUnit;
import se.sics.mspsim.core.MSP430Config;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.Multiplier32;
import se.sics.mspsim.core.PMM;
import se.sics.mspsim.core.PMMDummy;
import se.sics.mspsim.core.SysReg;
import se.sics.mspsim.core.Timer;
import se.sics.mspsim.core.UnifiedClockSystem;
import se.sics.mspsim.util.Utils;
import se.sics.mspsim.core.RF1A;

public class CC430f5137Config extends MSP430Config {

    // NOTE: this MCU also needs to configure 
    // - positions of all timers (A0, A1, B)
    // - memory configuration
    // - 
    private static final String portConfig[] = {
            "P1=200,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A,IV_L 0E,IV_H 0F,IES 18,IE 1A,IFG 1C",
            "P2=200,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B,IV_L 1E,IV_H 1F,IES 19,IE 1B,IFG 1D",
            "P3=220,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P4=220,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            "P5=240,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P6=240,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            "P7=260,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P8=260,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
            "P9=280,IN 00,OUT 02,DIR 04,REN 06,DS 08,SEL 0A",
            "P:=280,IN 01,OUT 03,DIR 05,REN 07,DS 09,SEL 0B",
    };
    
    public CC430f5137Config() {
        /* 64 vectors for the MSP430f54xx series */
        maxInterruptVector = 63;
        MSP430XArch = true;
        flashControllerOffset = 0x140;
        sfrOffset = 0x100;
        
        /* configuration for the timers - need to set-up new source maps!!! */
        
        /* XXX Adam: the ints after TimerConfig(X, Y) seem to be the interrupt vectors, i.e. i = (vector_addresss - 0xff80)/2 */
        
        //#define TIMER1_A1_VECTOR    (0x0064) /* 0xFFE4 Timer1_A3 CC1-2, TA1 */
        //#define TIMER1_A0_VECTOR    (0x0066) /* 0xFFE6 Timer1_A3 CC0 */
        //#define DMA_VECTOR          (0x0068) /* 0xFFE8 DMA */
        //#define CC1101_VECTOR       (0x006A) /* 0xFFEA CC1101 Radio Interface */
        //#define TIMER0_A1_VECTOR    (0x006C) /* 0xFFEC Timer0_A5 CC1-4, TA */
        //#define TIMER0_A0_VECTOR    (0x006E) /* 0xFFEE Timer0_A5 CC0 */
  
  
        TimerConfig timerA0 = new TimerConfig(0x6e / 2, 0x6c / 2, 5, 0x340, Timer.TIMER_Bx149, "TimerA0", 0x340 + 0x2e);
        TimerConfig timerA1 = new TimerConfig(0x66 / 2, 0x64 / 2, 3, 0x380, Timer.TIMER_Ax149, "TimerA1", 0x380 + 0x2e);
        
        timerConfig = new TimerConfig[] {timerA0, timerA1};
        
        uartConfig = new UARTConfig[] {
                new UARTConfig("USCI A0", 57, 0x5c0),
                new UARTConfig("USCI B0", 56, 0x5e0),
                new UARTConfig("USCI A1", 46, 0x600),
                new UARTConfig("USCI B1", 45, 0x620),
        };

        /* configure memory */
        infoMemConfig(0x1800, 128 * 4);
        ramConfig(0x1c00, 4 * 1024);
        mainFlashConfig(0x8000, 32 * 1024);
        
        ioMemSize(0x1000); /* 4 KB of IO Memory */
        
        watchdogOffset = 0x15c;
        // bsl, IO, etc at a later stage...
    }

    public int setup(MSP430Core cpu, ArrayList<IOUnit> ioUnits) {
    
        Multiplier32 mp = new Multiplier32(cpu, cpu.memory, 0x4c0);
        cpu.setIORange(0x4c0, 0x2e, mp);

        /* this code should be slightly more generic... and be somewhere else... */
        for (int i = 0, n = uartConfig.length; i < n; i++) {
            GenericUSCI usci = new GenericUSCI(cpu, i, cpu.memory, this);
            /* setup 0 - 1f as IO addresses */
            cpu.setIORange(uartConfig[i].offset, 0x20, usci);
//            System.out.println("Adding IOUnit USCI: " + usci.getName());
            ioUnits.add(usci);
        }
        IOPort last = null;
        ioUnits.add(last = IOPort.parseIOPort(cpu, 47, portConfig[0], last));
        ioUnits.add(last = IOPort.parseIOPort(cpu, 42, portConfig[1], last));
        
        for (int i = 2; i < portConfig.length; i++) {
            ioUnits.add(last = IOPort.parseIOPort(cpu, 0, portConfig[i], last));
        }

		/* XXX: Stub IO units: Sysreg and PMM */
		SysReg sysreg = new SysReg(cpu, cpu.memory);
		cpu.setIORange(SysReg.ADDRESS, SysReg.SIZE, sysreg);
		ioUnits.add(sysreg);

        PMMDummy pmmDummy = new PMMDummy(cpu, cpu.memory, 0x110);
        cpu.setIORange(0x110, PMMDummy.SIZE, pmmDummy);
        ioUnits.add(pmmDummy);
        
		PMM pmm = new PMM(cpu, cpu.memory, 0x120);
		cpu.setIORange(0x120, PMM.SIZE, pmm);
		ioUnits.add(pmm);

		RF1A rf1a = new RF1A(cpu, cpu.memory);
		cpu.setIORange(RF1A.ADDRESS, RF1A.SIZE, rf1a);
		ioUnits.add(rf1a);

		
        return portConfig.length + uartConfig.length;
    }

    public String getAddressAsString(int addr) {
        return Utils.hex20(addr);
    }

    public ClockSystem createClockSystem(MSP430Core cpu, int[] memory, Timer[] timers) {
        return new UnifiedClockSystem(cpu, memory, 0, timers);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/NetworkConnection.java`:

```java
/**
 * Copyright (c) 2007-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * NetworkConnection
 *
 * Author  : Joakim Eriksson
 * Created : 31 mar 2008
 */
package se.sics.mspsim.util;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;
import java.util.ArrayList;

import se.sics.mspsim.chip.PacketListener;

/**
 * @author joakim
 *
 */
public class NetworkConnection implements Runnable {

  private final static boolean DEBUG = false;
  private final static int DEFAULT_PORT = 4711;

  private ServerSocket serverSocket = null;
  private SendThread sendThread = null;
  private ConnectionThread[] connections = null;
  private PacketListener packetListener;

  public NetworkConnection() {
    if (connect(DEFAULT_PORT)) {
      System.out.println("NetworkConnection: Connected to network...");
    } else {
      setupServer(DEFAULT_PORT);
      System.out.println("NetworkConnection: Setup network server...");
    }
    sendThread = new SendThread();
  }
  
  public synchronized void addPacketListener(PacketListener listener) {
      packetListener = PacketListener.Proxy.INSTANCE.add(packetListener, listener);
  }

  public synchronized void removePacketListener(PacketListener listener) {
      packetListener = PacketListener.Proxy.INSTANCE.remove(packetListener, listener);
  }

  private void setupServer(int port) {
    try {
      serverSocket = new ServerSocket(port);
      if (DEBUG) System.out.println("NetworkConnection: setup of server socket finished... ");
      new Thread(this).start();
    } catch (IOException e) {
      e.printStackTrace();
    }
  }

  public void run() {
    System.out.println("NetworkConnection: Accepting new connections...");
    while (true) {
      try {
        Socket s = serverSocket.accept();
        if (DEBUG) System.out.println("NetworkConnection: New connection from " + s.getRemoteSocketAddress());
        connections = ArrayUtils.add(ConnectionThread.class, connections, new ConnectionThread(s));
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
  }
  
  // Data incoming from the network!!! - forward to radio and if server, to
  // all other nodes
  private void dataReceived(byte[] data, ConnectionThread source) {
    PacketListener listener = this.packetListener;
    if (listener != null) {
      // Send this data to the transmitter in this node!
      listener.transmissionStarted();      
      listener.transmissionEnded(data);
    }

    // And if this is the server, propagate to the others
    if (serverSocket != null) {
      dataSent(data, source);
    }
  }

  // Data was sent from the radio in the node (or other node) and should
  // be sent out to other nodes!!!
  public void dataSent(byte[] receivedData) {
    dataSent(receivedData, null);
  }

  // Data was sent either from radio, or came from another "radio" -
  // and if so it should be propagated to all others.
  public void dataSent(byte[] receivedData, ConnectionThread source) {
    if (connections != null && sendThread != null) {
      sendThread.send(receivedData, source);
    }
  }

  private void printPacket(String prefix, byte[] data) {
    System.out.print("NetworkConnection: " + prefix);
    for (int i = 0, len = data.length; i < len; i++) {
      System.out.print(' ' + Utils.hex8(data[i]));
    }
    System.out.println();
  }
  
  private boolean connect(int port) {
    try {
      Socket socket = new Socket("127.0.0.1", port);
      connections = ArrayUtils.add(ConnectionThread.class, connections, new ConnectionThread(socket));
    } catch (UnknownHostException e) {
      return false;
    } catch (IOException e) {
      return false;
    }    
    return true;
  }

  private static class SendEvent {
    public final byte[] data;
    public final ConnectionThread source;
    public SendEvent(byte[] data, ConnectionThread source) {
      this.data = data;
      this.source = source;
    }
  }

  class SendThread implements Runnable {

    private ArrayList<SendEvent> queue = new ArrayList<SendEvent>();

    public SendThread() {
      new Thread(this).start();
    }

    public synchronized void send(byte[] receivedData, ConnectionThread source) {
      queue.add(new SendEvent(receivedData, source));
      notifyAll();
    }

    public synchronized SendEvent getNext() throws InterruptedException {
      while (queue.isEmpty()) {
        wait();
      }
      return queue.remove(0);
    }

    private void sendPacket(SendEvent event) {
      ConnectionThread[] cthr = connections;
      if (cthr != null) {
        for (int i = 0; i < cthr.length; i++) {
          if (cthr[i].isClosed()) {
            connections = ArrayUtils.remove(connections, cthr[i]);
            // Do not write back to the source
          } else if (cthr[i] != event.source){
            try {
              cthr[i].output.write(event.data, 0, event.data.length);
              cthr[i].output.flush();
            } catch (IOException e) {
              e.printStackTrace();
              cthr[i].close();
            }
          }
        }
        if (DEBUG) {
//              System.out.println("NetworkConnection: wrote " + receivedData.length + " bytes");
          printPacket("sent", event.data);
        }
      }
    }

    public void run() {
      try {
        SendEvent event;
        do {
          event = getNext();
          if (event != null) {
            sendPacket(event);
          }
        } while (event != null);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }

  class ConnectionThread implements Runnable {
    Socket socket;
    DataInputStream input;
    OutputStream output;
    
    public ConnectionThread(Socket socket) throws IOException {
      this.socket = socket;
      input = new DataInputStream(socket.getInputStream());
      output = socket.getOutputStream();
      new Thread(this).start();
    }
    
    public void close() {
      try {
        input.close();
        socket.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
      socket = null;
    }
    
    public boolean isClosed() {
      return socket == null;
    }
    
    public void run() {
      if (DEBUG) System.out.println("NetworkConnection: Started connection thread...");
      try {
        while (socket != null) {
          int len = input.read();
          if (len > 0) {
            byte[] buffer = new byte[len + 1];
            buffer[0] = (byte) (len & 0xff);
            input.readFully(buffer, 1, len);
            if (DEBUG) {
//              System.out.println("NetworkConnection: Read packet with " + len + " bytes");
              printPacket("read", buffer);
            }
            dataReceived(buffer, this);
          }
        }
      } catch (IOException e) {
        e.printStackTrace();
        close();
      }
    }
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/GDBStubs.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * GDBStubs
 *
 * Author  : Joakim Eriksson
 * Created : 31 mar 2008
 * Updated : $Date:$
 *           $Revision:$
 */
package se.sics.mspsim.util;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.Memory;

public class GDBStubs implements Runnable {

    private final static String OK = "OK";

    ServerSocket serverSocket;
    OutputStream output;
    MSP430Core cpu;

    public void setupServer(MSP430Core cpu, int port) {
        this.cpu = cpu;
        try {
            serverSocket = new ServerSocket(port);
            System.out.println("GDBStubs open server socket port: " + port);
            new Thread(this).start();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    int[] buffer = new int[256];
    int len;

    public void run() {
        while (true) {
            try {
                Socket s = serverSocket.accept();

                DataInputStream input = new DataInputStream(s.getInputStream());
                output = s.getOutputStream();

                String cmd = "";
                boolean readCmd = false;
                int c;
                while (s != null && ((c = input.read()) != -1)) {
                    System.out.println("GDBStubs: Read  " + c + " => "
                            + (char) c);
                    if (c == '#') {
                        readCmd = false;
                        /* ack the message */
                        output.write('+');
                        handleCmd(cmd, buffer, len);
                        cmd = "";
                        len = 0;
                    }
                    if (readCmd) {
                        cmd += (char) c;
                        buffer[len++] = (c & 0xff);
                    }
                    if (c == '$') {
                        readCmd = true;
                    }
                }
            } catch (IOException e) {
                e.printStackTrace();
            } catch (EmulationException e) {
                e.printStackTrace();
            }
        }
    }

    private void handleCmd(String cmd, int[] cmdBytes, int cmdLen)
    throws IOException, EmulationException {
        System.out.println("cmd: " + cmd);
        char c = cmd.charAt(0);
        switch (c) {
        case 'H':
            sendResponse(OK);
            break;
        case 'q':
            if ("qC".equals(cmd)) {
                sendResponse("QC1");
            } else if ("qOffsets".equals(cmd)) {
                sendResponse("Text=0;Data=0;Bss=0");
            } else if ("qfThreadInfo".equals(cmd)){
                sendResponse("m 01");
            } else if ("qsThreadInfo".equals(cmd)){
                sendResponse("l");      
            } else if ("qSymbol::".equals(cmd)){
                sendResponse(OK);
                //} else if ("qThreadExtraInfo,1".equals(cmd)){
                //              sendResponse(stringToHex("Stoped"));
            } else {
                System.out.println("Command unknown");
                sendResponse("");
            }

            break;
        case '?':
            sendResponse("S01");
            break;
        case 'g':
            readRegisters();
            break;
        case 'k': // kill
            sendResponse(OK);
            break;
        case 'm':
        case 'M':
        case 'X':
            String cmd2 = cmd.substring(1);
            String wdata[] = cmd2.split(":");
            int cPos = cmd.indexOf(':');
            if (cPos > 0) {
                /* only until length in first part */
                cmd2 = wdata[0];
            }
            String parts[] = cmd2.split(",");
            int addr = Integer.decode("0x" + parts[0]);
            int len = Integer.decode("0x" + parts[1]);
            String data = "";
            Memory mem = cpu.getMemory();
            if (c == 'm') {
                System.out.println("Returning memory from: " + addr + " len = "
                        + len);
                /* This might be wrong - which is the correct byte order? */
                for (int i = 0; i < len; i++) {
                    data += Utils.hex8(mem.get(addr++, Memory.AccessMode.BYTE));
                }
                sendResponse(data);
            } else {
                System.out.println("Writing to memory at: " + addr + " len = "
                        + len + " with: "
                        + ((wdata.length > 1) ? wdata[1] : ""));
                cPos++;
                for (int i = 0; i < len; i++) {
                    System.out.println("Writing: " + cmdBytes[cPos] + " to "
                            + addr + " cpos=" + cPos);
                    mem.set(addr++, cmdBytes[cPos++], Memory.AccessMode.BYTE);
                }
                sendResponse(OK);
            }
            break;
        case 'C':
            sendResponse("S01");
            break;
        default:
            System.out.println("Command unknown");
            sendResponse("");
        }
    }

    private void readRegisters() throws IOException {
        String regs = "";
        for (int i = 0; i < 16; i++) {
            regs += Utils.hex8(cpu.reg[i] & 0xff) + Utils.hex8(cpu.reg[i] >> 8);
        }
        sendResponse(regs);
    }

    public static String stringToHex(String base)
    {
        StringBuilder buffer = new StringBuilder();
        int intValue;
        for(int x = 0; x < base.length(); x++)
        {
            int cursor = 0;
            intValue = base.charAt(x);
            String binaryChar = new String(Integer.toBinaryString(base.charAt(x)));
            for(int i = 0; i < binaryChar.length(); i++) {
                if(binaryChar.charAt(i) == '1') {
                    cursor += 1;
                }
            }
            if((cursor % 2) > 0) {
                intValue += 128;
            }
            buffer.append(Integer.toHexString(intValue));
        }
        return buffer.toString();
    }


    public void sendResponse(String resp) throws IOException {
        output.write('$');
        int cs = 0;
        if (resp != null) {
            for (int i = 0; i < resp.length(); i++) {
                output.write(resp.charAt(i));
                System.out.print(resp.charAt(i));
                cs += resp.charAt(i);
            }
        }
        output.write('#');
        System.out.print('#');
        int c = (cs & 0xff) >> 4;
            if (c < 10) {
                c = c + '0';
            } else {
                c = c - 10 + 'a';
            }
            output.write((char) c);
            System.out.print((char) c);
            c = cs & 15;
            if (c < 10) {
                c = c + '0';
            } else {
                c = c - 10 + 'a';
            }
            output.write((char) c);
            System.out.println((char) c);
    }
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/StatCommands.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * StatCommands
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 11 March 2008
 * Updated : $Date$
 *           $Rev$
 */
package se.sics.mspsim.util;
import java.io.PrintStream;

import se.sics.mspsim.cli.BasicAsyncCommand;
import se.sics.mspsim.cli.BasicCommand;
import se.sics.mspsim.cli.BasicLineCommand;
import se.sics.mspsim.cli.CommandBundle;
import se.sics.mspsim.cli.CommandContext;
import se.sics.mspsim.cli.CommandHandler;
import se.sics.mspsim.core.Loggable;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.TimeEvent;

public class StatCommands implements CommandBundle {

  private final MSP430Core cpu;
  private final OperatingModeStatistics statistics;

  public StatCommands(MSP430Core cpu, OperatingModeStatistics statistics) {
    this.cpu = cpu;
    this.statistics = statistics;
  }

  public void setupCommands(ComponentRegistry registry, CommandHandler handler) {
    handler.registerCommand("info", new BasicCommand("show information about specified chip/loggable",
    "[unit...]") {

      @Override
      public int executeCommand(CommandContext context) {
        if (context.getArgumentCount() > 0) {
          for (int i = 0, n = context.getArgumentCount(); i < n; i++) {
            String unitName = context.getArgument(i);
            Loggable unit = cpu.getLoggable(unitName);
            if (unit == null) {
              context.out.println("  " + unitName + ": NOT FOUND");
            } else {
              String id = unit.getID();
              String name = unit.getName();
              if (id == name) {
                context.out.println(unit.getName() + ": " + unit.getClass().getName());
              } else {
                context.out.println(unit.getID() + " (" + unit.getName() + "): "
                    + unit.getClass().getName());
              }
              String info = unit.info();
              if (info != null) {
                context.out.println(info);
              }
            }
          }
        } else {
          Loggable[] units = cpu.getLoggables();
          if (units == null) {
            context.out.println("No loggables found.");
          } else {
            for (int i = 0, n = units.length; i < n; i++) {
              String id = units[i].getID();
              String name = units[i].getName();
              if (id == name) {
                  context.out.println("  " + id);
              } else {
                  context.out.println("  " + id + " (" + name + ')');
              }
            }
          }
        }
        return 0;
      }
        
    });

    handler.registerCommand("mult", new BasicLineCommand("multiply line of doubles",
        "[m1...mn]") {
          double[] multiplicator;
          private PrintStream out;
          public int executeCommand(CommandContext context) {
            this.out = context.out;
            int args = context.getArgumentCount();
            multiplicator = new double[args];
            for(int i = 0; i < args; i++) {
              multiplicator[i] = context.getArgumentAsDouble(i);
            }
            return 0;
          }
          public void lineRead(String line) {
            // Split & parse double on each + multiplicate...
            String[] parts = line.split(" ");
            for(int i = 0; i < parts.length; i++) {
              out.print(multiplicator[i % multiplicator.length] * Double.parseDouble(parts[i]) + " ");
            }
            out.println();
          }
          public void stopCommand(CommandContext context) {
          }
    });
    
    handler.registerCommand("duty", new BasicAsyncCommand("add a duty cycle sampler for operating modes to the specified chips",
        "<frequency> <chip> [chips...]") {

      private PrintStream out;
      private Object[] sources;
      private double frequency;
      private boolean isRunning = true;

      public int executeCommand(CommandContext context) {
        frequency = context.getArgumentAsDouble(0);
        if (frequency <= 0.0) {
          context.err.println("illegal frequency: " + context.getArgument(0));
          return 1;
        }
        sources = new Object[context.getArgumentCount() - 1];
        for (int i = 0, n = sources.length; i < n; i++) {
          String sName = context.getArgument(i + 1);
          if (sName.indexOf('.') >= 0) {
            String[] parts = sName.split("\\.");
            sources[i] = statistics.getDataSource(parts[0], parts[1]); 
            if (sources[i] == null) {
              context.err.println("could not find chip / mode combination " + sName);
              return 1;
            }
          } else {
            sources[i] = statistics.getMultiDataSource(sName); 
            if (sources[i] == null) {
              context.err.println("could not find chip " + sName);
              return 1;
            }
          }
        }
        this.out = context.out;

        cpu.scheduleTimeEventMillis(new TimeEvent(0) {

          @Override
          public void execute(long t) {
            if (isRunning) {
              cpu.scheduleTimeEventMillis(this, 1000.0 / frequency);
              for (int j = 0, n = sources.length; j < n; j++) {
                Object s = sources[j];
                if (j > 0) out.print(' ');
                if (s instanceof MultiDataSource) {
                  MultiDataSource ds = (MultiDataSource) s;
                  for (int k = 0, m = ds.getModeMax(); k <= m; k++) {
                    if (k > 0) out.print(' ');
                    out.print(((int) (ds.getDoubleValue(k) * 100.0 + 0.5)) / 100.0);       
                  }
                } else {
                  out.print( ((int) (((DataSource)s).getDoubleValue() * 100.0 + 0.5)) / 100.0);
                }
              }
              out.println();
            }
          }
        }, 1000.0 / frequency);
        return 0;
      }

      public void stopCommand(CommandContext context) {
        isRunning = false;
        context.exit(0);
      }
    });
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ArgumentManager.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ArgumentManager
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Tue Apr 08 22:08:32 2003
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;
import java.util.ArrayList;

/**
 */
public class ArgumentManager extends ConfigManager {

  private String configName = "config";
  private String[] arguments;
  private boolean isConfigLoaded;

  public ArgumentManager() {
  }

  public ArgumentManager(ConfigManager parent) {
    super(parent);
  }

  public boolean isConfigLoaded() {
    return isConfigLoaded;
  }

  public String getConfigArgumentName() {
    return configName;
  }

  public void setConfigArgumentName(String configName) {
    this.configName = configName;
  }

  public String[] getArguments() {
    return arguments;
  }

  public void handleArguments(String[] args) {
    ArrayList<String> list = new ArrayList<String>();
    ArrayList<String> config = new ArrayList<String>();
    for (int i = 0, n = args.length; i < n; i++) {
      if ("-".equals(args[i])) {
          // The rest should be considered arguments
          for(++i; i < args.length; i++) {
              list.add(args[i]);
          }
          break;
      }
      if (args[i].startsWith("-")) {
        String param = args[i].substring(1);
        String value = "";
        int index = param.indexOf('=');
        if (index >= 0) {
          if (index < param.length()) {
            value = param.substring(index + 1);
          }
          param = param.substring(0, index);
        }
        if (param.length() == 0) {
          throw new IllegalArgumentException("illegal argument: " + args[i]);
        }
        if (configName != null && configName.equals(param)) {
          if (value.length() == 0) {
            throw new IllegalArgumentException("no config file name specified");
          }
          if (!loadConfiguration(value)) {
            throw new IllegalArgumentException("failed to load configuration " + value);
          }
          isConfigLoaded = true;
        }
        config.add(param);
        config.add(value.length() > 0 ? value : "true");
      } else {
        // Normal argument
        list.add(args[i]);
      }
    }
    this.arguments = list.toArray(new String[list.size()]);
    for (int i = 0, n = config.size(); i < n; i += 2) {
      setProperty(config.get(i), config.get(i + 1));
    }
  }

} // ArgumentManager

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/StackMonitor.java`:

```java
package se.sics.mspsim.util;
import se.sics.mspsim.core.MSP430;
import se.sics.mspsim.core.RegisterMonitor;
import se.sics.mspsim.core.Memory.AccessMode;
import se.sics.mspsim.profiler.SimpleProfiler;

public class StackMonitor {

  private int heapStartAddress;
  private int stackStartAddress;

  private int stackMin = 0;
  private int stackMax = 0;
  private int stack = 0;
  private int profStackMax = 0;
  
  private DataSource maxDataSource = new DataSource() {
    public int getValue() {
      int tmp = stackMax;
      stackMax = stack;
      return tmp;
    }
    public double getDoubleValue() {
      return getValue();
    }
  };
  
  private DataSource minDataSource = new DataSource() {
    public int getValue() {
      int tmp = stackMin;
      stackMin = stack;
      return tmp;
    }   
    public double getDoubleValue() {
      return getValue();
    }
  };
  
  private DataSource dataSource = new DataSource() {
    public int getValue() {
      return stack;
    }
    public double getDoubleValue() {
      return getValue();
    }
  };
  
  public StackMonitor(MSP430 cpu) {
    SimpleProfiler profiler = cpu.getRegistry().getComponent(SimpleProfiler.class);
    if (profiler != null) {
        profiler.setStackMonitor(this);
        System.out.println("Found simple profiler!!!: " + profiler);
    } else {
        System.out.println("Could not find any suitable profiler");
    }
    if (cpu.getDisAsm() != null) {
      MapTable mapTable = cpu.getDisAsm().getMap();
      if (mapTable != null) {
        this.heapStartAddress = mapTable.heapStartAddress;
        this.stackStartAddress = mapTable.stackStartAddress;
      }
    }
    cpu.addRegisterWriteMonitor(MSP430.SP, new RegisterMonitor.Adapter() {

        @Override
        public void notifyWriteBefore(int reg, int data, AccessMode mode) {
            // TODO add support for 20 bit addresses
            stack = ((stackStartAddress - data) + 0xffff) & 0xffff;
            if (stack > stackMax) {
              stackMax = stack;
            }
            if (stack < stackMin) {
              stackMin = stack;
            }
            if (stack > profStackMax) {
                profStackMax = stack;
            }
        }

    });
  }

  public int getStackStart() {
    return stackStartAddress;
  }
  
  public int getHeapStart() {
    return heapStartAddress;
  }
  

  public DataSource getMaxSource() {
    return maxDataSource;
  }

  public DataSource getMinSource() {
    return minDataSource; 
  }
  
  public DataSource getSource() {
    return dataSource; 
  }

  /* specialized profiler support for the stack */
  /* set current profiler Stack max to this value */
  public void setProfStackMax(int max) {
      profStackMax = max;
  }

  /* get profiler stack max */
  public int getProfStackMax() {
      return profStackMax;
  }
  
  public int getStack() {
      return stack;
  }
  
}
```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/Test.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Utils
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;
import java.io.IOException;

import se.sics.mspsim.config.MSP430f1611Config;
import se.sics.mspsim.core.*;

/**
 * Test - tests a firmware file and exits when reporting "FAIL:" first
 * on a line...
 */
public class Test implements USARTListener {

  private StringBuilder lineBuffer = new StringBuilder();
  private MSP430 cpu;

  public Test(MSP430 cpu) {
    this.cpu = cpu;
    IOUnit usart = cpu.getIOUnit("USART 1");
    if (usart instanceof USART) {
      ((USART) usart).addUSARTListener(this);
    }
  }

  public void dataReceived(USARTSource source, int data) {
    if (data == '\n') {
      String line = lineBuffer.toString();
      lineBuffer.setLength(0);
      System.out.println("#|" + line);
      if (line.startsWith("FAIL:")) {
	System.err.println("Tests failed!");
	System.exit(1);
      } else if (line.startsWith("EXIT")) {
	System.out.println("Tests succeded!");
	System.exit(0);
      } else if (line.startsWith("DEBUG")) {
	cpu.setDebug(true);
      } else if (line.startsWith("PROFILE")) {
	cpu.getProfiler().printProfile(System.out);
      } else if (line.startsWith("CLEARPROFILE")) {
	cpu.getProfiler().clearProfile();
      }
    } else {
      lineBuffer.append((char) data);
    }
  }

  public static void main(String[] args) {
    MSP430 cpu = new MSP430(0, new ComponentRegistry(), new MSP430f1611Config());
    int index = 0;
    if (args[index].startsWith("-")) {
      // Flag
      if ("-debug".equalsIgnoreCase(args[index])) {
	cpu.setDebug(true);
      } else {
	System.err.println("Unknown flag: " + args[index]);
	System.exit(1);
      }
      index++;
    }

    try {
      int[] memory = cpu.memory;
      ELF elf = ELF.readELF(args[index++]);
      elf.loadPrograms(memory);
      MapTable map = elf.getMap();
      cpu.getDisAsm().setMap(map);
      cpu.setMap(map);
      cpu.reset();

      // Create the "tester"
      new Test(cpu);
      try {
        cpu.cpuloop();        
      } catch (Exception e) {
        e.printStackTrace();
      }
    } catch (IOException ioe) {
      ioe.printStackTrace();
    }

  }

  public void stateChanged(int state) {
    // TODO Auto-generated method stub
    
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/DotDiagram.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * DotDiagram
 *
 * Author  : Joakim Eriksson, Niclas Finne, Fredrik Osterlind
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.util;
import java.awt.Color;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GridLayout;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JOptionPane;

public class DotDiagram extends JComponent {

  private static final long serialVersionUID = -2284181166518780931L;

  public static final int NORMAL = 0;
  public static final int ADDITIVE = 1;
  public static final int FILLED_ADDITIVE = 2;

  public static final char[] NOTE_CHAR = { 'N' };

  // The data "vector" - any number of vectors
  private int[][] data;
  private String[][] notes;
  private Point[][] notesCoords;
  private int[] dataLen;
  private int[] start;
  private int[] maxData;
  private int[] minData;
  private int totMax;
  private int totMin;
  private boolean lockMinMax = false;
  private int maxDataLen;
  private double factor;

  private int[] constantY;
  private Color[] constantColor;

  private int sizeX;
  private int sizeY;
  private int lowerY;
  private double xspace;
  private int ySpacing = 0;
  private boolean rescale = false;
  private boolean gridVisible = false;

  private String yLabel = null;
  private String xLabel = null;

  private boolean isAdditive = false;
  private boolean isFilled = false;

  // Cache to avoid creating new insets objects for each repaint. Is
  // created when first needed.
  private Insets insets;

  private Color[] lineColor;

  public DotDiagram(int diagrams) {
    this(diagrams, NORMAL);
  }

  public DotDiagram(int diagrams, int mode) {
    data = new int[diagrams][];
    notes = new String[diagrams][];
    notesCoords = new Point[diagrams][];
    lineColor = new Color[diagrams];
    dataLen = new int[diagrams];
    start = new int[diagrams];
    maxData = new int[diagrams];
    minData = new int[diagrams];
    for (int i = 0; i < diagrams; i++) {
      lineColor[i] = Color.black;
    }
    setOpaque(true);
    isFilled = mode == FILLED_ADDITIVE;
    isAdditive = isFilled || mode == ADDITIVE;

    // Listen for note clicks
    this.addMouseListener(new MouseListener() {
      public void mouseClicked(MouseEvent e) {
        int x = e.getX();
        int y = e.getY();

        // Check if click on previously painted note
        for (int i=0; i < notes.length; i++) {
          if (notes[i] == null) {
            continue;
          }
          for (int j=0; j < notes[i].length; j++) {
            if (notes[i][j] == null) {
              continue;
            }
            Point nodeCoords = notesCoords[i][j];
            if (nodeCoords == null) {
              continue;
            }

            if (nodeCoords.distance(x, y) < 10) {
              JOptionPane.showMessageDialog(
                  DotDiagram.this,
                  notes[i][j],
                  "Log message", JOptionPane.INFORMATION_MESSAGE);
            }
          }
        }

      }
      public void mouseReleased(MouseEvent e) {
      }
      public void mousePressed(MouseEvent e) {
      }
      public void mouseEntered(MouseEvent e) {
      }
      public void mouseExited(MouseEvent e) {
      }
    });
  }

  public void setShowGrid(boolean on) {
    gridVisible = on;
  }

  public void setGridYSpacing(int spacing) {
    // values / y grid
    ySpacing = spacing;
  }

  public void setYLabel(String yLabel) {
    this.yLabel = yLabel;
  }

  public void setXLabel(String xLabel) {
    this.xLabel = xLabel;
  }

  public void setName(int index, String name) {
//     if (names == null) {
//       names = new String[diagrams];
//     }
//     names[index] = name;
//     StringBuilder sb = new StringBuilder();
//     for (int i = 0, n = names.length; i < n; i++) {
//       // Setup JLables...
//     }
  }

  public void setToolTipVisible(boolean showToolTip) {
//     setToolTipText(showToolTip ? toolTipText : null);
  }

  public void addConstant(Color color, int y) {
    int index;
    if (constantY == null) {
      index = 0;
      constantY = new int[1];
      constantColor = new Color[1];
    } else {
      index = constantY.length;

      int[] tmpY = new int[index + 1];
      Color[] tmpC = new Color[index + 1];
      for (int i = 0; i < index; i++) {
	tmpY[i] = constantY[i];
	tmpC[i] = constantColor[i];
      }
      constantY = tmpY;
      constantColor = tmpC;
    }
    constantY[index] = y;
    constantColor[index] = color == null ? Color.black : color;
    rescale = true;
    repaint();
  }

  public void setMinMax(int min, int max) {
    totMax = max;
    totMin = min;
    lockMinMax = true;
    rescale = true;
  }

  public void setData(int diag, int[] data, int start, int len) {
    int maxData = Integer.MIN_VALUE;
    int minData = Integer.MAX_VALUE;

    if (len > 0) {
      int totLen = data.length;
      for (int i = start, n = start + len; i < n; i++) {
	int val = data[i % totLen];
	if (maxData < val) {
	  maxData = val;
	}
	if (minData > val) {
	  minData = val;
	}
      }
    }
    if (minData > 0) {
      minData = 0;
    }
    if (maxData < minData) {
      maxData = minData;
    }

    this.dataLen[diag] = len;
    this.start[diag] = start;
    this.data[diag] = data;
    this.maxData[diag] = maxData;
    this.minData[diag] = minData;
    this.rescale = true;

    repaint();
  }

  public void setDataWithNotes(int diag, int[] data, String[] notes, int start, int len) {
    this.notes[diag] = notes;
    this.notesCoords[diag] = new Point[notes.length];
    setData(diag, data, start, len);
  }

  public void setDotColor(int diag, Color color) {
    if (color == null) {
      throw new NullPointerException();
    }
    lineColor[diag] = color;
    if (dataLen[diag] > 0) {
      repaint();
    }
  }

  protected void paintComponent(Graphics g0) {
    Graphics2D g = (Graphics2D) g0;
    FontMetrics fm = g.getFontMetrics();
    int fmHeight = fm.getAscent();
    Color oldColor = g.getColor();
    Insets insets = getInsets();
    int width = getWidth();
    int height = getHeight();
    int leftInset = 2;
    int topInset = 2;
    int yLabelSize = 0;
    if (yLabel != null || xLabel != null) {
      yLabelSize = fm.stringWidth(yLabel);
    }
    if(gridVisible) {
      topInset += fmHeight / 2;
      height -= fmHeight / 2;
      leftInset += 40;
    }
    height -= topInset + insets.top + insets.bottom;
    width -= leftInset + insets.left + insets.right;
    g.translate(leftInset + insets.left + 1, topInset + insets.top + 1);

    if (isOpaque()) {
      g.setColor(Color.white);
      g.fillRect(0, 0, width, height);
    }

    insets = getInsets(insets);
    int reserveX = yLabel != null ? (12 * width)/200 : 0;
    int x = insets.left + reserveX;
    int y = insets.top;
    width = width - insets.left - insets.right - reserveX;
    height = height - insets.top - insets.bottom;

    if (rescale || width != sizeX || height != sizeY) {
      if (rescale) {
	rescale = false;
	maxDataLen = 0;
	if (lockMinMax) {
	  for (int i = 0, n = this.data.length; i < n; i++) {
	    if (this.dataLen[i] > maxDataLen) {
	      maxDataLen = this.dataLen[i];
	    }
	  }
	} else {
	  totMin = Integer.MAX_VALUE;
	  totMax = Integer.MIN_VALUE;

	  if (constantY != null) {
	    for (int cy : constantY) {
	      if (cy < totMin) {
		totMin = cy;
	      }
	      if (cy > totMax) {
		totMax = cy;
	      }
	    }
	  }

	  int sum = 0;
	  for (int i = 0, n = this.data.length; i < n; i++) {
	    if (this.dataLen[i] > 0) {
	      int min = this.minData[i];
	      int max = this.maxData[i];
	      if (min < totMin) {
		totMin = min;
	      }
	      if (max > totMax) {
		totMax = max;
	      }
	      if (this.dataLen[i] > maxDataLen) {
		maxDataLen = this.dataLen[i];
	      }
	      sum += max;
	    }
	  }
	  if (isAdditive && sum > totMax) {
	    totMax = sum;
	  }
	  // Make sure the zero line is visible
	  if (totMin > 0) {
	    totMin = 0;
	  }
	  if (totMax < totMin) {
	    totMax = totMin;
	  }
	}
      }

      sizeY = height;
      sizeX = width - 2;

      if (totMax < 0) {
	factor = (sizeY - 15) / (double) (0 - totMin);
      } else if (totMax == totMin) {
	factor = 1;
      } else {
        factor = (sizeY - 15) / (double) (totMax - totMin);
      }

      lowerY = sizeY - 5;
      if (maxDataLen == 0) {
	xspace = 1;
      } else {
	xspace = (double) sizeX / maxDataLen;
      }
    }

    x = x + 2;

    // Draw grid...
    int zero = y + lowerY - (int) (factor * (0 - totMin));

    if (gridVisible) {
      g.setColor(Color.lightGray);

      double yfac = (1.0 * height) / (totMax - totMin);
//      if (totMin < 0) {
//        zero += (int) (yfac * totMin);
//      }
      // Draw zero line
      g.setColor(Color.lightGray);
      g.drawLine(0, zero, width, zero);
      g.setColor(Color.black);
      g.drawString("0", -4 - fm.stringWidth("0"), zero + fmHeight / 2);

      double div = getDivider(totMin, totMax);
      for (double d = div; d < totMax; d += div) {
        int dy = (int) (zero - yfac * d);
        String text = "" + (int) d;
        int tlen = fm.stringWidth(text);
        g.setColor(Color.lightGray);
        g.drawLine(0, dy, width, dy);
        g.setColor(Color.black);
        g.drawString(text, -4 - tlen, dy + fmHeight / 2);
      }
      for (double d = div; d < -totMin; d += div) {
        int dy = (int) (zero + yfac * d);
        String text = "" + (int) -d;
        int tlen = fm.stringWidth(text);
        g.setColor(Color.lightGray);
        g.drawLine(0, dy, width, dy);
        g.setColor(Color.black);
        g.drawString(text, -4 - tlen, dy + fmHeight / 2);
      }

      
      
//      for (int i = 0, n = 10; i < n; i++) {
//	g.drawLine(x + (i * sizeX) / 10, y,
//		   x + (i * sizeX) / 10, y + sizeY - 1);
//      }
//      int z0 = zero - y;
//      int z1 = zero - (y + sizeY);
//      double tot =  (ySpacing * factor) == 0 ? (sizeY / 10.0)
//	:  (factor * ySpacing);
//      for (double i = 0; i < z0; i += tot) {
//	g.drawLine(x + 1, (int) (zero - i), x + sizeX, (int) (zero - i));
//      }
//
//      for (double i = 0; i > z1; i -= tot) {
//	g.drawLine(x + 1, (int) (zero - i), x + sizeX, (int) (zero - i));
//      }
    }

    if (isAdditive) {
      if (isFilled) {
	int delta = (int) (xspace + 1);
	for (int i = 0, n = maxDataLen; i < n; i++) {
	  int lastY = zero;
	  for (int j = 0, m = data.length; j < m; j++) {
	    if (dataLen[j] > i) {
	      int[] drawData = data[j];
	      int pos = start[j] + i;
	      int y0 = (int) (factor * drawData[pos % drawData.length]);
	      if (y0 > 0) {
		g.setColor(lineColor[j]);
		g.fillRect(x + (int) (i * xspace), lastY - y0, delta, y0);
		lastY -= y0;
	      }
	    }
	  }
	}
      } else {
	for (int i = 0, n = maxDataLen; i < n; i++) {
	  int lastY = zero;
	  for (int j = 0, m = data.length; j < m; j++) {
	    if (dataLen[j] > i) {
	      int[] drawData = data[j];
	      int pos = start[j] + i;
	      int y0 = (int) (factor * drawData[pos % drawData.length]);
	      if (y0 > 0) {
		g.setColor(lineColor[j]);
		g.drawLine(x + (int) ((i - 1) * xspace), lastY - y0,
			   x + (int) (i * xspace), lastY - y0);
		lastY -= y0;
	      }
	    }
	  }
	}
      }

    } else {
      for (int j = 0, m = data.length; j < m; j++) {
	if (dataLen[j] > 0) {
	  int[] drawData = data[j];
	  int maxLen = drawData.length;
	  int startData = start[j];
	  int lastY = (int) (factor * (drawData[startData % maxLen] - totMin));
	  g.setColor(lineColor[j]);
	  for (int i = 1, n = dataLen[j]; i < n; i++) {
	    int pos = startData + i;
	    int y0 = (int) (factor * (drawData[pos % maxLen] - totMin));
	    g.drawLine(x + (int) ((i - 1) * xspace), y + lowerY - lastY,
		       x + (int) (i * xspace), y + lowerY - y0);
	    lastY = y0;
	  }
	  g.setColor(Color.BLACK);
	  String[] noteData = notes[j];
	  if (noteData != null) {
	    for (int i = 1, n = dataLen[j]; i < n; i++) {
	      int pos = startData + i;
	      // Draw notes
	      if (noteData[pos % maxLen] != null) {
		int charWidth = g.getFontMetrics().charWidth('N');
		int charHeight = g.getFontMetrics().getAscent();
		g.drawChars(NOTE_CHAR, 0, 1, x + (int) (i * xspace) - charWidth/2, y + charHeight);

		// Save coordinate
		this.notesCoords[j][pos % maxLen] =
		  new Point(x + (int) (i * xspace) - charWidth/2, y + charHeight);
	      }

	    }
	  }
	}
      }
    }

    if (constantY != null) {
      for (int i = 0, n = constantY.length; i < n; i++) {
	int cy = y + lowerY - (int) (factor * (constantY[i] - totMin));
	g.setColor(constantColor[i]);
	g.drawLine(x, cy, x + sizeX, cy);
      }
    }

    // Draw the coordinate system last to avoid having it overwritten
    // by diagrams (for example with value of 0)
    x = x - 2;
    g.setColor(Color.black);
    g.drawLine(x, zero, x + sizeX, zero);
    g.drawLine(x + 1, y, x + 1, y + sizeY - 1);

    if (yLabel != null) {
      g.rotate(-3.1415/2);
      g.scale(height/200.0, width/200.0);
      g.drawString(yLabel, -100 - yLabelSize/2, 10);
    }
    g.setColor(oldColor);
  }

  private double getDivider(double minY, double maxY) {
    double diff = Math.abs(maxY - minY);
    if (diff >= 1500) {
      return 500.0;
    }
    if (diff >= 400) {
      return 100.0;
    }
    if (diff >= 80) {
      return 20.0;
    }
    if (diff >= 20) {
      return 10.0;
    }
    if (diff >= 10) {
      return 5.0;
    }
    return 1.0;
  }


  // -------------------------------------------------------------------
  // Test main
  // -------------------------------------------------------------------

  public static void main(String[] args) throws Exception {
    JFrame jf = new JFrame("DotDiagram - Test");
    // bd.setMinMax(0, 200);
    int[] data = new int[100];
    int[] data2 = new int[100];
    int[] data3 = new int[100];

    boolean neg = true;
    int pos = 100;
    int pos2 = 50;
    int pos3 = 0;
    int s = neg ? -10 : 0;
    for (int i = 0; i < 60; i++) {
      pos = pos + (int)(s + 20 * Math.random());
      pos2 = pos2 + (int)(s + 20 * Math.random());
      pos3 = pos3 + (int)(s + 20 * Math.random());
      data[i] = pos;
      data2[i] = pos2;
      data3[i] = pos3;
    }
    DotDiagram bd = setupDiagram(10, data, data2, data3, NORMAL);
    DotDiagram bd2 = setupDiagram(10, data, data2, data3, ADDITIVE);
    DotDiagram bd3 = setupDiagram(10, data, data2, data3, FILLED_ADDITIVE);

    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    jf.setSize(600, 200);
    jf.getContentPane().setLayout(new GridLayout(0, 3));
    jf.getContentPane().add(bd);
    jf.getContentPane().add(bd2);
    jf.getContentPane().add(bd3);
    jf.setVisible(true);

    for (int i = 0; i < 20000; i++) {
      Thread.sleep(100);
      pos = pos + (int)(5 - 10 * Math.random());
      pos2 = pos2 + (int)(5 - 10 * Math.random());
      pos3 = pos3 + (int)(5 - 10 * Math.random());

      if (pos < 0) {
        pos = 0;
      }
      if (pos3 < 0) {
        pos3 = 0;
      }

      data[(60 + i) % data.length] = pos;
      data2[(60 + i) % data2.length] = pos2;
      data3[(60 + i) % data3.length] = pos3;
      bd.setData(0, data, i % data.length, 60);
      bd.setData(1, data2, i % data2.length, 60);
      bd.setData(2, data3, i % data3.length, 60);
      bd2.setData(0, data, i % data.length, 60);
      bd2.setData(1, data2, i % data2.length, 60);
      bd2.setData(2, data3, i % data3.length, 60);
      bd3.setData(0, data, i % data.length, 60);
      bd3.setData(1, data2, i % data2.length, 60);
      bd3.setData(2, data3, i % data3.length, 60);
    }
  }

  private static DotDiagram setupDiagram(int v, int[] d1, int[] d2, int[] d3,
           int mode) {
    DotDiagram bd = new DotDiagram(v, mode);
    bd.setDotColor(0, Color.red);
    bd.setDotColor(1, Color.green);
    bd.setDotColor(2, Color.blue);
    bd.addConstant(Color.yellow, 100);
    bd.setShowGrid(true);
    bd.setYLabel("The Y-Axis ("
     + (mode == NORMAL ? "normal" : "additive")
     + ')');
    bd.setData(0, d1, 0, 60);
    bd.setData(1, d2, 0, 60);
    bd.setData(2, d3, 0, 60);
    return bd;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/DebugInfo.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * DebugInfo - contains some debug info
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;

public class DebugInfo {

  private String file;
  private String path;
  private int lineNo;
  private String function;

  public DebugInfo(int line, String path, String file, String fun) {
    this.lineNo = line;
    this.file = file;
    this.path = path;
    this.function = fun;
  }

  public String getFile() {
    return file;
  }

  public String getPath() {
    return path;
  }

  public String getFunction() {
    return function;
  }

  public int getLine() {
    return lineNo;
  }
  
  public String toString() {
    return "Line: " + lineNo + " in file: " + file + " (function: " + function + ")";
  }

} // DebugInfo

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/Utils.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * Utils
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;

public class Utils {
  private static final String str16 = "0000000000000000";

  public static final int BYTE = 0;
  public static final int UBYTE = 1;
  public static final int WORD = 2;
  public static final int UWORD = 3;
  
  public static final int ASCII = 1;
  public static final int HEX = 2;
  public static final int DEC = 3;
  public static final int ASCII_UNMODIFIED = 4;
  public static final int DIS_ASM = 5;
  
  public static int size(int type) {
      return 1 + (type / 2);
  }

  public static String toString(int data, int type, int mode) {
      int size = 1 + type / 2;
      switch (mode) {
      case    ASCII:
          if (data >= 32 && data <= 127) {
              return "" + ((char) data);
          } else {
              return ".";
          }
      case    ASCII_UNMODIFIED:
          return "" + ((char) data);
      case    HEX: 
          return (size == 2 ? Utils.hex16(data):Utils.hex8(data));
      }
      return "" + data;
  }
  
  public static String binary8(int data) {
    String s = Integer.toString(data, 2);
    if (s.length() < 8) {
      s = str16.substring(0, 8 - s.length()) + s;
    }
    return s;
  }

  public static String binary16(int data) {
    String s = Integer.toString(data, 2);
    if (s.length() < 16) {
      s = str16.substring(0, 16 - s.length()) + s;
    }
    return s;
  }

  public static String hex(int data) {
      return Integer.toString(data, 16);
  }

  public static String hex(int data, int len) {
      String s = Integer.toString(data, 16);
      if (s.length() < len) {
        s = str16.substring(0, len - s.length()) + s;
      }
      return s;
  }

  public static String hex8(int data) {
      return hex(data & 0xff, 2);
  }

  public static String hex16(int data) {
      return hex(data & 0xffff, 4);
  }

  public static String hex20(int data) {
      return hex(data & 0xfffff, 5);
  }

  public static String hex24(int data) {
      return hex(data & 0xffffff, 6);
  }

  public static int decodeInt(String value) throws NumberFormatException {
    int radix = 10;
    int index = 0;
    boolean negative = false;
    if (value.startsWith("-")) {
      index++;
      negative = true;
    }

    if (value.startsWith("$", index) || value.startsWith("#", index)) {
      radix = 16;
      index++;
    } else if (value.startsWith("0x", index) || value.startsWith("0X", index)) {
      radix = 16;
      index += 2;
    } else if (value.startsWith("0", index) && value.length() > index + 1) {
      radix = 8;
      index++;
    } else if (value.startsWith("%", index)) {
      radix = 2;
      index++;
    }
    String intValue = value;
    if (radix != 10) {
      if (value.startsWith("-", index)) {
        throw new NumberFormatException("unexpected negative sign: " + value);
      }
      if (negative) {
        intValue = '-' + value.substring(index);
      } else {
        intValue = value.substring(index);
      }
    }
    return Integer.parseInt(intValue, radix);
  }

  public static long decodeLong(String value) throws NumberFormatException {
    int radix = 10;
    int index = 0;
    boolean negative = false;
    if (value.startsWith("-")) {
      index++;
      negative = true;
    }

    if (value.startsWith("$", index) || value.startsWith("#", index)) {
      radix = 16;
      index++;
    } else if (value.startsWith("0x", index) || value.startsWith("0X", index)) {
      radix = 16;
      index += 2;
    } else if (value.startsWith("0", index) && value.length() > index + 1) {
      radix = 8;
      index++;
    } else if (value.startsWith("%", index)) {
      radix = 2;
      index++;
    }
    String longValue = value;
    if (radix != 10) {
      if (value.startsWith("-", index)) {
        throw new NumberFormatException("unexpected negative sign: " + value);
      }
      if (negative) {
        longValue = '-' + value.substring(index);
      } else {
        longValue = value.substring(index);
      }
    }
    return Long.parseLong(longValue, radix);
  }

  /* converts hexa-decimal data in a string to an array of bytes */
  public static byte[] hexconv(String line) {
    if (line == null) {
      return null;
    }
    byte[] data = new byte[line.length() / 2]; 
    int hpos = 0;
    int totVal = 0;
    int dataPos = 0;
    for (int i = 0, n = line.length(); i < n; i++) {
      int val = line.charAt(i);
      if (val >= '0' && val <= '9') {
        val = val - '0';
      } else if (val >= 'a' && val <= 'f') {
        val = val + 10 - 'a';  
      } else if (val >= 'A' && val <= 'F'){
        val = val + 10 - 'A';  
      } else {
        // Not a hexa-decimal format
        return null;
      }

      if (hpos == 0) {
        totVal = val << 4;
        hpos++;
      } else {
        totVal = totVal + val;
        hpos = 0;
        data[dataPos++] = (byte) (totVal & 0xff);
      }
    }
    return data;
  }

  public static boolean equals(byte[] arr1, byte[] arr2) {
    if (arr1 == null && arr2 == null) return true;
    if (arr1 == null || arr2 == null) return false;
    if (arr1.length != arr2.length) return false;
    for (int i = 0; i < arr1.length; i++) {
      if (arr1[i] != arr2[i]) return false;
    }
    return true;
  }


//  public static void main(String[] args) {
//    System.out.println("Hex 47 = " + hex8(47));
//  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ELFException.java`:

```java
package se.sics.mspsim.util;

import java.io.IOException;

public class ELFException extends IOException {
  private static final long serialVersionUID = 6288198720830818497L;

  ELFException(String message) {
    super(message);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/TSPTest.java`:

```java
package se.sics.mspsim.util;

import se.sics.jipv6.core.AbstractPacketHandler;
import se.sics.jipv6.core.ICMP6Packet;
import se.sics.jipv6.core.IPStack;
import se.sics.jipv6.core.IPv6Packet;
import se.sics.jipv6.core.Packet;
import se.sics.jipv6.tunnel.TSPClient;

public class TSPTest extends AbstractPacketHandler implements Runnable {

  public byte[] GOOGLE = new byte[] {
      0x20, 0x01,  0x48, 0x60,  (byte) 0xb0, 0x02,  0x00, 0x00,
      0x00, 0x00,  0x00, 0x00,  0x00, 0x00,  0x00, 0x68
  };
  static IPStack ipStack;
  
  public static void main(String[] args) {
    ipStack = new IPStack();
    TSPTest testLink = new TSPTest();
    ipStack.setLinkLayerHandler(testLink);
    TSPClient tunnel = TSPClient.startTSPTunnel(ipStack, "anon.freenet6.net", null, null);
    ipStack.setTunnel(tunnel);
    
    new Thread(testLink).start();
   
  }

  public void run() {
    IPv6Packet ping = new IPv6Packet();
    ping.setDestinationAddress(GOOGLE);
    ping.setSourceAddress(ipStack.getIPAddress());
    ICMP6Packet icmpER = new ICMP6Packet();
    icmpER.setType(ICMP6Packet.ECHO_REQUEST);
    ping.setIPPayload(icmpER);
    while(true) {
      try {
        Thread.sleep(10000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      System.out.println("Sending ping to google...");
      ipStack.sendPacket(ping, null);
    }
  }
  
  public void packetReceived(Packet container) {
    System.out.println("Packet received from IP Stack...: " + container);
  }

  public void sendPacket(Packet packet) {  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/MultiDataSource.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * MultiDataSource
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : 11 March 2008
 * Updated : $Date$
 *           $Rev$
 */
package se.sics.mspsim.util;

public interface MultiDataSource {

  public int getModeMax();

  public double getDoubleValue(int mode);
  public int getValue(int mode);

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/DefaultEmulationLogger.java`:

```java
package se.sics.mspsim.util;

import java.io.PrintStream;

import se.sics.mspsim.core.EmulationException;
import se.sics.mspsim.core.EmulationLogger;
import se.sics.mspsim.core.LogListener;
import se.sics.mspsim.core.Loggable;
import se.sics.mspsim.core.MSP430Core;

public class DefaultEmulationLogger implements EmulationLogger {

  private final MSP430Core cpu;
  private final WarningMode[] warningModes = new WarningMode[WarningType.values().length];
  private WarningMode defaultMode = WarningMode.PRINT;
  private PrintStream out;
  private LogListener[] logListeners;
  
  public DefaultEmulationLogger(MSP430Core cpu, PrintStream out) {
    this.cpu = cpu;
    this.out = out;
  }

  protected WarningMode getMode(WarningType type) {
      WarningMode mode = warningModes[type.ordinal()];
      if (mode == null) {
          mode = defaultMode;
      }
      return mode;
  }

  @Override
  public void log(Loggable source, String message) {
//      out.println(source.getID() + ": " + message);
      LogListener[] listeners = this.logListeners;
      if (listeners != null) {
          for (LogListener l : listeners) {
              l.log(source, message);
          }
      }
  }

  @Override
  public void logw(Loggable source, WarningType type, String message)
          throws EmulationException {
      switch (getMode(type)) {
      case SILENT:
          break;
      case PRINT:
          out.println(source.getID() + ": " + message);
          cpu.generateTrace(out);
          break;
      case EXCEPTION:
          out.println(source.getID() + ": " + message);
          cpu.generateTrace(out);
          throw new EmulationException(message);
      }

      LogListener[] listeners = this.logListeners;
      if (listeners != null) {
          for (LogListener l : listeners) {
              l.logw(source, type, message);
          }
      }
  }

  @Override
  public WarningMode getDefaultWarningMode() {
      return defaultMode;
  }

  @Override
  public void setDefaultWarningMode(WarningMode mode) {
      this.defaultMode = mode;
  }

  @Override
  public WarningMode getWarningMode(WarningType type) {
      return warningModes[type.ordinal()];
  }

  @Override
  public void setWarningMode(WarningType type, WarningMode mode) {
      warningModes[type.ordinal()] = mode;
  }

  @Override
  public synchronized void addLogListener(LogListener listener) {
      logListeners = ArrayUtils.add(LogListener.class, logListeners, listener);
  }

  @Override
  public synchronized void removeLogListener(LogListener listener) {
      logListeners = ArrayUtils.remove(logListeners, listener);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/NetworkPacket.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id: $
 *
 * -----------------------------------------------------------------
 *
 * NetworkPacket
 *
 * Author  : Joakim Eriksson
 * Created : 31 mar 2008
 * Updated : $Date:$
 *           $Revision:$
 */

package se.sics.mspsim.util;
import java.util.Enumeration;
import java.util.Hashtable;

public class NetworkPacket {
  byte[] data;
  String description;
  public static final String IPv6 = 
    "version:4=6|trafficClass:8|flowLabel:20" +
    "|payloadLength:16|nextHeader:8|hopLimit:8" +
    "|sourceAddress:128|destinationAddress:128";

  Hashtable<String,Field> fields = new Hashtable<String,Field>();

  private static class Field {
    String name;
    int pos;
    int size;
    int mask = 0;
    int value = 0;

    Field(String name, int pos, int size) {
      this.name = name;
      this.pos = pos;
      this.size = size;
    }

    public void setMatchMask(int mask, int value) {
      this.mask = mask;
      this.value = value;
    }
    
    public String toString() {
      return name + ":" + pos + "-" + (pos + size - 1) + 
      (mask != 0 ? "=" + value : "");
    }
  }


  public NetworkPacket(String pattern) {
      description = pattern;      
      String[] parts = description.split("\\|");
      int pos = 0;
      for (int i = 0; i < parts.length; i++) {
        String field[] = parts[i].split(":");
        String val = field[1];
        String matchVal = null;
        if (val.indexOf('=') > 0) {
          String[] match = val.split("=");
          val = match[0];
          matchVal = match[1];
        }
        int size = Integer.parseInt(val);
        Field f = new Field(field[0], pos, size);
        if (matchVal != null) {
          int mask = Integer.parseInt(matchVal);
          f.setMatchMask(mask, mask);
        }
        pos += size;
        System.out.println("Adding field: " + f);
        fields.put(f.name, f);
      }
  }


  NetworkPacket(String pattern, Hashtable<String, Field> fields) {
    this.description = pattern;
    this.fields = fields;
  }
  
  public boolean matches(byte[] data) {
    for (Enumeration<Field> iterator = fields.elements(); iterator.hasMoreElements();) {
      Field f = iterator.nextElement();
      if (f.mask != 0) {
        int val = getIntBits(data, f.pos, f.pos + f.size - 1);
        if ((val & f.mask) != f.value) {
          return false;
        } else {
          System.out.println("Field: " + f.name + " matches");
        }
      }
    }
    return true;
  }
  
  /* create a network packet based on a packet with description */
  public NetworkPacket parseData(byte[] data) {
    if (matches(data)) {
      NetworkPacket np = new NetworkPacket(description, fields);
      np.data = data;
      return np;
    }
    return null;
  }

  public int getLength() {
    return data.length;
  }

  public static int getIntBits(byte[] data, int startBit, int endBit) {
    int startByte = startBit >> 8;
    int endByte = endBit >> 8;
    startBit = startBit & 7;
    endBit = endBit & 7;

    int result = 0;
    for (int i = startByte; i < endByte + 1; i++) {
      int bt = data[i] & 0xff;

      if (i == startByte) {
        bt = bt >> startBit;
      }
      if (i == endByte) {
        // Rotate with 0 -- 7
        bt = bt >> (7 - endBit);
      }
      result = (result << 8) | bt;
    }
    return result;
  }

  public int getInt(String field) {
    Field f = fields.get(field);
    return getIntBits(data, f.pos, f.pos + f.size - 1);
  }

  public static void main(String[] args) {
    byte data[] = new byte[] {
        0x61, 0x04, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    };
    NetworkPacket np = new NetworkPacket(IPv6);
    np = np.parseData(data);
    System.out.println("Version: " + NetworkPacket.getIntBits(np.data, 0, 3));
    System.out.println("Version: " + np.getInt("version"));
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/PluginRepository.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * PluginRepository
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Wed Feb 13 19:51:00 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;
import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

public class PluginRepository implements ActiveComponent {

  private URLClassLoader classLoader;

  @Override
  public void init(String name, ComponentRegistry registry) {
    File dir = new File("plugins");
    if (dir.isDirectory()) {
      File[] files = dir.listFiles(new JarFilter());
      if (files != null) {
	try {
	  URL[] jarFiles = new URL[files.length];
	  String[] plugins = new String[files.length];
	  int pluginCount = 0;
	  for (int i = 0, n = files.length; i < n; i++) {
	    URL jarURL = files[i].toURI().toURL();
// 	    System.out.println("JAR FILE: " + jarURL);
	    JarFile jarFile = new JarFile(files[i]);
	    Manifest mf = jarFile.getManifest();
	    Attributes attr = mf.getMainAttributes();
	    String pluginBundle = attr.getValue("mspsim-plugin");
	    if (pluginBundle != null) {
	      plugins[pluginCount++] = pluginBundle;
	    }
	    jarFiles[i] = jarURL;
	    jarFile.close();
	  }

	  classLoader = URLClassLoader.newInstance(jarFiles);

	  for (int i = 0; i < pluginCount; i++) {
	    try {
              PluginBundle bundle = (PluginBundle)
			      classLoader.loadClass(plugins[i]).getDeclaredConstructor().newInstance();
	      bundle.init(registry);
	    } catch (Exception e) {
	      // TODO: handle exception
	    }
	  }
	} catch (IOException e) {
	  e.printStackTrace();
	}
      }
    }
  }

  public Class<?> loadClass(String name) throws ClassNotFoundException {
    if (classLoader == null) {
      return Class.forName(name);
    }
    return classLoader.loadClass(name);
  }

  @Override
  public void start() {
  }

  private static class JarFilter implements FileFilter {

    public boolean accept(File f) {
      if (f.isFile() && f.canRead()) {
	String name = f.getName().toLowerCase();
	return name.endsWith(".jar");
      }
      return false;
    }

  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ELFSection.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ELFSection
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;

import se.sics.mspsim.debug.DwarfReader;

public class ELFSection {

  public static final int TYPE_NULL       =   0;
  public static final int TYPE_PROGBITS   =   1;
  public static final int TYPE_SYMTAB     =   2;
  public static final int TYPE_STRTAB	  =   3;
  public static final int TYPE_RELA	  =   4;
  public static final int TYPE_HASH	  =   5;
  public static final int TYPE_DYNAMIC    =   6;
  public static final int TYPE_NOTE	  =   7;
  public static final int TYPE_NOBITS	  =   8;
  public static final int TYPE_REL	  =   9;
  public static final int TYPE_SHLIB      =  10;
  public static final int TYPE_DYNSYM     =  11;

  public static final int SYMBIND_LOCAL = 0;
  public static final int SYMBIND_GLOBAL = 1;
  public static final int SYMBIND_WEAK = 2;

  public static final int SYMTYPE_NONE = 0;
  public static final int SYMTYPE_OBJECT = 1;
  public static final int SYMTYPE_FUNCTION = 2;
  public static final int SYMTYPE_SECTION = 3;
  public static final int SYMTYPE_FILE = 4;

  public static final String[] typeNames = new String[] {
    "null", "progbits", "symtab", "strtab", "rela",
    "hash", "dynamic", "note", "nobits", "rel", "shlib", "dynsym"
  };

  public static final String[] symTypeNames = new String[] {
    "none", "object", "function", "section", "file"
  };

  int name;
  int type;
  int flags;
  int addr;
  private int offset;
  int size;
  int link;
  int info;
  int addralign;
  private int entrySize;

  ELF elf;

  int pos = 0;
  
  public String getSectionName() {
    if (elf.strTable != null) {
      return elf.strTable.getName(name);
    } else {
      return Integer.toString(name, 16);
    }
  }

  public void reset() {
      pos = 0;
  }

  public int getPosition() {
      return pos;
  }
  
  public int getSize() {
      return size;
  }
  
  public String getName(int i) {
    int pos = getOffset() + i;
    StringBuilder sb = new StringBuilder();
    char c;
    int elfSize = elf.elfData.length;
    while (pos < elfSize && (c = (char) elf.elfData[pos++]) != 0) {
      sb.append(c);
    }
    return sb.toString();
  }

  public String readString() {
      StringBuilder sb = new StringBuilder();
      int c;
      while ((c = readElf8()) != 0) {
          sb.append((char)c);
      }
      return sb.toString();
  }

  public int readElf8() {
      return readElf8(pos++);
  }
  
  public int readElf16() {
      int val = readElf16(pos);
      pos += 2;
      return val;
  }
  
  public int readElf32() {
      int val = readElf32(pos);
      pos += 4;
      return val;
  }

  public long readLEB128() {
      long val = 0;
      /* LSB first always? */
      int b;
      int bitPos = 0;
      do {
          b = readElf8(pos++);
          val = val + ((b & 127) << bitPos);
          bitPos += 7;
      } while ((b & 128) != 0);
      return val;
  }

  public long readLEB128S() {
      long val = 0;
      /* LSB first always? */
      int b;
      int bitPos = 0;
      do {
          b = readElf8(pos++);
          val = val + ((b & 127) << bitPos);
          bitPos += 7;
      } while ((b & 128) != 0);
      long negval = 0x1 << bitPos;
      if (b < 0x40) {
          return val;
      }
      if (ELF.DEBUG || DwarfReader.DEBUG)
          System.out.println("Line: read negative : " + val + " negval: " + negval);
      return -(negval - val);
  }

  public int readElf8(int pos) {
      return elf.readElf8(pos + getOffset());
  }

  public int readElf16(int pos) {
      return elf.readElf16(pos + getOffset());
  }

  public int readElf32(int pos) {
      return elf.readElf32(pos + getOffset());
  }
  
  public int LEB128Size(long val) {
      /* at least one byte, but possibly more */
      return (int) (1 + (val / 128));
  }

  public long readLEB128(int pos) {
      long val = 0;
      /* LSB first always? */
      int b;
      int bitPos = 0;
      do {
          b = readElf8(pos++);
          val = val + ((b & 127) << bitPos);
          bitPos += 7;
      } while ((b & 128) != 0);
      return val;
  }
  
  
  public String toString() {
    String nameStr = getSectionName();
    return "name: " + nameStr +
      "\ntype: " + Integer.toString(type, 16) +
      ((type <= TYPE_DYNSYM) ? " " + typeNames[type] : "") +
      "\nflags: " + Integer.toString(flags, 16) +
      "\naddr: " + Integer.toString(addr, 16) +
      "\noffset: " + Integer.toString(getOffset(), 16) +
      "\nsize: " + Integer.toString(size, 16) +
      "\nlink: " + Integer.toString(link, 16) +
      "\ninfo: " + Integer.toString(info, 16);
  }

public void setEntrySize(int entrySize) {
    this.entrySize = entrySize;
}

public int getEntrySize() {
    return entrySize;
}

public void setOffset(int offset) {
    this.offset = offset;
}

public int getOffset() {
    return offset;
}

} // ELFSection

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/OperatingModeStatistics.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * OperatingModeStatistics
 *
 * Author  : Joakim Eriksson
 * Created : 17 jan 2008
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;

import java.io.PrintStream;
import java.util.ArrayList;

import se.sics.mspsim.core.Chip;
import se.sics.mspsim.core.MSP430Core;
import se.sics.mspsim.core.OperatingModeListener;

/**
 * @author Joakim
 *
 */
public class OperatingModeStatistics {

  public static final int OP_NORMAL = 0;
  public static final int OP_INVERT = 1;

  private final MSP430Core cpu;
  private ArrayList<StatEntry> statistics = new ArrayList<StatEntry>();

  public OperatingModeStatistics(MSP430Core cpu) {
    this.cpu = cpu;
  }

  private synchronized StatEntry getStatEntry(String name) {
      for (StatEntry entry : statistics) {
          if (name.equalsIgnoreCase(entry.chip.getID()) ||
                  name.equalsIgnoreCase(entry.chip.getName())) {
              return entry;
          }
      }
      return null;
  }

  public Chip getChip(String chipName) {
    StatEntry entry = getStatEntry(chipName);
    return entry == null ? null : entry.chip;
  }

  public synchronized Chip[] getChips() {
    Chip[] chips = new Chip[statistics.size()];
    int index = 0;
    for (StatEntry entry : statistics) {
      chips[index++] = entry.chip;
    }
    return chips;
  }

  public void addMonitor(Chip chip) {
    StatEntry entry = new StatEntry(chip);
    synchronized (this) {
        statistics.add(entry);
    }
  }

  public synchronized void printStat() {
    for (StatEntry entry : statistics) {
      entry.printStat(System.out);
    }
  }

  public DataSource getDataSource(String chip, int mode) {
    return getDataSource(chip, mode, OP_NORMAL);
  }

  public DataSource getDataSource(String chip, String modeStr) {
    StatEntry se = getStatEntry(chip);
    if (se != null) {
      int mode = se.chip.getModeByName(modeStr);
      if (mode != -1) { 
        return new StatDataSource(se, mode, OP_NORMAL);
      }
    }
    return null;
  }

  
  public DataSource getDataSource(String chip, int mode, int operation) {
    StatEntry se = getStatEntry(chip);
    if (se != null) {
      return new StatDataSource(se, mode, operation);
    }
    return null;
  }

  public MultiDataSource getMultiDataSource(String chip) {
    StatEntry se = getStatEntry(chip);
    if (se != null) {
      return new StatMultiDataSource(se);
    }
    return null;  
  }

  private class StatDataSource implements DataSource {

    private final StatEntry entry;
    private final int mode;
    private final int operation;
    private long lastCycles;
    private long lastValue;
    
    public StatDataSource(StatEntry entry, int mode, int operation) {
      this.entry = entry;
      this.mode = mode;
      this.operation = operation;
      this.lastCycles = cpu.cycles;
      this.lastValue = entry.getValue(mode, this.lastCycles);
    }

    // returns percentage since last call...
    public double getDoubleValue() {
      long diff = cpu.cycles - lastCycles;
      if (diff == 0) return 0;
      long val = entry.getValue(mode, cpu.cycles);
      long valDiff = val - lastValue;
      lastValue = val;
      lastCycles = cpu.cycles;
      if (operation == OP_INVERT) {
        return (100.0 - (100.0 * valDiff) / diff); 
      }
      return (100.0 * valDiff) / diff;
    }

    public int getValue() {
      return (int) getDoubleValue();
    }
  }

  private class StatMultiDataSource implements MultiDataSource {

    private final StatEntry entry;
    private long[] lastValue;
    private long[] lastCycles;
    
    public StatMultiDataSource(StatEntry entry) {
      this.entry = entry;
      this.lastValue = new long[entry.elapsed.length];
      this.lastCycles = new long[entry.elapsed.length];
      long cycles = cpu.cycles;
      for (int i = 0, n = this.lastValue.length; i < n; i++) {
        this.lastValue[i] = entry.getValue(i, cycles);
        this.lastCycles[i] = cycles;
      }
    }
    
    public int getModeMax() {
      return entry.chip.getModeMax();
    }

    // returns percentage since last call...
    public int getValue(int mode) {
      return (int) getDoubleValue(mode);
    }
    
    public double getDoubleValue(int mode) {
      long diff = cpu.cycles - lastCycles[mode];
      if (diff == 0) return 0;

      long val = entry.getValue(mode, cpu.cycles);
      long valDiff = (val - lastValue[mode]);
      lastValue[mode] = val;
      lastCycles[mode] = cpu.cycles;
      return (100.0 * valDiff) / diff;
    }

  }


  private class StatEntry implements OperatingModeListener {
    final Chip chip;
    long startTime;
    int mode;
    long[] elapsed;

    StatEntry(Chip chip) {
      this.chip = chip;
      this.elapsed = new long[chip.getModeMax() + 1];
      this.mode = chip.getMode();
      this.startTime = cpu.cycles;
      chip.addOperatingModeListener(this);
    }

    long getValue(int mode, long cycles) {
      if (mode == this.mode) {
        return elapsed[mode] + (cycles - startTime);
      }
      return elapsed[mode];
    }

    public void modeChanged(Chip source, int mode) {
      this.elapsed[this.mode] += cpu.cycles - startTime;
      this.mode = mode;
      this.startTime = cpu.cycles;
    }

    void printStat(PrintStream out) {
      out.println("Stat for: " + chip.getID());
      for (int i = 0; i < elapsed.length; i++) {
        out.println("" + (i + 1) + " = " + elapsed[i]);
      }
    }
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ELFProgram.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ELFProgram
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;

public class ELFProgram {

  int type;
  int offset;
  int vaddr;
  int paddr;
  int fileSize;
  int memSize;
  int flags;
  int align;

  public String toString() {
    return "type: " + Integer.toString(type, 16) +
      "\noffset: " + Integer.toString(offset, 16) +
      "\nvaddr: " + Integer.toString(vaddr, 16) +
      "\npaddr: " + Integer.toString(paddr, 16) +
      "\nfileSize: " + Integer.toString(fileSize, 16) +
      "\nmemSize: " + Integer.toString(memSize, 16);
  }


} // ELFProgram

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ArrayUtils.java`:

```java
package se.sics.mspsim.util;

public class ArrayUtils {

  @SuppressWarnings("unchecked")
  public static <T> T[] add(Class<T> componentType, T[] array, T value) {
    T[] tmp;
    if (array == null) {
      tmp = (T[]) java.lang.reflect.Array.newInstance(componentType, 1);
    } else {
      tmp = (T[]) java.lang.reflect.Array.newInstance(componentType, array.length + 1);
      System.arraycopy(array, 0, tmp, 0, array.length);
    }
    tmp[tmp.length - 1] = value;
    return tmp;
  }

  public static <T> T[] remove(T[] array, T value) {
    if (array != null) {
      for (int index = 0, n = array.length; index < n; index++) {
        if (value.equals(array[index])) {
          if (n == 1) {
            return null;
          }
          @SuppressWarnings("unchecked")
          T[] tmp = (T[]) java.lang.reflect.Array.newInstance(array.getClass().getComponentType(), array.length - 1);
          if (index > 0) {
            System.arraycopy(array, 0, tmp, 0, index);
          }
          if (index < tmp.length) {
            System.arraycopy(array, index + 1, tmp, index, tmp.length - index);
          }
          return tmp;
        }
      }
    }
    return array;
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ELFDebug.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ELFDebug
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;
import java.util.ArrayList;

public interface ELFDebug {

  public DebugInfo getDebugInfo(int address);

  public ArrayList<Integer> getExecutableAddresses();

  public String[] getSourceFiles();

} // ELFDebug

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ProxySupport.java`:

```java
/**
 * Copyright (c) 2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ProxySupport
 *
 * Author  : Niclas Finne
 * Created : 22 mar 2012
 */

package se.sics.mspsim.util;

public abstract class ProxySupport<T> implements Cloneable {

    private final Class<T> type;
    protected T[] listeners;

    @SuppressWarnings("unchecked")
    protected ProxySupport() {
        Class<?>[] interfaces = getClass().getInterfaces();
        if (interfaces.length != 1) {
            throw new IllegalStateException("proxy does not implement one interface");
        }
        type = (Class<T>) interfaces[0];
    }

    @SuppressWarnings("unchecked")
    public T add(T oldListener, T newListener) {
        if (oldListener == null) {
            return newListener;
        }
        if (oldListener instanceof ProxySupport<?>) {
            ProxySupport<T> proxy = (ProxySupport<T>) oldListener;
            proxy.listeners = ArrayUtils.add(type, proxy.listeners, newListener);
            return oldListener;
        }

        // A new proxy is needed
        ProxySupport<T> newProxy;
        try {
            newProxy = (ProxySupport<T>) clone();
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
        T[] tmp = (T[]) java.lang.reflect.Array.newInstance(type, 2);
        tmp[0] = oldListener;
        tmp[1] = newListener;
        newProxy.listeners = tmp;
        return (T) newProxy;
    }

    public T remove(T oldListener, T listener) {
        if (oldListener == listener) {
            return null;
        }
        if (oldListener instanceof ProxySupport<?>) {
            @SuppressWarnings("unchecked")
            ProxySupport<T> proxy = (ProxySupport<T>) oldListener;
            T[] l = ArrayUtils.remove(proxy.listeners, listener);
            if (l == null) {
                return null;
            }
            if (l.length == 1) {
                return l[0];
            }
            proxy.listeners = l;
        }
        return oldListener;
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/IHexReader.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * IHexReader
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import se.sics.mspsim.config.MSP430f1611Config;
import se.sics.mspsim.core.MSP430;

public class IHexReader {

  // 64k tmp ram!
  private int tmpMemory[] = new int[64 * 1024];

  /**
   * Creates a new <code>IHexReader</code> instance.
   *
   */
  public IHexReader() {
  }

  public boolean readFile(int memory[], String file) {
    for (int i = 0, n = tmpMemory.length; i < n; i++) {
      tmpMemory[i] = -1;
    }
    try {
      BufferedReader bInput = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
      String line;
      boolean terminate = false;
      while ((line = bInput.readLine()) != null && !terminate) {
	if (line.charAt(0) != ':') {
	  System.out.println("Not an IHex file?! " + line.charAt(0));
	  bInput.close();
	  return false;
	}
	int size = hexToInt(line.charAt(1)) * 0x10 + hexToInt(line.charAt(2));
	int adr =  hexToInt(line.charAt(3)) * 0x1000 +
	  hexToInt(line.charAt(4)) * 0x100 + hexToInt(line.charAt(5)) * 0x10 +
	  hexToInt(line.charAt(6));
	int type = hexToInt(line.charAt(7)) * 0x10 + hexToInt(line.charAt(8));
// 	System.out.println("Block:  size: " + size + "=>  address: " +
// 			   hex(adr) +   "  type: " + type);

	// Termination !!!
	if (type == 0x01) {
	  System.out.println("IHEX file ended (termination)");
	  terminate = true;
	} else {
	  int index = 9;
	  for (int i = 0, n = size; i < n; i++) {
	    tmpMemory[adr + i] = (hexToInt(line.charAt(index++)) * 0x10 +
				  hexToInt(line.charAt(index++)));
	  }

//	  int checksum = (byte) hexToInt(line.charAt(index++)) * 0x10
//	    + hexToInt(line.charAt(index++));
	  //	System.out.println("Checksum: " + checksum);
	}
      }
      bInput.close();

      // Write all data that we got in to the real memory!!!
      System.out.println("Writing to memory!");
      for (int i = 0, n = tmpMemory.length; i < n; i++) {
	if (tmpMemory[i] != -1) {
	  memory[i] = tmpMemory[i];
	}
      }

      return true;
    } catch (IOException ioe) {
      ioe.printStackTrace();
    }
    return false;
  }

  private static String hex(int data) {
    return Integer.toString(data, 16);
  }

  private static int hexToInt(char c) {
    if (c >= '0' && c <= '9') {
      return c - '0';
    } else {
      return c - 'A' + 10;
    }
  }

  public static void main(String[] args) throws Exception {
    IHexReader reader = new IHexReader();
    int data = 0x84;
    System.out.println("RRA: " + hex((data & 0x80) + (data >> 1)));

//     for (int i = 0, n = 0x3ff; i < n; i++) {
//       int val = (i & 0x200) == 0 ? i : -(0x200 - (i & 0x1ff));
//     System.out.println("Value: " + val);
//     }
//     System.out.println("T ^ T =>  " + (true ^ true) +
// 		       " T ^ F => " + (false ^ true));

    MSP430 cpu = new MSP430(0, new ComponentRegistry(), new MSP430f1611Config());
    int[] memory = cpu.memory;
    reader.readFile(memory, args[0]);
    cpu.reset();
    cpu.cpuloop();
  }


}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/PrefixConfigManager.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * PrefixConfigManager
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : Fri Oct 11 15:24:14 2002
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;

/**
 *
 */
public class PrefixConfigManager extends ConfigManager {

  private final ConfigManager config;
  private final String shortPrefix;
  private final String longPrefix;

  public PrefixConfigManager(ConfigManager config, String prefix, String name) {
    this(config, prefix, name, '.');
  }

  public PrefixConfigManager(ConfigManager config, String prefix,
                 String name, char separator) {
    if (config == null) {
      throw new NullPointerException();
    }
    this.config = config;
    prefix = prefix != null && prefix.length() > 0 ? (prefix + separator) : null;

    if (name != null && name.length() > 0) {
      this.longPrefix =	prefix == null ? (name + separator) : (prefix + name + separator);
      this.shortPrefix = prefix;
    } else if (prefix != null) {
      this.longPrefix = prefix;
      this.shortPrefix = null;
    } else {
      this.longPrefix = "";
      this.shortPrefix = null;
    }
  }

  public String getProperty(String name, String defaultValue) {
    String value = config.getProperty(longPrefix + name);
    if (value != null) {
      return value;
    }
    if (shortPrefix == null) {
      return defaultValue;
    }
    return config.getProperty(shortPrefix + name, defaultValue);
  }

  public void setProperty(String name, String value) {
    config.setProperty(longPrefix + name, value);
  }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ArrayFIFO.java`:

```java
package se.sics.mspsim.util;

import se.sics.mspsim.core.EmulationException;

public class ArrayFIFO {

    public static final boolean STRICT = false;
    
    private final int memory[];
    private final int start;
    private final int size;
    private final String name;
    
    private int readPos = 0;
    private int writePos = 0;
    private int len = 0;

    private int markWritePos;
    
    public ArrayFIFO(String name, int[] mem, int start, int size) {
        memory = mem;
        this.name = name;
        this.start = start;
        this.size = size;
        len = 0;
    }

    
    public boolean write(int data) {
        memory[start + writePos++] = data;
        if (writePos >= size) {
            writePos = 0;
        }
        len++;
        return len == size;
    }
    
    public boolean isEmpty() {
        return len == 0;
    }
    
    public boolean isFull() {
        return len == size;
    }

    /* peek data as if it would be read, but leave it on the fifo */
    public int peek(int index) {
        int pos = readPos + index;
        if (pos < 0) {
            pos += size;
        } else if (pos >= size) {
            pos -= size;
        }        
        int v = memory[start + pos];
        return v & 0xff;
    }
    
    public int read() {
        if (len <= 0) {
            if (STRICT) {
                throw new EmulationException("Reading from empty FIFO");
            } else {
                /*System.out.println("Reading from empty FIFO");*/
                return 0;
            }
        }
        int v = memory[start + readPos++];
        if (readPos >= size) {
            readPos = 0;
        }
        len--;
        return v & 0xff;
    }
    
    /* get data relative the write position (typically negative input values */
    public int get(int index) {
        int pos = writePos + index;
        if (pos < 0) {
            pos += size;
        } else if (pos >= size) {
            pos -= size;
        }
        return memory[start + pos] & 0xff;
    }

    /* set data relative the write position (typically negative input values */
    public void set(int index, int data) {
        int pos = writePos + index;
        if (pos < 0) {
            pos += size;
        } else if (pos >= size) {
            pos -= size;
        }
        memory[start + pos] = data & 0xff;
    }

    
    public int length() {
        return len;
    }
    
    public void reset() {
        writePos = 0;
        readPos = 0;
        len = 0;
    }

    /* for marking a write pos - needed for supporting dropping non-matching packets */
    public void mark() {
        markWritePos = writePos;
    }
    
    public void restore() {
        writePos = markWritePos;
        len = writePos - readPos;
        if (len < 0) len += size;
    }


    public String stateToString() {
        return name + " len: " + len + " rpos: " + readPos + " wpos: " + writePos;
    }


    public boolean tailEquals(int[] data, int offset, int len) {
        return tailEquals(data, offset, len, 0);
    }


    public boolean tailEquals(int[] data, int offset, int len, int ignore) {
        for (int i = 0; i < len; i++) {
            if ((data[offset + i] & 0xff) != get(i - len - ignore)) {
                return false;
            }
        }
        return true;
    }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ELF.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * ELF
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.util;
import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;

import se.sics.mspsim.debug.DwarfReader;
import se.sics.mspsim.debug.StabDebug;

public class ELF {

  // private static final int EI_NIDENT = 16;
  private static final int EI_ENCODING = 5;
  private static final int[] MAGIC = new int[] {0x7f, 'E', 'L', 'F'};
  
  public static final boolean DEBUG = false;
  
  
  boolean encMSB = true;
  int type;
  int machine;
  int version;
  int entry;
  int phoff;
  int shoff;
  int flags;
  int ehsize;
  int phentsize;
  int phnum;
  int shentsize;
  int shnum;
  int shstrndx;

  byte[] elfData;
  private int pos = 0;

  private ELFSection sections[];
  private ELFProgram programs[];
  private ArrayList<FileInfo> files = new ArrayList<FileInfo>();

  ELFSection strTable;
  ELFSection symTable;
  ELFSection dbgStab;
  public ELFSection dbgStabStr;

  ELFDebug debug;

  public ELF(byte[] data) {
    elfData = data;
    setPos(0);
  }

  /* check if the file exists and is an ELF file */
  public static boolean isELF(File file) {
    try {
      InputStream input = new BufferedInputStream(new FileInputStream(file));
      for (int i = 0; i < MAGIC.length; i++) {
        if (MAGIC[i] != input.read()) {
          input.close();
          return false;
        }
      }
      input.close();
      return true;
    } catch(IOException ioe) {
      // ignore and return false - this is not an elf.
      return false;
    }
  }

  private void readHeader() throws ELFException {
    for (int i = 0; i < MAGIC.length; i++) {
      if (elfData[i] != (byte) (MAGIC[i] & 0xff)) {
        throw new ELFException("Not an elf file");
      }
    }
    
    if (elfData[EI_ENCODING] == 2) {
      encMSB = true;
    } else if (elfData[EI_ENCODING] == 1) {
      encMSB = false;
    } else {
      throw new ELFException("Illegal encoding: " + elfData[EI_ENCODING]);
    }
    
    setPos(getPos() + 16);
    type = readElf16();
    machine = readElf16();
    version = readElf32();
    entry = readElf32();
    phoff = readElf32();
    shoff = readElf32();
    flags = readElf32();
    ehsize = readElf16();
    phentsize = readElf16();
    phnum = readElf16();
    shentsize = readElf16();
    shnum = readElf16();
    shstrndx = readElf16();

    if (DEBUG) {
      System.out.println("-- ELF Header --");
      System.out.println("type: " + Integer.toString(type, 16));
      System.out.println("machine: " + Integer.toString(machine, 16));
      System.out.println("version: " + Integer.toString(version, 16));
      System.out.println("entry: " + Integer.toString(entry, 16));
      System.out.println("phoff: " + Integer.toString(phoff, 16));
      System.out.println("shoff: " + Integer.toString(shoff, 16));
      System.out.println("flags: " + Integer.toString(flags, 16));
      System.out.println("ehsize: " + Integer.toString(ehsize, 16));
      System.out.println("phentsize: " + Integer.toString(phentsize, 16));
      System.out.println("phentnum: " + Integer.toString(phnum, 16));
      System.out.println("shentsize: " + Integer.toString(shentsize, 16));
      System.out.println("shentnum: " + Integer.toString(shnum, 16));
      System.out.println("shstrndx: " + Integer.toString(shstrndx, 16));
    }
  }

  private ELFSection readSectionHeader() {
    ELFSection sec = new ELFSection();
    sec.name = readElf32();
    sec.type = readElf32();
    sec.flags = readElf32();
    sec.addr = readElf32();
    sec.setOffset(readElf32());
    sec.size = readElf32();
    sec.link = readElf32();
    sec.info = readElf32();
    sec.addralign = readElf32();
    sec.setEntrySize(readElf32());
    sec.elf = this;
    return sec;
  }

  private ELFProgram readProgramHeader() {
    ELFProgram pHeader = new ELFProgram();
    pHeader.type = readElf32();
    pHeader.offset = readElf32();
    pHeader.vaddr = readElf32();
    pHeader.paddr = readElf32();
    pHeader.fileSize = readElf32();
    pHeader.memSize = readElf32();
    pHeader.flags = readElf32();
    pHeader.align = readElf32();
    // 8 * 4 = 32
    if (phentsize > 32) {
      System.out.println("Program Header Entry SIZE differs from specs?!?!??!?!?***");
    }
    return pHeader;
  }

  public int getSectionCount() {
      return shnum;
  }

  public ELFSection getSection(int index) {
      return sections[index];
  }

  public int readElf32() {
      int val = readElf32(getPos());
      setPos(getPos() + 4);
      return val;
  }

  public int readElf16() {
      int val = readElf16(getPos());
      setPos(getPos() + 2);
      return val;
  }
  
  public int readElf8() {
      int val = readElf16(getPos());
      setPos(getPos() + 1);
      return val;
  }
  
  int readElf32(int pos) {
    int b = 0;
    if (encMSB) {
      b = (elfData[pos++] & 0xff) << 24 |
	((elfData[pos++] & 0xff) << 16) |
	((elfData[pos++] & 0xff) << 8) |
	(elfData[pos++] & 0xff);
    } else {
      b = (elfData[pos++] & 0xff) |
	((elfData[pos++] & 0xff) << 8) |
	((elfData[pos++] & 0xff) << 16) |
	((elfData[pos++] & 0xff) << 24);
    }
    return b;
  }

  int readElf16(int pos) {
    int b = 0;
    if (encMSB) {
      b = ((elfData[pos++] & 0xff) << 8) |
	(elfData[pos++] & 0xff);
    } else {
      b = (elfData[pos++] & 0xff) |
	((elfData[pos++] & 0xff) << 8);
    }
    return b;
  }

  int readElf8(int pos) {
    return elfData[pos++] & 0xff;
  }

  public static void printBytes(String name, byte[] data) {
    System.out.print(name + " ");
    for (byte element : data) {
      System.out.print("" + (char) element);
    }
    System.out.println("");
  }

  private void readSections() {
    setPos(shoff);

    sections = new ELFSection[shnum];
    for (int i = 0, n = shnum; i < n; i++) {
      sections[i] = readSectionHeader();
      if (sections[i].type == ELFSection.TYPE_SYMTAB) {
	symTable = sections[i];
      }
      if (i == shstrndx) {
	strTable = sections[i];
      }
    }

    boolean readDwarf = false;
    /* Find sections */
    for (int i = 0, n = shnum; i < n; i++) {
        String name = sections[i].getSectionName();
        if (DEBUG) {
          System.out.println("ELF-Section: " + name);
        }
      if (".stabstr".equals(name)) {
	dbgStabStr = sections[i];
      }
      if (".stab".equals(name)) {
	dbgStab = sections[i];
      }
      if (".debug_aranges".equals(name) || 
          ".debug_line".equals(name)) {
          readDwarf = true;
      }
    }
    if (readDwarf) {
        DwarfReader dwarf = new DwarfReader(this);
        dwarf.read();
        debug = dwarf;
    }

  }

  private void readPrograms() {
    setPos(phoff);
    programs = new ELFProgram[phnum];
    for (int i = 0, n = phnum; i < n; i++) {
      programs[i] = readProgramHeader();
      if (DEBUG) {
	System.out.println("-- Program header --\n" + programs[i].toString());
      }
    }
  }

  public void readAll() throws ELFException {
    readHeader();
    readPrograms();
    readSections();
    if (dbgStab != null) {
      debug = new StabDebug(this, dbgStab, dbgStabStr);
    }
  }

  public void loadPrograms(int[] memory) {
    for (int i = 0, n = phnum; i < n; i++) {
      // paddr or vaddr???
      loadBytes(memory, programs[i].offset, programs[i].paddr,
		programs[i].fileSize, programs[i].memSize);
    }
  }

  private void loadBytes(int[] memory, int offset, int addr, int len,
			 int fill) {
    if (DEBUG) {
      System.out.println("Loading " + len + " bytes into " +
             Integer.toString(addr, 16) + " fill " + fill);
    }
    for (int i = 0, n = len; i < n; i++) {
      memory[addr++] = elfData[offset++] & 0xff;
    }
    if (fill > len) {
      int n = fill - len;
      if (n + addr > memory.length) {
	n = memory.length - addr;
      }
      for (int i = 0; i < n; i++) {
	memory[addr++] = 0;
      }
    }
  }

  public ELFDebug getDebug() {
    return debug;
  }

  public DebugInfo getDebugInfo(int adr) {
      if (debug != null) {
          return debug.getDebugInfo(adr);
      }
      return null;
  }

  public String lookupFile(int address) {
    if (debug != null) {
        DebugInfo di = debug.getDebugInfo(address);
        if (di != null) {
            return di.getFile();
        }
    }
    for (int i = 0; i < files.size(); i++) {
      FileInfo fi = files.get(i);
      if (address >= fi.start && address <= fi.end) {
        return fi.name;
      }
    }
    return null;
  }

  public MapTable getMap() {
    MapTable map = new MapTable();
    int sAddrHighest = -1;
    boolean foundEnd = false;

    ELFSection name = sections[symTable.link];
    int len = symTable.size;
    int count = len / symTable.getEntrySize();
    int addr = symTable.getOffset();
    String currentFile = null;
    if (DEBUG) {
      System.out.println("Number of symbols:" + count);
    }
    int currentAddress = 0;
    for (int i = 0, n = count; i < n; i++) {
      setPos(addr);
      int nI = readElf32();
      String sn = name.getName(nI);
      int sAddr = readElf32();
      int size = readElf32();
      int info = readElf8();
      int bind = info >> 4;
      int type = info & 0xf;

      if (type == ELFSection.SYMTYPE_NONE && sn != null){
        if ("Letext".equals(sn)) {
          if (currentFile != null) {
            files.add(new FileInfo(currentFile, currentAddress, sAddr));
            currentAddress = sAddr;
          }
        } else if (!sn.startsWith("_")) {
            map.setEntry(new MapEntry(MapEntry.TYPE.variable, sAddr, 0, sn, currentFile,
                    false));
        }
      }
      if (type == ELFSection.SYMTYPE_FILE) {
	currentFile = sn;
      }

      if (DEBUG) {
        System.out.println("Found symbol: " + sn + " at " +
        		   Integer.toString(sAddr, 16) + " bind: " + bind +
        		   " type: " + type + " size: " + size);
      }

      if (sAddr > 0 && sAddr < 0x100000) {
	String symbolName = sn;
	
	if (sAddr < 0x5c00 && sAddr > sAddrHighest && !sn.equals("__stack")) {
	  sAddrHighest = sAddr;
	}
//	if (bind == ELFSection.SYMBIND_LOCAL) {
//	  symbolName += " (" + currentFile + ')';
//	}
	if ("_end".equals(symbolName)) {
      foundEnd = true;
	  map.setHeapStart(sAddr);
	} else if ("__stack".equals(symbolName)){
	  map.setStackStart(sAddr);
	}


	if (type == ELFSection.SYMTYPE_FUNCTION) {
          String file = lookupFile(sAddr);
          if (file == null) {
            file = currentFile;
          }
	  map.setEntry(new MapEntry(MapEntry.TYPE.function, sAddr, 0, symbolName, file,
	      bind == ELFSection.SYMBIND_LOCAL));
	} else if (type == ELFSection.SYMTYPE_OBJECT) {
          String file = lookupFile(sAddr);
          if (file == null) {
            file = currentFile;
          }
	  map.setEntry(new MapEntry(MapEntry.TYPE.variable, sAddr, size, symbolName, file,
	      bind == ELFSection.SYMBIND_LOCAL));
	} else {
	  if (DEBUG) {
	    System.out.println("Skipping entry: '" + symbolName + "' @ 0x" + Integer.toString(sAddr, 16) + " (" + currentFile + ")");
	  }
	}

      }
      addr += symTable.getEntrySize();
    }

  if (!foundEnd && sAddrHighest > 0) {
    System.out.printf("Warning: Unable to parse _end symbol. I'm guessing that heap starts at 0x%05x\n", sAddrHighest);
    map.setHeapStart(sAddrHighest);
  }

    return map;
  }

  public static ELF readELF(String file) throws IOException {
    DataInputStream input = new DataInputStream(new FileInputStream(file));
    ByteArrayOutputStream baous = new ByteArrayOutputStream();
    byte[] buf = new byte[2048];
    for(int read; (read = input.read(buf)) != -1; baous.write(buf, 0, read)) {
      ;
    }
    input.close();
    buf = null;
    byte[] data = baous.toByteArray();
    if (DEBUG) {
      System.out.println("Length of data: " + data.length);
    }

    ELF elf = new ELF(data);
    elf.readAll();

    return elf;
  }

  public static void main(String[] args) throws Exception {
    ELF elf = readELF(args[0]);

    if (args.length < 2) {
      for (int i = 0, n = elf.shnum; i < n; i++) {
        if (DEBUG) {
          System.out.println("-- Section header " + i + " --\n" + elf.sections[i]);
        }
        if (".stab".equals(elf.sections[i].getSectionName()) ||
            ".stabstr".equals(elf.sections[i].getSectionName())) {
          int adr = elf.sections[i].getOffset();
          if (DEBUG) {
            System.out.println(" == Section data ==");
          }
          for (int j = 0, m = 2000; j < m; j++) {
            if (DEBUG) {
              System.out.print((char) elf.elfData[adr++]);
              if (i % 20 == 19) {
                System.out.println();
              }
            }
          }
        }
        System.out.println();
      }
    }
    elf.getMap();
    if (args.length > 1) {
      DebugInfo dbg = elf.getDebugInfo(Integer.parseInt(args[1]));
      if (dbg != null) {
	System.out.println("File: " + dbg.getFile());
	System.out.println("Function: " + dbg.getFunction());
	System.out.println("LineNo: " + dbg.getLine());
      }
    }
  }

  public void setPos(int pos) {
    this.pos = pos;
  }

  public int getPos() {
    return pos;
  }

  private static class FileInfo {
      public final String name;
      public final int start;
      public final int end;

      FileInfo(String name, int start, int end) {
          this.name = name;
          this.start = start;
          this.end = end;
      }

  }

} // ELF

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/DataSource.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * DataSource
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;

public interface DataSource {
  public double getDoubleValue();
  public int getValue();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ComponentRegistry.java`:

```java
/**
 * Copyright (c) 2008-2012, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson
 * Created : Mon Feb 11 2008
 */
package se.sics.mspsim.util;
import java.io.PrintStream;
import java.util.ArrayList;

public class ComponentRegistry {

    private ArrayList<ComponentEntry> components = new ArrayList<>();
    private boolean running = false;

    private synchronized ComponentEntry[] getAllEntries() {
        return components.toArray(new ComponentEntry[components.size()]);
    }

    public void registerComponent(String name, Object component) {
        if (name == null || component == null) {
            throw new NullPointerException();
        }
        synchronized (this) {
            components.add(new ComponentEntry(name, component));
        }
        if (component instanceof ActiveComponent) {
            ((ActiveComponent)component).init(name, this);
            if (running) {
                ((ActiveComponent)component).start();
            }
        } else if (component instanceof ServiceComponent) {
            ((ServiceComponent)component).init(name, this);
        }
    }

    public synchronized Object getComponent(String name) {
        for (ComponentEntry entry : components) {
            if (name.equals(entry.name)) {
                return entry.component;
            }
        }
        return null;
    }

    public synchronized boolean removeComponent(String name) {
      ComponentEntry rem = null;
        for (ComponentEntry entry : components) {
            if (name.equals(entry.name)) {
              rem = entry;
              break;
            }
        }
        if (rem == null) {
          return false;
        }
        components.remove(rem);
        return true;
    }

    public synchronized Object[] getAllComponents(String name) {
        ArrayList<Object> list = new ArrayList<>();
        for (ComponentEntry entry : components) {
            if (name.equals(entry.name)) {
                list.add(entry.component);
            }
        }
        return list.toArray();
    }

    public synchronized <T> T getComponent(Class<T> type, String name) {
        for (ComponentEntry entry : components) {
            if (type.isInstance(entry.component) && name.equals(entry.name)) {
                return type.cast(entry.component);
            }
        }
        return null;
    }

    @SuppressWarnings("unchecked")
    public synchronized <T> T[] getAllComponents(Class<T> type, String name) {
        ArrayList<T> list = new ArrayList<T>();
        for (ComponentEntry entry : components) {
            if (type.isInstance(entry.component) && name.equals(entry.name)) {
                list.add(type.cast(entry.component));
            }
        }
        return list.toArray((T[]) java.lang.reflect.Array.newInstance(type, list.size()));
    }

    public synchronized <T> T getComponent(Class<T> type) {
        for (ComponentEntry entry : components) {
            if (type.isInstance(entry.component)) {
                return type.cast(entry.component);
            }
        }
        return null;
    }

    @SuppressWarnings("unchecked")
    public synchronized <T> T[] getAllComponents(Class<T> type) {
        ArrayList<T> list = new ArrayList<T>();
        for (ComponentEntry entry : components) {
            if (type.isInstance(entry.component)) {
                list.add(type.cast(entry.component));
            }
        }
        return list.toArray((T[]) java.lang.reflect.Array.newInstance(type, list.size()));
    }

    public void start() {
        ComponentEntry[] plugs;
        synchronized (this) {
            running = true;
            plugs = getAllEntries();
        }

        for (ComponentEntry entry : plugs) {
            if (entry.component instanceof ActiveComponent) {
                ((ActiveComponent) entry.component).start();
            }
        }
    }

    public void printRegistry(PrintStream out) {
        ComponentEntry[] plugs = getAllEntries();
        out.printf("%-22s %s\n", "Component Name", "Component Class");
        out.println("----------------------------------------------");
        for (ComponentEntry entry : plugs) {
            out.printf("%-22s %s\n", entry.name, entry.component.getClass().getName());
        }
    }

    private static class ComponentEntry {
        public final String name;
        public final Object component;

        private ComponentEntry(String name, Object component) {
            this.name = name;
            this.component = component;
        }
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ActiveComponent.java`:

```java
package se.sics.mspsim.util;

/* Active components are always started when added to registry */
public interface ActiveComponent {
  public void init(String name, ComponentRegistry registry);
  public void start();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/MapEntry.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id $
 *
 * -----------------------------------------------------------------
 *
 * MapEntry
 *
 * Author  : Joakim Eriksson
 * Created : Jan 14 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;

public class MapEntry {

  public static enum TYPE {function, variable, module}

  private final TYPE type;
  private final int address;
  private final String name;
  private final String file;
  private final boolean isLocal;
  private int size;
  private int dataAddr;
  private int dataSize;
  private int bssAddr;
  private int bssSize;
  
  public MapEntry(TYPE type, int address, int size, String name, String file, boolean isLocal) {
    this.type = type;
    this.address = address;
    this.name = name;
    this.file = file;
    this.isLocal = isLocal;
    this.size = size;
  }

  void setData(int dataAddr, int dataSize) {
    this.dataAddr = dataAddr;
    this.dataSize = dataSize;
  }

  void setBSS(int bssAddr, int bssSize) {
    this.bssAddr = bssAddr;
    this.bssSize = bssSize;
  }

  void setSize(int size) {
    this.size = size;
  }

  public int getSize() {
    return size;
  }

  public int getDataAddress() {
      return dataAddr;
  }

  public int getDataSize() {
    return dataSize;
  }

  public int getBSSAddress() {
      return bssAddr;
  }

  public int getBSSSize() {
    return bssSize;
  }

  public TYPE getType() {
    return type;
  }

  public int getAddress() {
    return address;
  }

  public String getName() {
    return name;
  }

  public String getFile() {
    return file;
  }
  
  public boolean isLocal() {
    return isLocal;
  }
  
  public String getInfo() {
    StringBuilder sb = new StringBuilder();
    sb.append(name);
    if (file != null) {
      sb.append(" (");
      if (isLocal) sb.append("local in ");
      sb.append(file).append(')'); 
    } else if (isLocal) {
      sb.append(" (local)");
    }
    return sb.toString();    
  }
  
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append('$').append(Utils.hex(address, 4)).append(' ').append(type).append(' ').append(name);
    if (file != null) {
      sb.append(" (");
      if (isLocal) sb.append("local in ");
      sb.append(file).append(')'); 
    } else if (isLocal) {
      sb.append(" (local)");
    }
    return sb.toString();
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/CCITT_CRC.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * Author  : Joakim Eriksson
 */

package se.sics.mspsim.util;

/* basic CRC-CCITT code */
public class CCITT_CRC {
  int crc;

  public int getCRC() {
    return crc;
  }

  /* this will only work with zero... */
  public void setCRC(int val) {
    crc = val;
  }
  
  public void clr() {
    crc = 0xffff;
  }

  public void addBitrev(int data) {
      add(bitrev(data));
  }
  
  public int getCRCLow() {
      return bitrev(crc & 0xff);
  }

  public int getCRCHi() {
      return bitrev(crc >> 8);
  }

  
  public int add(int data) {
    int newCrc = ((crc >> 8) & 0xff) | (crc << 8) & 0xffff;
    newCrc ^= (data & 0xff);
    newCrc ^= (newCrc & 0xff) >> 4;
    newCrc ^= (newCrc << 12) & 0xffff;
    newCrc ^= (newCrc & 0xff) << 5;
    crc = newCrc & 0xffff;
    return crc;
  }

  public int getCRCBitrev() {
      return getCRCLow() + (getCRCHi() << 8);
  }
  
  public static final String hex = "0123456789abcdef";

  private static int bitrev(int data) {
      return ((data << 7) & 0x80) | ((data << 5) & 0x40) |
      (data << 3) & 0x20 | (data << 1) & 0x10 |
      (data >> 7) & 0x01 | (data >> 5) & 0x02 |
      (data >> 3) & 0x04 | (data >> 1) & 0x08;
  }
  
  public static void main(String[] args) {
      CCITT_CRC crc = new CCITT_CRC();
      crc.setCRC(0x0);
      
      String packet = "41c8a7cdabffff777777feff7777027b493a0201ff777777870015d300000000fe80000000000000007777fffe777777";
      packet = "41cc39adba020202000274120007070700077412007b333a8700939800000000fe80000000000000021274020002020201020012740700070707000000000000";
      packet = "41c816adbaffff09090900097412007a3b3a029b02d1f5e0000011aaaa00000000000002127401000101010500020000040005080a011004";
      for (int i = 0; i < packet.length(); i += 2) {
          int data = (hex.indexOf(packet.charAt(i)) << 4) + hex.indexOf(packet.charAt(i + 1)); 
          crc.addBitrev(data);
      }
      
      //0x901d
      System.out.println("CRC: " + Utils.hex8(crc.getCRCHi()) + Utils.hex8(crc.getCRCLow()));
  }
  
  
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/MapTable.java`:

```java
/**
 * Copyright (c) 2007, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * -----------------------------------------------------------------
 *
 * MapTable
 *
 * Author  : Joakim Eriksson
 * Created : Sun Oct 21 22:00:00 2007
 */

package se.sics.mspsim.util;
import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Pattern;


/**
 * The map reader reads the map file with memory map and
 * other information about the binary/firmware to load into the
 * node.
 *
 * Format of the map file must be:
 * .text WS Adress WS Size WS file
 * WS Adress WS function_name
 * WS Adress WS function_name
 * ...
 */
public class MapTable {

  private final static boolean DEBUG = false;

  private enum Mode {NONE,CODE,DATA,BSS};
  private Mode mode;

  public int heapStartAddress = -1;
  public int stackStartAddress = -1;
  private int bssFill = 0;
  private int dataFill = 0;

  private ArrayList<MapEntry> modules = new ArrayList<MapEntry>();
  private ArrayList<MapEntry> entries = new ArrayList<MapEntry>();
  private HashMap<Integer, MapEntry> addressMap = new HashMap<Integer, MapEntry>();
  
  public MapTable() {
  }

  public MapTable(String file) throws IOException {
    loadMap(file);
  }

  private MapEntry addModuleEntry(HashMap<String,MapEntry> moduleTable,
                                  int addr, int size, String name) {
    MapEntry entry = moduleTable.get(name);
    if (entry == null) {
      entry = new MapEntry(MapEntry.TYPE.module, addr, size, name, null, false);
      moduleTable.put(name, entry);
      modules.add(entry);
    } else if (size > 0) {
      entry.setSize(entry.getSize() + size);
    }
    return entry;
  }

  /**
   *  <code>parseMapLine</code>
   * parses a line of a map file!
   * @param line a <code>String</code> value
   */
  private void parseMapLine(HashMap<String,MapEntry> moduleTable, String line) {
    String parts[] = line.split("\\s+");
    if (line.startsWith(".text")) {
      mode = Mode.CODE;
      if (DEBUG) {
        System.out.println("CODE Mode");
      }
    } else if (line.startsWith(".bss")) {
      mode = Mode.BSS;
      if (DEBUG) {
        System.out.println("BSS Mode!");
      }
    } else if (line.startsWith(".data")) {
      mode = Mode.DATA;
      if (DEBUG) {
        System.out.println("Data Mode!");
      }
    } else if (line.startsWith(" .text") || line.startsWith(" .init")
               || line.startsWith(" .vectors")) {
      if (parts.length > 3) {
        int addr = Integer.parseInt(parts[2].substring(2), 16);
        int size = Integer.parseInt(parts[3].substring(2), 16);
        addModuleEntry(moduleTable, addr, size, parts[4]);
        if (DEBUG) {
          System.out.println("Module add: " + addr + " Size:" + size
                             + " file:" + parts[4]);
        }
      }
    } else if (line.startsWith(" .data")) {
      if (parts.length > 3) {
        int addr = Integer.parseInt(parts[2].substring(2), 16);
        int size = Integer.parseInt(parts[3].substring(2), 16);
        MapEntry entry = addModuleEntry(moduleTable, addr, 0, parts[4]);
        if (DEBUG) {
          System.out.println("Module add data: " + addr + " Size:" + size
                             + " file:" + parts[4]);
        }
        entry.setData(addr, size);
      }
    } else if (line.startsWith(" .bss") || line.startsWith(" COMMON")) {
      if (parts.length > 3) {
        int addr = Integer.parseInt(parts[2].substring(2), 16);
        int size = Integer.parseInt(parts[3].substring(2), 16);
        MapEntry entry = addModuleEntry(moduleTable, addr, 0, parts[4]);
        if (DEBUG) {
          System.out.println("Module add bss: " + addr + " Size:" + size
                             + " file: " + parts[4]);
        }
        entry.setBSS(addr, entry.getBSSSize() + size);
      }
    } else if (line.startsWith(" *fill*")) {
      if(parts.length > 3) {
        int size = Integer.parseInt(parts[3].substring(2), 16);
        if (mode == Mode.BSS) {
          bssFill += size;
        } else if (mode == Mode.DATA) {
          dataFill += size;
        }
      }

    } else if (mode == Mode.CODE && line.startsWith("    ")) {
      if (parts.length > 2) {
	// Scrap 0x and parse as hex!
	int val = Integer.parseInt(parts[1].substring(2), 16);
        if (DEBUG) {
          System.out.println("Function: " + parts[2] + " at " +
                             Utils.hex16(val));
        }
	// Add the file part later some time...
	// After the demo...
	setEntry(new MapEntry(MapEntry.TYPE.function, val, 0, parts[2], null, false));
      }

    } else if (line.contains(" _end = .") && parts.length > 2) {
      heapStartAddress = Integer.parseInt(parts[1].substring(2), 16);

    } else if (line.contains("PROVIDE (__stack") && parts.length > 2) {
      stackStartAddress = Integer.parseInt(parts[1].substring(2), 16);

//     } else if ((line.startsWith("text ")
//                 || line.startsWith("data ")
//                 || line.startsWith("vectors ")
//                 || line.startsWith("bootloader ")
//                 || line.startsWith("infomem ")
//                 || line.startsWith("infomemnobits ")) && parts.length == 4) {
      // Memory configuration

    }
  }

  public void loadMap(String file) throws IOException {
    FileInputStream fInput = new FileInputStream(file);
    BufferedReader bInput = new BufferedReader(new InputStreamReader(fInput));
    HashMap<String,MapEntry> moduleTable = new HashMap<String,MapEntry>();
    String line;
    while ((line = bInput.readLine()) != null) {
      parseMapLine(moduleTable, line);
    }
    bInput.close();
    fInput.close();
  }

  public String getFunctionName(int address) {
      MapEntry entry = getEntry(address);
      if (entry != null) {
          return entry.getName();
      } else {
          return null;
      }
  }

  public MapEntry getEntry(int address) {
      return addressMap.get(address);
  }

  public MapEntry[] getAllEntries() {
    return entries.toArray(new MapEntry[entries.size()]);
  }

  public MapEntry[] getEntries(String regexp) {
    Pattern pattern = Pattern.compile(regexp);
    ArrayList<MapEntry> allEntries = new ArrayList<MapEntry>();
    for (MapEntry entry : entries) {
        if (pattern.matcher(entry.getName()).find()) {
            allEntries.add(entry);
        }
    }
    return allEntries.toArray(new MapEntry[allEntries.size()]);
  }

  // Should be any symbol... not just function...
  public void setFunctionName(int address, String name) {
    setEntry(new MapEntry(MapEntry.TYPE.function, address, 0, name, null, false));
  }

  public void setEntry(MapEntry entry) {
    entries.add(entry);
    addressMap.put(entry.getAddress(), entry);
  }

  // Really slow way to find a specific function address!!!!
  // Either reimplement this or cache in hashtable...
  public int getFunctionAddress(String function) {
      for (MapEntry entry : entries) {
        if (function.equals(entry.getName())) {
          return entry.getAddress();
        }
      }
    return -1;
  }

  public int getStackStart() {
      return stackStartAddress;
  }

  public void setStackStart(int start) {
    stackStartAddress = start;
  }

  public int getHeapStart() {
      return heapStartAddress;
  }

  public void setHeapStart(int start) {
    heapStartAddress = start;
  }

  public static void main(String[] args) throws IOException {
    MapTable map = new MapTable(args[0]);
    int totsize = 0;
    int totdata = map.dataFill, totbss = map.bssFill;
//    int totmemory = totdata + totbss;
    System.out.printf("%7s %7s %7s  %4s %s\n",
                      "text", "data", "bss", "addr", "name");
    for (int i = 0; i < map.modules.size(); i++) {
      MapEntry module = map.modules.get(i);
      totsize += module.getSize();
      totdata += module.getDataSize();
      totbss += module.getBSSSize();
//      totmemory += module.getDataSize() + module.getBSSSize();
      System.out.printf("%7d %7d %7d $%04x %s\n", module.getSize(),
                        module.getDataSize(), module.getBSSSize(),
                        module.getAddress(), module.getName());
    }
    System.out.printf("%7d %7d %7d       Total Size\n",
                      totsize, totdata, totbss);
//     System.out.println("Total data/bss size: " + totmemory + " (0x" + Integer.toHexString(totmemory) + ") data: " + totdata + " bss: " + totbss);
  }
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ConfigManager.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * ConfigManager
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Fri Oct 11 15:24:14 2002
 * Updated : $Date$
 *           $Revision$
 */
package se.sics.mspsim.util;
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.URL;
import java.util.Properties;
import java.util.StringTokenizer;

public class ConfigManager {

  protected final ConfigManager parent;
  protected Properties properties = null;

  public ConfigManager() {
    this(null);
  }

  public ConfigManager(ConfigManager parent) {
    this.parent = parent;
  }



  // -------------------------------------------------------------------
  // Config file handling
  // -------------------------------------------------------------------

  protected String getBackupFile(String configFile) {
    int index = configFile.lastIndexOf('.');
    if (index > 0 && index < configFile.length() - 1) {
      return configFile.substring(0, index) + ".bak";
    }
    return null;
  }

  public boolean loadConfiguration(String configFile) {
    return loadConfiguration(new File(configFile));
  }

  public boolean loadConfiguration(File configFile) {
    try {
      InputStream input =
        new BufferedInputStream(new FileInputStream(configFile));
      try {
        loadConfiguration(input);
      } finally {
        input.close();
      }
      return true;
    } catch (FileNotFoundException e) {
      return false;
    } catch (IOException e) {
      throw new IllegalArgumentException("could not read config file '"
          + configFile + "': " + e);
    }
  }

  public boolean loadConfiguration(URL configURL) {
    try {
      InputStream input = new BufferedInputStream(configURL.openStream());
      try {
        loadConfiguration(input);
      } finally {
        input.close();
      }
      return true;
    } catch (FileNotFoundException e) {
      return false;
    } catch (IOException e) {
      throw new IllegalArgumentException("could not read config file '"
          + configURL + "': " + e);
    }
  }

  public void loadConfiguration(InputStream input) throws IOException {
    Properties p = new Properties();
    p.load(input);
    this.properties = p;
  }

  public boolean saveConfiguration(File filename, String comments) {
    if (properties != null) {
      OutputStream output = null;
      try {
        output = new FileOutputStream(filename);
        properties.store(output, comments);
        return true;
      } catch (IOException e) {
        e.printStackTrace();
      } finally {
        if (output != null) {
          try {
            output.close();
          } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
        }
      }
    }
    return false;
  }


  // -------------------------------------------------------------------
  // Properties handling
  // -------------------------------------------------------------------

  /**
   * Returns the property names. Does not include inherited properties.
   *
   * @return an array with the non-inherited property names
   */
  public String[] getPropertyNames() {
    if (properties == null) {
      return new String[0];
    }
    synchronized (properties) {
      return properties.keySet().toArray(new String[properties.size()]);
    }
  }

  public String getProperty(String name) {
    return getProperty(name, null);
  }

  public String getProperty(String name, String defaultValue) {
    String value = (properties != null)
    ? properties.getProperty(name)
        : null;

    if (value == null || value.length() == 0) {
      value = parent != null
      ? parent.getProperty(name, defaultValue)
          : defaultValue;
    }
    return value;
  }

  public void setProperty(String name, String value) {
    if (properties == null) {
      synchronized (this) {
        if (properties == null) {
          properties = new Properties();
        }
      }
    }

    if (value == null) {
      properties.remove(name);
    } else {
      properties.put(name, value);
    }
  }

  public String[] getPropertyAsArray(String name) {
    return getPropertyAsArray(name, null);
  }

  public String[] getPropertyAsArray(String name, String defaultValue) {
    String valueList = getProperty(name, defaultValue);
    if (valueList != null) {
      StringTokenizer tok = new StringTokenizer(valueList, ", \t");
      int len = tok.countTokens();
      if (len > 0) {
        String[] values = new String[len];
        for (int i = 0; i < len; i++) {
          values[i] = tok.nextToken();
        }
        return values;
      }
    }
    return null;
  }

  public int getPropertyAsInt(String name, int defaultValue) {
    String value = getProperty(name, null);
    return value != null ? parseInt(name, value, defaultValue) : defaultValue;
  }

  public int[] getPropertyAsIntArray(String name) {
    return getPropertyAsIntArray(name, null);
  }

  public int[] getPropertyAsIntArray(String name, String defaultValue) {
    String valueList = getProperty(name, defaultValue);
    if (valueList != null) {
      return parseIntArray(valueList, defaultValue);
    } else if (defaultValue != null) {
      return parseIntArray(defaultValue, null);
    } else {
      return null;
    }
  }

  private int[] parseIntArray(String valueList, String secondaryValue) {
    StringTokenizer tok = new StringTokenizer(valueList, ", \t/");
    int len = tok.countTokens();
    if (len > 0) {
      try {
        int[] values = new int[len];
        for (int i = 0; i < len; i++) {
          values[i] = Integer.parseInt(tok.nextToken());
        }
        return values;
      } catch (NumberFormatException e) {
        // Ignore parse errors and try secondary value if specified and not already tried
      }
    }
    if(secondaryValue != null && !secondaryValue.equals(valueList)) {
      return parseIntArray(secondaryValue, null);
    }
    return null;
  }

  public long getPropertyAsLong(String name, long defaultValue) {
    String value = getProperty(name, null);
    return value != null
    ? parseLong(name, value, defaultValue)
        : defaultValue;
  }

  public float getPropertyAsFloat(String name, float defaultValue) {
    String value = getProperty(name, null);
    return value != null
    ? parseFloat(name, value, defaultValue)
        : defaultValue;
  }

  public double getPropertyAsDouble(String name, double defaultValue) {
    String value = getProperty(name, null);
    return value != null
    ? parseDouble(name, value, defaultValue)
        : defaultValue;
  }

  public boolean getPropertyAsBoolean(String name, boolean defaultValue) {
    String value = getProperty(name, null);
    return value != null
    ? parseBoolean(name, value, defaultValue)
        : defaultValue;
  }

  protected int parseInt(String name, String value, int defaultValue) {
    try {
      return Integer.parseInt(value);
    } catch (Exception e) {
      System.err.println("config '" + name + "' has a non-integer value '"
          + value + '\'');
    }
    return defaultValue;
  }

  protected long parseLong(String name, String value, long defaultValue) {
    try {
      return Long.parseLong(value);
    } catch (Exception e) {
      System.err.println("config '" + name + "' has a non-long value '"
          + value + '\'');
    }
    return defaultValue;
  }

  protected float parseFloat(String name, String value, float defaultValue) {
    try {
      return Float.parseFloat(value);
    } catch (Exception e) {
      System.err.println("config '" + name + "' has a non-float value '"
          + value + '\'');
    }
    return defaultValue;
  }

  protected double parseDouble(String name, String value,
      double defaultValue) {
    try {
      return Double.parseDouble(value);
    } catch (Exception e) {
      System.err.println("config '" + name + "' has a non-double value '"
          + value + '\'');
    }
    return defaultValue;
  }

  protected boolean parseBoolean(String name, String value,
      boolean defaultValue) {
    return "true".equals(value) || "yes".equals(value) || "1".equals(value);
  }

  public void print(PrintStream out) {
      properties.list(out);
  }

  
} // ConfigManager

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/PluginBundle.java`:

```java
/**
 * Copyright (c) 2008, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * This file is part of MSPSim.
 *
 * $Id$
 *
 * -----------------------------------------------------------------
 *
 * PluginBundle
 *
 * Author  : Joakim Eriksson, Niclas Finne
 * Created : Wed Feb 13 19:52:00 2008
 * Updated : $Date$
 *           $Revision$
 */

package se.sics.mspsim.util;

public interface PluginBundle {
  public void init(ComponentRegistry registry);
}

```

`/home/deadbytes/Documents/mspsim/se/sics/mspsim/util/ServiceComponent.java`:

```java
package se.sics.mspsim.util;

/* Service component that can be stopped and is not autostarted when
 * registered (unless it also implements ActiveComponent)
 */
public interface ServiceComponent {
  public static enum Status {STARTED, STOPPED, ERROR};
  public String getName();
  public Status getStatus();
  public void init(String name, ComponentRegistry registry);
  public void start();
  public void stop();
}

```

`/home/deadbytes/Documents/mspsim/se/sics/json/JSONObject.java`:

```java
/*
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: JSONObject.java 95 2011-04-19 13:29:41Z nfi $
 *
 * -----------------------------------------------------------------
 *
 * JSONObject
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 18 apr 2011
 * Updated : $Date: 2011-04-19 15:29:41 +0200 (Tue, 19 Apr 2011) $
 *           $Revision: 95 $
 */

package se.sics.json;

import java.io.IOException;
import java.io.Reader;
import java.io.Writer;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import org.json.simple.parser.ContainerFactory;
import org.json.simple.parser.ContentHandler;
import org.json.simple.parser.JSONParser;

/**
 *
 */
public class JSONObject extends HashMap<String,Object> implements JSONAware, JSONStreamAware {

    private static final long serialVersionUID = -4565653621517131043L;

    private void checkForCycles(Object value) {
        if (this == value) {
            throw new IllegalArgumentException("cycle detected");
        }
        if (value instanceof JSONObject) {
            JSONObject object = (JSONObject) value;
            for (Object v : object.values()) {
                checkForCycles(v);
            }
        } else if (value instanceof JSONArray) {
            JSONArray list = (JSONArray) value;
            for (Object v : list) {
                checkForCycles(v);
            }
        }
    }

    @Override
    public Object put(String key, Object value) {
        checkForCycles(value);
        return super.put(key, value);
    }

    @Override
    public void putAll(Map<? extends String,? extends Object> map) {
        for (Object v : map.values()) {
            checkForCycles(v);
        }
        super.putAll(map);
    }

    @Override
    public Object remove(Object key) {
        return super.remove(key);
    }

    @Override
    public void clear() {
        super.clear();
    }

    public boolean has(String key) {
        return containsKey(key);
    }

    public JSONObject set(String key, Object value) {
        put(key, value);
        return this;
    }

    public String[] getKeys() {
        return keySet().toArray(new String[0]);
    }

    public String getAsString(String key) {
        return getAsString(key, null);
    }

    public String getAsString(String key, String defaultValue) {
        Object v = get(key);
        return v != null ? v.toString() : defaultValue;
    }

    public int getAsInt(String key, int defaultValue) {
        Object v = get(key);
        if (v instanceof Number) {
            return ((Number) v).intValue();
        }
        return defaultValue;
    }

    public long getAsLong(String key, long defaultValue) {
        Object v = get(key);
        if (v instanceof Number) {
            return ((Number) v).longValue();
        }
        return defaultValue;
    }

    public float getAsFloat(String key, float defaultValue) {
        Object v = get(key);
        if (v instanceof Number) {
            return ((Number) v).floatValue();
        }
        return defaultValue;
    }

    public double getAsDouble(String key, double defaultValue) {
        Object v = get(key);
        if (v instanceof Number) {
            return ((Number) v).doubleValue();
        }
        return defaultValue;
    }

    public boolean getAsBoolean(String key, boolean defaultValue) {
        Object v = get(key);
        if (v instanceof Boolean) {
            return ((Boolean) v).booleanValue();
        }
        return defaultValue;
    }

    public JSONObject getJSONObject(String key) {
        Object v = get(key);
        if (v instanceof JSONObject) {
            return (JSONObject) v;
        }
        return null;
    }

    public JSONArray getJSONArray(String key) {
        Object v = get(key);
        if (v instanceof JSONArray) {
            return (JSONArray) v;
        }
        return null;
    }

    public void update(JSONObject source) {
        for(Map.Entry<String,Object> entry : source.entrySet()) {
            if (containsKey(entry.getKey())) {
                Object target = get(entry.getKey());
                Object v = entry.getValue();
                if (v instanceof JSONObject) {
                    if (target instanceof JSONObject) {
                        ((JSONObject) target).update((JSONObject) v);
                    }
                } else if (v instanceof JSONArray) {
                    if (target instanceof JSONArray) {
                        ((JSONArray) target).update((JSONArray) v);
                    }
                } else if (target instanceof JSONObject || target instanceof JSONArray) {
                    // Compound values can not be replaced by primitive values
                } else {
                    put(entry.getKey(), entry.getValue());
                }
            }
        }
    }

    public void merge(JSONObject source) {
        for(Map.Entry<String,Object> entry : source.entrySet()) {
            Object target = get(entry.getKey());
            Object v = entry.getValue();
            if (target != null) {
                if (v instanceof JSONObject) {
                    if (target instanceof JSONObject) {
                        ((JSONObject) target).merge((JSONObject) v);
                    }
                } else if (v instanceof JSONArray) {
                    if (target instanceof JSONArray) {
                        ((JSONArray) target).merge((JSONArray) v);
                    }
                } else if (target instanceof JSONObject || target instanceof JSONArray) {
                    // Compound values can not be replaced by primitive values
                } else {
                    put(entry.getKey(), entry.getValue());
                }
            } else {
                /* New value */
                if (v instanceof JSONObject) {
                    v = ((JSONObject) v).clone();
                } else if (v instanceof JSONArray) {
                    v = ((JSONArray) v).clone();
                }
                put(entry.getKey(), v);
            }
        }
    }

    @Override
    public JSONObject clone() {
        JSONObject clone = (JSONObject) super.clone();
        // Create deep copy
        for (String key : clone.getKeys()) {
            Object value = clone.get(key);
            if (value instanceof JSONObject) {
                clone.put(key, ((JSONObject) value).clone());
            } else if (value instanceof JSONArray) {
                clone.put(key, ((JSONArray) value).clone());
            }
        }
        return clone;
    }

    @Override
    public String toString() {
        return toJSONString();
    }

    @Override
    public String toJSONString() {
        return org.json.simple.JSONObject.toJSONString(this);
    }

    @Override
    public void writeJSONString(Writer out) throws IOException {
        org.json.simple.JSONObject.writeJSONString(this, out);
    }

    public static Object parseJSON(String input) throws ParseException {
        try {
            JSONParser parser = new JSONParser();
            return parser.parse(input, jsonObjectFactory);
        } catch (org.json.simple.parser.ParseException e) {
            throw new ParseException(e.getMessage(), e);
        }
    }

    public static Object parseJSON(Reader input) throws IOException, ParseException {
        try {
            JSONParser parser = new JSONParser();
            JSONObjectHandler doh = new JSONObjectHandler();
            parser.parse(input, doh);
            return doh.getResult();
        } catch (org.json.simple.parser.ParseException e) {
            throw new ParseException(e.getMessage(), e);
        }
    }

    public static JSONObject parseJSONObject(String input) throws ParseException {
        Object value = parseJSON(input);
        if (value instanceof JSONObject) {
            return (JSONObject) value;
        }
        throw new ParseException("not a JSON object: " + input);
    }

    public static JSONObject parseJSONObject(Reader input) throws ParseException, IOException {
        Object value = parseJSON(input);
        if (value instanceof JSONObject) {
            return (JSONObject) value;
        }
        throw new ParseException("not a JSON object: " + input);
    }

    private static ContainerFactory jsonObjectFactory = new ContainerFactory() {

        @Override
        public List<Object> creatArrayContainer() {
            return new JSONArray();
        }

        @Override
        public Map<String,Object> createObjectContainer() {
            return new JSONObject();
        }

    };

    private static class JSONObjectHandler implements ContentHandler {

        private Stack<Object> valueStack = new Stack<Object>();

        public Object getResult() {
            if (this.valueStack.size() == 0) {
                return null;
            }
            return this.valueStack.peek();
        }

        @Override
        public boolean endArray() throws IOException {
            trackBack();
            return true;
        }

        @Override
        public void endJSON() throws IOException {
        }

        @Override
        public boolean endObject() throws IOException {
            trackBack();
            // System.out.println("End JSON Object: " + getResult() + " Stack: "
            // + valueStack.size());
            /* we are finished if value stack is 1 */
            return this.valueStack.size() > 1;
        }

        @Override
        public boolean endObjectEntry() throws IOException {
            Object value = this.valueStack.pop();
            Object key = this.valueStack.pop();
            JSONObject parent = (JSONObject) this.valueStack.peek();
            parent.put((String) key, value);
            return true;
        }

        private void trackBack() {
            if (this.valueStack.size() > 1) {
                Object value = this.valueStack.pop();
                Object prev = this.valueStack.peek();
                if (prev instanceof String) {
                    this.valueStack.push(value);
                }
            }
        }

        private void consumeValue(Object value) {
            if (this.valueStack.size() == 0) {
                this.valueStack.push(value);
            } else {
                Object prev = this.valueStack.peek();
                if (prev instanceof JSONArray) {
                    JSONArray array = (JSONArray) prev;
                    array.add(value);
                } else {
                    this.valueStack.push(value);
                }
            }
        }

        @Override
        public boolean primitive(Object value) throws IOException {
            consumeValue(value);
            return true;
        }

        @Override
        public boolean startArray() throws IOException {
            JSONArray array = new JSONArray();
            consumeValue(array);
            this.valueStack.push(array);
            return true;
        }

        @Override
        public void startJSON() throws IOException {
            this.valueStack.clear();
        }

        @Override
        public boolean startObject() throws IOException {
            JSONObject object = new JSONObject();
            consumeValue(object);
            this.valueStack.push(object);
            return true;
        }

        @Override
        public boolean startObjectEntry(String key) throws IOException {
            this.valueStack.push(key);
            return true;
        }
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/json/JSONAware.java`:

```java
/*
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: JSONAware.java 95 2011-04-19 13:29:41Z nfi $
 *
 * -----------------------------------------------------------------
 *
 * JSONAware
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 18 apr 2011
 * Updated : $Date: 2011-04-19 15:29:41 +0200 (Tue, 19 Apr 2011) $
 *           $Revision: 95 $
 */

package se.sics.json;

/**
 *
 */
public interface JSONAware extends org.json.simple.JSONAware {

}

```

`/home/deadbytes/Documents/mspsim/se/sics/json/ParseException.java`:

```java
/*
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: ParseException.java 95 2011-04-19 13:29:41Z nfi $
 *
 * -----------------------------------------------------------------
 *
 * ParseException
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 18 apr 2011
 * Updated : $Date: 2011-04-19 15:29:41 +0200 (Tue, 19 Apr 2011) $
 *           $Revision: 95 $
 */

package se.sics.json;

/**
 *
 */
public class ParseException extends Exception {

    private static final long serialVersionUID = -7187769778260624049L;

    public ParseException(String message) {
        super(message);
    }

    public ParseException(String message, Throwable cause) {
        super(message, cause);
    }

}

```

`/home/deadbytes/Documents/mspsim/se/sics/json/JSONStreamAware.java`:

```java
/*
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: JSONStreamAware.java 95 2011-04-19 13:29:41Z nfi $
 *
 * -----------------------------------------------------------------
 *
 * JSONStreamAware
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 18 apr 2011
 * Updated : $Date: 2011-04-19 15:29:41 +0200 (Tue, 19 Apr 2011) $
 *           $Revision: 95 $
 */

package se.sics.json;

/**
 *
 */
public interface JSONStreamAware extends org.json.simple.JSONStreamAware {

}

```

`/home/deadbytes/Documents/mspsim/se/sics/json/JSONArray.java`:

```java
/*
 * Copyright (c) 2011, Swedish Institute of Computer Science.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the Institute nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: JSONArray.java 95 2011-04-19 13:29:41Z nfi $
 *
 * -----------------------------------------------------------------
 *
 * JSONArray
 *
 * Authors : Joakim Eriksson, Niclas Finne
 * Created : 18 apr 2011
 * Updated : $Date: 2011-04-19 15:29:41 +0200 (Tue, 19 Apr 2011) $
 *           $Revision: 95 $
 */

package se.sics.json;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collection;

/**
 *
 */
public class JSONArray extends ArrayList<Object> implements JSONAware, JSONStreamAware {

    private static final long serialVersionUID = 396701954050866614L;

    private void checkForCycles(Object value) {
        if (this == value) {
            throw new IllegalArgumentException("cycle detected");
        }
        if (value instanceof JSONObject) {
            JSONObject object = (JSONObject) value;
            for (Object v : object.values()) {
                checkForCycles(v);
            }
        } else if (value instanceof JSONArray) {
            JSONArray list = (JSONArray) value;
            for (Object v : list) {
                checkForCycles(v);
            }
        }
    }

    private void checkAllForCycles(Collection<? extends Object> c) {
        for(Object v : c) {
            checkForCycles(v);
        }
    }

    @Override
    public boolean add(Object e) {
        checkForCycles(e);
        return super.add(e);
    }

    @Override
    public boolean remove(Object o) {
        return super.remove(o);
    }

    @Override
    public boolean addAll(Collection<? extends Object> c) {
        checkAllForCycles(c);
        return super.addAll(c);
    }

    @Override
    public boolean addAll(int index, Collection<? extends Object> c) {
        checkAllForCycles(c);
        return super.addAll(index, c);
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return super.removeAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return super.retainAll(c);
    }

    @Override
    public void clear() {
        super.clear();
    }

    @Override
    public Object set(int index, Object element) {
        checkForCycles(element);
        return super.set(index, element);
    }

    @Override
    public void add(int index, Object element) {
        checkForCycles(element);
        super.add(index, element);
    }

    @Override
    public Object remove(int index) {
        return super.remove(index);
    }

    public String getAsString(int index) {
        Object v = get(index);
        return v != null ? v.toString() : null;
    }

    public int getAsInt(int index, int defaultValue) {
        Object v = get(index);
        if (v instanceof Number) {
            return ((Number)v).intValue();
        }
        return defaultValue;
    }

    public long getAsLong(int index, long defaultValue) {
        Object v = get(index);
        if (v instanceof Number) {
            return ((Number)v).longValue();
        }
        return defaultValue;
    }

    public float getAsFloat(int index, float defaultValue) {
        Object v = get(index);
        if (v instanceof Number) {
            return ((Number)v).floatValue();
        }
        return defaultValue;
    }

    public double getAsDouble(int index, double defaultValue) {
        Object v = get(index);
        if (v instanceof Number) {
            return ((Number)v).doubleValue();
        }
        return defaultValue;
    }

    public boolean getAsBoolean(int index, boolean defaultValue) {
        Object v = get(index);
        if (v instanceof Boolean) {
            return ((Boolean)v).booleanValue();
        }
        return defaultValue;
    }

    public JSONObject getJSONObject(int index) {
        Object v = get(index);
        if (v instanceof JSONObject) {
            return (JSONObject)v;
        }
        return null;
    }

    public JSONArray getJSONArray(int index) {
        Object v = get(index);
        if (v instanceof JSONArray) {
            return (JSONArray)v;
        }
        return null;
    }

    public void update(JSONArray v) {
        int count = v.size();
        if (size() < count) {
            count = size();
        }
        for(int i = 0; i < count; i++) {
            Object target = get(i);
            Object source = v.get(i);
            if (source instanceof JSONObject) {
                if (target instanceof JSONObject) {
                    ((JSONObject) target).update((JSONObject) source);
                }
            } else if (source instanceof JSONArray) {
                if (target instanceof JSONArray) {
                    ((JSONArray) target).update((JSONArray) source);
                }
            } else if (target instanceof JSONObject || target instanceof JSONArray) {
                // Compound values can not be replaced by primitive values
            } else {
                set(i, source);
            }
        }
    }

    public void merge(JSONArray v) {
        int count = v.size();
        if (size() < count) {
            count = size();
        }
        for(int i = 0; i < count; i++) {
            Object target = get(i);
            Object source = v.get(i);
            if (source instanceof JSONObject) {
                if (target instanceof JSONObject) {
                    ((JSONObject) target).merge((JSONObject) source);
                }
            } else if (source instanceof JSONArray) {
                if (target instanceof JSONArray) {
                    ((JSONArray) target).merge((JSONArray) source);
                }
            } else if (target instanceof JSONObject || target instanceof JSONArray) {
                // Compound values can not be replaced by primitive values
            } else {
                set(i, source);
            }
        }
        if (v.size() > size()) {
            for(int i = size(), n = v.size(); i < n; i++) {
                Object source = v.get(i);
                if (source instanceof JSONObject) {
                    add(((JSONObject) source).clone());
                } else if (source instanceof JSONArray) {
                    add(((JSONArray) source).clone());
                } else {
                    add(source);
                }
            }
        }
    }

    @Override
    public JSONArray clone() {
        JSONArray clone = (JSONArray) super.clone();
        // Create deep copy
        for(int i = 0, n = clone.size(); i < n; i++) {
            Object value = clone.get(i);
            if (value instanceof JSONObject) {
                clone.set(i, ((JSONObject)value).clone());
            } else if (value instanceof JSONArray) {
                clone.set(i, ((JSONArray)value).clone());
            }
        }
        return clone;
    }

    @Override
    public String toString() {
        return toJSONString();
    }

    @Override
    public String toJSONString() {
        return org.json.simple.JSONArray.toJSONString(this);
    }

    @Override
    public void writeJSONString(Writer out) throws IOException {
        org.json.simple.JSONArray.writeJSONString(this, out);
    }

}

```

`/home/deadbytes/Documents/mspsim/CHANGE_LOG.txt`:

```txt
0.97
- fixed bug on SFR interrupt handling
- added initial support for printing IPv6 packets (HC01) from CC2420
- added CLI commands for adding rflisteners and analyser
- added warning for too large packets in CC2420
- added profiling of interrupts
- added verification of MAGIC init bytes in ELF files
- fixed multiplicator (submitted patch)
- added support for flash
- several bugfixes for emulation core (instruction emulation)
- made call logger configurable for hide of selected calls
- fixed some cycle timing bugs of instruction set execution
- added stack trace for misalignment warnings if MSP430 Core is in log mode
- added MSP430 Core as a loggable
- added emulation of DS2411 for generating MAC addresses
- added warning when UART is transmitting while in LPM3
- added profiling of events and added event system

0.96
- added warning on unaligned write/read
- fixed bug in timer system causing severe delays when several CCR/Compare
  interrupts was trigger simultaneously
- added profiling of interrupts

0.95
- initial GDB stubs implementation (only for memory access)
- CLI command for setting up gdbstubs server (gdbstubs PORT)
- fixed USART timing to be more correct
- added Ant build script
- cleanup of CLI and platforms
- fixed statistics to be more correct
- added SimEvent for notications of start/stop of emulator
- CORE: bugfix in read/write SR - made it impossible to turn of interrupts
- improved CC2420 support including correct overflow handling and better
  handling of VREG_OFF
- added logging on/off from CLI and support for loggin CC2420
- added CLI commands tee and trig.

0.94
Changes:
- fixed so that IOPorts output 1 on pins that are configured as input
  (with DIR)
- fixed notification of operating modes on the CC2420 for duty cycle calculation, etc.
- fixed status register update bug (byte/word problem)
- improved CC2420 implementation correctness (including RSSI_VALID flag, SFD timing, etc)
- fixed SPI bug in CC2420
- added SHT11 implementation for Tmote Sky
- added I/O ports -> timer capture functionality
- added SFD capture interrupt support for CC2420
- improved correctness of timer when reconfiguring CPU clock speed (MCLK)
- improved interrupt handling in MSP430 core
- added CLI command printcalls that prints all function calls
- fixed buffering of serial input in GUI to avoid freezing AWT.

0.93
Changes:
- removed tick based component support from MSP430 core
- re-implemented USART to be event based instead of tick based
- fixed bug in ADC12 subsystem that caused lots of events to be
  scheduled back in time (causing other subsystems to get
  delays on their events...)
- fixed RadioWrapper for backward compatibility with PacketListener
  (for the CC2420).
- fixed ADC12 to turn off event scheduling when ADC12 is not on anymore
- fixed xmem read/write for cli and added Memory API for flash memory.

0.92
Changes:
- fixed bug with a write register which did not handle word/byte
- fixed bug which caused array out of bounds on IO-units.
- fixed bug in timer causing interrupts when timer was stopped
- fixed bug in timer to handle start/stop better
- fixed bug in MSP430 core that caused MOV instruction to change status flags
- added getDoubleValue in DataSource and made "duty" command print
  duty cycle information as double instead of int
- fixed windows to accept double input and not only int input
- corrected cycle count on some instructions
- improved CC2420 emulation (thanks to Matt Thompson)
- added Telos platform including AT45DB flash memory chip (Matt Thompson)


0.91
Changes:
- added window system and support for it in the CLI
- added two chart types for the windows subsystem
- added redirect to windows in the CLI
- added memory dump for both std out and Windows
- improved CC2420 emulation
- added CLI commands
- reimplemented reset of the CPU
- improved support for Digital IO Ports
- added working ADC12 subsystem
- added watchdog WDT subsystem
- added support for file based scripts to the CLI
- added configuration system
- added connectivity between multiple running mspsim's
- bugfix in instruction emulation thanks to Matt Thompson
  (addressing mode - autoincrement byte wrong on PC).


0.90
Changes:
- fixed multiplier to handle the different modes better.
- refactored so that IOUnit is no longer a Chip
- added statistics commands and an exec command to the CLI
- implemented better support for statistics (operating mode)
- fixed interrupt handling bugs in IOUnit
- added API for accessing frequency/channel and output power in CC2420
- added RSSI support for CC2420
- refactored radio emulation code of ESB platform into a separate TR1001 class
- added watch on register, grep, and other commands in CLI
- added redirect to files in CLI
- added speed control API and CLI command (speed)
- added event system for cycle based events
- fixed timer (A/B) to be event driven instead of tick driven
- fixed bugs in interrupt handling of timer system
- added argument management and -nogui parameter

0.84
Changes:
- fixed bug in source file handling in ELF symbol loader
- fixed RSSI-ready flag to be set in CC2420
- refactored code from Sky/ESB into GenericNode
- fixed workaround for AWT/IO read line hang bug. (works but not nice in
  cygwin). Workaround is off by default by can be configured in CLI.
- added several new commands (start, stop, step, print, printreg, etc).
- fixed bug in USART - TX Interrupt implemented
- changed API for interruptServiced to include which vector that was serviced
- changed when interruptServiced is called - now before servicing the interrupt
  instead of after (RETI).

0.83
Changes:
- added support for external flash on Sky node (M25P80)
- added symbolic name in disassembler
- fixed timer interrupt bug causing problem with TinyOS firmwares
- implemented virtual time and event system based on that time.
- improved emulation of CC2420
- implemented writer monitors (CPUMonitor - monitor of writes on any address)
- added commands and command (line) handler
- added plug-in system

0.82 - JFreechart, operation mode statistics (2008-02-03)
Changes:
- added jfreechart diagrams for stack and operation mode statistics
- added profiling of operation modes (e.g. chip modes such as on/off/lpm)
- fixed bug in Timer causing division by zero when main clock is slower than ACLK.
- added possibility to print a stack trace when CPU is stopped
- more symbol information available after loading ELF files

0.81 - ELF Stabs, source debugging (2007-12-07)
Changes:
- support for ELF debug information (stab section)
- possible to convert address into linenumber and file
- simple source-level viewer that shows current execution position
  (and updates during single stepping) - with highlighting for C.
- support for LPM/CPUOFF which stops instruction emulation when in
  LPM modes
- refactored profiling into separate classes

0.8  - Initial release (2007-11-26)

```

`/home/deadbytes/Documents/mspsim/scripts/autorun.sc`:

```sc
# autorun script for MSPSim
# - all commands will run after loaded firmware into MSPSim
#log CC2420 >log.txt
#printcalls >>log.txt

# Install and activate the plugin 'ContikiChecker'
# install ContikiChecker
# contikichecker

#start the nodegui service
service -f controlgui start
service -f nodegui start
service -f serialgui start
#service -f stackchart start
#rflistener output CC2420 >> rfdata.txt
start

```

`/home/deadbytes/Documents/mspsim/scripts/duty.sc`:

```sc
echo "#!type line" | window duty
duty 10 "MSP430 Core.active" CC2420.listen CC2420.transmit "Tmote Sky.0" | window duty
echo "#!set 0 label CPU" | window duty
echo "#!set 1 label Listen" | window duty
echo "#!set 2 label Transmit" | window duty
echo "#!set 3 label LEDS" | window duty
echo "#!title Duty Cycle" | window duty
```

`/home/deadbytes/Documents/mspsim/build.xml`:

```xml
<project name="MSPSim" default="jar" basedir=".">
  <description>
     Builds MSPSim
  </description>

  <property name="src" location="."/>
  <property name="build" location="build"/>
  <property name="lib" location="lib"/>
  <property name="jarfile" location="mspsim.jar"/>
  <property name="javac.debug" value="true"/>
  <property name="ant.build.javac.source" value="11"/>
  <property name="ant.build.javac.target" value="11"/>
  <property name="ARGS" value=""/>

  <path id="classpath">
    <fileset dir="${lib}" includes="**/*.jar"/>
  </path>

  <manifestclasspath property="jar.classpath" jarfile="${jarfile}">
    <classpath refid="classpath" />
  </manifestclasspath>

  <target name="init">
    <tstamp/>
    <mkdir dir="${build}"/>
  </target>

  <target name="compile" depends="init" description="compile the source">
    <javac srcdir="${src}" destdir="${build}" classpathref="classpath"
           debug="${javac.debug}" includeantruntime="false" encoding="utf-8">
      <compilerarg value="-Xlint:unchecked"/>
      <compilerarg value="-deprecation"/>
      <exclude name="tests/**" />
    </javac>
  </target>

  <target name="jar" depends="compile" description="generate MSPSim jar file" >
    <jar jarfile="${jarfile}" basedir="${build}">
      <manifest>
        <attribute name="Main-Class" value="se.sics.mspsim.Main"/>
      	<attribute name="Sealed" value="true"/>
      	<attribute name="Class-Path" value="${jar.classpath}" />
      </manifest>
      <fileset dir="." includes="images/*.jpg,images/*.png"/>
    </jar>
  </target>

  <target name="runesb" depends="jar" description="run MSPSim with platform ESB">
    <property name="FIRMWAREFILE" value="firmware/esb/sensor-demo.esb"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.esb.ESBNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runsky" depends="jar" description="run MSPSim with platform Sky">
    <property name="FIRMWAREFILE" value="firmware/sky/blink.sky"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.sky.SkyNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runskyprof" depends="jar" description="run MSPSim with platform Sky for profiling">
    <property name="FIRMWAREFILE" value="firmware/sky/blink.sky"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.sky.SkyNode">
      <jvmarg value="-agentlib:yjpagent" />
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runtelos" depends="jar" description="run MSPSim with platform Telos">
    <property name="FIRMWAREFILE" value="firmware/sky/blink.sky"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.sky.TelosNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runjcreate" depends="jar" description="run MSPSim with platform Sentilla JCreate">
    <property name="FIRMWAREFILE" value="firmware/sky/blink.sky"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.jcreate.JCreateNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runsentillausb" depends="jar" description="run MSPSim with platform Sentilla Gateway USB">
    <property name="FIRMWAREFILE" value="firmware/sky/blink.sky"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.sentillausb.SentillaUSBNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runz1" depends="jar" description="run MSPSim with platform Zolertia Z1">
    <property name="FIRMWAREFILE" value="firmware/z1/blink.z1"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.z1.Z1Node">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runwismote" depends="jar" description="run MSPSim with platform Wismote">
    <property name="FIRMWAREFILE" value="firmware/wismote/blink.wismote"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.wismote.WismoteNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runtyndall" depends="jar" description="run MSPSim with platform Tyndall">
    <property name="FIRMWAREFILE" value="firmware/tyndall/blink.tyndall"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.tyndall.TyndallNode">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="runexp5438" depends="jar" description="run MSPSim with platform exp5438">
    <property name="FIRMWAREFILE" value="firmware/exp5438/tesetcase-bits.exp5438"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.platform.ti.Exp5438">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="run" depends="jar" description="run MSPSim">
    <property name="FIRMWAREFILE" value="firmware/sky/blink.sky"/>
    <java fork="true" classpath="${jarfile}" classname="se.sics.mspsim.Main">
      <arg value="${FIRMWAREFILE}"/>
      <arg line="${ARGS}"/>
    </java>
  </target>

  <target name="test-cpu" depends="jar" description="run MSPSim CPU test">
    <java fork="true" classpath="${jarfile}"
          classname="se.sics.mspsim.util.Test"
          failonerror="true"
          timeout="10000">
      <arg value="firmware/sky/cputest.sky"/>
    </java>
  </target>

  <target name="test-timer" depends="jar" description="run MSPSim Timer test">
    <java fork="true" classpath="${jarfile}"
          classname="se.sics.mspsim.util.Test"
          failonerror="true"
          timeout="10000">
      <arg value="firmware/sky/timertest.sky"/>
    </java>
  </target>

  <target name="test" depends="jar, test-cpu, test-timer"/>

  <target name="clean" description="clean up" >
    <delete dir="${build}"/>
    <delete file="${jarfile}" />
  </target>

</project>

```

`/home/deadbytes/Documents/mspsim/firmware/exp5438/testcase-shift-fcf.txt`:

```txt
prunt:
    8f4e:	0a 12       PUSH.W R10
    8f50:	5a 4c 04 00 MOV.B $0004(R12), R10
    8f54:	5a f3       AND.B #1, R10
    8f56:	45 18       ExtWord 1845:ZC:0 #:0 A/L:1 src:0 dst:5 R5
    8f58:	4a 5a       ADD.B R10, R10
    8f5a:	0a 12       PUSH.W R10
    8f5c:	3c 40 e4 5e MOV.W #$5ee4, R12
    8f60:	b0 13 3a 8d CALLA #08d3a 
    8f64:	4c 4a       MOV.B R10, R12
    8f66:	21 53       ADD.W #2, SP
    8f68:	3a 41       MOV.W @SP+, R10
    8f6a:	10 01       MOVA @R1+,R0 
 

```

`/home/deadbytes/Documents/mspsim/firmware/tyndall/blink.ihex`:

```ihex
:020000020000FC
:105C00003140005CB01312A20C930E243C40661C81
:105C10003D404F10B0133E9E3C40001C3D406C5F29
:105C20003E406600B013F2A2B013986EB013D6A235
:105C300082435C0100133F15A2926E030720B0134C
:105C4000149B0C930324B1C0F00008003C17001310
:105C50003F15B0139AA0B0135495B013447E1C9313
:105C60000338B1C0F0000800B013BC9E3C1700130D
:105C70003F15A293DE051520E2B2CA050328C293A0
:105C8000CC050F3C5C42CC051F42642B1FD2662B17
:105C90000F9307248013642B0C930324B1C0F000EE
:105CA00008003C1700133F15A293AE033A20B2B090
:105CB0002000800306281F4294031F8290031F9335
:105CC000F627B2500001940392536C2B82636E2B23
:105CD0001E426C2B7EB07F0006209253682B82639D
:105CE0006A2BB01300A31F4294031F8290033F90BE
:105CF0000101E72F92429003702BB01300A00C9388
:105D00001024B013589C1C826C2B1D726E2B3C53BC
:105D10003D633D9000800528B01338A2B1C0F0006B
:105D200008003C170013041C0000F65EF29300000C
:105D3000449000004088000004A300006698000022
:105D4000C29700009C700000FA710000E09E000005
:105D5000275FEAA20000C28A0000B4950000B6A244
:105D6000000012A10000CAA20000847B0000AE83E4
:105D700000002F5FD69F0000B4800000E2A2000068
:105D8000CEA20000BEA20000F29D000078810000BB
:105D9000828B0000747C0000049F00005C7D00008A
:105DA000AC6A0000486A00003E6A0000886A000091
:105DB000526A0000686A6C747A4C006E616E004E24
:105DC000414E00696E6600494E46003000436C6FDC
:105DD000636B2074657374657200537461727469C7
:105DE0006E6720757020626C696E6B0A0052696D77
:105DF00065207374617274656420776974682061CA
:105E0000646472657373200025752E0025750A0081
:105E10005374617274696E670020272573270053DD
:105E2000746172746564206574696D657220707246
:105E30006F636573732E2E2E0A00496E6974696153
:105E40006C697A6564206363323432302E2E2E0AF8
:105E5000004D414320253032783A253032783A25BA
:105E60003032783A253032783A253032783A253057
:105E700032783A253032783A253032782000436F34
:105E80006E74696B6920322E35207374617274658B
:105E9000642E20004E6F646520696420697320734E
:105EA000657420746F2025752E0A004E6F6465207E
:105EB0006964206973206E6F74207365742E0A0004
:105EC00025732025732C206368616E6E656C2063DA
:105ED0006865636B207261746520256C7520487A53
:105EE0002C20726164696F206368616E6E656C203E
:105EF00025750A00000052696D6500616461746176
:105F00002E6E756D20776179206F757420746865C9
:105F100072653A2025640A00181000000000008015
:105F2000C0E0F0F8FCFEFF6E756C6C7264630043B9
:105F3000534D410053657269616C206472697665E6
:105F400072004576656E742074696D6572004374E5
:105F5000696D65722070726F6365737300434332BD
:0B5F60003432302064726976657200F4
:105F6C00010000000000CD5D8E8C000000000000E0
:105F7C000C1D561DA61D0E000600772BA81DFC1D22
:105F8C000000345F7A850000000000000000425FD2
:105F9C0036820000000000005E1E00004E5F4A8446
:105FAC00000000000000961EBA001000912C4A1F41
:105FBC0036000200A12CEA2A00005D5FE08D000093
:105FCC0000000000ABCD7C80620031247C80060098
:105FDC0022246C8313246C830A247C8005000E24F9
:105FEC007C80030018247C8006000D24143C2F4D6B
:105FFC00AD5200002C4F1D4F0200133C2F4DBD52D3
:10600C00000080005C652F4DAD5300002C4F0D43FC
:10601C000E430F4310012F4DAD5300002C4FB01306
:10602C0048600E4D3EE30E5E0E7E0F4E10012F4D5E
:10603C00AD5300006C4F8C11F23F03430D4C3DE30C
:10604C000D5D0D7D10015B15318064000A4F1B4105
:10605C007400B01362A081431E0008413850280020
:10606C00774020006E4A4E9306201C411E00315092
:10607C006400561710017E9025000E2081431200FB
:10608C0081431400814316008143180081431A0098
:10609C0081431C000E43093C7D4A0C41B0131A97F6
:1060AC000C93E0373C43E33F1ED31A536F4A4D4FDA
:1060BC004D87FA277D8003000C247D8206246D8396
:1060CC0006247D8003000724093C2ED3EE3F2ED2FC
:1060DC00EC3F3ED2EA3F3ED01000E73F7F902A00D3
:1060EC0010202F4BA14F2200AB5300001F41220068
:1060FC000F9305343FE31F53814F22002ED21A53C6
:10610C00123C814322000C3C1D4122003D90FF7F3C
:10611C00062449180F5D3F50D0FF814F22001A53BF
:10612C00B0134E65F12BFA902E0000000324B143FE
:10613C0020001E3C1A53FA902A00000007202F4B17
:10614C00A14F2000AB5300001A53123C8143200096
:10615C000C3C1D4120003D90FF7F062449180F5D2B
:10616C003F50D0FF814F20001A53B0134E65F12BD6
:10617C00814E24006D4A3C40B45DB013589F0C9383
:10618C0002247E4A013C4E43C14E26007E9068009C
:10619C000820FA90680000000F20F14062002600F1
:1061AC000A3C7E906C000820FA906C0000000420E1
:1061BC00F140710026001A5381481000664A4E4681
:1061CC007E8025002B247E801C009B246E829924CB
:1061DC005E8397245E8395247E801100B9247E8093
:1061EC0009008F246E8329255E8309255E8389240B
:1061FC005E8387245E8385246E8301257E80050063
:10620C0040245E83A5245E8327247E80030009241A
:10621C006E839E247E8003009B24173DB01342A105
:10622C001E3D2F4BA14F0E00AB5300001C410E0026
:10623C001E4120000E930B380D43B013F49C0C93AD
:10624C0003201C412000053C1C810E00023CB013B5
:10625C00989E814C1400053D2F4BA14F0000B013AC
:10626C004065AB53000081F3020081F3040081F31D
:10627C00060081480E007D4078000C41B0139472EA
:10628C00F03C5E4126007E80620035247E80060054
:10629C0019246E831D246E8306247E800500182429
:1062AC007E8009000F3C1E411E000F4E3FE30F5F26
:1062BC000F7F2D4B2D4D8D4E00008D4F0200AB539B
:1062CC000000CF3C2F4B2F4F9F411E000000F73F8B
:1062DC001C411E00B01348600E4D3EE30E5E0E7E58
:1062EC00264B2646864C0000864D0200864E040046
:1062FC00864E0600E43F2F4B2F4FDF411E0000005F
:10630C00DE3FF1904C0026002F4B2E4F1F4F02000A
:10631C00AB520000814E0000814F02000F930334FA
:10632C00B0135AA10D3CA1B324000328B01396A1BD
:10633C00073C91B324000628B013AAA2CF47000053
:10634C0091531200B0138AA10C41B0136C65893CB7
:10635C005E4126007E906C0014247E9071000B240C
:10636C007E906A0008242F4B2C4F0D430E430F4395
:10637C00AB5300000E3C2F4BB0135C65BB520000BE
:10638C00083C2F4B2C4F1D4F02000E430F43AB52BA
:10639C000000B013F29E5E4126007E9068000E2431
:1063AC007E90620007247E90740008247E907A0010
:1063BC000920043C6C41814C0000023CA1410000CE
:1063CC00B0134065B1B2240035282F411FD1020013
:1063DC001FD104001FD106000F932C244E464ED71C
:1063EC007E9078002720B013AAA2FF403000000056
:1063FC0091531200B013AAA2CF460000193C0D4BCA
:10640C005C412600B013D25FB013F29E0F930E388E
:10641C00A1B324000328B01396A10A3C91B3240025
:10642C000928B013AAA2CF470000023CB0135AA10E
:10643C0091531200B0138AA1203F2E4BB013AAA285
:10644C00EF4E0000AB5300000A3CB01342A1915335
:10645C00120046930624B013AAA2CF460000915313
:10646C0012001A53164122001681120016811800D0
:10647C001681140016811A001681160016811C0054
:10648C00A1B22400062C4E470D460C41B0133865C2
:10649C0009261E4112000D480C41B013B0990C9303
:1064AC0001227E4030001D4118000C41B0133865AC
:1064BC0002208000B0601E4114001D410E000C41F2
:1064CC00B013B0990C9302248000B0607E40300071
:1064DC001D411A000C41B013386502208000B060D9
:1064EC001E4116001D410E001D5114000C41B0132D
:1064FC00B0990C9302248000B0607E4030001D41A6
:10650C001C000C41B013386502208000B060A1B2B1
:10651C002400022C800070604E470D460C41B013D5
:10652C0038650224800070608000B060B0133E9625
:10653C000C931001814306008143080081430A003B
:10654C0010016F4A4D4F7D50D0007D900A00100114
:10655C002C4F1D4F02001E4F04001F4F0600100150
:10656C005B154D12318034000A4C094139500C0036
:10657C000B49A14C0200914C02000400584134001C
:10658C0078D020007640610048960E241F4C2000E5
:10659C000F930434BC4006002000063C0520789084
:1065AC00670002209C4320000D4C0C41B013188F47
:1065BC005E4134007E509F000F4A3F500E002C93DA
:1065CC001120BA40030014007E901A00032C3D40A9
:1065DC00BB5D023C3D40BF5D3E4003002C4FB01301
:1065EC00749E9A3D1C930C38BA40030014007E90A4
:1065FC001A00032C3D40C35DEF3F3D40C75DEC3FAF
:10660C0048961620274FF740300000002F4F1F539D
:10661C00074F17538A470E00C196340003247E405F
:10662C005800023C7E407800CF4E0000AA53120066
:10663C000C930420084381430000643D374007005D
:10664C004896AB20184A20000893033438402100A8
:10665C00013C185306481653B013989F06242E4A33
:10666C001F4A0200B0130EA0053CA14A0200914A39
:10667C0002000400A1820000C1430C001B53073C24
:10668C003B53CB4300003F530F93FA370B571693F2
:10669C003E380E433F408000B01398A2B013F4A1D3
:1066AC000C9335243E401C000F430C412C53B0136B
:1066BC00E284B01398A2B013C094B013AEA13650BC
:1066CC00F9FF169308381C410800B0131286B0135A
:1066DC007EA1B013D6A10B570F4781930A00D33B71
:1066EC00032091930800CF2B3F530F93CC3B3B538C
:1066FC005E4108007EF00F00CB4E00001C410800EC
:10670C001D410A00B013AA9EB013AEA1E63F0F497B
:10671C001F530B8F064B0B491B530698013408462D
:10672C0008933338089608340F490F58FF9201002C
:10673C0003287E400F00013C4E430F48013C385368
:10674C003F530749075FC79E0100F9277E900F0052
:10675C000220D75301000F9304340B491853A15254
:10676C0000000F480F3C074B075F6E477E50300010
:10677C007E903A0005285D4134007D50C6004E5D88
:10678C00C74E00003F530F93EE378A932000BA3464
:10679C000F483F538A4F2000B53CB013989F0624F6
:1067AC001E4102001F410400B0130EA02C41B01377
:1067BC0048603E4097750F43B013E2953E40A0866B
:1067CC001F43B013DC91814C0000078C0E471793CC
:1067DC000538B01398A2B01358910D3C3EE31E53EC
:1067EC000C433D40803FB01358910E4C0F4DB013ED
:1067FC0098A2B0132C78B013D6A178906600042020
:10680C00264136500A00023C36400600165A20003B
:10681C0036900B00023836400A00F14030000C0074
:10682C001B5316932C38B01340A2B013AEA13B529D
:10683C00F1420600B013869EC14E0700B013869E2F
:10684C00B013AEA13B535E4107007E503000CB4EDF
:10685C000000F1530600EE233B5236821693E13BC7
:10686C00B01340A2B0132686B0137EA13E4020BCCC
:10687C003F40BE4CB013747AB013D6A1D43F0F492D
:10688C001F530B8F064B19530B49043C3653B15312
:10689C0000001B53FB9030000000F8277890660036
:1068AC00032028411853063C7890650002240843C5
:1068BC00013C1843185A20000698013408460893E6
:1068CC002138089609340F4B0F58FF903500000003
:1068DC0003287E403900023C7E4030000F48013CCA
:1068EC0038533F53074B075FC79E0000F9277E9034
:1068FC0039000220D75300000F9304343B53185334
:10690C0091530000111202000F480E4B5D413600EE
:10691C000C4AB013226C215331503600561710011B
:10692C00B013066CC293EC051C43B0139EA2D2D3D9
:10693C002202D2C32202B013449DF242EE05B013E0
:10694C00369DF242EE05703C0343D2C32202B013D3
:10695C00449DC24CEE05683C0343D2C32202B013E3
:10696C00449DC243EE05B0131C6B5C42EC055E3CCF
:10697C0003430A12C243A82CB0131EA10A4CB01335
:10698C0066693CB20728B0131EA10C8A3C5034F344
:10699C000C93F53B7C400600B0135669B2C0100056
:1069AC004603E2B26102022CB0132C693A41100189
:1069BC000A12B2D010004603B01336A10A4CB01321
:1069CC00E0A1032CB0135C6BFA3BD243A82C3A41E8
:1069DC001001D293A92C0E20C293AA2C0424B0131C
:1069EC00BC69C243AA2CC293AB2C0424B0137E699D
:1069FC00C243AB2CF253A92C1001D2C32202B01308
:106A0C00449DC24CEE05B013449D0F4D47190F1019
:106A1C00C24FEE05B013449DC24DEE05B0131C6B76
:106A2C00B013449DC243EE05B0131C6BD2D32202AB
:106A3C001001E2B261024C7C5C531001F2B04000D8
:106A4C006102F93F0343C293A82C02201C4310019E
:106A5C00C293A92C0424D243AB2C1C431001D24367
:106A6C00A92CB01366693CB20328D243AB2C023C70
:106A7C00B0137E69B013DE691C431001C293A82CBD
:106A8C0002241C431001C293A92C0424D243AA2C27
:106A9C001C431001D243A92CB013BC69EB3F034338
:106AAC001B150B43C293A92C02241C43153CB01399
:106ABC00246BC293A82C0720B013DE690B93F52727
:106ACC00B013526AF23FB013466BF2B02000610271
:106ADC004A7A5A53B013366B1A171001D2C32202DA
:106AEC00B013449D7CD04000C24CEE05B0131C6B1F
:106AFC00C293EC05B013E66B5C42EC0547180C5CDA
:106B0C00B013E66B5F42EC05D2D322020CDF10010E
:106B1C00D2B3EA05FD2F1001D243A92CC293A82CA5
:106B2C0003201B43B013886A10010B930224B0138B
:106B3C00526AB013DE690C4A1001B0131EA10A4C44
:106B4C00B01366692CB3032CB0135C6BF93B1001CA
:106B5C00B0131EA10C8A3C50B9FE0C9310010A1202
:106B6C00D253A92C7C401500B013E86A0A4CB01320
:106B7C00DE693AF01F000C4A3A4110014E4C7C4041
:106B8C001500B013E86A3EF01F003CF0E0FF0CDE8D
:106B9C000D4C7C4015008000066A0A12D2C32202FA
:106BAC00B013449DF2407F00EE05B0131C6BC293F2
:106BBC00EC054E43083CB013E66B0F4C0F5ADF420A
:106BCC00EC0500005E534A4E0A9DF53B1C43B01386
:106BDC009EA2D2D322023A411001C243EE05D2B397
:106BEC00FD05FD2B1001B013066CDC42EC0500001A
:106BFC001C43B0139EA21A3F0343D2C32202B0130C
:106C0C00449DF2407F00EE05D2B3EA05FD2FC293FE
:106C1C00EC05E33F03435B154D1231800E000A4C2B
:106C2C00084E0B4F16412000174C20001F930334C5
:106C3C001B433840CB5D094C395014005E410E00AB
:106C4C007ED020007E90660008247E906700752020
:106C5C003690FCFF7A380697783416537E9066008F
:106C6C000A24BCB22400032C0B970134074B078673
:106C7C000793013407431F4C0E000C4F1C590000A6
:106C8C0016932B34FC40300000009A5314001793D9
:106C9C000334BAB2240003280E4FB013289F0E46BB
:106CAC003EE31E53079E0334064736E316530E4647
:106CBC003EE31E538A4E1A000756079B01340B47BE
:106CCC008A4B16000E4B0D481F5900000C4FB01389
:106CDC00749E078B8A471C00BD3C0B9613340E4BDD
:106CEC000D48B013749E8A5B1400068B8A461A00FA
:106CFC0017930334BAB22400ED2BB013689F9A5348
:106D0C001600E83F0E460D48B013749E8A561400C8
:106D1C000B8617930334BAB224000428B013689F6F
:106D2C009A531400079B01340B470E4B08560D4821
:106D3C001C4A0E00B013A29D8D3CF19061000E0018
:106D4C001A20F14070000E001D3C0B970434BCB2AD
:106D5C002400012C074B3753079301340743F19060
:106D6C0067000E0003247E404500023C7E40650017
:106D7C00C14E0E00073CF19041000E000320F14083
:106D8C0050000E001C4A0E000E4C1E590000FE480E
:106D9C0000009A53140017930334BAB224000D2840
:106DAC000E4CB013289F179308383B53079B0134A4
:106DBC000B470E4B0D48B013A29D184A0E001859E4
:106DCC000000D8410E000000185306930538F84017
:106DDC002B0000001853063CF8402D0000001853FF
:106DEC0036E316530B430D3C3E400A000D460C4156
:106DFC00B0139C9C0F4B0F51DF4102000400264145
:106E0C001B531693F1372B930B345E410E007ED03F
:106E1C0020007E9065000420F840300000001853DC
:106E2C000B930F20F8403000000018530C3C3B53E0
:106E3C000F4B0F515E4F04007E503000C84E0000C7
:106E4C0018531B93F4371F4A0E001F590000088F6C
:106E5C008A4816005E4A24007EF014007E901000D2
:106E6C0011201F4A12001F5900001F5A1A001F5AE6
:106E7C0016001F5A1C001B4A22000F9B03340B8F59
:106E8C008A4B180031501000561710011B15318217
:106E9C003A4005000B43B013B69DB0133E98B013A7
:106EAC00C4A06C42B013D09A043C3C406400B013B4
:106EBC006E970D4A0F4B3A533B630DDF0D93F52341
:106ECC003C4045000D43B0139A91B013EEA2B013A1
:106EDC003A8DB013509B0D433C402C1CB0138E9438
:106EEC003C401F5EB0134699B013C89CB0132A895E
:106EFC003C406400B0136E97B01378813C403A5E0E
:106F0C00B01346995B42732B47180B5B5F42742B93
:106F1C000B5F0A413E420D430C41B013629E3D4053
:106F2C00732B0C41B013DA9B5F4107000F125F41CA
:106F3C0008000F125F4109000F125F410A000F1287
:106F4C005F410B000F125F410C000F125F410D00EF
:106F5C000F125F410E000F123C40515EB013469968
:106F6C000E4A0D4B3C40CDABB013187F3C401A0081
:106F7C00B013B08F7C400700B013C89A3C407E5EC3
:106F8C00B01346991F42622B315010000F93072407
:106F9C000F123C40945EB01346992153043C3C4084
:106FAC00AB5EB01346998013525D8013745D8013F1
:106FBC002C5D8013665D0C9302201E43033C8013F2
:106FCC00665D0E4C30121A003C408000B013709B72
:106FDC0003120C121212505D1212725D3C40C05E14
:106FEC00B01346993C40FA8F3D400000B013FEA10F
:106FFC00B0130E9C5C43B013C89AB013FEA23B4076
:10700C00265D3C40105EB013469931500A00083C96
:10701C003F4B1F1202003C40195EB013469921539E
:10702C008B930000F5233C400A00B01370A03C4049
:10703C00265DB013889BB0139AA0B013BC9EB013FE
:10704C00389FB013067F1C93FA37B01348A2B013C5
:10705C00447E0C93F423B01306A14C93F0231E42F0
:10706C00061D1F42081D2C43B01302A3B013BC9E77
:10707C0032D0D80032C203432C43B01386A2824CC8
:10708C00061D824D081D32D2B0139AA0D83F03437F
:10709C005B152183B013C89F0B4C2C43B0130A9D76
:1070AC000C9302200C43493C5C4B010047180C5CD0
:1070BC006F4B0C5FB01322990A4C0C93F327B0134F
:1070CC00C89F0B4C5C4A06007CB0070002241F438F
:1070DC00013C0F4342194C100C5FB0130A9D0C93EA
:1070EC00E1270843194A04000C3C814300000F4679
:1070FC000C41B013BC876F490F5FAF41621E08563D
:10710C00295367494793182456490100B0134C7111
:10711C000D4B0D5C0E483EF0070077901800E52BE8
:10712C000F460C41B013BC870D416C490C5C3C50B4
:10713C00582CB013DA9BE33F0C4A2153561710011D
:10714C000C483E4280005E940A124E4E7A4010006B
:10715C004A8D4A8F5A830230CA180E5E0F4E471959
:10716C000F10CCDF0000CCDE01003A4110015B15A2
:10717C00084C0B4D094E0C4F3F9203346E490C4892
:10718C00323C0A4F3AF00700B0134E71064C0B9389
:10719C0007431720033CEC4B000017530C480C57CB
:1071AC000B490B570796F73B0A931F240F4A6E4B5C
:1071BC007D424D8A133C3F426E4E0D4BB0135471C1
:1071CC0017530C480C570E490E570796F43B0A936D
:1071DC000C240F4A6E4E7D424D8A4D5B5D8302300E
:1071EC00CD180E110D43B0135471561710015B15C9
:1071FC002183094C5A4C06007AB0070002241F4325
:10720C00013C0F4342194A100A5F0C4A2C53B0132D
:10721C008E990C9302200C43353CB01366A1DC49CB
:10722C0002000000DC4903000100B01366A10B4C06
:10723C002B530E4A0D430C4BB013629E0843164958
:10724C000400093C914E621E00000F4A0E41B0131F
:10725C007A71085A26536946499313245A460100F9
:10726C00B0134C710F4C4E490E5E0C4B0C5F0D481D
:10727C003DF0070079901800E52B0F4A3E50582C32
:10728C00E63F1C435A3F03435B154D1231801800F7
:10729C00064C914C10000400F1906F001800032074
:1072AC00B14200000E3C5E4118007ED020007E9062
:1072BC00780003203F401000023C3F400A00814F01
:1072CC00000037403C00284C194C02001A4C0400BA
:1072DC001B4C0600B013169FF19064001800042498
:1072EC00F1906900180012200B931034184108001B
:1072FC0019410A001A410C0038E339E33AE33BE345
:10730C00185309630A630B63B013169FB013CA9D1D
:10731C0011208C9320000E20B19200005720BCB29B
:10732C002400542837531F4104000F57FF403000EE
:10733C0000004C3C3753814706002841094839E38B
:10734C00095909790A493AE30A5A0A7A0B4A8148D7
:10735C00100081491200814A1400814A1600B013B2
:10736C001CA0B0131A9EB013C4777C5030007C90D4
:10737C003A0005285E4118007E50AF004C5E1F415C
:10738C0004001F510600814F0200CF4C0000B013C7
:10739C001CA01B411600B0131A9EB013E876B01354
:1073AC0062A0814F0E00B013CA9D04249691020076
:1073BC000E00C02BB19200000920B6B224000628A2
:1073CC001F410200FF9030000000AC233F403C0006
:1073DC000F87864F14001B4104000B57864B0E0081
:1073EC001B4620000F9B07340B8F864B1800B6C032
:1073FC0010002400143C0B9312345E4624007EF0E3
:10740C0014007E9010000B201746220017861200E5
:10741C0017861800078F17930238864718003150CB
:10742C001A00561710013FE000800612064D065652
:10743C00369001FFA72C064F0656369001FF0E2CF6
:10744C00064D0656369000FF0B20064F065636901A
:10745C0000FF9820064D06EF065694283D43923CBB
:10746C00064F0656369000FF07243FB0FF7F0720DB
:10747C00064D0656872086280C4E0D4F833C3DB09A
:10748C00FF7FFA27091208120712064D074F0656FE
:10749C0007570796092802200E9C06280FED0DEFC2
:1074AC000FED0EEC0CEE0EEC064F0656096986102D
:1074BC007FD08000084D08580969881078F37DD07A
:1074CC0080000743468815247690F1FF0D2C7690AA
:1074DC00E8FF4628074E0E4F0F4376501000092444
:1074EC004793022437D000010F110E10071056538A
:1074FC00FB230649061106E916B32F2437E317536D
:10750C000C7E4D7F10200C93072007933824871096
:10751C004D4738801800063C8C104D4C0CED8710F4
:10752C000CD73882074307570C6C4D6D092C188308
:10753C0007570C6C4D6D042C18830C5C4D6DFC2B9B
:10754C00189311340D43053C585378930C203D404F
:10755C0000FF0C4309100D10123C0C5E4D6FF42F04
:10756C0007570C6C4D6D88100DD809100D100C10B0
:10757C000628079302201CB302241C530D633741C9
:10758C0038413941364110015B153182084C4B4D65
:10759C00094E764003004D969D286E4C7EF00700F8
:1075AC00C14E00006E4C42194E105EF3C14E0100EC
:1075BC006E4C43194E105EF3C14E02006E4C4419D2
:1075CC004E105EF3C14E03006E4C45194E105EF327
:1075DC00C14E04005E4C010041194E104EF6C14ED6
:1075EC0005005E4C010043194E104EF6C14E0600CC
:1075FC005E4C010045194E10C14E07003E420D4134
:10760C000C49B013749ED948020008000A480A5667
:10761C003740F45EC19305002124B013D2A0894EEB
:10762C000A002A535E4105006E930920B013FAA09C
:10763C00D94A01000C00E94A0D002A53133C4E961E
:10764C0011204C430F4A0F8C0E490E5CDE4F070085
:10765C000C005C537C92F62B3A52043CB013FAA00B
:10766C0089430A00C19307002824C1930400062013
:10767C00B013D2A0894E14002A53033C99490A0036
:10768C0014005E4107006E930920B013A2A1D94AE1
:10769C0001001600E94A17002A53133C4E9611209C
:1076AC004C430F4A0F8C0749075CD74F0700160055
:1076BC005C537C92F62B3A52043CB013A2A1894342
:1076CC0014004C4A4C884E4B4E8CC94E3200894AA1
:1076DC003000012C4C4331525617100106120B127C
:1076EC000A120912081231801000814C0800814DD9
:1076FC000A00814E0C00814F0E0081430000814333
:10770C0002008143040081430600B0138C77B01350
:10771C00AA77B1B000800E00B0139A77915108008F
:10772C00080091610A000A0091610C000C00916143
:10773C000E000E001F91160016280B201E9114002F
:10774C00122807201D9112000E2803201C911000F6
:10775C000A281C8110001D7112001E7114001F716B
:10776C00160091D300007653D2232C411D41020008
:10777C001E4104001F410600315018003641100113
:10778C000C430D430E430F43764040001001087824
:10779C0018530C5C0D6D0E6E0F6F0CD810019151BF
:1077AC0004000400916106000600916108000800C5
:1077BC0091610A000A00100106120B120A1209123A
:1077CC0008123182814C0000814D0200814E040070
:1077DC00814F0600B0138C77B1B000800600B01357
:1077EC009A77B013AA771F910E0014280B201E91C4
:1077FC000C00102807201D910A000C2803201C9156
:10780C00080008281C8108001D710A001E710C005C
:10781C001F710E007653E0233150100036411001D9
:10782C000612064D0656369001FF902C064F065652
:10783C00369001FF0A2C064F36F000800DE63DB065
:10784C00FF7F05203FB0FF7F81203D437F3C3FB051
:10785C00FF7F06200C433DF000803DD0807F763CBE
:10786C00064F0656369000FF0920064D06563690F8
:10787C0000FFEB273DC0FF7F0C43683C064D0656CE
:10788C00369000FF63240A120B1208120B4D0A4C9F
:10789C000F5F0D5D084F0F108D1088107DF378F37E
:1078AC0038807F000D882630084D3FD080007BD07B
:1078BC0080001C430D430A8E4B7F2C2C18831A30EE
:1078CC000A5A4B6B0A5E4B6F0A5A4B6B25280A8E71
:1078DC004B7F12D30C6C4D6DF72B3890FF00033897
:1078EC003D4000FF083C089327201CD33C9302200A
:1078FC007D9322240D430C430F6F0D10243C0C6C14
:10790C004D6D08280A93E9234B93E7232CB3E52309
:10791C001CC3E33F0A5A4B6B04300C6C4D6DFA2BB5
:10792C00DC3F0A8E4B7FEB2F0C6C4D6DD62F0A5A19
:10793C004B6B0A5E4B6FCD3F88100DD80F6F0D103F
:10794C000C100C630D6338413B413A413641100138
:10795C003B15318006000B4C084D4A4E0D41B013BF
:10796C0036876E415F4101000E5F5F4102000E5F82
:10797C005F4103000E5F5F4104000E5F3E50030049
:10798C000A9E02344C436C3C5E4B04005EF345187B
:10799C004E5E5F4B03005FF344184F5F5D4B02007C
:1079AC005DF343184D5D5A4B01005AF342184A5A85
:1079BC006C4B7CF007004CDA4CDD4CDF4CDEC84CD9
:1079CC0000005E4B070045184E5E5F4B06007FF0D3
:1079DC00030043184F5F5D4B05007DF00300411819
:1079EC004D5D4DDF4DDEC84D0100D84B0800020047
:1079FC007C400300E19300000820D84B0A000300F0
:107A0C00D84B0B0004007C4005005E410100073C94
:107A1C000A4B0A5EDF4A0B0000004C4D3E530F48E8
:107A2C000F5C4D4C5D531E93F337E19302000A201B
:107A3C00DF4B140000004C4D0F480F5CDF4B150062
:107A4C0000005C535E410300093C0D4B0D5E0F487A
:107A5C000F5CDF4D150000005C533E531E93F53751
:107A6C0031500600381710010612064D0656369096
:107A7C0001FF802C064F0656369001FF0C2C064F4A
:107A8C0036F000800DE6064D0656369000FF0520B8
:107A9C00064F06566F203D436D3C064F06563690FA
:107AAC0000FF3640FF7F08200DB6F5273DF0008023
:107ABC003DD0807F0C435E3C0DB65C240FB602209B
:107ACC000DC6F83F0A120B1208120A4C0B4D3BD094
:107ADC0080000D5D8D10484D0C430D4306430E93F5
:107AEC000D2416434E93022086108E100E10022881
:107AFC000C5A4D6B4D100C100666F82B26430124C6
:107B0C0016D30F1002280C5A4D6B4D100C104666F4
:107B1C00F82B3FF0FF00085F38807F001030389062
:107B2C00FF000F340C5A4D6B122C089304240611D1
:107B3C000C6C4D6D0F3C7D9302203C930B240D433C
:107B4C00023C3D4000FF0B5B0D100C43103C1853E6
:107B5C007893F7270B5B48104D1088100DD80C103C
:107B6C000628069302201CB302241C530D633841D3
:107B7C003B413A41364110013B15318034003E40C7
:107B8C0034000D430C41B013629EC293762B062039
:107B9C00D243762BB013BAA2C24C752BD143000042
:107BAC00C1430100D142861E0200B013B89F0324CA
:107BBC00C1430300033CD142781E0300C1430400BF
:107BCC00C14306008293761E0424D142761E08001F
:107BDC00093CD142752B0800D253752B5F4108002C
:107BEC00824F761EE1430700B140CDAB0A00B013C3
:107BFC00B89F0724E1430500F1430C00F1430D004D
:107C0C00093C3D408A2C0C413C500C00B013DA9BD3
:107C1C00E1430500B140CDAB14003D40732B0C414A
:107C2C003C501600B013DA9BB013C89F814C300047
:107C3C00B013B0A2C14C32000C41B0138E984A4C18
:107C4C00484C0C48B0138E990C930924B01366A1C0
:107C5C000D4C4E4A0C41B0135C790C48013C0C4362
:107C6C0031503400381710013B1521830B4CD25383
:107C7C00A92C4A4382936E1E0824B0136A6B4A4C9B
:107C8C005C426E1E7C53B013886BB01336A1084C4B
:107C9C00B01366692CB3072CB0131EA10C883C5092
:107CAC0034F30C93F53B7C400500B01356693F4010
:107CBC001605F2B0400061023C2891425C2B00009A
:107CCC00A2927E1E1B20D2C32202B013449D4E4BA7
:107CDC007E537ED08000C24EEE05B013449D3B53C4
:107CEC005B037BF0C000C24BEE054E43B01368A2A1
:107CFC000F51B013C2A1FA2BB0134EA1B013666989
:107D0C003CB2062CB013DE692C43215338171001FA
:107D1C00B013B29CC293A82C0220B0137E6982933C
:107D2C006E1E03244C4AB013886BB013DE690C43EF
:107D3C00EC3F3F530F93BD239253461D8263481D66
:107D4C0082936E1EDF274C4AB013886BDB3F0343D4
:107D5C001B1521820A4C0B4DE2B26102022C0C4322
:107D6C00683CC243A52CD253A92C92535A2B0C41DC
:107D7C00B013F26BF190800000000928B0132C694D
:107D8C0092533E1D8263401DB013DE69E83FF190B3
:107D9C0003000000072CB0132C6992533A1D826328
:107DAC003C1DF23F6D412D830B9D092CB0132C69AA
:107DBC009253361D8263381DB013DE69D03F0C4AD6
:107DCC00B013A66B2D430C411C53B013A66BC1937F
:107DDC0002001534D2410100A62C5E4102007EF057
:107DEC007F00C24EA72C5F42A62C8F11824F6A1EB9
:107DFC00824E681E9253521D8263541D063C925350
:107E0C00421D8263441DE1430000E2B261020A2874
:107E1C00E2B36102032CB0132C69043C3C40581CA7
:107E2C00B013F49BB013DE69E1930000982B6C4106
:107E3C002C8321521A1710015C427F2B5F42822B3C
:107E4C000C5F10010A12C243822B1A42161E0E3C02
:107E5C00CA930B000A24DA430A00CA430B000E43F0
:107E6C007D4082000C4AB013308E2A4A0A93F023CC
:107E7C003A4110013B15C2937F2B3D245C42802B71
:107E8C000F4C44180F5C5A4F1A1EC24A832B1B4FBF
:107E9C001C1E824B4A1E184F1E1E82484C1E1C5321
:107EAC003E42B0135E94C24E802BF2537F2B08934C
:107EBC0018209242161E4E1E82934E1E1C24C293F4
:107ECC00822B0224B013507E1E424A1E5D42832B2D
:107EDC001C424E1EB013308E1F424E1EA24F4E1E21
:107EEC00EB3F7A9081000220D8430A000E4B4D4A9A
:107EFC000C48B013308E38171001C293822B022419
:107F0C00B013507EB013807E973F03433B153180F6
:107F1C000A000A4C0B4D084ED253A92CB0131EA1CB
:107F2C00094CB013E0A1072CB0131EA10C893C50D6
:107F3C0034F30C93F63BC14A000047190A10C14AAE
:107F4C000100D2C32202B013449DF240E800EE05BA
:107F5C00B013B6A0B01368A20F51B013C2A1FA2B84
:107F6C00B0134EA1C14B000047190B10C14B0100BF
:107F7C00D2C32202B013449DF240EA00EE05B013C6
:107F8C00B6A0B01368A20F51B013C2A1FA2BB01354
:107F9C004EA108931F240F430B480B5F0E412E5329
:107FAC000E8FEE4B07001F533F92F62BD2C32202CB
:107FBC00B013449DF240E000EE05B013B6A0B01330
:107FCC0068A20F51D24F0200EE055E537E92F72B42
:107FDC00B0134EA1B013DE6931500A0038171001EE
:107FEC007B152183084C094DC2437D2B0F4D0F830C
:107FFC0007241F8308241F8303241F830724083CA2
:10800C00DC530A00053CDC530C00023CDC530D0035
:10801C00144C0400154C0600914C08000000574C01
:10802C000A001D9302242D933120B013789F0A4C23
:10803C000B4D56480A001653269202383640030060
:10804C00B013BAA203120C120C460D463DE30D5DA3
:10805C000D7D0E4A0F4BB013E2950E4C0F4D3C416B
:10806C003D41B0134E93D8980B000A000F2C3012E0
:10807C000000301296960D430E5A0F6BB01370A27F
:10808C001C480200B0132AA021520B3CB013648F81
:10809C0007120F491E4102000C440D45B013F69A0D
:1080AC0021532153741710013B150A4C0B4D084EEC
:1080BC009242141E761E9253141E3D40F45E3C40B8
:1080CC008A2CB013D2990C934A203C40161CB01346
:1080DC00D692094C0C934324B013FC89894C0200B2
:1080EC000C9338248293741E03207E400300023CC0
:1080FC005E42741EC94E0B00C9430A00C9430C00F2
:10810C00C9430D00894A0400894B060089480800C0
:10811C0092937E1E0D491C421E1C0320B013DE9C44
:10812C00023CB013B4981C421E1CB013509E1C93FE
:10813C001B383C40FE1DB01310960C9315243012C6
:10814C000000301296960D430E430F43B01370A2ED
:10815C0021520A3C0D493C40161CB01326940E4883
:10816C000C4A0D4B8013565D38171001B01348A202
:10817C00B0138E9DB2C010004603B013F499F2D226
:10818C0063023C40FA00B0139EA2F2C010006302DE
:10819C003C407F00B0139EA2F2D0100063023C4022
:1081AC007D00B0139EA25C43B01356697C40110055
:1081BC00B013E86A3CD010080D4C7C401100B01391
:1081CC00066A3D4000057C401200B013066A7C40F4
:1081DC001700B013E86A3CD000200D4C7C4017000F
:1081EC00B013066A3D407F007C401C00B013066A49
:1081FC007C401900B013E86A3CF0FFFD0D4C7C404C
:10820C001900B013066A0E430D433C43B013187F9C
:10821C003C401A00B013B08FB0132C690D433C4096
:10822C00581CB0138E941C4310013B150A4C2F4C58
:10823C000F8304243F805A0008244F3C8243581E6D
:10824C00BA405A0000005C434C3C7D9087000724E8
:10825C007D908200F5231D3C924B0800581E1B425A
:10826C00581E0B93ED278B9E0A00F627033C9B4F61
:10827C00080008001F4B08000F93E2278F9E0A008E
:10828C00F6270B4FF73F824F581E8B430800B01355
:10829C00608A08431B42581E073C3C402C1CB01300
:1082AC00F49B084B1B4B08000B93CA270C4BB013C9
:1082BC006A990C93F6270E4B7D4088001C4B0A00E4
:1082CC00B0138C900C93E9238B430A001F4B0800CE
:1082DC000893D927884F0800D83F8C4300007C4076
:1082EC000300381710010A121F42661C1FD2681CAB
:1082FC000F9302248013661C1F426A1C1FD26C1C35
:10830C000F93022480136A1C1F42721C1FD2741C10
:10831C000F9302248013721C1F42F61C1FD2F81CF0
:10832C000F9302248013F61CC293722B22201C4242
:10833C00001C1D42021C7A42B013869C7A53FC230B
:10834C00824C001C824D021C0A43B013209D0F4A24
:10835C005F068F4C761C8F4D781C1A533A90200078
:10836C00F43B9242F21C6E1C9242F41C701CD243E1
:10837C00722BB013209D1A426E1C3AF01F005A0645
:10838C001E4A761C1F4A781C824E6E1C824F701C33
:10839C008A4C761C8A4D781C0C4F3CF0FF7F3A417E
:1083AC0010011B1531803400B013B0A20A4CB0136D
:1083BC00C89F0B410E414D4AB01394754C93132436
:1083CC005F4132000C4A0C8FB0130A9D0C930B24A6
:1083DC005E4105004E931C241F410A003F90CDAB1B
:1083EC0004243F9302240C43263C6E9302243E4209
:1083FC00013C2E433E530C380F410F5EFF930C0093
:10840C00F9270D413D500C003C408A2CB013DA9BEF
:10841C003B5016000D4B3C40882CB013DA9B5F414F
:10842C000200824F861E5F410800824F7C1E5F4116
:10843C0032000A8F0C4A315034001A1710013B15C8
:10844C000A4C084E2F4C0F8304243F804B001624FB
:10845C003C3CB01330A20B4C093C1E4B06001F4B8E
:10846C0008000C4B2C53B013569D2B4B0B93F52340
:10847C00D243872CBA404B000000033C7D9088000F
:10848C0002245C43263CB01330A20B4C013C2B4B1A
:10849C000B93F0270F4B2F530F98F9230D4BB01361
:1084AC00BAA11842181E924B0E00181E1E4B10003B
:1084BC001F4B12000D4E0DDF0D9304241C4B1400AA
:1084CC00B013DEA28248181ED53F8C4300007C40BE
:1084DC000300381710011B151D4C020046190D1016
:1084EC007DF33D90FF000820FCB07F0002000220CD
:1084FC001C433B3C2C43393C0D9336240F931738CB
:10850C0002201E9314287A430A8D0F9310380220F0
:10851C000E9A0D288C93020003343F4080FF023CDE
:10852C003F40807F8C4300008C4F0200E13F0A4D9E
:10853C003AE31A530B4A3BE30B5B0B7B0B9F033861
:10854C000E200A9E0C2C0E5D46180E5E1F4C02006F
:10855C003FF07F800FDE8C4F02003C43063CBCF0AA
:10856C00008002008C4300000C431A1710010A1201
:10857C000A4C2F4C0F8307243F80680012243F8045
:10858C00120037243A3CB0138CA0C24C052C824309
:10859C00561E073C3F907F000434CF4C072C92535F
:1085AC00561E3C40501EB01316983C930520BA4002
:1085BC00680000005C43253C1F42561E3C900A009C
:1085CC00E923CF43072C9253561E3E40072C5D42A5
:1085DC00052C0C43B0138C900E437D4085001C423F
:1085EC00181EB0138C900C93D223BA407A00000062
:1085FC00E13F7D908500DE23CA3F8C4300007C4028
:10860C0003003A4110010D93083408123CE33DE39A
:10861C001C530D6338409701033C081238409700F7
:10862C003D9000011C2C0D930F203C90000106285E
:10863C008C104D4C3CC0FF003882063C0C930D2432
:10864C000D4C0C433880100018830C5C4D6DFC2BCA
:10865C0008114D100C1088100DD83841100107125C
:10866C0047433D900002082812C30D100C10471010
:10867C0018533D900002F82F08114D100C10881063
:10868C000DD84767062812C34710012002281C5337
:10869C000D633741384110015B15094C064D1842EA
:1086AC00181E1B42161E033C0B933D242B4B0B9C9C
:1086BC00FB230B933824B01338A00C932324C94309
:1086CC000A001B42161E093C099B06240E497D40DC
:1086DC0087000C4BB013308E2B4B0B93F5231A49A0
:1086EC0004001B4906000F4A0FDB0F930B2409965D
:1086FC0009248249181E0E437D4083000C493C52CC
:10870C00B013E6A21B42161E099B0420A24B161E98
:10871C00083C0B4F0B9305242F4B0F99FA23AB49B5
:10872C0000008248181E561710011B150A4C0B4DE1
:10873C003E4005000D430C4BB013629E7E4003007F
:10874C00CABE05000224EB430000CABE0700022487
:10875C00EB430200CABE05000C24CABE0700092464
:10876C009A9A0A0014000520DA430400CB43020055
:10877C00023CCA4304004F4E5FFA05006F83042489
:10878C005F8304207F42033C6F43013C4F43CB4F3C
:10879C0001005EFA07006E8304245E8304207E428F
:1087AC00033C6E43013C4E43CB4E03001A171001A1
:1087BC007B150B4C084D074E3F9208340E4F0D475E
:1087CC000C48B013C296CB4C0000323C0A4F3AF026
:1087DC0007000C4FB0134E71094C079306431A2037
:1087EC00033CE74C00001653074B07560C480C563D
:1087FC000699F73B0E4A0A931B240D43B013C296FD
:10880C00C74C0000153C3E420D47B013C296C44CF9
:10881C0000001653044B04560C480C560699F33BB7
:10882C000E4A0A9305240D47B013C296C44C00009F
:10883C00741710013B15318006000A4DB013C89F08
:10884C000D4C2E430C41B013749E2F415F073F908B
:10885C0003000828111202003C40FB5EB01346993D
:10886C002153223C0B431E3CB013C89F084B5806A7
:10887C002E430C582C530D4C0C412C53B013749E9E
:10888C00B013C89F0D4C2E430D582D520C412C5239
:10889C00B013749E1E4104001D4102000C4AB0131B
:1088AC0098921B532B91E02B315006003817100176
:1088BC000D4A3C40501CB013EE960C9310010A125A
:1088CC00B0131E890E242D4A0C4A2C53B013449716
:1088DC000D4A3D50B2003A5082000C4AB0135A92E5
:1088EC00163CB013BC881324B013D89A2D4A1C4ADA
:1088FC000200B01344975C4A3400B0138E99B01345
:10890C0066A15E4A34002A520D4AB013749E3A4155
:10891C0010010A4C0D4C3C40481CCD3F03430A123D
:10892C0021832E430D430C41B013629E1E42622BD9
:10893C000E930D200E430D4E3DE31D530F410F5E64
:10894C00DF4DB32C00001E532E93072CF43FC14E69
:10895C00000047190E10C14E01000C41B013CCA100
:10896C003C40ED5DB01346996F410F123C40085EE0
:10897C00B01346995F4103000F123C400C5EB013DC
:10898C004699315006003A411001C2430A02C243D3
:10899C000B02C2432A02C2432B02C2434A02C24305
:1089AC004B02C2430402C2430202C2430502C24349
:1089BC000302C2430B02C2432402C2432202C2433B
:1089CC002502C2432302C2434402C2434202C243B1
:1089DC004502C2434302C2436402C2436202C24321
:1089EC006502C2436302C2431A02C2431B02100156
:1089FC000A12B013709C0C9316243C40501CB013FC
:108A0C00D6920A4C0C932324B013B0A28A4C0000CB
:108A1C00B01380A28A4C02000C4A2C52B013989AC4
:108A2C00CA4C3400143C3C40481CB013D6920A4C3F
:108A3C000C930D242C53B013808E8A4C00000D4ADD
:108A4C003D50B2000C4A3C508200B0137C920C4A50
:108A5C003A4110013B158293581E03200C430D43E1
:108A6C00243CB013629D1F42581E2A4F1B4F02001C
:108A7C001A5F04001B6F06000A8C0B7D103C284FFC
:108A8C00194F0200185F0400196F0600088C097D4D
:108A9C00099B03280420089A022C0A480B491F4FF3
:108AAC0008000F93EC230C5A0D6B824C5A1E824D0E
:108ABC005C1E381710013B150A4C0B4D084E3D40FF
:108ACC00732B3C40882CB013DA9B80136A5D0C939B
:108ADC0003203F400500163CB0137EA0094CB01398
:108AEC0066A10D498013985D0C8305242C83052405
:108AFC001C830524063C0F43053C1F43033C2F43BA
:108B0C00013C2F4213120E480C4A0D4BB013F69A2F
:108B1C002153381710010A12B013D89AB013C89FFA
:108B2C000A4C8C430000B01358A2123C2F4A5F062B
:108B3C000E4A0E5F9E4C020002002F4A5F060E4A40
:108B4C000E5F9E4C040004009A530000B01372A1F7
:108B5C000C930324CC930A00E9232C4A5C062C5377
:108B6C00B01392A28A93000004243C405C1DB01305
:108B7C00C09B3A4110010E4CD253A92C92534E1D5E
:108B8C008263501D7C400900B01356694F4D6F53E2
:108B9C00D2C32202B013449DF2403E00EE05B01346
:108BAC00449DC24FEE05B013369DF2403E00EE05DB
:108BBC004F43073CB013449D0C4E0C5FE24CEE054A
:108BCC005F530F9DF72BB0134EA1B013DE690C430E
:108BDC001001B013B8A10D4A1C42381CB013B49844
:108BEC001A1710011B42181EB2403A1C181E2C53A7
:108BFC0010011B150A4C9C42181E0E009C410800CB
:108C0C0010009C410A0012008C4D1400C293872C5A
:108C1C000724B013F08BB013569D824B181E043CE6
:108C2C008C4E06008C4F0800D43F03430A121A42A4
:108C3C00461CB013709C0C930A241E42921E1D42BB
:108C4C00481F3A5030000C4AB013749E183C829363
:108C5C00941E15241E42921E3E5030003D403000A2
:108C6C000A3C0F4D1F52941E0C4A0C5F0F4A0F5DAD
:108C7C00EF4C00001D530D9EF43B8243941E3A4171
:108C8C0010010A120A4C2F4C0F8304243F80380029
:108C9C0010241C3C3C40DA5DB01346993E408000E9
:108CAC000F433C40FA1CB013569DBA4038000000EC
:108CBC00063C3C40FA1CB013F29F0C9302205C4320
:108CCC00093C7C400700B013B89AE83F8C43000085
:108CDC007C4003003A4110010612064D06563690B0
:108CEC0001FF052C064F0656369001FF022812C3D1
:108CFC001C3C3DB0FF7F1524064F065603200DFD8E
:108D0C00F633123C07280DFD0F340F9D0E200E9CE0
:108D1C000C200A3C0DFDEB330D9F07200C9E05200B
:108D2C00033C064F0656012012D336411001D29255
:108D3C00641C00180C20D292651C011808204F43AB
:108D4C00DF4F0218AC2C5F537F92122CF93FE24399
:108D5C00AC2CF2401200AD2CF2407400AF2CC2438C
:108D6C00B02CD243B12CE243B22CF2400300B32C12
:108D7C005E42B32C5F42B22C5F060EDF824E622B3A
:108D8C0010010612064D0656369001FF202C064F98
:108D9C000656369001FF1B2C3FB0FF7F1524064D65
:108DAC00065603200FFF1330133C07280FFF103417
:108DBC000D9F0E200C9E0B240B3C0FFF08300F9DBB
:108DCC0007200E9C0424043C064D0656012012C3B9
:108DDC00364110010A120A4C2F4C0F8304243F8099
:108DEC0084020524193CBA4084020000033C7D90A7
:108DFC00820002245C43143CB013D89A92425E2B3E
:108E0C006C1EB013C89F3D408000B0135C7DB01346
:108E1C0092A280135A5DE73F8C4300007C40030014
:108E2C003A4110013B15084C494DDCB30A0020288F
:108E3C001A4C04001B4C06000F4A0FDB0F9318242E
:108E4C00824C181EEC430A004D493C52B013E6A26A
:108E5C004C4C2C9306243C90030003247990830003
:108E6C0005200D480C48B013A486023CD8430A00D8
:108E7C00381710010A120A4C5F42902C3E40300009
:108E8C000E8F0D4E1D52921E3D90810002280C43F8
:108E9C00153C1D42461C0D5FB013749E1E42921E63
:108EAC001D42481F1D52941E5F42902C0A8F3A504F
:108EBC0030000C4AB013A89A1C52921E3A41100171
:108ECC0006120712064D7DD08000066607678610D5
:108EDC0076F376807F00032C0C430D43133C768095
:108EEC001800072C76E30E240D110C105683FC236E
:108EFC00093C369203383C433D43043C0C5C0D6DFD
:108F0C005683FC2F07103741364110011F4D0200CC
:108F1C0046190F107FF33F90FF000A208C4300008E
:108F2C00FDB07F00020002201C4310012C431001F5
:108F3C001F930E381E4D02003EF07F803ED0003F46
:108F4C008D4E02003F5082FF8C4F00003C431001BD
:108F5C008C4300000C4310010A12B01346A02024CD
:108F6C001C4A0200B013DA980D4A1C421E1CB013A6
:108F7C006A960D4A3C40161CB01326941C421E1CCB
:108F8C00B013509E1C930C38B013789F0E4C0F4DA1
:108F9C0030120000301296960D43B01370A221527D
:108FAC003A4110011B15D253A92C824C602B3A402C
:108FBC002E4144180A5CB0131EA10B4CB013E0A157
:108FCC00032CB013A8A0FA3BB013B29C0D4A7C4002
:108FDC001800B013066AC293A82C04247C4003002A
:108FEC00B0135669B013DE691C431A1710017C903C
:108FFC000D0002200C431001C293062C0A204D4C8C
:10900C003C40501EB013BC930C931020D243062C42
:10901C000D3C7C900A000A207D400A003C40501E0A
:10902C00B013BC930C930224C243062C3C40201C6E
:10903C00B013F49B1C4310011B159253121D826339
:10904C00141DB013489F0A4C1C42101CB013F6A2FE
:10905C000D3C1E4B02001F4B04000D4E0DDF0D93FB
:10906C000224B013DEA20C4BB01372A10B4C0B9369
:10907C00F0230A9303240C4AB013889F1A1710018B
:10908C000A12F2927F2B02201C431B3C5F42802B66
:10909C005F527F2B7FF00700C24F842B0A4F44187E
:1090AC000A5FCA4D1A1E8A4E1C1E8A4C1E1ED253B3
:1090BC007F2B5E427F2BC29E812B022CC24E812BBA
:1090CC000C433A4110011B150A4E0B4F3E40345DC8
:1090DC000D4C3C405C1DB013169A824A941D824B79
:1090EC00961D92410800981D92410A009A1D9241CA
:1090FC000C009C1D92410E009E1D3C40409C3D402E
:10910C000000B01308A21A1710013B150A4C0B4DA6
:10911C00084E1C42101CB013F6A20E3C1E49060051
:10912C001F4908000D4E0DDF0D9303240C4BB0139B
:10913C00DEA20C49B01372A1094C0993EF230E481F
:10914C000D4B0C4AB013EC97381710015B15084CFB
:10915C00094D064E0A433B402041133C16B30828E8
:10916C000E4A0F4B0C480D49B013747A084C094D3C
:10917C0006110E4A0F4B0C4A0D4BB013747A0A4C65
:10918C000B4D0693EB230C480D4956171001D2D307
:10919C00C005F2D08000C005F2404500C605C243B0
:1091AC00C705F2400600C805F2C020002402F2D028
:1091BC0010002402F2D030002A02C243B42CD2C3D5
:1091CC00DC05E2C3DC05D2C3C005D2D3DC0510013B
:1091DC00091209430F9305343EE33FE31E530F631B
:1091EC0019D30D9305343CE33DE31C530D6339E374
:1091FC00B0134E9319B304243CE33DE31C530D63AD
:10920C0029B304243EE33FE31E530F63394110019D
:10921C000A120A4C3C402C1CB013F49B1F42581EE3
:10922C008A930A0009240E4F023C1E4E08000E932E
:10923C0003240E9AFA23073C9A42181E0A008A4FFE
:10924C000800824A581EB013608A3A4110010A1273
:10925C000A4D3E4030000D4C3C40621EB013749ED3
:10926C003E420D4A3C40882CB013749E3A4110018A
:10927C000A120A4D3E4030003D40621EB013749EEF
:10928C003E423D40882C0C4AEF3F03435B15084C93
:10929C00094D064E1C42121CB013F6A2023CB01330
:1092AC0072A10C9310248C990200F9231A4C06001D
:1092BC001B4C08000F4A0FDB0F9305240F460E4979
:1092CC000D48B013E6A2561710010E43013C1E5375
:1092DC001E9C0200172C1F4C04000F5ECF93000045
:1092EC00F623DF5300001F4C0600021232C2034368
:1092FC00824EC004A24CC8041E42CA0432410F5E06
:10930C000C4F10010C4310010A12301200003012E5
:10931C009897B013EEA03C407E1DB013FE8BB0139B
:10932C00BAA2301200003012228BB013EEA0B01390
:10933C004E930D433C40681DB013FE8B31523A41A5
:10934C00100109120A120B120A430B433940200078
:10935C000C5C0D6D0A6A0B6B0A8E0B7F04281CD3F8
:10936C003953F623043C0A5E0B6F3953F1230E4A32
:10937C000F4B3B413A41394110010A120A4C1E4C29
:10938C0002000D431C4A0400B013629E021232C24A
:10939C000343A24AC004924A0200C8041E42CA04F3
:1093AC0032410D431C4A0600B013629E3A41100133
:1093BC000A125E4C02005F4C03004A4F5A8C0400A8
:1093CC004AFE4A9E02200C430C3C2E4C0E5FCE4DA6
:1093DC0000005E4C03005E535EFC0200CC4E0300AA
:1093EC001C433A411001B013A89FB013D89AB01384
:1093FC0078A2B240725D0A1DB013C6A230120700EB
:10940C003012000803123012001E3E4000040F43BD
:10941C002C43B013D290315210011F4C06000E4356
:10942C00023C2F5C1E531E9C02000F2C0F9DF92337
:10943C001F4C04000F5ECF9300000224FF5300006A
:10944C001F4C04000F5E6C4F10017C4310018C11FB
:10945C008E11091209430E9303343EE31E5319D3A4
:10946C000C9303343CE31C5339E3B013709B19B3D6
:10947C0002243CE31C5329B302243EE31E5339411E
:10948C0010011F42161E0E4F013C2E4E0E9C022444
:10949C000E93FB230E9C0D248C4F0000824C161E49
:1094AC00DC430A008C4308000E4D7D408100B01354
:1094BC002C9E1001B013CC8E0F283D9000800620FE
:1094CC000C9309243D4000800C431001FB2F3CE31E
:1094DC003DE31C530D6310013DB00080FC273D4063
:1094EC00FF7F3C431001D2D3E005F2D08000E005B1
:1094FC00F2406900E105C243E705E243E605F2D01C
:10950C000E002A02F2D00C002402D2C3FC05E2C3E6
:10951C00FC05D2C3E00510010A120A430F4A0F5F83
:10952C008F43621E1A533A901800F83B0A433D4091
:10953C00F45E0C4A0C5C3C50882CB013DA9B1A532A
:10954C002A92F53B3A4110011F42601E0F931324DF
:10955C008243601E1D4F06000C4F1E4F02001F4F12
:10956C000400B013DEA28293601E05241F42601E0D
:10957C002C4FB0138CA210010A120A4C92530E1DE0
:10958C008263101DB013A49B0C930B24B013388C66
:10959C000E4A3C4016913D4000008013785D1C4300
:1095AC00013C0C433A41100180136E5D0C93122464
:1095BC003D40732B3C408A2CB013D2990C9308205D
:1095CC003D40F45E3C408A2CB013D2990C9302249B
:1095DC0080137C5D10010A120B120A4C0B4D0C43CC
:1095EC000D430A9302200B930A245B030A100228F2
:1095FC000C5E0D6F0E5E0F6FF4230E93F2233B4146
:10960C003A4110010A120A4CC293872C05242A53A2
:10961C000C4AB013F29F0B3CB01330A2013C2C4C03
:10962C000C9304240C9AFB230C43013C1C433A413D
:10963C0010013B154E120A4C0B4D0843013C1853BC
:10964C00089B09341E430D410C4AB013B0990C937E
:10965C00F6270C43013C1C432153381710012F4CA7
:10966C000F9312240E43023C0E4F2F4F0F930C24DA
:10967C000F9DFA232D4F0E9303208C4D0000023CBE
:10968C008E4D00008F43000010010A12C2937D2BF7
:10969C001020B01346A00D241C4A0200B013CA8837
:1096AC00D2437D2B0E4A3C40EC7F3D4000008013A2
:1096BC00565D3A4110015F4C01006C4C47180C5C34
:1096CC000CDF5D830230CD180C5C47190C105F4E1B
:1096DC001E5F0CFF7F424F8E5F830230CF190C1040
:1096EC0010011F4C06000D9F1028021232C20343BA
:1096FC00924C0200C004A24CC8041E42CA0432415F
:10970C000F5E0D9F4C7C5CF310014C4310010A1250
:10971C000A4C1C4A0C001E4A08001F4A0A00B013CF
:10972C00DEA28A4C0C000C9304249A531E000C43AA
:10973C00013C3C433A4110011B150A4C0B4DB01334
:10974C00D89A3B90810002283B4080000E4B0D4A7A
:10975C001C42481FB013749E824B921E0C4B1A175E
:10976C0010011B150E4CB013629D0A4C0B4DB0131F
:10977C00629D0C8A0D7B0F4E3FE30F5F0F7F0D9F99
:10978C00F62B02200C9EF32B1A171001B013F0A02D
:10979C000E5E0F6F1C429C1D1D429E1D0D9F0328CB
:1097AC0004200C9E022C0E4C0F4D824EA01D824F9D
:1097BC00A21D800014931B150F4C1C4F0A001A4C51
:1097CC0004001ADC06000A9309240C4F1F4F0A00F0
:1097DC001A4F04001B4F0600B013E6A21A17100113
:1097EC001B150F4C1C4F08001A4C04001ADC060009
:1097FC000A9309240C4F1F4F08001A4F04001B4FEB
:10980C000600B013E6A21A1710015D4C02005F4C63
:10981C0004005E4C03004E8F4EBD09242E4C0E5F8F
:10982C006E4E5F534FFDCC4F04004C4E10013C4329
:10983C00100132C20343B24004018003B240100055
:10984C008403B24000019403B2D020008003824311
:10985C006C2B82436E2B32D210010A1221830A4CDC
:10986C003D40882C0C41B013DA9B0D410C4A1F4A29
:10987C000A002E4F1F4F0200B013DEA221533A41B3
:10988C001001318006000D41B01336876C415C51DC
:10989C0001005C5102005C5103005C5104007C50DF
:1098AC0003003150060010011B150A4C0B4DB01370
:1098BC006A968B4300000C4AB013069E0C9303204F
:1098CC008A4B0000023C8C4B00001A1710010A1244
:1098DC00B0131E890D4A03243C40481C063CB013AF
:1098EC00BE8805240D4A3C40501CB01326943A41C6
:1098FC0010015F4262026CB20E7E5E0A7E527FC223
:10990C004FDEC24F62025CB3032CD2C36302100160
:10991C00D2D3630210010A120A4C1C42141CB0135D
:10992C00F6A2023CB01372A10C9304248C9A020090
:10993C00F923013C0C433A41100121830F413F5064
:10994C000600814F00000F410F120F4C1E433C408C
:10995C00289C3D400000B0135260215210013B1571
:10996C00084C1A4C04001B4C0600B013629D3C883A
:10997C003D781C530D630A8C0B7D4C7C5CF33817C3
:10998C0010010E4C5F42902C0F9C0A38B0137EA035
:10999C000C5E3C908100042CC28E902C1C43100158
:1099AC000C4310013B150A4C0B4D084E0C43013C6B
:1099BC003853089306247D4B0C4AB0131A970C931A
:1099CC00F737381710010A124E430A4C0A5E0F4D36
:1099DC000F5EEA9F000002240C43043C5E536E931E
:1099EC00F42B1C433A411001B2C010004603E2D2E2
:1099FC006B02B24004014003B2401059460392C3BB
:109A0C004603B2D02000400310013B150A4C0B4D0D
:109A1C00084E3E403C5DB013329B8A480A003D40E4
:109A2C00185F0C4BB013389A381710011B150A4DE0
:109A3C00B01322990B4C0C9307248C4A04000C4A4B
:109A4C00B013D2A2CB4C06001A171001B013629DB2
:109A5C008A4C00008A4D02003A4110010A120A4C4D
:109A6C008C4E04008C4F0600F13F034332D0400073
:109A7C0082436001B24040006201B240F4006401D4
:109A8C00B2403300680132C0400010015F42902C9C
:109A9C003E4030000E8F1D42461C0D5FB013749E6D
:109AAC003C4030005F42902C0C8F1001C2ECA42C77
:109ABC005C42A32C5CE2A42C8000FE98C2CCA32CAC
:109ACC00F73F0343C2DCA32CF33F03438243941EB2
:109ADC008243921EF2403000902C1F42461C3F5095
:109AEC003000824F481F800024951B150A4C0B4DEB
:109AFC000C4E0E4A0EDD0E9305241E4108000D4F30
:109B0C00B013E6A21A17100192C346033C40581C2E
:109B1C00B013F49B92425C2B5E2BD253A52C925328
:109B2C00582B1C4310013B150A4C0B4D084EB0131F
:109B3C00E49F8A4808003D401C5F0C4BB013389AD8
:109B4C0038171001F2408A007E2BC243802BC2438F
:109B5C007F2BC243812B8243161E8243181E100199
:109B6C007CF37EF30F4E0D4C0E431C430D5D0E6EBD
:109B7C000E9F01280E8F0C6CF92B10011B150A4C33
:109B8C000B43053C0D432C4EB0138E941B53B0135A
:109B9C0054A0F8231A1710010A120A4C8013485DBE
:109BAC00924A0200641E0C9302200C43013C1C439D
:109BBC003A4110010A120A4C3D40732B3C40882C50
:109BCC00B013DA9B0C4AB013C2A23A4110010A122C
:109BDC004E430A4D0A5E0F4C0F5EEF4A00005E5377
:109BEC006E93F72B3A4110010C930A245E4C0A0039
:109BFC005E9302246E930420DC430B00D243822B31
:109C0C0010017E4080003D40852B3C40501EB0131F
:109C1C00DE9D0D433C40201C80008E941B150B4C8C
:109C2C004A4D0C4AB01370A00C9A01240B430C4BF8
:109C3C001A171001D193040008209242941DA01D04
:109C4C009242961DA21DB01314931001B01300A0E4
:109C5C000C9305241C425A1E1D425C1E10010C4321
:109C6C000D4310011F42461C3F503000829F481F7D
:109C7C0002204C4310015C4310013E400D663F40F6
:109C8C001900B013E2953C505FF33D606E3C10013F
:109C9C000C120C4DB0135E940D4C3C418C4D0000DD
:109CAC008C4E02001001B0131EA10B4CB013666950
:109CBC003CB20328B013A8A0F93B1001C243872C77
:109CCC001C42381CB013A4A20D433C403A1C80002B
:109CDC008E941B150A4C0B4DB0136A96AB4A0000C0
:109CEC008A4B00001A171001023C1C533E530E9372
:109CFC000424CC9D0000F92310010C431001829C1C
:109D0C00921E022C0C431001825C941E828C921EBB
:109D1C001C4310011C42001C1D42021CB013869CEB
:109D2C00824C001C824D021C1001D2B3EA05FD2F9F
:109D3C00D2D32202D2C32202E2B3FD05FD2B1001C5
:109D4C000C4AB0131C923A4110010A120A4CB0137F
:109D5C00689AF63F03431C426C2B1D426E2B1C92DF
:109D6C006C2BF9231D926E2BF62310010A124A4C10
:109D7C00B013389FD2B3CA05FD2FC24ACE053A4163
:109D8C001001B013F294D2D32402F2D26502F2D0B5
:109D9C001000650210011C590000B013749E8A5B00
:109DAC001400078B8A471A00100132C20343B01308
:109DBC00CE9EB0139689B013789A32D210011F41FF
:109DCC000C001FD10E001FD110001FD112000F93D9
:109DDC0010018C4D00007E53CC4E0200CC4303008E
:109DEC00CC43040010011F42665D1FD2685D0F93C7
:109DFC0002242000665D0C4310012C4C0C930320B4
:109E0C000C4310010C4F2F4C0F93FC2310011C41E1
:109E1C000C001D410E001E4110001F4112001001CC
:109E2C000A121A42181EB013308E824A181E3A417A
:109E3C0010010F4C0F5D033CCC4300001C530C9FD6
:109E4C00FB2310010F432E4C023C1F532E4E0E933E
:109E5C00FC230C4F10010F4C043CCF4D00001F5342
:109E6C003E530E93FA2310010F4C043CFF4D00009F
:109E7C001F533E530E93FA2310011C410C001D413D
:109E8C000E003E400A000F4380004E930F4C013CE5
:109E9C001F53CF930000FC230F8C0C4F10010D119E
:109EAC000C100D110C100D110C100D110C101001CB
:109EBC009253562B9293562B0320B240805A5C013E
:109ECC0010018243562BB013BC9E92C3020192D355
:109EDC00000110010E43023C7F4C0E5F7F4C4F93F0
:109EEC00FB230C4E1001814C0400814D0600814E69
:109EFC000800814F0A0010010A120A4DB013828B20
:109F0C000C4AB013747C3A41100181480C00814911
:109F1C000E00814A1000814B120010011E590000E6
:109F2C00FE402E0000009A53140010011F425C01E9
:109F3C007FF33FD0185A824F5C0110018013445DAF
:109F4C000C930324924C0200641E1001CC9D000063
:109F5C0004247E4C4E93FA230C4310011F4A0E002E
:109F6C001F590000FF402E00000010018013665D99
:109F7C000D430C9302203C40100010010F4C1F4F5E
:109F8C0008002E4F1F4F02008000DEA20E430F432D
:109F9C00B0131CA2B01326A20C9310013C40481C19
:109FAC00B01386933C40501C800086933D40F45E79
:109FBC003C408A2CB013D2990C9310011C42461CC5
:109FCC001C52941E3C50300010013C40161CB01327
:109FDC008693C2437D2B10018C4D02000D4C1C420C
:109FEC00141C8000B4988C930A0002244C4310017A
:109FFC005C4310018293581E02204C4310015C43B9
:10A00C0010013FE00080814E0600814F08001001D6
:10A01C0018411400194116001A41180010010D4C7A
:10A02C003D50B2003C50820080007C92CC930A00E0
:10A03C0002204C4310015C4310011C421E1CB01347
:10A04C00F6A20A4C0C9310010F4B0F5F0E4A0E5FD9
:10A05C008E9300001001814C0C00814D0E00814E3E
:10A06C00100010010A120A4CB013789D0C4A3A41A8
:10A07C0010017C4030005C82902C1C52921E10010E
:10A08C005C427E2B4E4C5E53C24E7E2B1001B25363
:10A09C00562B0320B2403C5A5C011001B0131EA198
:10A0AC000C8B3C5034F30C931001B013449DF240D4
:10A0BC008000EE054E431001B013EAA1C243A42C5C
:10A0CC00C243A32C10016E4A5F4A010047180F5F70
:10A0DC000E5F100132C20343B2401000820332D231
:10A0EC0010010D431E42A01D1F42A21D10010D4761
:10A0FC000C493C500C008000DA9B5C42CA055CF3B6
:10A10C005CD2B42C10010C9302242000AC5D200016
:10A11C00B05D1C4290031C929003FB231001B01302
:10A12C00CC8E02280C430D4310017C400300B0136D
:10A13C00566980001EA1B01350A2FF4025000000FC
:10A14C001001D2B3EA05FD2FD2D322021001B013B5
:10A15C0050A2FF402D00000010011C42461C5F4223
:10A16C00902C0C5F10010C9302200C4310012C4C12
:10A17C0010010E4C0F4DB0131CA280003274B013A2
:10A18C0050A2814F12004D461001B01350A2FF4057
:10A19C002B00000010010D470C493C5016008000AC
:10A1AC00DA9B814C0C00814D0E0010010D4A1C42B3
:10A1BC00381C80006A96E24FEE055E536E931001D8
:10A1CC000D4C3C40732B8000DA9B814C0600814D7A
:10A1DC0008001001B01366693CB040001001F2D2C7
:10A1EC006402D2D365021001B013E48C0C430C63EF
:10A1FC001001824C642B824D662B1001824C581D31
:10A20C00824D5A1D1001B240805A5C011C43100152
:10A21C001C410A001D410C001001B0138E8D0C4323
:10A22C000C6310011C42381C8000F6A23C402C1C14
:10A23C008000F49BB0131CA280002AA10C4232C2F5
:10A24C003CF210010F481F511A0010011C42121C45
:10A25C008000F6A21C42141C8000A4A2B013449DE2
:10A26C004F4E10013C40FE1D8000FE8B1C42121C08
:10A27C008000A4A21C42481F10010C430D43100186
:10A28C00824C92031001824C921E1001B0131CA23E
:10A29C0010013F53FE2310018C4300001001B0133A
:10A2AC0050A210011C42921E10012000AC5D8000D7
:10A2BC00F2822000625D80008495800060A20C43D5
:10A2CC00100120005E5D20004C5D8000FAA2FF3F73
:10A2DC0003431F1510012000305D1B1510012000D9
:10A2EC00AC5D8000E0A08000749E2C4C10018000BE
:0AA2FC00DAA2100110011001100198
:04FFE000A65C505C6F
:02FFEA00365C83
:04FFF200705C305CB3
:02FFFE00005CA5
:0400000300005C009D
:00000001FF

```